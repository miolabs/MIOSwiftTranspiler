----Swift.(file).Array.append(contentsOf:S)
{
let $el$generator = newElements.makeIterator({}, );
while(true) {
const $ifLet0 = $el$generator.next({$setThis: $val => $el$generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
let el = $ifLet0[0]
this.append({$setThis: $val => $info.$setThis(_cloneStruct($val))}, el);
}
}
----Swift.(file).Array.append(_:Element)
this.replaceSubrangeWith({$setThis: $val => $info.$setThis(_cloneStruct($val))}, Int.infix_46_46_60({}, this.count, this.count), _create(CollectionOfOne, 'init', {}, newElement))
----Swift.(file).Array.replaceSubrange(_:Range<Int>,with:C)
{
let $generator = _cloneStruct(subrange.makeIterator({}, ));
while(true) {
const $ifLet0 = $generator.next({$setThis: $val => $generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
this.removeAt({$setThis: $val => $info.$setThis(_cloneStruct($val))}, subrange.startIndex);
}
};
let i = subrange.startIndex;
{
let $el$generator = newElements.makeIterator({}, );
while(true) {
const $ifLet0 = $el$generator.next({$setThis: $val => $el$generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
let el = $ifLet0[0]
this.insertAt({$setThis: $val => $info.$setThis(_cloneStruct($val))}, el, i);
Int.infix_43_61({}, {get: () => i, set: $val => i = $val}, 1);
}
}
----Swift.(file).Array.removeAll(keepingCapacity:Bool)
this.replaceSubrangeWith({$setThis: $val => $info.$setThis(_cloneStruct($val))}, this.indices, _create(EmptyCollection, 'init', {}, ))
----Swift.(file).Array.==infix(_:Array<Element>,_:Array<Element>)
const lhsCount = lhs.count;
{
if((Int.infix_33_61({}, lhsCount, rhs.count))) {
return false;
}
};
{
if((Int.infix_61_61({}, lhsCount, 0))) {
return true;
}
};
{
let $idx$generator = _cloneStruct(Int.infix_46_46_60({}, 0, lhsCount).makeIterator({}, ));
while(true) {
const $ifLet0 = $idx$generator.next({$setThis: $val => $idx$generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
let idx = $ifLet0[0]
{
if(((lhs.subscript$get({}, idx)).constructor.infix_33_61({}, lhs.subscript$get({}, idx), rhs.subscript$get({}, idx)))) {
return false;
}
};
}
};
return true
----Swift.(file).RangeReplaceableCollection.removeLast()
return this.removeAt({$setThis: $val => $info.$setThis(_cloneStruct($val))}, this.indexBefore({}, this.endIndex))
----Swift.(file).Array.init(repeating:Element,count:Int)
let result = _create(Array, 'init', {}, );
{
let $generator = _cloneStruct(Int.infix_46_46_60({}, 0, count).makeIterator({}, ));
while(true) {
const $ifLet0 = $generator.next({$setThis: $val => $generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
result.append({$setThis: $val => result = $val}, repeatedValue);
}
};
return result
----Swift.(file).BidirectionalCollection.joined(separator:String)
let result = "";
{
if((separator.isEmpty)) {
{
let $x$generator = this.makeIterator({}, );
while(true) {
const $ifLet0 = $x$generator.next({$setThis: $val => $x$generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
let x = $ifLet0[0]
result.append({$setThis: $val => result = $val}, _create(String, 'initString', {}, x));
}
};
return result;
}
};
let iter = this.makeIterator({}, );
{const $ifLet0 = iter.next({$setThis: $val => iter = $val}, )
if($ifLet0.rawValue === 'some') {
let first = $ifLet0[0]
result.append({$setThis: $val => result = $val}, _create(String, 'initString', {}, first));
while(true){
const $ifLet0 = iter.next({$setThis: $val => iter = $val}, )
if(!($ifLet0.rawValue === 'some')) break
let next = $ifLet0[0]
result.append({$setThis: $val => result = $val}, separator);
result.append({$setThis: $val => result = $val}, _create(String, 'initString', {}, next));
};
}
};
return result
----Swift.(file).Sequence.joined(separator:String)
let result = "";
{
if((separator.isEmpty)) {
{
let $x$generator = this.makeIterator({}, );
while(true) {
const $ifLet0 = $x$generator.next({$setThis: $val => $x$generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
let x = $ifLet0[0]
result.append({$setThis: $val => result = $val}, _create(String, 'initString', {}, x));
}
};
return result;
}
};
let iter = this.makeIterator({}, );
{const $ifLet0 = iter.next({$setThis: $val => iter = $val}, )
if($ifLet0.rawValue === 'some') {
let first = $ifLet0[0]
result.append({$setThis: $val => result = $val}, _create(String, 'initString', {}, first));
while(true){
const $ifLet0 = iter.next({$setThis: $val => iter = $val}, )
if(!($ifLet0.rawValue === 'some')) break
let next = $ifLet0[0]
result.append({$setThis: $val => result = $val}, separator);
result.append({$setThis: $val => result = $val}, _create(String, 'initString', {}, next));
};
}
};
return result
----Swift.(file)._ArrayProtocol.filter(_:(Self.Element) throws -> Bool)
let result = _create(Array, 'init', {}, );
let iterator = _cloneStruct(this.makeIterator({}, ));
while(true){
const $ifLet0 = iterator.next({$setThis: $val => iterator = $val}, )
if(!($ifLet0.rawValue === 'some')) break
let _element = $ifLet0[0]
{
if((isIncluded({}, _element))) {
result.append({$setThis: $val => result = $val}, _element);
}
};
};
return _create(Array, 'initBuffer', {}, result)
----Swift.(file).Array.endIndex
return this.count;
}
get endIndex() { return this.endIndex$get()
----Swift.(file).Array.subscript(_:Range<Int>)#ASS

this.replaceSubrangeWith({$setThis: $val => $info.$setThis(_cloneStruct($val))}, bounds, rhs)
----Swift.(file).Array.subscript(_:Range<Int>)
let result = _create(Array, 'init', {}, );
{
let $index$generator = _cloneStruct(bounds.makeIterator({}, ));
while(true) {
const $ifLet0 = $index$generator.next({$setThis: $val => $index$generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
let index = $ifLet0[0]
result.append({$setThis: $val => result = $val}, this.subscript$get({}, index));
}
};
return result;

----Swift.(file).IndexingIterator.next()
{
if(((this._position).constructor.infix_61_61({}, this._position, this._elements.endIndex))) {
return Optional.none;
}
};
const _element = this._elements.subscript$get({}, this._position);
this._elements.formIndexAfter({}, {get: () => this._position, set: $val => this._position = $val});
return _injectIntoOptional(_element)
----Swift.(file).IndexingIterator.init(_elements:Elements)
this._elements = _elements;
this._position = _elements.startIndex;
return
----Swift.(file).IndexingIterator.init(_elements:Elements,_position:Elements.Index)
this._elements = _elements;
this._position = _position;
return
----Swift.(file).CollectionOfOne.init(_:Element)
this._element = _element;
return
----Swift.(file).CollectionOfOne.subscript(_:Int)#ASS

preconditionFileLine({}, () => Int.infix_61_61({}, position, 0), () => "Index out of range", '?3', '?3');
this._element = _element
----Swift.(file).CollectionOfOne.subscript(_:Int)
preconditionFileLine({}, () => Int.infix_61_61({}, position, 0), () => "Index out of range", '?3', '?3');
return this._element;

----Swift.(file).Collection.map(_:(Self.Element) throws -> T)
const n = this.count;
{
if((Int.infix_61_61({}, n, 0))) {
return _create(Array, 'initBuffer', {}, []);
}
};
let result = _create(Array, 'init', {}, );
let i = this.startIndex;
{
let $generator = _cloneStruct(Int.infix_46_46_60({}, 0, n).makeIterator({}, ));
while(true) {
const $ifLet0 = $generator.next({$setThis: $val => $generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
result.append({$setThis: $val => result = $val}, transform({}, this.subscript$get({}, i)));
this.formIndexAfter({}, {get: () => i, set: $val => i = $val});
}
};
return result
----Swift.(file).Sequence.sorted(by:(Self.Element, Self.Element) throws -> Bool)
let result = _create(Array, 'initBuffer', {}, this);
result.sortBy({$setThis: $val => result = $val}, areInIncreasingOrder);
return result
----Swift.(file).Int.advanced(by:Int)
return Int.infix_43({}, this, n)
----Swift.(file).??infix(_:T?,_:() throws -> T?)
const $match = optional
if((($match.rawValue == Optional.some().rawValue))) {
const value = $match[0]
return value;
}
else if((($match.rawValue == Optional.none.rawValue))) {
return defaultValue({}, );
}
----Swift.(file).ClosedRange.index(after:ClosedRange<Bound>.Index)
const $match = i
if((($match.rawValue == ClosedRange.Index.inRange().rawValue))) {
const x = $match[0]
return ((this.upperBound).constructor.infix_61_61({}, x, this.upperBound) ? ClosedRange.Index.pastEnd : ClosedRange.Index.inRange({}, x.advancedBy({}, _create(Int, 'initIntegerLiteral', {}, 1))));
}
else if((($match.rawValue == ClosedRange.Index.pastEnd.rawValue))) {
preconditionFailureFileLine({}, () => "Incrementing past end index", '?3', '?3');
}
----Swift.(file).Range.index(after:Range<Bound>.Index)
this._failEarlyRangeCheckBounds({}, i, (this.startIndex).constructor.infix_46_46_60({}, this.startIndex, this.endIndex));
return i.advancedBy({}, _create(Int, 'initIntegerLiteral', {}, 1))
----Swift.(file).Sequence.min()
return this.minBy({}, this.first[0].constructor.infix_60)
----Swift.(file).Sequence.max()
return this.maxBy({}, this.first[0].constructor.infix_60)
----Swift.(file).Sequence.starts(with:PossiblePrefix)
return this.startsWithBy({}, possiblePrefix, this.first[0].constructor.infix_61_61)
----Swift.(file).Sequence.elementsEqual(_:OtherSequence)
return this.elementsEqualBy({}, other, this.first[0].constructor.infix_61_61)
----Swift.(file).Sequence.lexicographicallyPrecedes(_:OtherSequence)
return this.lexicographicallyPrecedesBy({}, other, this.first[0].constructor.infix_60)
----Swift.(file).Sequence.sorted()
return this.sortedBy({}, this.first[0].constructor.infix_60)
----Swift.(file).MutableCollection.sort()
this.sortBy({$setThis: $val => $info.$setThis(_cloneStruct($val))}, this.first[0].constructor.infix_60)
----XCTest.(file).XCTAssert(_:() throws -> Bool,_:() -> String,file:StaticString,line:UInt)
preconditionFileLine({}, () => expression({}, ), () => message({}, ), '?3', '?3')
----XCTest.(file).XCTAssertFalse(_:() throws -> Bool,_:() -> String,file:StaticString,line:UInt)
preconditionFileLine({}, () => Bool.prefix_33({}, expression({}, )), () => message({}, ), '?3', '?3')
----XCTest.(file).XCTAssertGreaterThan(_:() throws -> T,_:() throws -> T,_:() -> String,file:StaticString,line:UInt)
preconditionFileLine({}, () => (expression1({}, )).constructor.infix_62({}, expression1({}, ), expression2({}, )), () => message({}, ), '?3', '?3')
----XCTest.(file).XCTAssertGreaterThanOrEqual(_:() throws -> T,_:() throws -> T,_:() -> String,file:StaticString,line:UInt)
preconditionFileLine({}, () => (expression1({}, )).constructor.infix_62_61({}, expression1({}, ), expression2({}, )), () => message({}, ), '?3', '?3')
----XCTest.(file).XCTAssertLessThan(_:() throws -> T,_:() throws -> T,_:() -> String,file:StaticString,line:UInt)
preconditionFileLine({}, () => (expression1({}, )).constructor.infix_60({}, expression1({}, ), expression2({}, )), () => message({}, ), '?3', '?3')
----XCTest.(file).XCTAssertLessThanOrEqual(_:() throws -> T,_:() throws -> T,_:() -> String,file:StaticString,line:UInt)
preconditionFileLine({}, () => (expression1({}, )).constructor.infix_60_61({}, expression1({}, ), expression2({}, )), () => message({}, ), '?3', '?3')
----XCTest.(file).XCTAssertNil(_:() throws -> Any?,_:() -> String,file:StaticString,line:UInt)
preconditionFileLine({}, () => Optional.wrappedEqualsOptionalNilComparisonType({}, expression({}, ), _create(_OptionalNilComparisonType, 'initNilLiteraltuple_type', {}, {})), () => message({}, ), '?3', '?3')
----XCTest.(file).XCTAssertNotNil(_:() throws -> Any?,_:() -> String,file:StaticString,line:UInt)
preconditionFileLine({}, () => Optional.wrappedNotEqualsOptionalNilComparisonType({}, expression({}, ), _create(_OptionalNilComparisonType, 'initNilLiteraltuple_type', {}, {})), () => message({}, ), '?3', '?3')
----XCTest.(file).XCTAssertTrue(_:() throws -> Bool,_:() -> String,file:StaticString,line:UInt)
preconditionFileLine({}, () => Bool.infix_61_61({}, expression({}, ), true), () => message({}, ), '?3', '?3')
----XCTest.(file).XCTAssertEqual(_:() throws -> T,_:() throws -> T,_:() -> String,file:StaticString,line:UInt)
preconditionFileLine({}, () => (expression1({}, )).constructor.infix_61_61({}, expression1({}, ), expression2({}, )), () => message({}, ), '?3', '?3')
----XCTest.(file).XCTAssertNotEqual(_:() throws -> T,_:() throws -> T,_:() -> String,file:StaticString,line:UInt)
preconditionFileLine({}, () => (expression1({}, )).constructor.infix_33_61({}, expression1({}, ), expression2({}, )), () => message({}, ), '?3', '?3')
----XCTest.(file).XCTFail(_:String,file:StaticString,line:UInt)
throw message
----Swift.(file).precondition(_:() -> Bool,_:() -> String,file:StaticString,line:UInt)
{
if((Bool.prefix_33({}, condition({}, )))) {
throw message({}, );
}
}
----XCTest.(file).XCTest.setUp()

----XCTest.(file).XCTest.tearDown()

----closing dashes needed for the last definition to be processed