----Swift.(file).Array.append(contentsOf:S)
{
let $el$generator = newElements.makeIterator({Self: newElements.constructor}, );
while(true) {
const $ifLet0 = $el$generator.next({$setThis: $val => $el$generator = $val, Self: newElements.constructor}, );
if(!($ifLet0.rawValue === 'some')) break
let el = $ifLet0[0]
this.append({$setThis: $val => $info.$setThis(_cloneStruct($val)), Element: '?'}, el);
}
}
----Swift.(file).Array.append(_:Element)
this.replaceSubrangeWith({$setThis: $val => $info.$setThis(_cloneStruct($val)), Element: newElement.constructor, C: _clarifyGenerics({Self:CollectionOfOne, Element: newElement.constructor})}, Int.infix_46_46_60({Self: Int, Self: Int}, this.count, this.count), _create(CollectionOfOne, 'init', {Element: newElement.constructor}, newElement))
----Swift.(file).Array.replaceSubrange(_:Range<Int>,with:C)
{
let $generator = _cloneStruct(subrange.makeIterator({Self: _clarifyGenerics({Self:Range, Bound: Int})}, ));
while(true) {
const $ifLet0 = $generator.next({$setThis: $val => $generator = $val, Elements: _clarifyGenerics({Self:Range, Bound: Int})}, );
if(!($ifLet0.rawValue === 'some')) break
this.removeAt({$setThis: $val => $info.$setThis(_cloneStruct($val)), Element: '?'}, subrange.startIndex);
}
};
let i = subrange.startIndex;
{
let $el$generator = newElements.makeIterator({Self: newElements.constructor}, );
while(true) {
const $ifLet0 = $el$generator.next({$setThis: $val => $el$generator = $val, Self: newElements.constructor}, );
if(!($ifLet0.rawValue === 'some')) break
let el = $ifLet0[0]
this.insertAt({$setThis: $val => $info.$setThis(_cloneStruct($val)), Element: '?'}, el, i);
Int.infix_43_61({Self: Int}, {get: () => i, set: $val => i = $val}, 1);
}
}
----Swift.(file).Array.removeAll(keepingCapacity:Bool)
this.replaceSubrangeWith({$setThis: $val => $info.$setThis(_cloneStruct($val)), Element: '?', C: _clarifyGenerics({Self:EmptyCollection, Element: '?'})}, this.indices, _create(EmptyCollection, 'init', {Element: '?'}, ))
----Swift.(file).Array.==infix(_:Array<Element>,_:Array<Element>)
const lhsCount = lhs.count;
{
if((Int.infix_33_61({Self: Int, Self: Int}, lhsCount, rhs.count))) {
return false;
}
};
{
if((Int.infix_61_61({Self: Int}, lhsCount, 0))) {
return true;
}
};
{
let $idx$generator = _cloneStruct(Int.infix_46_46_60({Self: Int, Self: Int}, 0, lhsCount).makeIterator({Self: _clarifyGenerics({Self:Range, Bound: Int})}, ));
while(true) {
const $ifLet0 = $idx$generator.next({$setThis: $val => $idx$generator = $val, Elements: _clarifyGenerics({Self:Range, Bound: Int})}, );
if(!($ifLet0.rawValue === 'some')) break
let idx = $ifLet0[0]
{
if(('?'.infix_33_61({Self: '?', Self: '?'}, lhs.subscript$get({}, idx), rhs.subscript$get({}, idx)))) {
return false;
}
};
}
};
return true
----Swift.(file).RangeReplaceableCollection.removeLast()
return this.removeAt({$setThis: $val => $info.$setThis(_cloneStruct($val)), Self: this.constructor}, this.indexBefore({Self: this.constructor}, this.endIndex))
----Swift.(file).Array.init(repeating:Element,count:Int)
let result = _create(Array, 'init', {Element: repeatedValue.constructor}, );
{
let $generator = _cloneStruct(Int.infix_46_46_60({Self: Int, Self: Int}, 0, count).makeIterator({Self: _clarifyGenerics({Self:Range, Bound: Int})}, ));
while(true) {
const $ifLet0 = $generator.next({$setThis: $val => $generator = $val, Elements: _clarifyGenerics({Self:Range, Bound: Int})}, );
if(!($ifLet0.rawValue === 'some')) break
result.append({$setThis: $val => result = $val, Element: repeatedValue.constructor}, repeatedValue);
}
};
return result
----Swift.(file).BidirectionalCollection.joined(separator:String)
let result = "";
{
if((separator.isEmpty)) {
{
let $x$generator = this.makeIterator({Self: this.constructor}, );
while(true) {
const $ifLet0 = $x$generator.next({$setThis: $val => $x$generator = $val, Self: this.constructor}, );
if(!($ifLet0.rawValue === 'some')) break
let x = $ifLet0[0]
result.append({$setThis: $val => result = $val}, _create(String, 'initString', {S: String}, x));
}
};
return result;
}
};
let iter = this.makeIterator({Self: this.constructor}, );
{const $ifLet0 = iter.next({$setThis: $val => iter = $val, Self: this.constructor}, )
if($ifLet0.rawValue === 'some') {
let first = $ifLet0[0]
result.append({$setThis: $val => result = $val}, _create(String, 'initString', {S: String}, first));
while(true){
const $ifLet0 = iter.next({$setThis: $val => iter = $val, Self: this.constructor}, )
if(!($ifLet0.rawValue === 'some')) break
let next = $ifLet0[0]
result.append({$setThis: $val => result = $val}, separator);
result.append({$setThis: $val => result = $val}, _create(String, 'initString', {S: String}, next));
};
}
};
return result
----Swift.(file).Sequence.joined(separator:String)
let result = "";
{
if((separator.isEmpty)) {
{
let $x$generator = this.makeIterator({Self: this.constructor}, );
while(true) {
const $ifLet0 = $x$generator.next({$setThis: $val => $x$generator = $val, Self: this.constructor}, );
if(!($ifLet0.rawValue === 'some')) break
let x = $ifLet0[0]
result.append({$setThis: $val => result = $val}, _create(String, 'initString', {S: this.constructor}, x));
}
};
return result;
}
};
let iter = this.makeIterator({Self: this.constructor}, );
{const $ifLet0 = iter.next({$setThis: $val => iter = $val, Self: this.constructor}, )
if($ifLet0.rawValue === 'some') {
let first = $ifLet0[0]
result.append({$setThis: $val => result = $val}, _create(String, 'initString', {S: this.constructor}, first));
while(true){
const $ifLet0 = iter.next({$setThis: $val => iter = $val, Self: this.constructor}, )
if(!($ifLet0.rawValue === 'some')) break
let next = $ifLet0[0]
result.append({$setThis: $val => result = $val}, separator);
result.append({$setThis: $val => result = $val}, _create(String, 'initString', {S: this.constructor}, next));
};
}
};
return result
----Swift.(file)._ArrayProtocol.filter(_:(Self.Element) throws -> Bool)
let result = _create(Array, 'init', {Element: '?'}, );
let iterator = _cloneStruct(this.makeIterator({Self: _clarifyGenerics({Self:Array, Element: '?'})}, ));
while(true){
const $ifLet0 = iterator.next({$setThis: $val => iterator = $val, Elements: _clarifyGenerics({Self:Array, Element: '?'})}, )
if(!($ifLet0.rawValue === 'some')) break
let _element = $ifLet0[0]
{
if((isIncluded({}, _element))) {
result.append({$setThis: $val => result = $val, Element: '?'}, _element);
}
};
};
return _create(Array, 'initBuffer', {Element: '?', S: _clarifyGenerics({Self:Array, Element: '?'})}, result)
----Swift.(file).Array.endIndex
return this.count;
}
get endIndex() { return this.endIndex$get()
----Swift.(file).Array.subscript(_:Range<Int>)#ASS

this.replaceSubrangeWith({$setThis: $val => $info.$setThis(_cloneStruct($val)), Element: '?', C: _clarifyGenerics({Self:ArraySlice, Element: '?'})}, bounds, rhs)
----Swift.(file).Array.subscript(_:Range<Int>)
let result = _create(Array, 'init', {Element: '?'}, );
{
let $index$generator = _cloneStruct(bounds.makeIterator({Self: _clarifyGenerics({Self:Range, Bound: Int})}, ));
while(true) {
const $ifLet0 = $index$generator.next({$setThis: $val => $index$generator = $val, Elements: _clarifyGenerics({Self:Range, Bound: Int})}, );
if(!($ifLet0.rawValue === 'some')) break
let index = $ifLet0[0]
result.append({$setThis: $val => result = $val, Element: '?'}, this.subscript$get({}, index));
}
};
return result;

----Swift.(file).IndexingIterator.next()
{
if((this._elements.startIndex.constructor.infix_61_61({Self: this._elements.startIndex.constructor, Self: this._elements.startIndex.constructor}, this._position, this._elements.endIndex))) {
return Optional.none;
}
};
const _element = this._elements.subscript$get({}, this._position);
this._elements.formIndexAfter({Self: this._elements.constructor}, {get: () => this._position, set: $val => this._position = $val});
return _injectIntoOptional(_element)
----Swift.(file).IndexingIterator.init(_elements:Elements)
this._elements = _elements;
this._position = _elements.startIndex;
return
----Swift.(file).IndexingIterator.init(_elements:Elements,_position:Elements.Index)
this._elements = _elements;
this._position = _position;
return
----Swift.(file).CollectionOfOne.init(_:Element)
this._element = _element;
return
----Swift.(file).CollectionOfOne.subscript(_:Int)#ASS

preconditionFileLine({}, () => Int.infix_61_61({Self: Int}, position, 0), () => "Index out of range", '?3', '?3');
this._element = _element
----Swift.(file).CollectionOfOne.subscript(_:Int)
preconditionFileLine({}, () => Int.infix_61_61({Self: Int}, position, 0), () => "Index out of range", '?3', '?3');
return this._element;

----Swift.(file).Collection.map(_:(Self.Element) throws -> T)
const n = this.count;
{
if((Int.infix_61_61({Self: Int}, n, 0))) {
return _create(Array, 'initBuffer', {Element: '?'}, []);
}
};
let result = _create(Array, 'init', {Element: '?'}, );
let i = this.startIndex;
{
let $generator = _cloneStruct(Int.infix_46_46_60({Self: Int, Self: Int}, 0, n).makeIterator({Self: _clarifyGenerics({Self:Range, Bound: Int})}, ));
while(true) {
const $ifLet0 = $generator.next({$setThis: $val => $generator = $val, Elements: _clarifyGenerics({Self:Range, Bound: Int})}, );
if(!($ifLet0.rawValue === 'some')) break
result.append({$setThis: $val => result = $val, Element: '?'}, transform({}, this.subscript$get({}, i)));
this.formIndexAfter({Self: this.constructor}, {get: () => i, set: $val => i = $val});
}
};
return result
----Swift.(file).Sequence.sorted(by:(Self.Element, Self.Element) throws -> Bool)
let result = _create(Array, 'initBuffer', {Element: this.constructor, S: this.constructor}, this);
result.sortBy({$setThis: $val => result = $val, Self: _clarifyGenerics({Self:Array, Element: this.constructor})}, areInIncreasingOrder);
return result
----Swift.(file).Int.advanced(by:Int)
return Int.infix_43({Self: Int}, this, n)
----Swift.(file).??infix(_:T?,_:() throws -> T?)
const $match = optional
if((($match.rawValue == Optional.some().rawValue))) {
const value = $match[0]
return value;
}
else if((($match.rawValue == Optional.none.rawValue))) {
return defaultValue({}, );
}
----XCTest.(file).XCTAssert(_:() throws -> Bool,_:() -> String,file:StaticString,line:UInt)
preconditionFileLine({}, () => expression({}, ), () => message({}, ), '?3', '?3')
----XCTest.(file).XCTAssertFalse(_:() throws -> Bool,_:() -> String,file:StaticString,line:UInt)
preconditionFileLine({}, () => Bool.prefix_33({Self: Bool}, expression({}, )), () => message({}, ), '?3', '?3')
----XCTest.(file).XCTAssertGreaterThan(_:() throws -> T,_:() throws -> T,_:() -> String,file:StaticString,line:UInt)
preconditionFileLine({}, () => '?'.infix_62({Self: '?', Self: '?'}, expression1({}, ), expression2({}, )), () => message({}, ), '?3', '?3')
----XCTest.(file).XCTAssertGreaterThanOrEqual(_:() throws -> T,_:() throws -> T,_:() -> String,file:StaticString,line:UInt)
preconditionFileLine({}, () => '?'.infix_62_61({Self: '?', Self: '?'}, expression1({}, ), expression2({}, )), () => message({}, ), '?3', '?3')
----XCTest.(file).XCTAssertLessThan(_:() throws -> T,_:() throws -> T,_:() -> String,file:StaticString,line:UInt)
preconditionFileLine({}, () => '?'.infix_60({Self: '?', Self: '?'}, expression1({}, ), expression2({}, )), () => message({}, ), '?3', '?3')
----XCTest.(file).XCTAssertLessThanOrEqual(_:() throws -> T,_:() throws -> T,_:() -> String,file:StaticString,line:UInt)
preconditionFileLine({}, () => '?'.infix_60_61({Self: '?', Self: '?'}, expression1({}, ), expression2({}, )), () => message({}, ), '?3', '?3')
----XCTest.(file).XCTAssertNil(_:() throws -> Any?,_:() -> String,file:StaticString,line:UInt)
preconditionFileLine({}, () => Optional.infix_61_61({Self: Optional, Wrapped: Bool}, _injectIntoOptional(expression({}, )), _create(_OptionalNilComparisonType, 'initNilLiteraltuple_type', {}, {})), () => message({}, ), '?3', '?3')
----XCTest.(file).XCTAssertNotNil(_:() throws -> Any?,_:() -> String,file:StaticString,line:UInt)
preconditionFileLine({}, () => Optional.infix_33_61({Self: Optional, Wrapped: Bool}, _injectIntoOptional(expression({}, )), _create(_OptionalNilComparisonType, 'initNilLiteraltuple_type', {}, {})), () => message({}, ), '?3', '?3')
----XCTest.(file).XCTAssertTrue(_:() throws -> Bool,_:() -> String,file:StaticString,line:UInt)
preconditionFileLine({}, () => Bool.infix_61_61({Self: Bool}, expression({}, ), true), () => message({}, ), '?3', '?3')
----XCTest.(file).XCTAssertEqual(_:() throws -> T,_:() throws -> T,_:() -> String,file:StaticString,line:UInt)
preconditionFileLine({}, () => '?'.infix_61_61({Self: '?', Self: '?'}, expression1({}, ), expression2({}, )), () => message({}, ), '?3', '?3')
----XCTest.(file).XCTAssertNotEqual(_:() throws -> T,_:() throws -> T,_:() -> String,file:StaticString,line:UInt)
preconditionFileLine({}, () => '?'.infix_33_61({Self: '?', Self: '?'}, expression1({}, ), expression2({}, )), () => message({}, ), '?3', '?3')
----Swift.(file).precondition(_:() -> Bool,_:() -> String,file:StaticString,line:UInt)
{
if((Bool.prefix_33({Self: Bool}, condition({}, )))) {
throw message({}, );
}
}
----XCTest.(file).XCTest.setUp()

----XCTest.(file).XCTest.tearDown()

----closing dashes needed for the last definition to be processed