----Swift.(file).Array.append(contentsOf:S)
{
let $el$generator = newElements.makeIterator({}, );
while(true) {
const $ifLet0 = $el$generator.next({$setThis: $val => $el$generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
let el = $ifLet0[0]
this.append({$setThis: $val => $info.$setThis(_cloneStruct($val))}, el);
}
}
----Swift.(file).Array.append(_:Element)
this.replaceSubrangeWith({$setThis: $val => $info.$setThis(_cloneStruct($val))}, Int.infix_46_46_60({}, this.count, this.count), _create(CollectionOfOne, 'init', {}, newElement))
----Swift.(file).Array.replaceSubrange(_:Range<Int>,with:C)
{
let $generator = _cloneStruct(subrange.makeIterator({}, ));
while(true) {
const $ifLet0 = $generator.next({$setThis: $val => $generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
this.removeAt({$setThis: $val => $info.$setThis(_cloneStruct($val))}, subrange.startIndex);
}
};
let i = subrange.startIndex;
{
let $el$generator = newElements.makeIterator({}, );
while(true) {
const $ifLet0 = $el$generator.next({$setThis: $val => $el$generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
let el = $ifLet0[0]
this.insertAt({$setThis: $val => $info.$setThis(_cloneStruct($val))}, el, i);
Int.infix_43_61({}, {get: () => i, set: $val => i = $val}, 1);
}
}
----Swift.(file).Array.removeAll(keepingCapacity:Bool)
this.replaceSubrangeWith({$setThis: $val => $info.$setThis(_cloneStruct($val))}, this.indices, _create(EmptyCollection, 'init', {}, ))
----Swift.(file).Array.init(repeating:Element,count:Int)
let result = _create(Array, 'init', {}, );
{
let $generator = _cloneStruct(Int.infix_46_46_60({}, 0, count).makeIterator({}, ));
while(true) {
const $ifLet0 = $generator.next({$setThis: $val => $generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
result.append({$setThis: $val => result = $val}, repeatedValue);
}
};
return result
----Swift.(file).BidirectionalCollection.joined(separator:String)
let result = "";
{
if((separator.isEmpty)) {
{
let $x$generator = this.makeIterator({}, );
while(true) {
const $ifLet0 = $x$generator.next({$setThis: $val => $x$generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
let x = $ifLet0[0]
result.append({$setThis: $val => result = $val}, _create(String, 'initString', {}, x));
}
};
return result;
}
};
let iter = this.makeIterator({}, );
{const $ifLet0 = iter.next({$setThis: $val => iter = $val}, )
if($ifLet0.rawValue === 'some') {
let first = $ifLet0[0]
result.append({$setThis: $val => result = $val}, _create(String, 'initString', {}, first));
while(true){
const $ifLet0 = iter.next({$setThis: $val => iter = $val}, )
if(!($ifLet0.rawValue === 'some')) break
let next = $ifLet0[0]
result.append({$setThis: $val => result = $val}, separator);
result.append({$setThis: $val => result = $val}, _create(String, 'initString', {}, next));
};
}
};
return result
----Swift.(file).Sequence.joined(separator:String)
let result = "";
{
if((separator.isEmpty)) {
{
let $x$generator = this.makeIterator({}, );
while(true) {
const $ifLet0 = $x$generator.next({$setThis: $val => $x$generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
let x = $ifLet0[0]
result.append({$setThis: $val => result = $val}, _create(String, 'initString', {}, x));
}
};
return result;
}
};
let iter = this.makeIterator({}, );
{const $ifLet0 = iter.next({$setThis: $val => iter = $val}, )
if($ifLet0.rawValue === 'some') {
let first = $ifLet0[0]
result.append({$setThis: $val => result = $val}, _create(String, 'initString', {}, first));
while(true){
const $ifLet0 = iter.next({$setThis: $val => iter = $val}, )
if(!($ifLet0.rawValue === 'some')) break
let next = $ifLet0[0]
result.append({$setThis: $val => result = $val}, separator);
result.append({$setThis: $val => result = $val}, _create(String, 'initString', {}, next));
};
}
};
return result
----Swift.(file)._ArrayProtocol.filter(_:(Self.Element) throws -> Bool)
let result = _create(Array, 'init', {}, );
let iterator = _cloneStruct(this.makeIterator({}, ));
while(true){
const $ifLet0 = iterator.next({$setThis: $val => iterator = $val}, )
if(!($ifLet0.rawValue === 'some')) break
let _element = $ifLet0[0]
{
if((isIncluded({}, _element))) {
result.append({$setThis: $val => result = $val}, _element);
}
};
};
return _create(Array, 'initBuffer', {}, result)
----Swift.(file).Array.endIndex
return this.count;
}
get endIndex() { return this.endIndex$get()
----Swift.(file).Array.subscript(_:Range<Int>)#ASS

this.replaceSubrangeWith({$setThis: $val => $info.$setThis(_cloneStruct($val))}, bounds, rhs)
----Swift.(file).Array.subscript(_:Range<Int>)
let result = _create(Array, 'init', {}, );
{
let $index$generator = _cloneStruct(bounds.makeIterator({}, ));
while(true) {
const $ifLet0 = $index$generator.next({$setThis: $val => $index$generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
let index = $ifLet0[0]
result.append({$setThis: $val => result = $val}, this.subscript$get({}, index));
}
};
return result;

----Swift.(file).IndexingIterator.init(_elements:Elements)
this._elements = _elements;
this._position = _elements.startIndex;
return
----Swift.(file).IndexingIterator.init(_elements:Elements,_position:Elements.Index)
this._elements = _elements;
this._position = _position;
return
----Swift.(file).CollectionOfOne.Iterator.init(_elements:CollectionOfOne<Element>.Iterator.Element?)
this._elements = _elements;
return
----Swift.(file).Collection.map(_:(Self.Element) throws -> T)
const n = this.count;
{
if((Int.infix_61_61({}, n, 0))) {
return _create(Array, 'initBuffer', {}, []);
}
};
let result = _create(Array, 'init', {}, );
let i = this.startIndex;
{
let $generator = _cloneStruct(Int.infix_46_46_60({}, 0, n).makeIterator({}, ));
while(true) {
const $ifLet0 = $generator.next({$setThis: $val => $generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
result.append({$setThis: $val => result = $val}, transform({}, this.subscript$get({}, i)));
this.formIndexAfter({}, {get: () => i, set: $val => i = $val});
}
};
return result
----Swift.(file).Sequence.sorted(by:(Self.Element, Self.Element) throws -> Bool)
let result = _create(Array, 'initBuffer', {}, this);
result.sortBy({$setThis: $val => result = $val}, areInIncreasingOrder);
return result
----Swift.(file).Int.advanced(by:Int)
return Int.infix_43({}, this, n)
----Swift.(file).??infix(_:T?,_:() throws -> T?)
const $match = optional
if((($match.rawValue == Optional.some().rawValue))) {
const value = $match[0]
return value;
}
else if((($match.rawValue == Optional.none.rawValue))) {
return defaultValue({}, );
}
----XCTest.(file).XCTAssert(_:() throws -> Bool,_:() -> String,file:StaticString,line:UInt)
preconditionFileLine({}, () => expression({}, ), () => message({}, ), '?3', '?3')
----XCTest.(file).XCTAssertFalse(_:() throws -> Bool,_:() -> String,file:StaticString,line:UInt)
preconditionFileLine({}, () => Bool.prefix_33({}, expression({}, )), () => message({}, ), '?3', '?3')
----XCTest.(file).XCTAssertGreaterThan(_:() throws -> T,_:() throws -> T,_:() -> String,file:StaticString,line:UInt)
preconditionFileLine({}, () => (expression1({}, )).constructor.infix_62({}, expression1({}, ), expression2({}, )), () => message({}, ), '?3', '?3')
----XCTest.(file).XCTAssertGreaterThanOrEqual(_:() throws -> T,_:() throws -> T,_:() -> String,file:StaticString,line:UInt)
preconditionFileLine({}, () => (expression1({}, )).constructor.infix_62_61({}, expression1({}, ), expression2({}, )), () => message({}, ), '?3', '?3')
----XCTest.(file).XCTAssertLessThan(_:() throws -> T,_:() throws -> T,_:() -> String,file:StaticString,line:UInt)
preconditionFileLine({}, () => (expression1({}, )).constructor.infix_60({}, expression1({}, ), expression2({}, )), () => message({}, ), '?3', '?3')
----XCTest.(file).XCTAssertLessThanOrEqual(_:() throws -> T,_:() throws -> T,_:() -> String,file:StaticString,line:UInt)
preconditionFileLine({}, () => (expression1({}, )).constructor.infix_60_61({}, expression1({}, ), expression2({}, )), () => message({}, ), '?3', '?3')
----XCTest.(file).XCTAssertNil(_:() throws -> Any?,_:() -> String,file:StaticString,line:UInt)
preconditionFileLine({}, () => Optional.wrappedEqualsOptionalNilComparisonType({}, expression({}, ), _create(_OptionalNilComparisonType, 'initNilLiteraltuple_type', {}, {})), () => message({}, ), '?3', '?3')
----XCTest.(file).XCTAssertNotNil(_:() throws -> Any?,_:() -> String,file:StaticString,line:UInt)
preconditionFileLine({}, () => Optional.wrappedNotEqualsOptionalNilComparisonType({}, expression({}, ), _create(_OptionalNilComparisonType, 'initNilLiteraltuple_type', {}, {})), () => message({}, ), '?3', '?3')
----XCTest.(file).XCTAssertTrue(_:() throws -> Bool,_:() -> String,file:StaticString,line:UInt)
preconditionFileLine({}, () => Bool.infix_61_61({}, expression({}, ), true), () => message({}, ), '?3', '?3')
----XCTest.(file).XCTAssertEqual(_:() throws -> T,_:() throws -> T,_:() -> String,file:StaticString,line:UInt)
preconditionFileLine({}, () => (expression1({}, )).constructor.infix_61_61({}, expression1({}, ), expression2({}, )), () => message({}, ), '?3', '?3')
----XCTest.(file).XCTAssertNotEqual(_:() throws -> T,_:() throws -> T,_:() -> String,file:StaticString,line:UInt)
preconditionFileLine({}, () => (expression1({}, )).constructor.infix_33_61({}, expression1({}, ), expression2({}, )), () => message({}, ), '?3', '?3')
----XCTest.(file).XCTFail(_:String,file:StaticString,line:UInt)
throw message
----Swift.(file).precondition(_:() -> Bool,_:() -> String,file:StaticString,line:UInt)
{
if((Bool.prefix_33({}, condition({}, )))) {
throw message({}, );
}
}
----XCTest.(file).XCTest.setUp()

----XCTest.(file).XCTest.tearDown()

----closing dashes needed for the last definition to be processed