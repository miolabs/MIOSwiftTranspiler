----Swift.(file)..(error_type).EncodedScalar

----Swift.(file)..(error_type).encodedReplacementCharacter
let _this = this;
return _create(Unicode.ASCII.EncodedScalar, 'init', 0x1a, {});
}
static get encodedReplacementCharacter() { return this.encodedReplacementCharacter$get()
----Swift.(file)..(error_type).decode(_:Unicode.ASCII.EncodedScalar)
let _this = this;
return _create(Unicode.Scalar, 'init_uncheckedUInt32', _create(UInt32, 'initT', source.first._unsafelyUnwrappedUnchecked, {}), {})
----Swift.(file)..(error_type).encode(_:Unicode.Scalar)
let _this = this;
if(!((UInt32.infix_60(source.value, Int.infix_38_60_60(1, 7, {}), {})))) {
return Optional.none;
};
return _injectIntoOptional(_create(Unicode.ASCII.EncodedScalar, 'init', _create(UInt8, 'initTruncatingIfNeeded', source.value, {}), {}))
----Swift.(file)..(error_type).transcode(_:FromEncoding.EncodedScalar,from:FromEncoding.Type)
let _this = this;
if((_fastPath(infix_61_61(_injectIntoOptional(((function(){throw '!unclarifiedGeneric:FromEncoding'})())), _injectIntoOptional(UTF16), {}), {}))) {
const c = _cloneStruct(_identityCastTo(content, UTF16.EncodedScalar, {}));
if(!((UInt32.infix_61_61(UInt32.infix_38(c._storage, 0xFF80, {}), 0, {})))) {
return Optional.none;
};
return _injectIntoOptional(_create(Unicode.ASCII.EncodedScalar, 'init', _create(Unicode.ASCII.CodeUnit, 'initT', UInt32.infix_38(c._storage, 0x7f, {}), {}), {}));
}
else {
if((_fastPath(infix_61_61(_injectIntoOptional(((function(){throw '!unclarifiedGeneric:FromEncoding'})())), _injectIntoOptional(UTF8), {}), {}))) {
const c = _cloneStruct(_identityCastTo(content, UTF8.EncodedScalar, {}));
const first = c.first.unsafelyUnwrapped;
if(!((UInt8.infix_60(first, 0x80, {})))) {
return Optional.none;
};
return _injectIntoOptional(_create(Unicode.ASCII.EncodedScalar, 'init', _create(Unicode.ASCII.CodeUnit, 'initT', first, {}), {}));
}
};
return _this.encode(((function(){throw '!unclarifiedGeneric:FromEncoding'})()).decode(content, {}), {})
----Swift.(file)..(error_type).parseScalar(from:I)
let _this = this;
let input = input$inout.get()
const $result = (() => {
const n = input.next( {$setThis: $val => input = $val});
const $ifLet0, x_1
if((_fastPath(Optional.wrappedNotEqualsOptionalNilComparisonType(n, _create(_OptionalNilComparisonType, 'initNilLiteraltuple_type', {}), {}), {})) && (($ifLet0 = n)||true) && $ifLet0.rawValue == 'some' && ((x_1 = $ifLet0[0])||true)) {
if(!((_fastPath(Int8.infix_62_61(_create(Int8, 'initTruncatingIfNeeded', x_1, {}), 0, {}), {})))) {
return Unicode.ParseResult.error(1, {});
};
return Unicode.ParseResult.valid(_create(Unicode.ASCII.EncodedScalar, 'init', x_1, {}), {});
};
return Unicode.ParseResult.emptyInput;})()
input$inout.set(input)
return $result
----Swift.(file).min(_:T,_:T)
return ((_.arg0 = y).constructor.infix_60(_.arg0, x, {}) ? y : x)
----Swift.(file).min(_:T,_:T,_:T,_:[T])
let minValue = min(min(x, y, {}), z, {});
{
let $value$generator = _cloneStruct(rest.makeIterator( {}));
while(true) {
const $ifLet0, value_1;
if(!((($ifLet0 = $value$generator.next( {$setThis: $val => $value$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((value_1 = $ifLet0[0])||true))) break
if(!((_.arg0 = value_1).constructor.infix_60(_.arg0, minValue, {}))) continue
minValue = value_1;
}
};
return minValue
----Swift.(file).max(_:T,_:T)
return ((_.arg0 = y).constructor.infix_62_61(_.arg0, x, {}) ? y : x)
----Swift.(file).max(_:T,_:T,_:T,_:[T])
let maxValue = max(max(x, y, {}), z, {});
{
let $value$generator = _cloneStruct(rest.makeIterator( {}));
while(true) {
const $ifLet0, value_1;
if(!((($ifLet0 = $value$generator.next( {$setThis: $val => $value$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((value_1 = $ifLet0[0])||true))) break
if(!((_.arg0 = value_1).constructor.infix_62_61(_.arg0, maxValue, {}))) continue
maxValue = value_1;
}
};
return maxValue
----Swift.(file).EnumeratedSequence.init(_base:Base)
let _this = this;
_this._base = _base;
return
----Swift.(file).EnumeratedSequence.Iterator.init(_base:Base.Iterator)
let _this = this;
_this._base = _base;
_this._count = 0;
return
----Swift.(file).EnumeratedSequence.Iterator.Element

----Swift.(file).EnumeratedSequence.Iterator.next()
let _this = this;
const $ifLet0, b_1
if(!((($ifLet0 = _this._base.next( {$setThis: $val => _this._base = $val}))||true) && $ifLet0.rawValue == 'some' && ((b_1 = $ifLet0[0])||true))) {
return Optional.none;
};
const result = {0: _this._count, 1: b_1};
Int.infix_43_61({get: () => _this._count, set: $val => _this._count = $val}, 1, {});
return _injectIntoOptional(result)
----Swift.(file).EnumeratedSequence.makeIterator()
let _this = this;
return _create(EnumeratedSequence.Iterator, 'init_base', _this._base.makeIterator( {}), {})
----Swift.(file).AnyHashable.init(_box:_AnyHashableBox)
let _this = this;
_this._box = _cloneStruct(box);
return
----Swift.(file).AnyHashable.init(_:H)
let _this = this;
const $ifLet0, custom_1
if((($ifLet0 = (((_.tmp0 = _injectIntoOptional(base)).rawValue === 'some') ? (_.tmp0[0]._toCustomAnyHashable( {})) : Optional.none))||true) && $ifLet0.rawValue == 'some' && ((custom_1 = $ifLet0[0])||true)) {
$info.$setThis(_this = _cloneStruct(_cloneStruct(custom_1)));
return ;
};
_this.init_box_AnyHashableBox(_create(_ConcreteHashableBox, 'init', false, {}), {});
_makeAnyHashableUpcastingToHashableBaseTypeStoringResultInto(base, /**/{get: () => _this, set: $val => $info.$setThis(_this = _cloneStruct($val))}, {});
return
----Swift.(file).AnyHashable.init(_usingDefaultRepresentationOf:H)
let _this = this;
_this._box = _cloneStruct(_create(_ConcreteHashableBox, 'init', base, {}));
return
----Swift.(file).AnyHashable.base
let _this = this;
return _this._box._base
----Swift.(file).AnyHashable.==infix(_:AnyHashable,_:AnyHashable)
let _this = this;
return infix_63_63(lhs._box._canonicalBox._isEqualTo(rhs._box._canonicalBox, {}), () => false, {})
----Swift.(file).AnyHashable.hashValue
let _this = this;
return _this._box._canonicalBox._hashValue
----Swift.(file).AnyHashable.hash(into:Hasher)
let _this = this;
let hasher = hasher$inout.get()
const $result = (() => {
_this._box._canonicalBox._hashInto({get: () => hasher, set: $val => hasher = $val}, {});})()
hasher$inout.set(hasher)
return $result
----Swift.(file).AnyHashable.description
let _this = this;
return _create(String, 'initDescribing', _this.base, {})
----Swift.(file).AnyHashable.debugDescription
let _this = this;
return String.infix_43(String.infix_43("AnyHashable(", _create(String, 'initReflecting', _this.base, {}), {}), ")", {})
----Swift.(file).AnyHashable.customMirror
let _this = this;
return _create(Mirror, 'initChildrenKeyValuePairsDisplayStyleOptionalAncestorRepresentationMirrorAncestorRepresentation', _this, new Map([["value", _this.base]]), nil/*!default_value*/, .generated/*!default_value*/, {})
----Swift.(file).Array.capacity
let _this = this;
return _this._getCapacity( {})
----Swift.(file).Array.Indices

----Swift.(file).Array.Iterator

----Swift.(file).Array.startIndex
let _this = this;
return 0
----Swift.(file).Array.endIndex
let _this = this;
return _this._getCount( {})
----Swift.(file).Array.index(after:Int)
let _this = this;
return Int.infix_43(i, 1, {})
----Swift.(file).Array.formIndex(after:Int)
let _this = this;
let i = i$inout.get()
const $result = (() => {
Int.infix_43_61({get: () => i, set: $val => i = $val}, 1, {});})()
i$inout.set(i)
return $result
----Swift.(file).Array.index(before:Int)
let _this = this;
return Int.infix_45(i, 1, {})
----Swift.(file).Array.formIndex(before:Int)
let _this = this;
let i = i$inout.get()
const $result = (() => {
Int.infix_45_61({get: () => i, set: $val => i = $val}, 1, {});})()
i$inout.set(i)
return $result
----Swift.(file).Array.index(_:Int,offsetBy:Int)
let _this = this;
return Int.infix_43(i, distance, {})
----Swift.(file).Array.index(_:Int,offsetBy:Int,limitedBy:Int)
let _this = this;
const l = Int.infix_45(limit, i, {});
if(((Int.infix_62(distance, 0, {}) ? Bool.infix_38_38(Int.infix_62_61(l, 0, {}), () => Int.infix_60(l, distance, {}), {}) : Bool.infix_38_38(Int.infix_60_61(l, 0, {}), () => Int.infix_60(distance, l, {}), {})))) {
return Optional.none;
};
return _injectIntoOptional(Int.infix_43(i, distance, {}))
----Swift.(file).Array.distance(from:Int,to:Int)
let _this = this;
return Int.infix_45(end, start, {})
----Swift.(file).Array.count
let _this = this;
return _this._getCount( {})
----Swift.(file).Array.init(arrayLiteral:[Element])
let _this = this;
return _cloneStruct(_cloneStruct(_elements));
return
----Swift.(file).Array.init(repeating:Element,count:Int)
let _this = this;
let p;
let $tuple = Array._allocateUninitialized(count, {})
return _cloneStruct($tuple[0])
p = $tuple[1];
{
let $generator = _cloneStruct(Int.infix_46_46_60(0, count, {}).makeIterator( {}));
while(true) {
const $ifLet0;
if(!((($ifLet0 = $generator.next( {$setThis: $val => $generator = $val}))||true) && $ifLet0.rawValue == 'some')) break
p.initializeTo(repeatedValue, {});
UnsafeMutablePointer.infix_43_61({get: () => p, set: $val => p = $val}, 1, {});
}
};
return
----Swift.(file).Array.append(_:Element)
let _this = this;
_this._makeUniqueAndReserveCapacityIfNotUnique( {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
const oldCount = _this._getCount( {});
_this._appendElementAssumeUniqueAndCapacityNewElement(oldCount, newElement, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
----Swift.(file).Array.insert(_:Element,at:Int)
let _this = this;
_this.replaceSubrangeWith(Int.infix_46_46_60(i, i, {}), _create(CollectionOfOne, 'init', newElement, {}), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
----Swift.(file).Array.withContiguousMutableStorageIfAvailable(_:(inout UnsafeMutableBufferPointer<Element>) throws -> R)
let _this = this;
return _injectIntoOptional(_this.withUnsafeMutableBufferPointer(((bufferPointer$inout, $info?) => body({get: () => bufferPointer, set: $val => bufferPointer = $val}, {})), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))}))
----Swift.(file).Array.withContiguousStorageIfAvailable(_:(UnsafeBufferPointer<Element>) throws -> R)
let _this = this;
return _injectIntoOptional(_this.withUnsafeBufferPointer(((bufferPointer, $info?) => body(bufferPointer, {})), {}))
----Swift.(file).Array.+infix(_:Array<Element>,_:Array<Element>)
let _this = this;
let lhs_dupl = _cloneStruct(lhs);
lhs_dupl.appendContentsOf(rhs, {$setThis: $val => lhs_dupl = $val});
return lhs_dupl
----Swift.(file).Array.+=infix(_:Array<Element>,_:Array<Element>)
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs.appendContentsOf(rhs, {$setThis: $val => lhs = $val});})()
lhs$inout.set(lhs)
return $result
----Swift.(file).Array.customMirror
let _this = this;
return _create(Mirror, 'initUnlabeledChildrenDisplayStyleOptionalAncestorRepresentationMirrorAncestorRepresentation', _this, _this, _injectIntoOptional(Mirror.DisplayStyle.collection), .generated/*!default_value*/, {})
----Swift.(file).Array.description
let _this = this;
return _this._makeCollectionDescriptionWithTypeName(nil/*!default_value*/, {})
----Swift.(file).Array.debugDescription
let _this = this;
return _this._makeCollectionDescriptionWithTypeName(nil/*!default_value*/, {})
----Swift.(file).Array.init(unsafeUninitializedCapacity:Int,initializingWith:(inout UnsafeMutableBufferPointer<Element>, inout Int) throws -> Void)
let _this = this;
return _cloneStruct(_cloneStruct(_create(Array, 'init_unsafeUninitializedCapacityIntInitializingWithfunction_type', unsafeUninitializedCapacity, initializer, {})));
return
----Swift.(file).Array.hash(into:Hasher)
let _this = this;
let hasher = hasher$inout.get()
const $result = (() => {
hasher.combine(_this.count, {$setThis: $val => hasher = $val});
{
let $element$generator = _cloneStruct(_this.makeIterator( {}));
while(true) {
const $ifLet0, _element_1;
if(!((($ifLet0 = $element$generator.next( {$setThis: $val => $element$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((_element_1 = $ifLet0[0])||true))) break
hasher.combine(_element_1, {$setThis: $val => hasher = $val});
}
};})()
hasher$inout.set(hasher)
return $result
----Swift.(file).Array.withUnsafeMutableBytes(_:(UnsafeMutableRawBufferPointer) throws -> R)
let _this = this;
return _this.withUnsafeMutableBufferPointer((($0$inout, $info?) => body(_create(UnsafeMutableRawBufferPointer, 'initUnsafeMutableBufferPointer', $0, {}), {})), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
----Swift.(file).Array.withUnsafeBytes(_:(UnsafeRawBufferPointer) throws -> R)
let _this = this;
return _this.withUnsafeBufferPointer((($0, $info?) => body(_create(UnsafeRawBufferPointer, 'initUnsafeBufferPointer', $0, {}), {})), {})
----Swift.(file).Array.init(_immutableCocoaArray:AnyObject)
let _this = this;
return _cloneStruct(_cloneStruct(_bridgeCocoaArray(_immutableCocoaArray, {})));
return
----Swift.(file)._ArrayBuffer.arrayPropertyIsNativeTypeChecked
let _this = this;
return _this._isNativeTypeChecked
----Swift.(file)._ArrayBuffer.isUniquelyReferenced()
let _this = this;
if((Bool.prefix_33(_isClassOrObjCExistential(((function(){throw '!unclarifiedGeneric:Element'})()), {}), {}))) {
return _this._storage.isUniquelyReferencedUnflaggedNative( {$setThis: $val => _this._storage = $val});
};
if((Bool.prefix_33(_this._storage.isUniquelyReferencedNative( {$setThis: $val => _this._storage = $val}), {}))) {
return false;
};
return _this._isNative
----Swift.(file)._ArrayBuffer.requestUniqueMutableBackingBuffer(minimumCapacity:Int)
let _this = this;
if((_fastPath(_this.isUniquelyReferenced( {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))}), {}))) {
const b = _cloneStruct(_this._native);
if((_fastPath(Int.infix_62_61(b.capacity, minimumCapacity, {}), {}))) {
return _injectIntoOptional(b);
};
};
return Optional.none
----Swift.(file)._ArrayBuffer.isMutableAndUniquelyReferenced()
let _this = this;
return _this.isUniquelyReferenced( {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
----Swift.(file)._ArrayBuffer.requestNativeBuffer()
let _this = this;
if((Bool.prefix_33(_isClassOrObjCExistential(((function(){throw '!unclarifiedGeneric:Element'})()), {}), {}))) {
return _injectIntoOptional(_this._native);
};
return (_fastPath(_this._storage.isNative, {}) ? _injectIntoOptional(_this._native) : Optional.none)
----Swift.(file)._ArrayBuffer.subscript(_:Range<Int>)#ASS

let _this = this;
fatalErrorFileLine(() => "not implemented", '?3', '?3', {})
----Swift.(file)._ArrayBuffer.subscript(_:Range<Int>)
let _this = this;
_this._typeCheck(bounds, {});
if((_fastPath(_this._isNative, {}))) {
return _this._native.subscript$get(bounds, {});
};
return _this._nonNative.subscriptRange$get(bounds, {}).unsafeCastElementsTo(((function(){throw '!unclarifiedGeneric:Element'})()), {});

----Swift.(file)._ArrayBuffer.firstElementAddress
let _this = this;
return _this._native.firstElementAddress
----Swift.(file)._ArrayBuffer.firstElementAddressIfContiguous
let _this = this;
return (_fastPath(_this._isNative, {}) ? _injectIntoOptional(_this.firstElementAddress) : Optional.none)
----Swift.(file)._ArrayBuffer.count
let _this = this;
return (_fastPath(_this._isNative, {}) ? _this._native.count : _this._nonNative.count)
----Swift.(file)._ArrayBuffer.capacity
let _this = this;
return (_fastPath(_this._isNative, {}) ? _this._native.capacity : _this._nonNative.count)
----Swift.(file)._ArrayBuffer.getElement(_:Int,wasNativeTypeChecked:Bool)
let _this = this;
if((_fastPath(wasNativeTypeChecked, {}))) {
return _this._nativeTypeChecked.subscript$get(i, {});
};
return unsafeBitCastTo(_this._getElementSlowPath(i, {}), ((function(){throw '!unclarifiedGeneric:Element'})()), {})
----Swift.(file)._ArrayBuffer.subscript(_:Int)#ASS

let _this = this;
if((_fastPath(_this._isNative, {}))) {
_this._native.subscript$set(newValue, i, {$setThis: $val => _this._native = _cloneStruct($val)});
}
else {
let refCopy = _cloneStruct(_this);
refCopy.replaceSubrangeWithElementsOf(Int.infix_46_46_60(i, Int.infix_43(i, 1, {}), {}), 1, _create(CollectionOfOne, 'init', newValue, {}), {$setThis: $val => refCopy = $val});
}
----Swift.(file)._ArrayBuffer.subscript(_:Int)
let _this = this;
return _this.getElementWasNativeTypeChecked(i, _this._isNativeTypeChecked, {});

----Swift.(file)._ArrayBuffer.withUnsafeBufferPointer(_:(UnsafeBufferPointer<Element>) throws -> R)
let _this = this;
if((_fastPath(_this._isNative, {}))) {
let $defer = () => {
_fixLifetime(_this, {});
}
const $result = (() => {
try {;
return body(_create(UnsafeBufferPointer, 'initStartOptionalCountInt', _injectIntoOptional(/*pointer_to_pointer*/_this.firstElementAddress), _this.count, {}), {});}catch($error){$defer( {});throw $error}})();$defer( {});return $result;
};
return _create(ContiguousArray, 'initBuffer', _this, {}).withUnsafeBufferPointer(body, {})
----Swift.(file)._ArrayBuffer.owner
let _this = this;
return (_fastPath(_this._isNative, {}) ? _this._native._storage : _this._nonNative.buffer)
----Swift.(file)._ArrayBuffer.nativeOwner
let _this = this;
return _this._native._storage
----Swift.(file)._ArrayBuffer.identity
let _this = this;
if((_this._isNative)) {
return _this._native.identity;
}
else {
return _create(UnsafeRawPointer, 'initUnsafeMutableRawPointer', Unmanaged.passUnretained(_this._nonNative.buffer, {}).toOpaque( {}), {});
}
----Swift.(file)._ArrayBuffer.startIndex
let _this = this;
return 0
----Swift.(file)._ArrayBuffer.endIndex
let _this = this;
return _this.count
----Swift.(file)._ArrayBuffer.Indices

----Swift.(file)._ArrayBuffer.Storage

----Swift.(file)._ArrayBuffer.NativeBuffer

----Swift.(file)._ArrayBufferProtocol.subscriptBaseAddress
let _this = this;
return _this.firstElementAddress
----Swift.(file)._ArrayBufferProtocol.replaceSubrange(_:Range<Int>,with:Int,elementsOf:C)
let _this = this;
const oldCount = _this.count;
const eraseCount = subrange.count;
const growth = Int.infix_45(newCount, eraseCount, {});
_this.count = Int.infix_43(oldCount, growth, {});
const _elements = _cloneStruct(_this.subscriptBaseAddress);
const oldTailIndex = subrange.upperBound;
const oldTailStart = _cloneStruct(UnsafeMutablePointer.infix_43(_elements, oldTailIndex, {}));
const newTailIndex = Int.infix_43(oldTailIndex, growth, {});
const newTailStart = _cloneStruct(UnsafeMutablePointer.infix_43(oldTailStart, growth, {}));
const tailCount = Int.infix_45(oldCount, subrange.upperBound, {});
if((Int.infix_62(growth, 0, {}))) {
newTailStart.moveInitializeFromCount(oldTailStart, tailCount, {});
let i = newValues.startIndex;
{
let $j$generator = _cloneStruct(subrange.makeIterator( {}));
while(true) {
const $ifLet0, j_1;
if(!((($ifLet0 = $j$generator.next( {$setThis: $val => $j$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((j_1 = $ifLet0[0])||true))) break
_elements.subscript$set(newValues.subscript$get(i, {}), j_1, {$setThis: $val => _elements = _cloneStruct($val)});
newValues.formIndexAfter({get: () => i, set: $val => i = $val}, {});
}
};
{
let $j$generator = _cloneStruct(Int.infix_46_46_60(oldTailIndex, newTailIndex, {}).makeIterator( {}));
while(true) {
const $ifLet2, j_3;
if(!((($ifLet2 = $j$generator.next( {$setThis: $val => $j$generator = $val}))||true) && $ifLet2.rawValue == 'some' && ((j_3 = $ifLet2[0])||true))) break
UnsafeMutablePointer.infix_43(_elements, j_3, {}).initializeTo(newValues.subscript$get(i, {}), {});
newValues.formIndexAfter({get: () => i, set: $val => i = $val}, {});
}
};
}
else {
let i = subrange.lowerBound;
let j = newValues.startIndex;
{
let $generator = _cloneStruct(Int.infix_46_46_60(0, newCount, {}).makeIterator( {}));
while(true) {
const $ifLet4;
if(!((($ifLet4 = $generator.next( {$setThis: $val => $generator = $val}))||true) && $ifLet4.rawValue == 'some')) break
_elements.subscript$set(newValues.subscript$get(j, {}), i, {$setThis: $val => _elements = _cloneStruct($val)});
Int.infix_43_61({get: () => i, set: $val => i = $val}, 1, {});
newValues.formIndexAfter({get: () => j, set: $val => j = $val}, {});
}
};
if((Int.infix_61_61(growth, 0, {}))) {
return ;
};
const shrinkage = Int.prefix_45(growth, {});
if((Int.infix_62(tailCount, shrinkage, {}))) {
newTailStart.moveAssignFromCount(oldTailStart, shrinkage, {});
oldTailStart.moveInitializeFromCount(UnsafeMutablePointer.infix_43(oldTailStart, shrinkage, {}), Int.infix_45(tailCount, shrinkage, {}), {});
}
else {
newTailStart.moveAssignFromCount(oldTailStart, tailCount, {});
UnsafeMutablePointer.infix_43(newTailStart, tailCount, {}).deinitializeCount(Int.infix_45(shrinkage, tailCount, {}), {});
};
}
----Swift.(file).ArraySlice.capacity
let _this = this;
return _this._getCapacity( {})
----Swift.(file).ArraySlice.Indices

----Swift.(file).ArraySlice.Iterator

----Swift.(file).ArraySlice.index(after:Int)
let _this = this;
return Int.infix_43(i, 1, {})
----Swift.(file).ArraySlice.formIndex(after:Int)
let _this = this;
let i = i$inout.get()
const $result = (() => {
Int.infix_43_61({get: () => i, set: $val => i = $val}, 1, {});})()
i$inout.set(i)
return $result
----Swift.(file).ArraySlice.index(before:Int)
let _this = this;
return Int.infix_45(i, 1, {})
----Swift.(file).ArraySlice.formIndex(before:Int)
let _this = this;
let i = i$inout.get()
const $result = (() => {
Int.infix_45_61({get: () => i, set: $val => i = $val}, 1, {});})()
i$inout.set(i)
return $result
----Swift.(file).ArraySlice.index(_:Int,offsetBy:Int)
let _this = this;
return Int.infix_43(i, distance, {})
----Swift.(file).ArraySlice.index(_:Int,offsetBy:Int,limitedBy:Int)
let _this = this;
const l = Int.infix_45(limit, i, {});
if(((Int.infix_62(distance, 0, {}) ? Bool.infix_38_38(Int.infix_62_61(l, 0, {}), () => Int.infix_60(l, distance, {}), {}) : Bool.infix_38_38(Int.infix_60_61(l, 0, {}), () => Int.infix_60(distance, l, {}), {})))) {
return Optional.none;
};
return _injectIntoOptional(Int.infix_43(i, distance, {}))
----Swift.(file).ArraySlice.distance(from:Int,to:Int)
let _this = this;
return Int.infix_45(end, start, {})
----Swift.(file).ArraySlice.count
let _this = this;
return _this._getCount( {})
----Swift.(file).ArraySlice.init(repeating:Element,count:Int)
let _this = this;
let p;
let $tuple = ArraySlice._allocateUninitialized(count, {})
$info.$setThis(_this = _cloneStruct($tuple[0]))
p = $tuple[1];
{
let $generator = _cloneStruct(Int.infix_46_46_60(0, count, {}).makeIterator( {}));
while(true) {
const $ifLet0;
if(!((($ifLet0 = $generator.next( {$setThis: $val => $generator = $val}))||true) && $ifLet0.rawValue == 'some')) break
p.initializeTo(repeatedValue, {});
UnsafeMutablePointer.infix_43_61({get: () => p, set: $val => p = $val}, 1, {});
}
};
return
----Swift.(file).ArraySlice.append(_:Element)
let _this = this;
_this._makeUniqueAndReserveCapacityIfNotUnique( {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
const oldCount = _this._getCount( {});
_this._appendElementAssumeUniqueAndCapacityNewElement(oldCount, newElement, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
----Swift.(file).ArraySlice.remove(at:Int)
let _this = this;
const result = _this.subscript$get(index, {});
_this.replaceSubrangeWith(Int.infix_46_46_60(index, Int.infix_43(index, 1, {}), {}), _create(EmptyCollection, 'init', {}), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
return result
----Swift.(file).ArraySlice.insert(_:Element,at:Int)
let _this = this;
_this.replaceSubrangeWith(Int.infix_46_46_60(i, i, {}), _create(CollectionOfOne, 'init', newElement, {}), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
----Swift.(file).ArraySlice.withContiguousMutableStorageIfAvailable(_:(inout UnsafeMutableBufferPointer<Element>) throws -> R)
let _this = this;
return _injectIntoOptional(_this.withUnsafeMutableBufferPointer(((bufferPointer$inout, $info?) => body({get: () => bufferPointer, set: $val => bufferPointer = $val}, {})), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))}))
----Swift.(file).ArraySlice.withContiguousStorageIfAvailable(_:(UnsafeBufferPointer<Element>) throws -> R)
let _this = this;
return _injectIntoOptional(_this.withUnsafeBufferPointer(((bufferPointer, $info?) => body(bufferPointer, {})), {}))
----Swift.(file).ArraySlice.customMirror
let _this = this;
return _create(Mirror, 'initUnlabeledChildrenDisplayStyleOptionalAncestorRepresentationMirrorAncestorRepresentation', _this, _this, _injectIntoOptional(Mirror.DisplayStyle.collection), .generated/*!default_value*/, {})
----Swift.(file).ArraySlice.description
let _this = this;
return _this._makeCollectionDescriptionWithTypeName(nil/*!default_value*/, {})
----Swift.(file).ArraySlice.debugDescription
let _this = this;
return _this._makeCollectionDescriptionWithTypeName(_injectIntoOptional("ArraySlice"), {})
----Swift.(file).ArraySlice.hash(into:Hasher)
let _this = this;
let hasher = hasher$inout.get()
const $result = (() => {
hasher.combine(_this.count, {$setThis: $val => hasher = $val});
{
let $element$generator = _cloneStruct(_this.makeIterator( {}));
while(true) {
const $ifLet0, _element_1;
if(!((($ifLet0 = $element$generator.next( {$setThis: $val => $element$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((_element_1 = $ifLet0[0])||true))) break
hasher.combine(_element_1, {$setThis: $val => hasher = $val});
}
};})()
hasher$inout.set(hasher)
return $result
----Swift.(file).ArraySlice.withUnsafeMutableBytes(_:(UnsafeMutableRawBufferPointer) throws -> R)
let _this = this;
return _this.withUnsafeMutableBufferPointer((($0$inout, $info?) => body(_create(UnsafeMutableRawBufferPointer, 'initUnsafeMutableBufferPointer', $0, {}), {})), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
----Swift.(file).ArraySlice.withUnsafeBytes(_:(UnsafeRawBufferPointer) throws -> R)
let _this = this;
return _this.withUnsafeBufferPointer((($0, $info?) => body(_create(UnsafeRawBufferPointer, 'initUnsafeBufferPointer', $0, {}), {})), {})
----Swift.(file)._ArrayProtocol.filter(_:(Self.Element) throws -> Bool)
let _this = this;
return _this._filter(isIncluded, {})
----Swift.(file).BidirectionalCollection.formIndex(before:Self.Index)
let _this = this;
let i = i$inout.get()
const $result = (() => {
i = _this.indexBefore(i, {});})()
i$inout.set(i)
return $result
----Swift.(file).BidirectionalCollection.index(_:Self.Index,offsetBy:Int)
let _this = this;
return _this._indexOffsetBy(i, distance, {})
----Swift.(file).BidirectionalCollection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)
let _this = this;
return _this._indexOffsetByLimitedBy(i, distance, limit, {})
----Swift.(file).BidirectionalCollection.distance(from:Self.Index,to:Self.Index)
let _this = this;
return _this._distanceFromTo(start, end, {})
----Swift.(file).BidirectionalCollection.popLast()
let _this = this;
if(!((Bool.prefix_33(_this.isEmpty, {})))) {
return Optional.none;
};
const _element = _this.last[0];
$info.$setThis(_this = _cloneStruct(_this.subscriptRange$get((_.arg0 = _this.startIndex).constructor.infix_46_46_60(_.arg0, _this.indexBefore(_this.endIndex, {}), {}), {})));
return _injectIntoOptional(_element)
----Swift.(file).BidirectionalCollection.removeLast()
let _this = this;
const _element = _this.last[0];
$info.$setThis(_this = _cloneStruct(_this.subscriptRange$get((_.arg0 = _this.startIndex).constructor.infix_46_46_60(_.arg0, _this.indexBefore(_this.endIndex, {}), {}), {})));
return _element
----Swift.(file).BidirectionalCollection.removeLast(_:Int)
let _this = this;
if((Int.infix_61_61(k, 0, {}))) {
return ;
};
preconditionFileLine(() => Int.infix_62_61(k, 0, {}), () => "Number of elements to remove should be non-negative", '?3', '?3', {});
preconditionFileLine(() => Int.infix_62_61(_this.count, k, {}), () => "Can't remove more items from a collection than it contains", '?3', '?3', {});
$info.$setThis(_this = _cloneStruct(_this.subscriptRange$get((_.arg0 = _this.startIndex).constructor.infix_46_46_60(_.arg0, _this.indexOffsetBy(_this.endIndex, Int.prefix_45(k, {}), {}), {}), {})))
----Swift.(file).BidirectionalCollection.dropLast(_:Int)
let _this = this;
preconditionFileLine(() => Int.infix_62_61(k, 0, {}), () => "Can't drop a negative number of elements from a collection", '?3', '?3', {});
const end = infix_63_63(_this.indexOffsetByLimitedBy(_this.endIndex, Int.prefix_45(k, {}), _this.startIndex, {}), () => _this.startIndex, {});
return _this.subscriptRange$get((_.arg0 = _this.startIndex).constructor.infix_46_46_60(_.arg0, end, {}), {})
----Swift.(file).BidirectionalCollection.suffix(_:Int)
let _this = this;
preconditionFileLine(() => Int.infix_62_61(maxLength, 0, {}), () => "Can't take a suffix of negative length from a collection", '?3', '?3', {});
const start = infix_63_63(_this.indexOffsetByLimitedBy(_this.endIndex, Int.prefix_45(maxLength, {}), _this.startIndex, {}), () => _this.startIndex, {});
return _this.subscriptRange$get((_.arg0 = start).constructor.infix_46_46_60(_.arg0, _this.endIndex, {}), {})
----Swift.(file)._UnsafeBitset.word(for:Int)
let _this = this;
const _element = _create(UInt, 'initBitPatternInt', _element, {});
const capacity = _create(UInt, 'initBitPatternInt', _UnsafeBitset.Word.capacity, {});
return _create(Int, 'initBitPatternUInt', UInt.infix_47(_element, capacity, {}), {})
----Swift.(file)._UnsafeBitset.bit(for:Int)
let _this = this;
const _element = _create(UInt, 'initBitPatternInt', _element, {});
const capacity = _create(UInt, 'initBitPatternInt', _UnsafeBitset.Word.capacity, {});
return _create(Int, 'initBitPatternUInt', UInt.infix_37(_element, capacity, {}), {})
----Swift.(file)._UnsafeBitset.split(_:Int)
let _this = this;
return {0: _this.wordFor(_element, {}), 1: _this.bitFor(_element, {})}
----Swift.(file)._UnsafeBitset.join(word:Int,bit:Int)
let _this = this;
return Int.infix_38_43(Int.infix_38_42(word, _UnsafeBitset.Word.capacity, {}), bit, {})
----Swift.(file)._UnsafeBitset.wordCount(forCapacity:Int)
let _this = this;
return _this.wordFor(Int.infix_38_45(Int.infix_38_43(capacity, _UnsafeBitset.Word.capacity, {}), 1, {}), {})
----Swift.(file)._UnsafeBitset.capacity
let _this = this;
return Int.infix_38_42(_this.wordCount, _UnsafeBitset.Word.capacity, {})
----Swift.(file)._UnsafeBitset.isValid(_:Int)
let _this = this;
return Bool.infix_38_38(Int.infix_62_61(_element, 0, {}), () => Int.infix_60_61(_element, _this.capacity, {}), {})
----Swift.(file)._UnsafeBitset.uncheckedContains(_:Int)
let _this = this;
const $tuple = _UnsafeBitset.split(_element, {})/*destructure_tuple_expr (**NULL EXPRESSION**), (**NULL EXPRESSION**)*/, word = $tuple && $tuple[0], bit = $tuple && $tuple[1];
return _this.words.subscript$get(word, {}).uncheckedContains(bit, {})
----Swift.(file)._UnsafeBitset.uncheckedInsert(_:Int)
let _this = this;
const $tuple = _UnsafeBitset.split(_element, {})/*destructure_tuple_expr (**NULL EXPRESSION**), (**NULL EXPRESSION**)*/, word = $tuple && $tuple[0], bit = $tuple && $tuple[1];
return _this.words.subscript$get(word, {}).uncheckedInsert(bit, {$setThis: $val => _this.words.subscript$set($val, word, {$setThis: $val => _this.words = _cloneStruct($val)})})
----Swift.(file)._UnsafeBitset.uncheckedRemove(_:Int)
let _this = this;
const $tuple = _UnsafeBitset.split(_element, {})/*destructure_tuple_expr (**NULL EXPRESSION**), (**NULL EXPRESSION**)*/, word = $tuple && $tuple[0], bit = $tuple && $tuple[1];
return _this.words.subscript$get(word, {}).uncheckedRemove(bit, {$setThis: $val => _this.words.subscript$set($val, word, {$setThis: $val => _this.words = _cloneStruct($val)})})
----Swift.(file)._UnsafeBitset.clear()
let _this = this;
_this.words.assignRepeatingCount(_UnsafeBitset.Word.empty, _this.wordCount, {})
----Swift.(file)._UnsafeBitset.count
let _this = this;
let count = 0;
{
let $w$generator = _cloneStruct(Int.infix_46_46_60(0, _this.wordCount, {}).makeIterator( {}));
while(true) {
const $ifLet0, w_1;
if(!((($ifLet0 = $w$generator.next( {$setThis: $val => $w$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((w_1 = $ifLet0[0])||true))) break
Int.infix_43_61({get: () => count, set: $val => count = $val}, _this.words.subscript$get(w_1, {}).count, {});
}
};
return count
----Swift.(file)._UnsafeBitset.underestimatedCount
let _this = this;
return _this.count
----Swift.(file)._UnsafeBitset.makeIterator()
let _this = this;
return _create(_UnsafeBitset.Iterator, 'init_UnsafeBitset', _this, {})
----Swift.(file)._UnsafeBitset.Word.capacity
let _this = this;
return UInt.bitWidth;
}
static get capacity() { return this.capacity$get()
----Swift.(file)._UnsafeBitset.Word.uncheckedContains(_:Int)
let _this = this;
return UInt.infix_33_61(UInt.infix_38(_this.value, UInt.infix_38_60_60(1, bit, {}), {}), 0, {})
----Swift.(file)._UnsafeBitset.Word.uncheckedInsert(_:Int)
let _this = this;
const mask = UInt.infix_38_60_60(1, bit, {});
const inserted = UInt.infix_61_61(UInt.infix_38(_this.value, mask, {}), 0, {});
UInt.infix_124_61({get: () => _this.value, set: $val => _this.value = $val}, mask, {});
return inserted
----Swift.(file)._UnsafeBitset.Word.uncheckedRemove(_:Int)
let _this = this;
const mask = UInt.infix_38_60_60(1, bit, {});
const removed = UInt.infix_33_61(UInt.infix_38(_this.value, mask, {}), 0, {});
UInt.infix_38_61({get: () => _this.value, set: $val => _this.value = $val}, UInt.prefix_126(mask, {}), {});
return removed
----Swift.(file)._UnsafeBitset.Word.minimum
let _this = this;
if(!((UInt.infix_33_61(_this.value, 0, {})))) {
return Optional.none;
};
return _injectIntoOptional(UInt.prototype.trailingZeroBitCount$get.call(_this.value))
----Swift.(file)._UnsafeBitset.Word.maximum
let _this = this;
if(!((UInt.infix_33_61(_this.value, 0, {})))) {
return Optional.none;
};
return _injectIntoOptional(Int.infix_38_45(Int.infix_38_45(_UnsafeBitset.Word.capacity, 1, {}), UInt.prototype.leadingZeroBitCount$get.call(_this.value), {}))
----Swift.(file)._UnsafeBitset.Word.complement
let _this = this;
return _create(_UnsafeBitset.Word, 'initUInt', UInt.prefix_126(_this.value, {}), {})
----Swift.(file)._UnsafeBitset.Word.subtracting(elementsBelow:Int)
let _this = this;
const mask = UInt.infix_38_60_60(UInt.max, bit, {});
return _create(_UnsafeBitset.Word, 'initUInt', UInt.infix_38(_this.value, mask, {}), {})
----Swift.(file)._UnsafeBitset.Word.intersecting(elementsBelow:Int)
let _this = this;
const mask = UInt.infix_38_45(UInt.infix_38_60_60(1, bit, {}), 1, {});
return _create(_UnsafeBitset.Word, 'initUInt', UInt.infix_38(_this.value, mask, {}), {})
----Swift.(file)._UnsafeBitset.Word.intersecting(elementsAbove:Int)
let _this = this;
const mask = UInt.infix_38_60_60(UInt.infix_38_60_60(UInt.max, bit, {}), 1, {});
return _create(_UnsafeBitset.Word, 'initUInt', UInt.infix_38(_this.value, mask, {}), {})
----Swift.(file)._UnsafeBitset.Word.empty
let _this = this;
return _create(_UnsafeBitset.Word, 'initUInt', 0, {});
}
static get empty() { return this.empty$get()
----Swift.(file)._UnsafeBitset.Word.allBits
let _this = this;
return _create(_UnsafeBitset.Word, 'initUInt', UInt.max, {});
}
static get allBits() { return this.allBits$get()
----Swift.(file)._UnsafeBitset.Word.count
let _this = this;
return UInt.prototype.nonzeroBitCount$get.call(_this.value)
----Swift.(file)._UnsafeBitset.Word.underestimatedCount
let _this = this;
return _this.count
----Swift.(file)._UnsafeBitset.Word.isEmpty
let _this = this;
return UInt.infix_61_61(_this.value, 0, {})
----Swift.(file)._UnsafeBitset.Word.next()
let _this = this;
if(!((UInt.infix_33_61(_this.value, 0, {})))) {
return Optional.none;
};
const bit = UInt.prototype.trailingZeroBitCount$get.call(_this.value);
UInt.infix_38_61({get: () => _this.value, set: $val => _this.value = $val}, UInt.infix_38_45(_this.value, 1, {}), {});
return _injectIntoOptional(bit)
----Swift.(file).Bool.init(_:Bool)
let _this = this;
return _cloneStruct(value);
return
----Swift.(file).Bool.random(using:T)
let _this = this;
let generator = generator$inout.get()
const $result = (() => {
return UInt64.infix_61_61(UInt64.infix_38(UInt64.infix_62_62(generator.next( {$setThis: $val => generator = $val}), 17, {}), 1, {}), 0, {});})()
generator$inout.set(generator)
return $result
----Swift.(file).Bool.random()
let _this = this;
let g = _create(SystemRandomNumberGenerator, 'init', {});
return Bool.randomUsing({get: () => g, set: $val => g = $val}, {})
----Swift.(file).Bool.init(booleanLiteral:Bool)
let _this = this;
return _cloneStruct(value);
return
----Swift.(file).Bool.description
let _this = this;
return (_this ? "true" : "false")
----Swift.(file).Bool.hash(into:Hasher)
let _this = this;
let hasher = hasher$inout.get()
const $result = (() => {
hasher.combine((_this ? 1 : 0), {$setThis: $val => hasher = $val});})()
hasher$inout.set(hasher)
return $result
----Swift.(file).Bool.init(_:String)
let _this = this;
if((String.infix_61_61(description, "true", {}))) {
return _cloneStruct(true);
}
else {
if((String.infix_61_61(description, "false", {}))) {
return _cloneStruct(false);
}
else {
return (this.$failed = true);
}
};
return
----Swift.(file).Bool.&&infix(_:Bool,_:() throws -> Bool)
let _this = this;
return (lhs ? rhs( {}) : false)
----Swift.(file).Bool.||infix(_:Bool,_:() throws -> Bool)
let _this = this;
return (lhs ? true : rhs( {}))
----Swift.(file).Bool.toggle()
let _this = this;
$info.$setThis(_this = _cloneStruct(Bool.prefix_33(_this, {})))
----Swift.(file).AutoreleasingUnsafeMutablePointer.subscript(_:Int)
let _this = this;
/*yield*/
----Swift.(file).AutoreleasingUnsafeMutablePointer.init(_:UnsafeMutablePointer<U>?)
let _this = this;
const $ifLet0, unwrapped_1
if(!((($ifLet0 = from)||true) && $ifLet0.rawValue == 'some' && ((unwrapped_1 = $ifLet0[0])||true))) {
return (this.$failed = true);
};
_this.initUnsafeMutablePointer(unwrapped_1, {});
return
----Swift.(file).AutoreleasingUnsafeMutablePointer.init(_:UnsafePointer<U>?)
let _this = this;
const $ifLet0, unwrapped_1
if(!((($ifLet0 = from)||true) && $ifLet0.rawValue == 'some' && ((unwrapped_1 = $ifLet0[0])||true))) {
return (this.$failed = true);
};
_this.initUnsafePointer(unwrapped_1, {});
return
----Swift.(file).UnsafeMutableRawPointer.init(_:AutoreleasingUnsafeMutablePointer<T>?)
let _this = this;
const $ifLet0, unwrapped_1
if(!((($ifLet0 = other)||true) && $ifLet0.rawValue == 'some' && ((unwrapped_1 = $ifLet0[0])||true))) {
return (this.$failed = true);
};
_this.initAutoreleasingUnsafeMutablePointer(unwrapped_1, {});
return
----Swift.(file).UnsafeRawPointer.init(_:AutoreleasingUnsafeMutablePointer<T>?)
let _this = this;
const $ifLet0, unwrapped_1
if(!((($ifLet0 = other)||true) && $ifLet0.rawValue == 'some' && ((unwrapped_1 = $ifLet0[0])||true))) {
return (this.$failed = true);
};
_this.init(/*pointer_to_pointer*/unwrapped_1, {});
return
----Swift.(file).ManagedBufferPointer.init(_:Int)
let _this = this;
_this.init_uncheckedBufferClassAnyClassMinimumCapacityInt(__BridgingBufferStorage, count, {});
_this.withUnsafeMutablePointerToHeader((($0, $info?) => $0.initializeTo(_create(_BridgingBufferHeader, 'initInt', count, {}), {})), {});
return
----Swift.(file).ManagedBufferPointer.count
let _this = this;
return _this.header.count
----Swift.(file).ManagedBufferPointer.subscript(_:Int)
let _this = this;
return _this.withUnsafeMutablePointerToElements((($0, $info?) => $0.subscript$get(i, {})), {})
----Swift.(file).ManagedBufferPointer.baseAddress
let _this = this;
return _this.withUnsafeMutablePointerToElements((($0, $info?) => $0), {})
----Swift.(file).ManagedBufferPointer.storage
let _this = this;
return _injectIntoOptional(_this.buffer)
----Swift.(file).!=infix(_:Any.Type?,_:Any.Type?)
return Bool.prefix_33(infix_61_61(t0, t1, {}), {})
----Swift.(file).String.init(cString:UnsafePointer<CChar>)
let _this = this;
const len = UTF8._nullCodeUnitOffsetIn(cString, {});
return _cloneStruct(String._fromUTF8Repairing(_create(UnsafeBufferPointer, 'initStartOptionalCountInt', _injectIntoOptional(/*pointer_to_pointer*/cString._asUInt8), len, {}), {})["0"]);
return
----Swift.(file).String.init(cString:UnsafePointer<UInt8>)
let _this = this;
const len = UTF8._nullCodeUnitOffsetIn(cString, {});
return _cloneStruct(String._fromUTF8Repairing(_create(UnsafeBufferPointer, 'initStartOptionalCountInt', _injectIntoOptional(/*pointer_to_pointer*/cString), len, {}), {})["0"]);
return
----Swift.(file).String.init(validatingUTF8:UnsafePointer<CChar>)
let _this = this;
const len = UTF8._nullCodeUnitOffsetIn(cString, {});
const $ifLet0, str_1
if(!((($ifLet0 = String._tryFromUTF8(_create(UnsafeBufferPointer, 'initStartOptionalCountInt', _injectIntoOptional(/*pointer_to_pointer*/cString._asUInt8), len, {}), {}))||true) && $ifLet0.rawValue == 'some' && ((str_1 = $ifLet0[0])||true))) {
return (this.$failed = true);
};
return _cloneStruct(str_1);
return
----Swift.(file).String.decodeCString(_:UnsafePointer<Encoding.CodeUnit>?,as:Encoding.Type,repairingInvalidCodeUnits:Bool)
let _this = this;
const $ifLet0, cPtr_1
if(!((($ifLet0 = cString)||true) && $ifLet0.rawValue == 'some' && ((cPtr_1 = $ifLet0[0])||true))) {
return Optional.none;
};
if((_fastPath(infix_61_61(_injectIntoOptional(encoding), _injectIntoOptional(Unicode.UTF8), {}), {}))) {
const ptr = _cloneStruct(_create(UnsafeRawPointer, 'init', /*pointer_to_pointer*/cPtr_1, {}).assumingMemoryBoundTo(UInt8, {}));
const len = UTF8._nullCodeUnitOffsetIn(ptr, {});
const codeUnits = _create(UnsafeBufferPointer, 'initStartOptionalCountInt', _injectIntoOptional(/*pointer_to_pointer*/ptr), len, {});
if((isRepairing)) {
return _injectIntoOptional(String._fromUTF8Repairing(codeUnits, {}));
}
else {
const $ifLet2, str_3
if(!((($ifLet2 = String._tryFromUTF8(codeUnits, {}))||true) && $ifLet2.rawValue == 'some' && ((str_3 = $ifLet2[0])||true))) {
return Optional.none;
};
return _injectIntoOptional({0: str_3, 1: false});
};
};
let end = _cloneStruct(cPtr_1);
while(true){
if(!((((function(){throw '!unclarifiedGeneric:Encoding.CodeUnit'})()).infix_33_61(end.pointee, 0, {})))) break
UnsafePointer.infix_43_61({get: () => end, set: $val => end = $val}, 1, {});
};
const len = UnsafePointer.infix_45(end, cPtr_1, {});
const codeUnits = _create(UnsafeBufferPointer, 'initStartOptionalCountInt', _injectIntoOptional(/*pointer_to_pointer*/cPtr_1), len, {});
return _injectIntoOptional(((_.tmp0 = String._fromCodeUnitsEncodingRepair(codeUnits, encoding, isRepairing, {})).rawValue === 'some') ? (_.tmp0[0]/*destructure_tuple_expr (**NULL EXPRESSION**), (**NULL EXPRESSION**)*/) : null)
----Swift.(file).String.init(decodingCString:UnsafePointer<Encoding.CodeUnit>,as:Encoding.Type)
let _this = this;
return _cloneStruct(String.decodeCStringAsRepairingInvalidCodeUnits(_injectIntoOptional(/*pointer_to_pointer*/ptr), sourceEncoding, true/*!default_value*/, {})[0]["0"]);
return
----Swift.(file).OpaquePointer.init(_:UnsafePointer<T>)
let _this = this;
_this._rawValue = from._rawValue;
return
----Swift.(file).OpaquePointer.init(_:UnsafePointer<T>?)
let _this = this;
const $ifLet0, unwrapped_1
if(!((($ifLet0 = from)||true) && $ifLet0.rawValue == 'some' && ((unwrapped_1 = $ifLet0[0])||true))) {
return (this.$failed = true);
};
_this.initUnsafeRawPointer(/*pointer_to_pointer*/unwrapped_1, {});
return
----Swift.(file).OpaquePointer.init(_:UnsafeMutablePointer<T>)
let _this = this;
_this._rawValue = from._rawValue;
return
----Swift.(file).OpaquePointer.init(_:UnsafeMutablePointer<T>?)
let _this = this;
const $ifLet0, unwrapped_1
if(!((($ifLet0 = from)||true) && $ifLet0.rawValue == 'some' && ((unwrapped_1 = $ifLet0[0])||true))) {
return (this.$failed = true);
};
_this.initUnsafeMutablePointer(unwrapped_1, {});
return
----Swift.(file).OpaquePointer.debugDescription
let _this = this;
return _rawPointerToString(_this._rawValue, {})
----Swift.(file).Int.init(bitPattern:OpaquePointer?)
let _this = this;
_this.initBitPatternOptional(_create(UnsafeRawPointer, 'initOptional', pointer, {}), {});
return
----Swift.(file).UInt.init(bitPattern:OpaquePointer?)
let _this = this;
_this.initBitPatternOptional(_create(UnsafeRawPointer, 'initOptional', pointer, {}), {});
return
----Swift.(file).CVaListPointer.init(_fromUnsafeMutablePointer:UnsafeMutableRawPointer)
let _this = this;
_this._value = _cloneStruct(from);
return
----Swift.(file).CVaListPointer.debugDescription
let _this = this;
return _this._value.debugDescription
----Swift.(file).Character.init(unchecked:String)
let _this = this;
_this = str;
_this._invariantCheck( {});
return
----Swift.(file).Character.utf8
let _this = this;
return _this.utf8
----Swift.(file).Character.utf16
let _this = this;
return _this.utf16
----Swift.(file).Character.unicodeScalars
let _this = this;
return _this.unicodeScalars
----Swift.(file).Character.init(_:Unicode.Scalar)
let _this = this;
_this.initUncheckedString(_create(String, 'initUnicodeScalar', content, {}), {});
return
----Swift.(file).Character.init(extendedGraphemeClusterLiteral:Character)
let _this = this;
_this.initUncheckedString(value, {});
return
----Swift.(file).Character.description
let _this = this;
return _this
----Swift.(file).Character.debugDescription
let _this = this;
return _this.debugDescription
----Swift.(file).Character.==infix(_:Character,_:Character)
let _this = this;
return String.infix_61_61(lhs, rhs, {})
----Swift.(file).Character.<infix(_:Character,_:Character)
let _this = this;
return String.infix_60(lhs, rhs, {})
----Swift.(file).Character.hash(into:Hasher)
let _this = this;
let hasher = hasher$inout.get()
const $result = (() => {
_this.hashInto({get: () => hasher, set: $val => hasher = $val}, {});})()
hasher$inout.set(hasher)
return $result
----Swift.(file).Character.isASCII
let _this = this;
return Optional.wrappedNotEqualsOptionalNilComparisonType(_this.asciiValue, _create(_OptionalNilComparisonType, 'initNilLiteraltuple_type', {}), {})
----Swift.(file).Character.asciiValue
let _this = this;
if((_slowPath(Character.infix_61_61(_this, "\r\n", {}), {}))) {
return _injectIntoOptional(0x000A);
};
if((_slowPath(Bool.infix_124_124(Bool.prefix_33(_this._isSingleScalar, {}), () => UInt32.infix_62_61(_this._firstScalar.value, 0x80, {}), {}), {}))) {
return Optional.none;
};
return _injectIntoOptional(_create(UInt8, 'initT', _this._firstScalar.value, {}))
----Swift.(file).Character.isWhitespace
let _this = this;
return _this._firstScalar.properties.isWhitespace
----Swift.(file).Character.isNewline
let _this = this;
const $match = _this._firstScalar.value
if((((ClosedRange.infix_126_61(UInt32.infix_46_46_46(0x000A, 0x000D, {}), $match, {}))))) {
return true;
}
else if((((infix_126_61(0x0085, $match, {}))))) {
return true;
}
else if((((infix_126_61(0x2028, $match, {}))))) {
return true;
}
else if((((infix_126_61(0x2029, $match, {}))))) {
return true;
}
else if(((true))) {
return false;
}
----Swift.(file).Character.isNumber
let _this = this;
return Optional.wrappedNotEqualsOptionalNilComparisonType(_this._firstScalar.properties.numericType, _create(_OptionalNilComparisonType, 'initNilLiteraltuple_type', {}), {})
----Swift.(file).Character.isWholeNumber
let _this = this;
return Optional.wrappedNotEqualsOptionalNilComparisonType(_this.wholeNumberValue, _create(_OptionalNilComparisonType, 'initNilLiteraltuple_type', {}), {})
----Swift.(file).Character.wholeNumberValue
let _this = this;
if(!((_this._isSingleScalar))) {
return Optional.none;
};
const $ifLet0, value_1
if(!((($ifLet0 = _this._firstScalar.properties.numericValue)||true) && $ifLet0.rawValue == 'some' && ((value_1 = $ifLet0[0])||true))) {
return Optional.none;
};
return _create(Int, 'initExactlyDouble', value_1, {})
----Swift.(file).Character.isHexDigit
let _this = this;
return Optional.wrappedNotEqualsOptionalNilComparisonType(_this.hexDigitValue, _create(_OptionalNilComparisonType, 'initNilLiteraltuple_type', {}), {})
----Swift.(file).Character.hexDigitValue
let _this = this;
if(!((_this._isSingleScalar))) {
return Optional.none;
};
const value = _this._firstScalar.value;
const $match = value
if((((ClosedRange.infix_126_61(UInt32.infix_46_46_46(0x0030, 0x0039, {}), $match, {}))))) {
return _injectIntoOptional(_create(Int, 'initT', UInt32.infix_38_45(value, 0x0030, {}), {}));
}
else if((((ClosedRange.infix_126_61(UInt32.infix_46_46_46(0x0041, 0x0046, {}), $match, {}))))) {
return _injectIntoOptional(_create(Int, 'initT', UInt32.infix_38_45(UInt32.infix_38_43(value, 10, {}), 0x0041, {}), {}));
}
else if((((ClosedRange.infix_126_61(UInt32.infix_46_46_46(0x0061, 0x0066, {}), $match, {}))))) {
return _injectIntoOptional(_create(Int, 'initT', UInt32.infix_38_45(UInt32.infix_38_43(value, 10, {}), 0x0061, {}), {}));
}
else if((((ClosedRange.infix_126_61(UInt32.infix_46_46_46(0xFF10, 0xFF19, {}), $match, {}))))) {
return _injectIntoOptional(_create(Int, 'initT', UInt32.infix_38_45(value, 0xFF10, {}), {}));
}
else if((((ClosedRange.infix_126_61(UInt32.infix_46_46_46(0xFF21, 0xFF26, {}), $match, {}))))) {
return _injectIntoOptional(_create(Int, 'initT', UInt32.infix_38_45(UInt32.infix_38_43(value, 10, {}), 0xFF21, {}), {}));
}
else if((((ClosedRange.infix_126_61(UInt32.infix_46_46_46(0xFF41, 0xFF46, {}), $match, {}))))) {
return _injectIntoOptional(_create(Int, 'initT', UInt32.infix_38_45(UInt32.infix_38_43(value, 10, {}), 0xFF41, {}), {}));
}
else if(((true))) {
return Optional.none;
}
----Swift.(file).Character.isLetter
let _this = this;
return _this._firstScalar.properties.isAlphabetic
----Swift.(file).Character.uppercased()
let _this = this;
return _create(String, 'initCharacter', _this, {}).uppercased( {})
----Swift.(file).Character.lowercased()
let _this = this;
return _create(String, 'initCharacter', _this, {}).lowercased( {})
----Swift.(file).Character.isUppercase
let _this = this;
if((_fastPath(Bool.infix_38_38(_this._isSingleScalar, () => _this._firstScalar.properties.isUppercase, {}), {}))) {
return true;
};
return Bool.infix_38_38(_this._isUppercased, () => _this.isCased, {})
----Swift.(file).Character.isLowercase
let _this = this;
if((_fastPath(Bool.infix_38_38(_this._isSingleScalar, () => _this._firstScalar.properties.isLowercase, {}), {}))) {
return true;
};
return Bool.infix_38_38(_this._isLowercased, () => _this.isCased, {})
----Swift.(file).Character.isCased
let _this = this;
if((_fastPath(Bool.infix_38_38(_this._isSingleScalar, () => _this._firstScalar.properties.isCased, {}), {}))) {
return true;
};
return Bool.infix_124_124(Bool.prefix_33(_this._isUppercased, {}), () => Bool.prefix_33(_this._isLowercased, {}), {})
----Swift.(file).Character.isSymbol
let _this = this;
return _this._firstScalar.properties.generalCategory._isSymbol
----Swift.(file).Character.isMathSymbol
let _this = this;
return _this._firstScalar.properties.isMath
----Swift.(file).Character.isCurrencySymbol
let _this = this;
return Unicode.GeneralCategory.infix_61_61(_this._firstScalar.properties.generalCategory, Unicode.GeneralCategory.currencySymbol, {})
----Swift.(file).Character.isPunctuation
let _this = this;
return _this._firstScalar.properties.generalCategory._isPunctuation
----Swift.(file).ClosedRange.isEmpty
let _this = this;
return false
----Swift.(file).ClosedRange.relative(to:C)
let _this = this;
return _create(Range, 'initUncheckedBoundstuple_type', {0: _this.lowerBound, 1: collection.indexAfter(_this.upperBound, {})}, {})
----Swift.(file).ClosedRange.contains(_:Bound)
let _this = this;
return Bool.infix_38_38((_.arg0 = _element).constructor.infix_62_61(_.arg0, _this.lowerBound, {}), () => (_.arg1 = _element).constructor.infix_60_61(_.arg1, _this.upperBound, {}), {})
----Swift.(file).ClosedRange.Iterator

----Swift.(file).ClosedRange.Index.==infix(_:ClosedRange<Bound>.Index,_:ClosedRange<Bound>.Index)
let _this = this;
const $match = {0: lhs, 1: rhs}
if((($match[0].rawValue == ClosedRange.Index.inRange().rawValue && $match[1].rawValue == ClosedRange.Index.inRange().rawValue))) {
const l = $match[0][0]
const r = $match[1][0]
return ((function(){throw '!unclarifiedGeneric:Bound'})()).infix_61_61(l, r, {});
}
else if((($match[0].rawValue == ClosedRange.Index.pastEnd.rawValue && $match[1].rawValue == ClosedRange.Index.pastEnd.rawValue))) {
return true;
}
else if(((true))) {
return false;
}
----Swift.(file).ClosedRange.Index.<infix(_:ClosedRange<Bound>.Index,_:ClosedRange<Bound>.Index)
let _this = this;
const $match = {0: lhs, 1: rhs}
if((($match[0].rawValue == ClosedRange.Index.inRange().rawValue && $match[1].rawValue == ClosedRange.Index.inRange().rawValue))) {
const l = $match[0][0]
const r = $match[1][0]
return ((function(){throw '!unclarifiedGeneric:Bound'})()).infix_60(l, r, {});
}
else if((($match[0].rawValue == ClosedRange.Index.inRange().rawValue && $match[1].rawValue == ClosedRange.Index.pastEnd.rawValue))) {
return true;
}
else if(((true))) {
return false;
}
----Swift.(file).ClosedRange.Index.hash(into:Hasher)
let _this = this;
let hasher = hasher$inout.get()
const $result = (() => {
const $match = _this
if((($match.rawValue == ClosedRange.Index.inRange().rawValue))) {
const value = $match[0]
hasher.combine(0, {$setThis: $val => hasher = $val});
hasher.combine(value, {$setThis: $val => hasher = $val});
}
else if((($match.rawValue == ClosedRange.Index.pastEnd.rawValue))) {
hasher.combine(1, {$setThis: $val => hasher = $val});
};})()
hasher$inout.set(hasher)
return $result
----Swift.(file).ClosedRange.SubSequence

----Swift.(file).ClosedRange.startIndex
let _this = this;
return ClosedRange.Index.inRange(_this.lowerBound, {})
----Swift.(file).ClosedRange.endIndex
let _this = this;
return ClosedRange.Index.pastEnd
----Swift.(file).ClosedRange.index(after:ClosedRange<Bound>.Index)
let _this = this;
const $match = i
if((($match.rawValue == ClosedRange.Index.inRange().rawValue))) {
const x = $match[0]
return ((_.arg0 = _this.upperBound).constructor.infix_61_61(x, _.arg0, {}) ? ClosedRange.Index.pastEnd : ClosedRange.Index.inRange(x.advancedBy(1, {}), {}));
}
else if((($match.rawValue == ClosedRange.Index.pastEnd.rawValue))) {
preconditionFailureFileLine(() => "Incrementing past end index", '?3', '?3', {});
}
----Swift.(file).ClosedRange.index(before:ClosedRange<Bound>.Index)
let _this = this;
const $match = i
if((($match.rawValue == ClosedRange.Index.inRange().rawValue))) {
const x = $match[0]
preconditionFileLine(() => (_.arg0 = _this.lowerBound).constructor.infix_62(x, _.arg0, {}), () => "Incrementing past start index", '?3', '?3', {});
return ClosedRange.Index.inRange(x.advancedBy(-1, {}), {});
}
else if((($match.rawValue == ClosedRange.Index.pastEnd.rawValue))) {
preconditionFileLine(() => (_.arg1 = _this.upperBound).constructor.infix_62_61(_.arg1, _this.lowerBound, {}), () => "Incrementing past start index", '?3', '?3', {});
return ClosedRange.Index.inRange(_this.upperBound, {});
}
----Swift.(file).ClosedRange.index(_:ClosedRange<Bound>.Index,offsetBy:Int)
let _this = this;
const $match = i
if((($match.rawValue == ClosedRange.Index.inRange().rawValue))) {
const x = $match[0]
const d = x.distanceTo(_this.upperBound, {});
if((Int.infix_60_61(distance, d, {}))) {
const newPosition = x.advancedBy(numericCast(distance, {T: Int, U: Int}), {});
preconditionFileLine(() => (_.arg0 = _this.lowerBound).constructor.infix_62_61(newPosition, _.arg0, {}), () => "Advancing past start index", '?3', '?3', {});
return ClosedRange.Index.inRange(newPosition, {});
};
if((Int.infix_61_61(Int.infix_45(d, -1, {}), distance, {}))) {
return ClosedRange.Index.pastEnd;
};
preconditionFailureFileLine(() => "Advancing past end index", '?3', '?3', {});
}
else if((($match.rawValue == ClosedRange.Index.pastEnd.rawValue))) {
if((Int.infix_61_61(distance, 0, {}))) {
return i;
};
if((Int.infix_60(distance, 0, {}))) {
return _this.indexOffsetBy(ClosedRange.Index.inRange(_this.upperBound, {}), numericCast(Int.infix_43(distance, 1, {}), {T: Int, U: Int}), {});
};
preconditionFailureFileLine(() => "Advancing past end index", '?3', '?3', {});
}
----Swift.(file).ClosedRange.distance(from:ClosedRange<Bound>.Index,to:ClosedRange<Bound>.Index)
let _this = this;
const $match = {0: start, 1: end}
if((($match[0].rawValue == ClosedRange.Index.inRange().rawValue && $match[1].rawValue == ClosedRange.Index.inRange().rawValue))) {
const left = $match[0][0]
const right = $match[1][0]
return numericCast(left.distanceTo(right, {}), {T: Int, U: Int});
}
else if((($match[0].rawValue == ClosedRange.Index.inRange().rawValue && $match[1].rawValue == ClosedRange.Index.pastEnd.rawValue))) {
const left = $match[0][0]
return numericCast(Int.infix_43(1, left.distanceTo(_this.upperBound, {}), {}), {T: Int, U: Int});
}
else if((($match[0].rawValue == ClosedRange.Index.pastEnd.rawValue && $match[1].rawValue == ClosedRange.Index.inRange().rawValue))) {
const right = $match[1][0]
return numericCast(Int.infix_45(_this.upperBound.distanceTo(right, {}), 1, {}), {T: Int, U: Int});
}
else if((($match[0].rawValue == ClosedRange.Index.pastEnd.rawValue && $match[1].rawValue == ClosedRange.Index.pastEnd.rawValue))) {
return 0;
}
----Swift.(file).ClosedRange.subscript(_:ClosedRange<Bound>.Index)
let _this = this;
const $match = position
if((($match.rawValue == ClosedRange.Index.inRange().rawValue))) {
const x = $match[0]
return x;
}
else if((($match.rawValue == ClosedRange.Index.pastEnd.rawValue))) {
preconditionFailureFileLine(() => "Index out of range", '?3', '?3', {});
}
----Swift.(file).ClosedRange.subscript(_:Range<ClosedRange<Bound>.Index>)
let _this = this;
return _create(Slice, 'initBaseBoundsRange', _this, bounds, {})
----Swift.(file).Comparable....infix(_:Self,_:Self)
let _this = this;
preconditionFileLine(() => (_.arg0 = minimum).constructor.infix_60_61(_.arg0, maximum, {}), () => "Can't form Range with upperBound < lowerBound", '?3', '?3', {});
return _create(ClosedRange, 'initUncheckedBoundstuple_type', {0: minimum, 1: maximum}, {})
----Swift.(file).ClosedRange.==infix(_:ClosedRange<Bound>,_:ClosedRange<Bound>)
let _this = this;
return Bool.infix_38_38((_.arg0 = lhs.lowerBound).constructor.infix_61_61(_.arg0, rhs.lowerBound, {}), () => (_.arg1 = lhs.upperBound).constructor.infix_61_61(_.arg1, rhs.upperBound, {}), {})
----Swift.(file).ClosedRange.hash(into:Hasher)
let _this = this;
let hasher = hasher$inout.get()
const $result = (() => {
hasher.combine(_this.lowerBound, {$setThis: $val => hasher = $val});
hasher.combine(_this.upperBound, {$setThis: $val => hasher = $val});})()
hasher$inout.set(hasher)
return $result
----Swift.(file).ClosedRange.description
let _this = this;
return (("") + (_this.lowerBound) + ("...") + (_this.upperBound) + (""))
----Swift.(file).ClosedRange.debugDescription
let _this = this;
return String.infix_43((("ClosedRange(") + (_create(String, 'initReflecting', _this.lowerBound, {})) + ("")), (("...") + (_create(String, 'initReflecting', _this.upperBound, {})) + (")")), {})
----Swift.(file).ClosedRange.customMirror
let _this = this;
return _create(Mirror, 'initChildrenKeyValuePairsDisplayStyleOptionalAncestorRepresentationMirrorAncestorRepresentation', _this, new Map([["lowerBound", _this.lowerBound], ["upperBound", _this.upperBound]]), nil/*!default_value*/, .generated/*!default_value*/, {})
----Swift.(file).ClosedRange.clamped(to:ClosedRange<Bound>)
let _this = this;
const lower = ((_.arg0 = limits.lowerBound).constructor.infix_62(_.arg0, _this.lowerBound, {}) ? limits.lowerBound : ((_.arg1 = limits.upperBound).constructor.infix_60(_.arg1, _this.lowerBound, {}) ? limits.upperBound : _this.lowerBound));
const upper = ((_.arg2 = limits.upperBound).constructor.infix_60(_.arg2, _this.upperBound, {}) ? limits.upperBound : ((_.arg3 = limits.lowerBound).constructor.infix_62(_.arg3, _this.upperBound, {}) ? limits.lowerBound : _this.upperBound));
return _create(ClosedRange, 'initUncheckedBoundstuple_type', {0: lower, 1: upper}, {})
----Swift.(file).ClosedRange.init(_:Range<Bound>)
let _this = this;
preconditionFileLine(() => Bool.prefix_33(other.isEmpty, {}), () => "Can't form an empty closed range", '?3', '?3', {});
const upperBound = other.upperBound.advancedBy(-1, {});
_this.initUncheckedBoundstuple_type({0: other.lowerBound, 1: upperBound}, {});
return
----Swift.(file).ClosedRange.overlaps(_:ClosedRange<Bound>)
let _this = this;
return Bool.infix_124_124(_this.contains(other.lowerBound, {}), () => other.contains(_this.lowerBound, {}), {})
----Swift.(file).ClosedRange.overlaps(_:Range<Bound>)
let _this = this;
return other.overlaps(_this, {})
----Swift.(file).ClosedRange.init(from:Decoder)
let _this = this;
let container = _cloneStruct(decoder.unkeyedContainer( {}));
const lowerBound = container.decode(((function(){throw '!unclarifiedGeneric:Bound'})()), {$setThis: $val => container = $val});
const upperBound = container.decode(((function(){throw '!unclarifiedGeneric:Bound'})()), {$setThis: $val => container = $val});
if(!(((_.arg0 = lowerBound).constructor.infix_60_61(_.arg0, upperBound, {})))) {
throw DecodingError.dataCorrupted(_create(DecodingError.Context, 'initCodingPathArrayDebugDescriptionStringUnderlyingErrorOptional', decoder.codingPath, (("Cannot initialize ") + (ClosedRange) + (" with a lowerBound (") + (lowerBound) + (") greater than upperBound (") + (upperBound) + (")")), nil/*!default_value*/, {}), {});
};
_this.initUncheckedBoundstuple_type({0: lowerBound, 1: upperBound}, {});
return
----Swift.(file).ClosedRange.encode(to:Encoder)
let _this = this;
let container = _cloneStruct(encoder.unkeyedContainer( {}));
container.encode(_this.lowerBound, {$setThis: $val => container = $val});
container.encode(_this.upperBound, {$setThis: $val => container = $val})
----Swift.(file).IndexingIterator.Iterator

----Swift.(file).IndexingIterator.SubSequence

----Swift.(file).IndexingIterator.next()
let _this = this;
if(((_.arg0 = _this._position).constructor.infix_61_61(_.arg0, _this._elements.endIndex, {}))) {
return Optional.none;
};
const _element = _this._elements.subscript$get(_this._position, {});
_this._elements.formIndexAfter({get: () => _this._position, set: $val => _this._position = $val}, {});
return _injectIntoOptional(_element)
----Swift.(file).Collection.formIndex(after:Self.Index)
let _this = this;
let i = i$inout.get()
const $result = (() => {
i = _this.indexAfter(i, {});})()
i$inout.set(i)
return $result
----Swift.(file).Collection.index(_:Self.Index,offsetBy:Int)
let _this = this;
return _this._advanceForwardBy(i, distance, {})
----Swift.(file).Collection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)
let _this = this;
return _this._advanceForwardByLimitedBy(i, distance, limit, {})
----Swift.(file).Collection.formIndex(_:Self.Index,offsetBy:Int)
let _this = this;
let i = i$inout.get()
const $result = (() => {
i = _this.indexOffsetBy(i, distance, {});})()
i$inout.set(i)
return $result
----Swift.(file).Collection.formIndex(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)
let _this = this;
let i = i$inout.get()
const $result = (() => {
const $ifLet0, advancedIndex_1
if((($ifLet0 = _this.indexOffsetByLimitedBy(i, distance, limit, {}))||true) && $ifLet0.rawValue == 'some' && ((advancedIndex_1 = $ifLet0[0])||true)) {
i = advancedIndex_1;
return true;
};
i = limit;
return false;})()
i$inout.set(i)
return $result
----Swift.(file).Collection.distance(from:Self.Index,to:Self.Index)
let _this = this;
preconditionFileLine(() => (_.arg0 = start).constructor.infix_60_61(_.arg0, end, {}), () => "Only BidirectionalCollections can have end come before start", '?3', '?3', {});
let start_dupl = start;
let count = 0;
while(true){
if(!(((_.arg1 = start_dupl).constructor.infix_33_61(_.arg1, end, {})))) break
count = Int.infix_43(count, 1, {});
_this.formIndexAfter({get: () => start_dupl, set: $val => start_dupl = $val}, {});
};
return count
----Swift.(file).Collection.randomElement(using:T)
let _this = this;
let generator = generator$inout.get()
const $result = (() => {
if(!((Bool.prefix_33(_this.isEmpty, {})))) {
return Optional.none;
};
const random = Int.randomInUsing(Int.infix_46_46_60(0, _this.count, {}), {get: () => generator, set: $val => generator = $val}, {});
const idx = _this.indexOffsetBy(_this.startIndex, random, {});
return _injectIntoOptional(_this.subscript$get(idx, {}));})()
generator$inout.set(generator)
return $result
----Swift.(file).Collection.randomElement()
let _this = this;
let g = _create(SystemRandomNumberGenerator, 'init', {});
return _this.randomElementUsing({get: () => g, set: $val => g = $val}, {})
----Swift.(file).Collection.makeIterator()
let _this = this;
return _create(IndexingIterator, 'init_elements', _this, {})
----Swift.(file).Collection.subscript(_:Range<Self.Index>)
let _this = this;
return _create(Slice, 'initBaseBoundsRange', _this, bounds, {})
----Swift.(file).Collection.popFirst()
let _this = this;
if(!((Bool.prefix_33(_this.isEmpty, {})))) {
return Optional.none;
};
const _element = _this.first[0];
$info.$setThis(_this = _cloneStruct(_this.subscriptRange$get((_.arg0 = _this.indexAfter(_this.startIndex, {})).constructor.infix_46_46_60(_.arg0, _this.endIndex, {}), {})));
return _injectIntoOptional(_element)
----Swift.(file).Collection.isEmpty
let _this = this;
return (_.arg0 = _this.startIndex).constructor.infix_61_61(_.arg0, _this.endIndex, {})
----Swift.(file).Collection.first
let _this = this;
const start = _this.startIndex;
if(((_.arg0 = start).constructor.infix_33_61(_.arg0, _this.endIndex, {}))) {
return _injectIntoOptional(_this.subscript$get(start, {}));
}
else {
return Optional.none;
}
----Swift.(file).Collection.underestimatedCount
let _this = this;
return _this.count
----Swift.(file).Collection.count
let _this = this;
return _this.distanceFromTo(_this.startIndex, _this.endIndex, {})
----Swift.(file).Collection.map(_:(Self.Element) throws -> T)
let _this = this;
const n = _this.count;
if((Int.infix_61_61(n, 0, {}))) {
return _create(Array, 'initArrayLiteralArray', [], {});
};
let result = _create(ContiguousArray, 'init', {});
let i = _this.startIndex;
{
let $generator = _cloneStruct(Int.infix_46_46_60(0, n, {}).makeIterator( {}));
while(true) {
const $ifLet0;
if(!((($ifLet0 = $generator.next( {$setThis: $val => $generator = $val}))||true) && $ifLet0.rawValue == 'some')) break
result.append(transform(_this.subscript$get(i, {}), {}), {$setThis: $val => result = $val});
_this.formIndexAfter({get: () => i, set: $val => i = $val}, {});
}
};
return _create(Array, 'initBuffer', result, {})
----Swift.(file).Collection.dropFirst(_:Int)
let _this = this;
preconditionFileLine(() => Int.infix_62_61(k, 0, {}), () => "Can't drop a negative number of elements from a collection", '?3', '?3', {});
const start = infix_63_63(_this.indexOffsetByLimitedBy(_this.startIndex, k, _this.endIndex, {}), () => _this.endIndex, {});
return _this.subscriptRange$get((_.arg0 = start).constructor.infix_46_46_60(_.arg0, _this.endIndex, {}), {})
----Swift.(file).Collection.dropLast(_:Int)
let _this = this;
preconditionFileLine(() => Int.infix_62_61(k, 0, {}), () => "Can't drop a negative number of elements from a collection", '?3', '?3', {});
const amount = /*dot_syntax_base_ignored*/max(0, Int.infix_45(_this.count, k, {}), {});
const end = infix_63_63(_this.indexOffsetByLimitedBy(_this.startIndex, amount, _this.endIndex, {}), () => _this.endIndex, {});
return _this.subscriptRange$get((_.arg0 = _this.startIndex).constructor.infix_46_46_60(_.arg0, end, {}), {})
----Swift.(file).Collection.drop(while:(Self.Element) throws -> Bool)
let _this = this;
let start = _this.startIndex;
while(true){
if(!((Bool.infix_38_38((_.arg0 = start).constructor.infix_33_61(_.arg0, _this.endIndex, {}), () => predicate(_this.subscript$get(start, {}), {}), {})))) break
_this.formIndexAfter({get: () => start, set: $val => start = $val}, {});
};
return _this.subscriptRange$get((_.arg1 = start).constructor.infix_46_46_60(_.arg1, _this.endIndex, {}), {})
----Swift.(file).Collection.prefix(_:Int)
let _this = this;
preconditionFileLine(() => Int.infix_62_61(maxLength, 0, {}), () => "Can't take a prefix of negative length from a collection", '?3', '?3', {});
const end = infix_63_63(_this.indexOffsetByLimitedBy(_this.startIndex, maxLength, _this.endIndex, {}), () => _this.endIndex, {});
return _this.subscriptRange$get((_.arg0 = _this.startIndex).constructor.infix_46_46_60(_.arg0, end, {}), {})
----Swift.(file).Collection.prefix(while:(Self.Element) throws -> Bool)
let _this = this;
let end = _this.startIndex;
while(true){
if(!((Bool.infix_38_38((_.arg0 = end).constructor.infix_33_61(_.arg0, _this.endIndex, {}), () => predicate(_this.subscript$get(end, {}), {}), {})))) break
_this.formIndexAfter({get: () => end, set: $val => end = $val}, {});
};
return _this.subscriptRange$get((_.arg1 = _this.startIndex).constructor.infix_46_46_60(_.arg1, end, {}), {})
----Swift.(file).Collection.suffix(_:Int)
let _this = this;
preconditionFileLine(() => Int.infix_62_61(maxLength, 0, {}), () => "Can't take a suffix of negative length from a collection", '?3', '?3', {});
const amount = /*dot_syntax_base_ignored*/max(0, Int.infix_45(_this.count, maxLength, {}), {});
const start = infix_63_63(_this.indexOffsetByLimitedBy(_this.startIndex, amount, _this.endIndex, {}), () => _this.endIndex, {});
return _this.subscriptRange$get((_.arg0 = start).constructor.infix_46_46_60(_.arg0, _this.endIndex, {}), {})
----Swift.(file).Collection.prefix(upTo:Self.Index)
let _this = this;
return _this.subscriptRange$get((_.arg0 = _this.startIndex).constructor.infix_46_46_60(_.arg0, end, {}), {})
----Swift.(file).Collection.suffix(from:Self.Index)
let _this = this;
return _this.subscriptRange$get((_.arg0 = start).constructor.infix_46_46_60(_.arg0, _this.endIndex, {}), {})
----Swift.(file).Collection.prefix(through:Self.Index)
let _this = this;
return _this.prefixUpTo(_this.indexAfter(position, {}), {})
----Swift.(file).Collection.split(maxSplits:Int,omittingEmptySubsequences:Bool,whereSeparator:(Self.Element) throws -> Bool)
let _this = this;
preconditionFileLine(() => Int.infix_62_61(maxSplits, 0, {}), () => "Must take zero or more splits", '?3', '?3', {});
let result = _create(Array, 'initArrayLiteralArray', [], {});
let subSequenceStart = _this.startIndex;
function appendSubsequenceEnd(end, $info?){
if((Bool.infix_38_38((_.arg0 = subSequenceStart).constructor.infix_61_61(_.arg0, end, {}), () => omittingEmptySubsequences, {}))) {
return false;
};
result.append(_this.subscriptRange$get((_.arg1 = subSequenceStart).constructor.infix_46_46_60(_.arg1, end, {}), {}), {$setThis: $val => result = $val});
return true;
}
if((Bool.infix_124_124(Int.infix_61_61(maxSplits, 0, {}), () => _this.isEmpty, {}))) {
_.discardAssignment = appendSubsequenceEnd(_this.endIndex, {});
return result;
};
let subSequenceEnd = subSequenceStart;
const cachedEndIndex = _this.endIndex;
while(true){
if(!(((_.arg2 = subSequenceEnd).constructor.infix_33_61(_.arg2, cachedEndIndex, {})))) break
if((isSeparator(_this.subscript$get(subSequenceEnd, {}), {}))) {
const didAppend = appendSubsequenceEnd(subSequenceEnd, {});
_this.formIndexAfter({get: () => subSequenceEnd, set: $val => subSequenceEnd = $val}, {});
subSequenceStart = subSequenceEnd;
if((Bool.infix_38_38(didAppend, () => Int.infix_61_61(result.count, maxSplits, {}), {}))) {
break;
};
continue;
};
_this.formIndexAfter({get: () => subSequenceEnd, set: $val => subSequenceEnd = $val}, {});
};
if((Bool.infix_124_124((_.arg3 = subSequenceStart).constructor.infix_33_61(_.arg3, cachedEndIndex, {}), () => Bool.prefix_33(omittingEmptySubsequences, {}), {}))) {
result.append(_this.subscriptRange$get((_.arg4 = subSequenceStart).constructor.infix_46_46_60(_.arg4, cachedEndIndex, {}), {}), {$setThis: $val => result = $val});
};
return result
----Swift.(file).Collection.split(separator:Self.Element,maxSplits:Int,omittingEmptySubsequences:Bool)
let _this = this;
return _this.splitMaxSplitsOmittingEmptySubsequencesWhereSeparator(maxSplits, omittingEmptySubsequences, (($0, $info?) => (_.arg0 = $0).constructor.infix_61_61(_.arg0, separator, {})), {})
----Swift.(file).Collection.removeFirst()
let _this = this;
preconditionFileLine(() => Bool.prefix_33(_this.isEmpty, {}), () => "Can't remove items from an empty collection", '?3', '?3', {});
const _element = _this.first[0];
$info.$setThis(_this = _cloneStruct(_this.subscriptRange$get((_.arg0 = _this.indexAfter(_this.startIndex, {})).constructor.infix_46_46_60(_.arg0, _this.endIndex, {}), {})));
return _element
----Swift.(file).Collection.removeFirst(_:Int)
let _this = this;
if((Int.infix_61_61(k, 0, {}))) {
return ;
};
preconditionFileLine(() => Int.infix_62_61(k, 0, {}), () => "Number of elements to remove should be non-negative", '?3', '?3', {});
preconditionFileLine(() => Int.infix_62_61(_this.count, k, {}), () => "Can't remove more items from a collection than it contains", '?3', '?3', {});
$info.$setThis(_this = _cloneStruct(_this.subscriptRange$get((_.arg0 = _this.indexOffsetBy(_this.startIndex, k, {})).constructor.infix_46_46_60(_.arg0, _this.endIndex, {}), {})))
----Swift.(file).BidirectionalCollection.last
let _this = this;
return (_this.isEmpty ? Optional.none : _injectIntoOptional(_this.subscript$get(_this.indexBefore(_this.endIndex, {}), {})))
----Swift.(file).Collection.firstIndex(of:Self.Element)
let _this = this;
const $ifLet0, result_1
if((($ifLet0 = _this._customIndexOfEquatableElement(_element, {}))||true) && $ifLet0.rawValue == 'some' && ((result_1 = $ifLet0[0])||true)) {
return result_1;
};
let i = _this.startIndex;
while(true){
if(!(((_.arg0 = i).constructor.infix_33_61(_.arg0, _this.endIndex, {})))) break
if(((_.arg1 = _this.subscript$get(i, {})).constructor.infix_61_61(_.arg1, _element, {}))) {
return _injectIntoOptional(i);
};
_this.formIndexAfter({get: () => i, set: $val => i = $val}, {});
};
return Optional.none
----Swift.(file).Collection.firstIndex(where:(Self.Element) throws -> Bool)
let _this = this;
let i = _this.startIndex;
while(true){
if(!(((_.arg0 = i).constructor.infix_33_61(_.arg0, _this.endIndex, {})))) break
if((predicate(_this.subscript$get(i, {}), {}))) {
return _injectIntoOptional(i);
};
_this.formIndexAfter({get: () => i, set: $val => i = $val}, {});
};
return Optional.none
----Swift.(file).BidirectionalCollection.last(where:(Self.Element) throws -> Bool)
let _this = this;
return _this.lastIndexWhere(predicate, {}).mapSwift((($0, $info?) => _this.subscript$get($0, {})), {})
----Swift.(file).BidirectionalCollection.lastIndex(where:(Self.Element) throws -> Bool)
let _this = this;
let i = _this.endIndex;
while(true){
if(!(((_.arg0 = i).constructor.infix_33_61(_.arg0, _this.startIndex, {})))) break
_this.formIndexBefore({get: () => i, set: $val => i = $val}, {});
if((predicate(_this.subscript$get(i, {}), {}))) {
return _injectIntoOptional(i);
};
};
return Optional.none
----Swift.(file).BidirectionalCollection.lastIndex(of:Self.Element)
let _this = this;
const $ifLet0, result_1
if((($ifLet0 = _this._customLastIndexOfEquatableElement(_element, {}))||true) && $ifLet0.rawValue == 'some' && ((result_1 = $ifLet0[0])||true)) {
return result_1;
};
return _this.lastIndexWhere((($0, $info?) => (_.arg0 = $0).constructor.infix_61_61(_.arg0, _element, {})), {})
----Swift.(file).MutableCollection.partition(by:(Self.Element) throws -> Bool)
let _this = this;
return _this._halfStablePartitionIsSuffixElement(belongsInSecondPartition, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
----Swift.(file).MutableCollection.partition(by:(Self.Element) throws -> Bool)
let _this = this;
const maybeOffset = _this._withUnsafeMutableBufferPointerIfSupported(((bufferPointer$inout, $info?) => { 
const unsafeBufferPivot = bufferPointer._partitionImplBy(belongsInSecondPartition, {$setThis: $val => bufferPointer = $val});
return Int.infix_45(unsafeBufferPivot, bufferPointer.startIndex, {}); }), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
const $ifLet0, offset_1
if((($ifLet0 = maybeOffset)||true) && $ifLet0.rawValue == 'some' && ((offset_1 = $ifLet0[0])||true)) {
return _this.indexOffsetBy(_this.startIndex, offset_1, {});
}
else {
return _this._partitionImplBy(belongsInSecondPartition, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
}
----Swift.(file).Sequence.shuffled(using:T)
let _this = this;
let generator = generator$inout.get()
const $result = (() => {
let result = _create(ContiguousArray, 'initBuffer', _this, {});
result.shuffleUsing({get: () => generator, set: $val => generator = $val}, {$setThis: $val => result = $val});
return _create(Array, 'initBuffer', result, {});})()
generator$inout.set(generator)
return $result
----Swift.(file).Sequence.shuffled()
let _this = this;
let g = _create(SystemRandomNumberGenerator, 'init', {});
return _this.shuffledUsing({get: () => g, set: $val => g = $val}, {})
----Swift.(file).MutableCollection.shuffle(using:T)
let _this = this;
let generator = generator$inout.get()
const $result = (() => {
if(!((Int.infix_62(_this.count, 1, {})))) {
return ;
};
let amount = _this.count;
let currentIndex = _this.startIndex;
while(true){
if(!((Int.infix_62(amount, 1, {})))) break
const random = Int.randomInUsing(Int.infix_46_46_60(0, amount, {}), {get: () => generator, set: $val => generator = $val}, {});
Int.infix_45_61({get: () => amount, set: $val => amount = $val}, 1, {});
_this.swapAt(currentIndex, _this.indexOffsetBy(currentIndex, random, {}), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
_this.formIndexAfter({get: () => currentIndex, set: $val => currentIndex = $val}, {});
};})()
generator$inout.set(generator)
return $result
----Swift.(file).MutableCollection.shuffle()
let _this = this;
let g = _create(SystemRandomNumberGenerator, 'init', {});
_this.shuffleUsing({get: () => g, set: $val => g = $val}, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
----Swift.(file).CollectionOfOne.init(_:Element)
let _this = this;
_this._element = _element;
return
----Swift.(file).CollectionOfOne.Iterator.init(_elements:Element?)
let _this = this;
_this._elements = _elements;
return
----Swift.(file).CollectionOfOne.Iterator.next()
let _this = this;
const result = _this._elements;
_this._elements = Optional.none;
return result
----Swift.(file).CollectionOfOne.Indices

----Swift.(file).CollectionOfOne.SubSequence

----Swift.(file).CollectionOfOne.startIndex
let _this = this;
return 0
----Swift.(file).CollectionOfOne.endIndex
let _this = this;
return 1
----Swift.(file).CollectionOfOne.index(after:CollectionOfOne<Element>.Index)
let _this = this;
preconditionFileLine(() => Int.infix_61_61(i, _this.startIndex, {}), () => String()/*!default_value*/, '?3', '?3', {});
return 1
----Swift.(file).CollectionOfOne.index(before:CollectionOfOne<Element>.Index)
let _this = this;
preconditionFileLine(() => Int.infix_61_61(i, _this.endIndex, {}), () => String()/*!default_value*/, '?3', '?3', {});
return 0
----Swift.(file).CollectionOfOne.makeIterator()
let _this = this;
return _create(CollectionOfOne.Iterator, 'init_elementsOptional', _injectIntoOptional(_this._element), {})
----Swift.(file).CollectionOfOne.subscript(_:Int)
let _this = this;
preconditionFileLine(() => Int.infix_61_61(position, 0, {}), () => "Index out of range", '?3', '?3', {});
/*yield*/;
}subscript$_modify(position, $info?){
let _this = this;
preconditionFileLine(() => Int.infix_61_61(position, 0, {}), () => "Index out of range", '?3', '?3', {});
/*yield*/
----Swift.(file).CollectionOfOne.subscript(_:Range<Int>)#ASS

let _this = this;
const n = newValue.count;
preconditionFileLine(() => Int.infix_61_61(bounds.count, n, {}), () => "CollectionOfOne can't be resized", '?3', '?3', {});
if((Int.infix_61_61(n, 1, {}))) {
$info.$setThis(_this = _cloneStruct(_cloneStruct(newValue.base)));
}
----Swift.(file).CollectionOfOne.subscript(_:Range<Int>)
let _this = this;
return _create(Slice, 'initBaseBoundsRange', _this, bounds, {});

----Swift.(file).CollectionOfOne.count
let _this = this;
return 1
----Swift.(file).CollectionOfOne.debugDescription
let _this = this;
return (("CollectionOfOne(") + (_create(String, 'initReflecting', _this._element, {})) + (")"))
----Swift.(file).CollectionOfOne.customMirror
let _this = this;
return _create(Mirror, 'initChildrenKeyValuePairsDisplayStyleOptionalAncestorRepresentationMirrorAncestorRepresentation', _this, new Map([["element", _this._element]]), nil/*!default_value*/, .generated/*!default_value*/, {})
----Swift.(file).CommandLine.argc
let _this = this;
_.discardAssignment = _cloneStruct(CommandLine.unsafeArgv);
return _this._argc;
}
static get argc() { return this.argc$get()
----Swift.(file).CommandLine.unsafeArgv
let _this = this;
return _this._unsafeArgv;
}
static get unsafeArgv() { return this.unsafeArgv$get()
----Swift.(file).Comparable.>infix(_:Self,_:Self)
let _this = this;
return (_.arg0 = rhs).constructor.infix_60(_.arg0, lhs, {})
----Swift.(file).Comparable.<=infix(_:Self,_:Self)
let _this = this;
return Bool.prefix_33((_.arg0 = rhs).constructor.infix_60(_.arg0, lhs, {}), {})
----Swift.(file).Comparable.>=infix(_:Self,_:Self)
let _this = this;
return Bool.prefix_33((_.arg0 = lhs).constructor.infix_60(_.arg0, rhs, {}), {})
----Swift.(file).==infix(_:T,_:T)
return (_.arg0 = lhs.rawValue).constructor.infix_61_61(_.arg0, rhs.rawValue, {})
----Swift.(file).!=infix(_:T,_:T)
return (_.arg0 = lhs.rawValue).constructor.infix_33_61(_.arg0, rhs.rawValue, {})
----Swift.(file).!=infix(_:T,_:T)
return (_.arg0 = lhs.rawValue).constructor.infix_33_61(_.arg0, rhs.rawValue, {})
----Swift.(file).RawRepresentable.hashValue
let _this = this;
return _this.rawValue.hashValue
----Swift.(file).RawRepresentable.hash(into:Hasher)
let _this = this;
let hasher = hasher$inout.get()
const $result = (() => {
hasher.combine(_this.rawValue, {$setThis: $val => hasher = $val});})()
hasher$inout.set(hasher)
return $result
----Swift.(file).ExpressibleByExtendedGraphemeClusterLiteral.init(unicodeScalarLiteral:Self.ExtendedGraphemeClusterLiteralType)
let _this = this;
_this.initExtendedGraphemeClusterLiteral(value, {});
return
----Swift.(file).ExpressibleByStringLiteral.init(extendedGraphemeClusterLiteral:Self.StringLiteralType)
let _this = this;
_this.initStringLiteral(value, {});
return
----Swift.(file).ExpressibleByStringInterpolation.init(stringInterpolation:DefaultStringInterpolation)
let _this = this;
_this.initStringLiteral(stringInterpolation.make( {}), {});
return
----Swift.(file).ContiguousArray.capacity
let _this = this;
return _this._getCapacity( {})
----Swift.(file).ContiguousArray.Indices

----Swift.(file).ContiguousArray.Iterator

----Swift.(file).ContiguousArray.startIndex
let _this = this;
return 0
----Swift.(file).ContiguousArray.endIndex
let _this = this;
return _this._getCount( {})
----Swift.(file).ContiguousArray.index(after:Int)
let _this = this;
return Int.infix_43(i, 1, {})
----Swift.(file).ContiguousArray.formIndex(after:Int)
let _this = this;
let i = i$inout.get()
const $result = (() => {
Int.infix_43_61({get: () => i, set: $val => i = $val}, 1, {});})()
i$inout.set(i)
return $result
----Swift.(file).ContiguousArray.index(before:Int)
let _this = this;
return Int.infix_45(i, 1, {})
----Swift.(file).ContiguousArray.formIndex(before:Int)
let _this = this;
let i = i$inout.get()
const $result = (() => {
Int.infix_45_61({get: () => i, set: $val => i = $val}, 1, {});})()
i$inout.set(i)
return $result
----Swift.(file).ContiguousArray.index(_:Int,offsetBy:Int)
let _this = this;
return Int.infix_43(i, distance, {})
----Swift.(file).ContiguousArray.index(_:Int,offsetBy:Int,limitedBy:Int)
let _this = this;
const l = Int.infix_45(limit, i, {});
if(((Int.infix_62(distance, 0, {}) ? Bool.infix_38_38(Int.infix_62_61(l, 0, {}), () => Int.infix_60(l, distance, {}), {}) : Bool.infix_38_38(Int.infix_60_61(l, 0, {}), () => Int.infix_60(distance, l, {}), {})))) {
return Optional.none;
};
return _injectIntoOptional(Int.infix_43(i, distance, {}))
----Swift.(file).ContiguousArray.distance(from:Int,to:Int)
let _this = this;
return Int.infix_45(end, start, {})
----Swift.(file).ContiguousArray.count
let _this = this;
return _this._getCount( {})
----Swift.(file).ContiguousArray.init(repeating:Element,count:Int)
let _this = this;
let p;
let $tuple = ContiguousArray._allocateUninitialized(count, {})
$info.$setThis(_this = _cloneStruct($tuple[0]))
p = $tuple[1];
{
let $generator = _cloneStruct(Int.infix_46_46_60(0, count, {}).makeIterator( {}));
while(true) {
const $ifLet0;
if(!((($ifLet0 = $generator.next( {$setThis: $val => $generator = $val}))||true) && $ifLet0.rawValue == 'some')) break
p.initializeTo(repeatedValue, {});
UnsafeMutablePointer.infix_43_61({get: () => p, set: $val => p = $val}, 1, {});
}
};
return
----Swift.(file).ContiguousArray.append(_:Element)
let _this = this;
_this._makeUniqueAndReserveCapacityIfNotUnique( {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
const oldCount = _this._getCount( {});
_this._appendElementAssumeUniqueAndCapacityNewElement(oldCount, newElement, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
----Swift.(file).ContiguousArray.insert(_:Element,at:Int)
let _this = this;
_this.replaceSubrangeWith(Int.infix_46_46_60(i, i, {}), _create(CollectionOfOne, 'init', newElement, {}), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
----Swift.(file).ContiguousArray.withContiguousMutableStorageIfAvailable(_:(inout UnsafeMutableBufferPointer<Element>) throws -> R)
let _this = this;
return _injectIntoOptional(_this.withUnsafeMutableBufferPointer(((bufferPointer$inout, $info?) => body({get: () => bufferPointer, set: $val => bufferPointer = $val}, {})), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))}))
----Swift.(file).ContiguousArray.withContiguousStorageIfAvailable(_:(UnsafeBufferPointer<Element>) throws -> R)
let _this = this;
return _injectIntoOptional(_this.withUnsafeBufferPointer(((bufferPointer, $info?) => body(bufferPointer, {})), {}))
----Swift.(file).ContiguousArray.customMirror
let _this = this;
return _create(Mirror, 'initUnlabeledChildrenDisplayStyleOptionalAncestorRepresentationMirrorAncestorRepresentation', _this, _this, _injectIntoOptional(Mirror.DisplayStyle.collection), .generated/*!default_value*/, {})
----Swift.(file).ContiguousArray.description
let _this = this;
return _this._makeCollectionDescriptionWithTypeName(nil/*!default_value*/, {})
----Swift.(file).ContiguousArray.debugDescription
let _this = this;
return _this._makeCollectionDescriptionWithTypeName(_injectIntoOptional("ContiguousArray"), {})
----Swift.(file).ContiguousArray.init(unsafeUninitializedCapacity:Int,initializingWith:(inout UnsafeMutableBufferPointer<Element>, inout Int) throws -> Void)
let _this = this;
$info.$setThis(_this = _cloneStruct(_cloneStruct(_create(ContiguousArray, 'initBuffer', _create(Array, 'init_unsafeUninitializedCapacityIntInitializingWithfunction_type', unsafeUninitializedCapacity, initializer, {}), {}))));
return
----Swift.(file).ContiguousArray.hash(into:Hasher)
let _this = this;
let hasher = hasher$inout.get()
const $result = (() => {
hasher.combine(_this.count, {$setThis: $val => hasher = $val});
{
let $element$generator = _cloneStruct(_this.makeIterator( {}));
while(true) {
const $ifLet0, _element_1;
if(!((($ifLet0 = $element$generator.next( {$setThis: $val => $element$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((_element_1 = $ifLet0[0])||true))) break
hasher.combine(_element_1, {$setThis: $val => hasher = $val});
}
};})()
hasher$inout.set(hasher)
return $result
----Swift.(file).ContiguousArray.withUnsafeMutableBytes(_:(UnsafeMutableRawBufferPointer) throws -> R)
let _this = this;
return _this.withUnsafeMutableBufferPointer((($0$inout, $info?) => body(_create(UnsafeMutableRawBufferPointer, 'initUnsafeMutableBufferPointer', $0, {}), {})), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
----Swift.(file).ContiguousArray.withUnsafeBytes(_:(UnsafeRawBufferPointer) throws -> R)
let _this = this;
return _this.withUnsafeBufferPointer((($0, $info?) => body(_create(UnsafeRawBufferPointer, 'initUnsafeBufferPointer', $0, {}), {})), {})
----Swift.(file).+=infix(_:_ContiguousArrayBuffer<Element>,_:C)
let lhs = lhs$inout.get()
const $result = (() => {
const oldCount = lhs.count;
const newCount = Int.infix_43(oldCount, numericCast(rhs.count, {T: Int, U: Int}), {});
const buf;
if((_fastPath(Int.infix_60_61(newCount, lhs.capacity, {}), {}))) {
buf = _create(UnsafeMutableBufferPointer, 'initStartOptionalCountInt', _injectIntoOptional(/*pointer_to_pointer*/UnsafeMutablePointer.infix_43(lhs.firstElementAddress, oldCount, {})), numericCast(rhs.count, {T: Int, U: Int}), {});
lhs.count = newCount;
}
else {
let newLHS = _create(_ContiguousArrayBuffer, 'init_uninitializedCountIntMinimumCapacityInt', newCount, _growArrayCapacity(lhs.capacity, {}), {});
newLHS.firstElementAddress.moveInitializeFromCount(lhs.firstElementAddress, oldCount, {});
lhs.count = 0;
let $tuple = {0: newLHS, 1: lhs}
lhs = $tuple[0]
newLHS = $tuple[1];
buf = _create(UnsafeMutableBufferPointer, 'initStartOptionalCountInt', _injectIntoOptional(/*pointer_to_pointer*/UnsafeMutablePointer.infix_43(lhs.firstElementAddress, oldCount, {})), numericCast(rhs.count, {T: Int, U: Int}), {});
};
let $tuple = buf.initializeFrom(rhs, {}), remainders = $tuple && $tuple[0], writtenUpTo = $tuple && $tuple[1];
preconditionFileLine(() => Optional.wrappedEqualsOptionalNilComparisonType(remainders.next( {$setThis: $val => remainders = $val}), _create(_OptionalNilComparisonType, 'initNilLiteraltuple_type', {}), {}), () => "rhs underreported its count", '?3', '?3', {});
preconditionFileLine(() => Int.infix_61_61(writtenUpTo, buf.endIndex, {}), () => "rhs overreported its count", '?3', '?3', {});})()
lhs$inout.set(lhs)
return $result
----Swift.(file)._ContiguousArrayBuffer.startIndex
let _this = this;
return 0
----Swift.(file)._ContiguousArrayBuffer.endIndex
let _this = this;
return _this.count
----Swift.(file)._ContiguousArrayBuffer.Indices

----Swift.(file).UnsafeBufferPointer.withUnsafeBytes(_:(UnsafeRawBufferPointer) throws -> R)
let _this = this;
const ptr = _create(UnsafeRawPointer, 'initOptional', _injectIntoOptional(((_.tmp0 = _this.baseAddress).rawValue === 'some') ? (/*pointer_to_pointer*/_.tmp0[0]) : null), {});
const len = Int.infix_38_42(_this.count, MemoryLayout.stride, {});
return body(_create(UnsafeRawBufferPointer, 'initStartOptionalCountInt', ptr, len, {}), {})
----Swift.(file).UnsafeMutableBufferPointer.withUnsafeBytes(_:(UnsafeRawBufferPointer) throws -> R)
let _this = this;
const ptr = _create(UnsafeRawPointer, 'initOptional', _this.baseAddress, {});
const len = Int.infix_38_42(_this.count, MemoryLayout.stride, {});
return body(_create(UnsafeRawBufferPointer, 'initStartOptionalCountInt', ptr, len, {}), {})
----Swift.(file).UnsafeRawBufferPointer.withUnsafeBytes(_:(UnsafeRawBufferPointer) throws -> R)
let _this = this;
return body(_this, {})
----Swift.(file).UnsafeMutableRawBufferPointer.withUnsafeBytes(_:(UnsafeRawBufferPointer) throws -> R)
let _this = this;
return body(_create(UnsafeRawBufferPointer, 'initUnsafeMutableRawBufferPointer', _this, {}), {})
----Swift.(file).String.withUnsafeBytes(_:(UnsafeRawBufferPointer) throws -> R)
let _this = this;
return _this._withUTF8((($0, $info?) => body(_create(UnsafeRawBufferPointer, 'initUnsafeBufferPointer', $0, {}), {})), {})
----Swift.(file).Substring.withUnsafeBytes(_:(UnsafeRawBufferPointer) throws -> R)
let _this = this;
return _this._withUTF8((($0, $info?) => body(_create(UnsafeRawBufferPointer, 'initUnsafeBufferPointer', $0, {}), {})), {})
----Swift.(file).Dictionary.init()
let _this = this;
_this.init_native_NativeDictionary(_create(_NativeDictionary, 'init', {}), {});
return
----Swift.(file).Dictionary.init(uniqueKeysWithValues:S)
let _this = this;
const $ifLet0, d_1
if((($ifLet0 = _injectIntoOptional(keysAndValues))||true) && $ifLet0.rawValue == 'some' && ((d_1 = $ifLet0[0])||true)) {
return _cloneStruct(_cloneStruct(d_1));
return ;
};
let _native = _create(_NativeDictionary, 'initCapacityInt', keysAndValues.underestimatedCount, {});
_native.mergeIsUniqueUniquingKeysWith(keysAndValues, true, ((_, _, $info?) => { 
throw _MergeError.keyCollision; }), {$setThis: $val => _native = $val});
_this.init_native_NativeDictionary(_native, {});
return
----Swift.(file).Dictionary.init(_:S,uniquingKeysWith:(Value, Value) throws -> Value)
let _this = this;
let _native = _create(_NativeDictionary, 'initCapacityInt', keysAndValues.underestimatedCount, {});
_native.mergeIsUniqueUniquingKeysWith(keysAndValues, true, combine, {$setThis: $val => _native = $val});
_this.init_native_NativeDictionary(_native, {});
return
----Swift.(file).Dictionary.init(grouping:S,by:(S.Element) throws -> Key)
let _this = this;
_this.init_native_NativeDictionary(_create(_NativeDictionary, 'initGroupingByfunction_type', values, keyForValue, {}), {});
return
----Swift.(file)..(error_type).bridged()
let _this = this;
const nsDictionary;
if((Bool.infix_124_124(infix_61_61_61(_injectIntoOptional(_this._storage), _injectIntoOptional(__RawDictionaryStorage.empty), {}), () => Int.infix_61_61(_this.count, 0, {}), {}))) {
nsDictionary = _cloneStruct(__RawDictionaryStorage.empty);
}
else {
if((_isBridgedVerbatimToObjectiveC(((function(){throw '!unclarifiedGeneric:Key'})()), {})) && (_isBridgedVerbatimToObjectiveC(((function(){throw '!unclarifiedGeneric:Value'})()), {}))) {
nsDictionary = _cloneStruct(unsafeDowncastTo(_this._storage, _DictionaryStorage, {}));
}
else {
nsDictionary = _cloneStruct(_create(_SwiftDeferredNSDictionary, 'init_NativeDictionary', _this, {}));
}
};
return nsDictionary
----Swift.(file).__CocoaDictionary.isEqual(to:__CocoaDictionary)
let _this = this;
return _stdlib_NSObject_isEqual(_this.object, other.object, {})
----Swift.(file).__CocoaDictionary.startIndex
let _this = this;
const allKeys = _cloneStruct(_stdlib_NSDictionary_allKeys(_this.object, {}));
return _create(__CocoaDictionary.Index, 'init__CocoaDictionaryIndexStorageOffsetInt', _create(__CocoaDictionary.Index.Storage, 'init__CocoaDictionary_BridgingBuffer', _this, allKeys, {}), 0, {})
----Swift.(file).__CocoaDictionary.endIndex
let _this = this;
const allKeys = _cloneStruct(_stdlib_NSDictionary_allKeys(_this.object, {}));
return _create(__CocoaDictionary.Index, 'init__CocoaDictionaryIndexStorageOffsetInt', _create(__CocoaDictionary.Index.Storage, 'init__CocoaDictionary_BridgingBuffer', _this, allKeys, {}), allKeys.count, {})
----Swift.(file).__CocoaDictionary.index(after:__CocoaDictionary.Index)
let _this = this;
_this.validate(index, {});
let result = _cloneStruct(index);
Int.infix_43_61({get: () => result._offset, set: $val => result._offset = $val}, 1, {});
return result
----Swift.(file).__CocoaDictionary.validate(_:__CocoaDictionary.Index)
let _this = this;
preconditionFileLine(() => infix_61_61_61(_injectIntoOptional(index.storage.base.object), _injectIntoOptional(_this.object), {}), () => "Invalid index", '?3', '?3', {});
preconditionFileLine(() => Int.infix_60(index._offset, index.storage.allKeys.count, {}), () => "Attempt to access endIndex", '?3', '?3', {})
----Swift.(file).__CocoaDictionary.formIndex(after:__CocoaDictionary.Index,isUnique:Bool)
let _this = this;
let index = index$inout.get()
const $result = (() => {
_this.validate(index, {});
Int.infix_43_61({get: () => index._offset, set: $val => index._offset = $val}, 1, {});})()
index$inout.set(index)
return $result
----Swift.(file).__CocoaDictionary.count
let _this = this;
const nsd = _cloneStruct(unsafeBitCastTo(_this.object, _NSDictionary, {}));
return nsd.count
----Swift.(file).__CocoaDictionary.contains(_:__CocoaDictionary.Key)
let _this = this;
const nsd = _cloneStruct(unsafeBitCastTo(_this.object, _NSDictionary, {}));
return Optional.wrappedNotEqualsOptionalNilComparisonType(nsd.objectForKey(key, {}), _create(_OptionalNilComparisonType, 'initNilLiteraltuple_type', {}), {})
----Swift.(file).__CocoaDictionary.lookup(_:__CocoaDictionary.Key)
let _this = this;
const nsd = _cloneStruct(unsafeBitCastTo(_this.object, _NSDictionary, {}));
return nsd.objectForKey(key, {})
----Swift.(file).__CocoaDictionary.lookup(_:__CocoaDictionary.Index)
let _this = this;
preconditionFileLine(() => infix_61_61_61(_injectIntoOptional(index.storage.base.object), _injectIntoOptional(_this.object), {}), () => "Invalid index", '?3', '?3', {});
const key = _cloneStruct(index.storage.allKeys.subscript$get(index._offset, {}));
const value = _cloneStruct(/*dynamic_member_ref_expr*/index.storage.base.object[0](key, {})[0]);
return {0: key, 1: value}
----Swift.(file).__CocoaDictionary.key(at:__CocoaDictionary.Index)
let _this = this;
preconditionFileLine(() => infix_61_61_61(_injectIntoOptional(index.storage.base.object), _injectIntoOptional(_this.object), {}), () => "Invalid index", '?3', '?3', {});
return index.key
----Swift.(file).__CocoaDictionary.value(at:__CocoaDictionary.Index)
let _this = this;
preconditionFileLine(() => infix_61_61_61(_injectIntoOptional(index.storage.base.object), _injectIntoOptional(_this.object), {}), () => "Invalid index", '?3', '?3', {});
const key = _cloneStruct(index.storage.allKeys.subscript$get(index._offset, {}));
return /*dynamic_member_ref_expr*/index.storage.base.object[0](key, {})[0]
----Swift.(file).__CocoaDictionary.mapValues(_:(Value) throws -> T)
let _this = this;
let result = _create(_NativeDictionary, 'initCapacityInt', _this.count, {});
{
let $generator = _this.makeIterator( {});
while(true) {
const $ifLet0, cocoaKey_1, cocoaValue_2;
if(!((($ifLet0 = _injectIntoOptional(((_.tmp0 = $generator.next( {})).rawValue === 'some') ? (_.tmp0[0]/*destructure_tuple_expr (**NULL EXPRESSION**), (**NULL EXPRESSION**)*/) : null))||true) && $ifLet0.rawValue == 'some' && ((cocoaKey_1 = $ifLet0[0][0])||true) && ((cocoaValue_2 = $ifLet0[0][1])||true))) break
const key = _forceBridgeFromObjectiveC(cocoaKey_1, ((function(){throw '!unclarifiedGeneric:Key'})()), {});
const value = _forceBridgeFromObjectiveC(cocoaValue_2, ((function(){throw '!unclarifiedGeneric:Value'})()), {});
result.insertNewKeyValue(key, transform(value, {}), {$setThis: $val => result = $val});
}
};
return result
----Swift.(file).__CocoaDictionary.Index.handleBitPattern
let _this = this;
return unsafeBitCastTo(_this.storage, UInt, {})
----Swift.(file).__CocoaDictionary.Index.dictionary
let _this = this;
return _this.storage.base
----Swift.(file).__CocoaDictionary.Index.key
let _this = this;
preconditionFileLine(() => Int.infix_60(_this._offset, _this.storage.allKeys.count, {}), () => "Attempting to access Dictionary elements using an invalid index", '?3', '?3', {});
return _this.storage.allKeys.subscript$get(_this._offset, {})
----Swift.(file).__CocoaDictionary.Index.age
let _this = this;
return _HashTable.ageFor(_this.storage.base.object, {})
----Swift.(file).__CocoaDictionary.Index.==infix(_:__CocoaDictionary.Index,_:__CocoaDictionary.Index)
let _this = this;
preconditionFileLine(() => infix_61_61_61(_injectIntoOptional(lhs.storage.base.object), _injectIntoOptional(rhs.storage.base.object), {}), () => "Comparing indexes from different dictionaries", '?3', '?3', {});
return Int.infix_61_61(lhs._offset, rhs._offset, {})
----Swift.(file).__CocoaDictionary.Index.<infix(_:__CocoaDictionary.Index,_:__CocoaDictionary.Index)
let _this = this;
preconditionFileLine(() => infix_61_61_61(_injectIntoOptional(lhs.storage.base.object), _injectIntoOptional(rhs.storage.base.object), {}), () => "Comparing indexes from different dictionaries", '?3', '?3', {});
return Int.infix_60(lhs._offset, rhs._offset, {})
----Swift.(file).__CocoaDictionary.makeIterator()
let _this = this;
return _create(__CocoaDictionary.Iterator, 'init__CocoaDictionary', _this, {})
----Swift.(file).__CocoaDictionary.Iterator.Element

----Swift.(file).__CocoaDictionary.Iterator.nextKey()
let _this = this;
if((Int.infix_60(_this.itemIndex, 0, {}))) {
return Optional.none;
};
const base = _cloneStruct(_this.base);
if((Int.infix_61_61(_this.itemIndex, _this.itemCount, {}))) {
const stackBufCount = _this._fastEnumerationStackBuf.count;
_this.itemCount = /*dynamic_member_ref_expr*/base.object[0](_this._fastEnumerationStatePtr, _create(UnsafeMutableRawPointer, 'initUnsafeMutablePointer', _this._fastEnumerationStackBufPtr, {}).assumingMemoryBoundTo(AnyObject, {}), stackBufCount, {});
if((Int.infix_61_61(_this.itemCount, 0, {}))) {
_this.itemIndex = -1;
return Optional.none;
};
_this.itemIndex = 0;
};
const itemsPtrUP = _cloneStruct(_create(UnsafeMutableRawPointer, 'initAutoreleasingUnsafeMutablePointer', _this._fastEnumerationState.itemsPtr[0], {}).assumingMemoryBoundTo(AnyObject, {}));
const itemsPtr = _create(_UnmanagedAnyObjectArray, 'initUnsafeMutablePointer', itemsPtrUP, {});
const key = _cloneStruct(itemsPtr.subscript$get(_this.itemIndex, {}));
Int.infix_43_61({get: () => _this.itemIndex, set: $val => _this.itemIndex = $val}, 1, {});
return _injectIntoOptional(key)
----Swift.(file).__CocoaDictionary.Iterator.next()
let _this = this;
const $ifLet0, key_1
if(!((($ifLet0 = _this.nextKey( {}))||true) && $ifLet0.rawValue == 'some' && ((key_1 = $ifLet0[0])||true))) {
return Optional.none;
};
const value = _cloneStruct(/*dynamic_member_ref_expr*/_this.base.object[0](key_1, {})[0]);
return _injectIntoOptional({0: key_1, 1: value})
----Swift.(file).Dictionary.init(_unsafeUninitializedCapacity:Int,allowingDuplicates:Bool,initializingWith:(UnsafeMutableBufferPointer<Key>, UnsafeMutableBufferPointer<Value>, inout Int) -> Void)
let _this = this;
_this.init_native_NativeDictionary(_create(_NativeDictionary, 'init_unsafeUninitializedCapacityIntAllowingDuplicatesBoolInitializingWithfunction_type', capacity, allowingDuplicates, initializer, {}), {});
return
----Swift.(file)..(error_type).init(_unsafeUninitializedCapacity:Int,allowingDuplicates:Bool,initializingWith:<<error type>>)
let _this = this;
_this.initCapacityInt(capacity, {});
let initializedCount = 0;
initializer(_create(UnsafeMutableBufferPointer, 'initStartOptionalCountInt', _injectIntoOptional(/*pointer_to_pointer*/_this._keys), capacity, {}), _create(UnsafeMutableBufferPointer, 'initStartOptionalCountInt', _injectIntoOptional(/*pointer_to_pointer*/_this._values), capacity, {}), {get: () => initializedCount, set: $val => initializedCount = $val}, {});
preconditionFileLine(() => Bool.infix_38_38(Int.infix_62_61(_this.count, 0, {}), () => Int.infix_60_61(_this.count, capacity, {}), {}), () => String()/*!default_value*/, '?3', '?3', {});
_this._storage._count = initializedCount;
let bucket = _create(_HashTable.Bucket, 'initOffsetInt', Int.infix_45(initializedCount, 1, {}), {});
while(true){
if(!((Int.infix_62_61(bucket.offset, 0, {})))) break
if((_this.hashTable._isOccupied(bucket, {}))) {
Int.infix_45_61({get: () => bucket.offset, set: $val => bucket.offset = $val}, 1, {});
continue;
};
const target;
if((Bool.infix_124_124(_isDebugAssertConfiguration( {}), () => allowingDuplicates, {}))) {
const $tuple = _this.find(_this._keys.subscript$get(bucket.offset, {}), {})/*destructure_tuple_expr (**NULL EXPRESSION**), (**NULL EXPRESSION**)*/, b = $tuple && $tuple[0], found = $tuple && $tuple[1];
if((found)) {
preconditionFileLine(() => allowingDuplicates, () => "Duplicate keys found", '?3', '?3', {});
_this.uncheckedDestroyAt(bucket, {});
Int.infix_45_61({get: () => _this._storage._count, set: $val => _this._storage._count = $val}, 1, {});
Int.infix_45_61({get: () => bucket.offset, set: $val => bucket.offset = $val}, 1, {});
continue;
};
_this.hashTable.insert(b, {});
target = _cloneStruct(b);
}
else {
const hashValue = _this.hashValueFor(_this._keys.subscript$get(bucket.offset, {}), {});
target = _cloneStruct(_this.hashTable.insertNewHashValue(hashValue, {}));
};
if((_NativeDictionary.Bucket.infix_62(target, bucket, {}))) {
_this.moveEntryFromTo(bucket, target, {});
Int.infix_45_61({get: () => bucket.offset, set: $val => bucket.offset = $val}, 1, {});
}
else {
if((_HashTable.Bucket.infix_61_61(target, bucket, {}))) {
Int.infix_45_61({get: () => bucket.offset, set: $val => bucket.offset = $val}, 1, {});
}
else {
_this.swapEntryWith(target, bucket, {});
}
};
};
return
----Swift.(file).__EmptyDictionarySingleton.copy(with:<<error type>>)
let _this = this;
return _this
----Swift.(file).__EmptyDictionarySingleton.count
let _this = this;
return 0
----Swift.(file).__EmptyDictionarySingleton.object(forKey:AnyObject)
let _this = this;
return Optional.none
----Swift.(file).__EmptyDictionarySingleton.keyEnumerator()
let _this = this;
return _create(__SwiftEmptyNSEnumerator, 'init', {})
----Swift.(file).__EmptyDictionarySingleton.getObjects(_:UnsafeMutablePointer<AnyObject>?,andKeys:UnsafeMutablePointer<AnyObject>?,count:Int)
let _this = this
----Swift.(file)._DictionaryStorage.copy(original:__RawDictionaryStorage)
let _this = this;
return _this.allocateScaleAgeSeed(original._scale, _injectIntoOptional(original._age), _injectIntoOptional(original._seed), {})
----Swift.(file)._DictionaryStorage.resize(original:__RawDictionaryStorage,capacity:Int,move:Bool)
let _this = this;
const scale = _HashTable.scaleForCapacity(capacity, {});
return _this.allocateScaleAgeSeed(scale, Optional.none, Optional.none, {})
----Swift.(file)._DictionaryStorage.allocate(capacity:Int)
let _this = this;
const scale = _HashTable.scaleForCapacity(capacity, {});
return _this.allocateScaleAgeSeed(scale, Optional.none, Optional.none, {})
----Swift.(file)._DictionaryStorage.convert(_:<<error type>>,capacity:Int)
let _this = this;
const scale = _HashTable.scaleForCapacity(capacity, {});
const age = _HashTable.ageFor(cocoa.object, {});
return _this.allocateScaleAgeSeed(scale, _injectIntoOptional(age), Optional.none, {})
----Swift.(file)._CollectionChanges.startIndex
let _this = this;
return 0
----Swift.(file)._CollectionChanges.endIndex
let _this = this;
return /*dot_syntax_base_ignored*/max(0, Int.infix_45(Int.infix_45(_this.pathStorage.endIndex, _this.pathStartIndex, {}), 1, {}), {})
----Swift.(file)._CollectionChanges.index(after:_CollectionChanges<SourceIndex, TargetIndex>.Index)
let _this = this;
return Int.infix_43(i, 1, {})
----Swift.(file)._CollectionChanges.subscript(_:_CollectionChanges<SourceIndex, TargetIndex>.Index)
let _this = this;
const current = _this.pathStorage.subscript$get(Int.infix_43(position, _this.pathStartIndex, {}), {});
const next = _this.pathStorage.subscript$get(Int.infix_43(Int.infix_43(position, _this.pathStartIndex, {}), 1, {}), {});
if((Bool.infix_38_38((_.arg0 = current["0"]).constructor.infix_33_61(_.arg0, next["0"], {}), () => (_.arg1 = current["1"]).constructor.infix_33_61(_.arg1, next["1"], {}), {}))) {
return _CollectionChanges.Element.matched((_.arg2 = current["0"]).constructor.infix_46_46_60(_.arg2, next["0"], {}), (_.arg3 = current["1"]).constructor.infix_46_46_60(_.arg3, next["1"], {}), {});
}
else {
if(((_.arg4 = current["0"]).constructor.infix_33_61(_.arg4, next["0"], {}))) {
return _CollectionChanges.Element.removed((_.arg5 = current["0"]).constructor.infix_46_46_60(_.arg5, next["0"], {}), {});
}
else {
return _CollectionChanges.Element.inserted((_.arg6 = current["1"]).constructor.infix_46_46_60(_.arg6, next["1"], {}), {});
}
}
----Swift.(file)._CollectionChanges.description
let _this = this;
return _this._makeCollectionDescriptionWithTypeName(nil/*!default_value*/, {})
----Swift.(file)._CollectionChanges.init(from:Source,to:Target,by:(Source.Element, Target.Element) -> Bool)
let _this = this;
_this.init( {});
_this.formChangesFromToBy(source, target, areEquivalent, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
return
----Swift.(file)._CollectionChanges.formChanges(from:Source,to:Target,by:(Source.Element, Target.Element) -> Bool)
let _this = this;
const pathStart = {0: source.startIndex, 1: target.startIndex};
const pathEnd = {0: source.endIndex, 1: target.endIndex};
const matches = source._commonPrefixWithBy(target, areEquivalent, {});
const $tuple = {0: matches["0"].endIndex, 1: matches["1"].endIndex}, x = $tuple && $tuple[0], y = $tuple && $tuple[1];
if((infix_61_61(pathStart/*destructure_tuple_expr (**NULL EXPRESSION**), (**NULL EXPRESSION**)*/, pathEnd/*destructure_tuple_expr (**NULL EXPRESSION**), (**NULL EXPRESSION**)*/, {}))) {
_this.pathStorage.removeAllKeepingCapacity(true, {$setThis: $val => _this.pathStorage = $val});
_this.pathStartIndex = 0;
}
else {
if((Bool.infix_124_124((_.arg0 = x).constructor.infix_61_61(_.arg0, pathEnd["0"], {}), () => (_.arg1 = y).constructor.infix_61_61(_.arg1, pathEnd["1"], {}), {}))) {
_this.pathStorage.removeAllKeepingCapacity(true, {$setThis: $val => _this.pathStorage = $val});
_this.pathStorage.append(pathStart, {$setThis: $val => _this.pathStorage = $val});
if((Bool.infix_38_38(infix_33_61(pathStart/*destructure_tuple_expr (**NULL EXPRESSION**), (**NULL EXPRESSION**)*/, {0: x, 1: y}, {}), () => infix_33_61(pathEnd/*destructure_tuple_expr (**NULL EXPRESSION**), (**NULL EXPRESSION**)*/, {0: x, 1: y}, {}), {}))) {
_this.pathStorage.append({0: x, 1: y}, {$setThis: $val => _this.pathStorage = $val});
};
_this.pathStorage.append(pathEnd, {$setThis: $val => _this.pathStorage = $val});
_this.pathStartIndex = 0;
}
else {
_this.formChangesCoreFromToXYBy(source, target, x, y, areEquivalent, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
}
}
----Swift.(file)._CollectionChanges.formChangesCore(from:Source,to:Target,x:Source.Index,y:Target.Index,by:(Source.Element, Target.Element) -> Bool)
let _this = this;
let $tuple = {0: x, 1: y}, x = $tuple && $tuple[0], y = $tuple && $tuple[1];
const $tuple = {0: a.endIndex, 1: b.endIndex}, n = $tuple && $tuple[0], m = $tuple && $tuple[1];
let v = _create(_SearchState, 'initConsumingArray', {get: () => _this.pathStorage, set: $val => _this.pathStorage = $val}, {});
v.appendFrontierRepeating({0: x, 1: y}, {$setThis: $val => v = $val});
let d = 1;
let delta = 0;
while(true){
if(!((true))) break
v.appendFrontierRepeating({0: n, 1: m}, {$setThis: $val => v = $val});
{
let $k$generator = _cloneStruct(strideFromThroughBy(Int.prefix_45(d, {}), d, 2, {}).makeIterator( {}));
while(true) {
const $ifLet0, k_1;
if(!((($ifLet0 = $k$generator.next( {$setThis: $val => $k$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((k_1 = $ifLet0[0])||true))) break
if((Bool.infix_124_124(Int.infix_61_61(k_1, Int.prefix_45(d, {}), {}), () => Bool.infix_38_38(Int.infix_33_61(k_1, d, {}), () => (_.arg0 = v.subscript$get(Int.infix_45(d, 1, {}), Int.infix_45(k_1, 1, {}), {})["0"]).constructor.infix_60(_.arg0, v.subscript$get(Int.infix_45(d, 1, {}), Int.infix_43(k_1, 1, {}), {})["0"], {}), {}), {}))) {
let $tuple = v.subscript$get(Int.infix_45(d, 1, {}), Int.infix_43(k_1, 1, {}), {})/*destructure_tuple_expr (**NULL EXPRESSION**), (**NULL EXPRESSION**)*/
x = $tuple[0]
y = $tuple[1];
if(((_.arg1 = y).constructor.infix_33_61(_.arg1, m, {}))) {
b.formIndexAfter({get: () => y, set: $val => y = $val}, {});
};
}
else {
let $tuple = v.subscript$get(Int.infix_45(d, 1, {}), Int.infix_45(k_1, 1, {}), {})/*destructure_tuple_expr (**NULL EXPRESSION**), (**NULL EXPRESSION**)*/
x = $tuple[0]
y = $tuple[1];
if(((_.arg2 = x).constructor.infix_33_61(_.arg2, n, {}))) {
a.formIndexAfter({get: () => x, set: $val => x = $val}, {});
};
};
const matches = a.subscriptRange$get((_.arg3 = x).constructor.infix_46_46_60(_.arg3, n, {}), {})._commonPrefixWithBy(b.subscriptRange$get((_.arg4 = y).constructor.infix_46_46_60(_.arg4, m, {}), {}), areEquivalent, {});
let $tuple = {0: matches["0"].endIndex, 1: matches["1"].endIndex}
x = $tuple[0]
y = $tuple[1];
v.subscript$set({0: x, 1: y}, d, k_1, {$setThis: $val => v = $val});
if((Bool.infix_38_38((_.arg5 = x).constructor.infix_61_61(_.arg5, n, {}), () => (_.arg6 = y).constructor.infix_61_61(_.arg6, m, {}), {}))) {
delta = k_1;
break;
};
}
};
Int.infix_43_61({get: () => d, set: $val => d = $val}, 1, {});
};
$info.$setThis(_this = _cloneStruct(_cloneStruct(v.removeCollectionChangesABDDelta(a, b, d, delta, {$setThis: $val => v = $val}))))
----Swift.(file)._SearchState.removeCollectionChanges(a:Source,b:Target,d:Int,delta:Int)
let _this = this;
const pathStart = {0: a.startIndex, 1: b.startIndex};
const pathEnd = {0: a.endIndex, 1: b.endIndex};
if((Int.infix_61_61(d, 1, {}))) {
_this.endpoints.storage.append(pathEnd/*destructure_tuple_expr (**NULL EXPRESSION**), (**NULL EXPRESSION**)*/, {$setThis: $val => _this.endpoints.storage = $val});
};
let i = Int.infix_45(_this.endpoints.storage.endIndex, 1, {});
let isInsertion = Optional.none;
let k = delta;
_this.endpoints.storage.subscript$set(pathEnd/*destructure_tuple_expr (**NULL EXPRESSION**), (**NULL EXPRESSION**)*/, i, {$setThis: $val => _this.endpoints.storage = $val});
{
let $d$generator = _cloneStruct(Int.infix_46_46_46(1, d, {}).reversed( {}).makeIterator( {}));
while(true) {
const $ifLet0, d_1;
if(!((($ifLet0 = $d$generator.next( {$setThis: $val => $d$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((d_1 = $ifLet0[0])||true))) break
if((Bool.infix_124_124(Int.infix_61_61(k, Int.prefix_45(d_1, {}), {}), () => Bool.infix_38_38(Int.infix_33_61(k, d_1, {}), () => (_.arg0 = _this.subscript$get(Int.infix_45(d_1, 1, {}), Int.infix_45(k, 1, {}), {})["0"]).constructor.infix_60(_.arg0, _this.subscript$get(Int.infix_45(d_1, 1, {}), Int.infix_43(k, 1, {}), {})["0"], {}), {}), {}))) {
const $tuple = _this.subscript$get(Int.infix_45(d_1, 1, {}), Int.infix_43(k, 1, {}), {})/*destructure_tuple_expr (**NULL EXPRESSION**), (**NULL EXPRESSION**)*/, x = $tuple && $tuple[0], y = $tuple && $tuple[1];
if(((_.arg1 = x).constructor.infix_33_61(_.arg1, _this.endpoints.storage.subscript$get(i, {})["0"], {}))) {
Int.infix_45_61({get: () => i, set: $val => i = $val}, 1, {});
_this.endpoints.storage.subscript$set({0: x, 1: b.indexAfter(y, {})}, i, {$setThis: $val => _this.endpoints.storage = $val});
isInsertion = Optional.none;
};
if((Optional.infix_33_61(isInsertion, Optional.some(true, {}), {}))) {
Int.infix_45_61({get: () => i, set: $val => i = $val}, 1, {});
};
_this.endpoints.storage.subscript$set({0: x, 1: y}, i, {$setThis: $val => _this.endpoints.storage = $val});
isInsertion = _injectIntoOptional(true);
Int.infix_43_61({get: () => k, set: $val => k = $val}, 1, {});
}
else {
const $tuple = _this.subscript$get(Int.infix_45(d_1, 1, {}), Int.infix_45(k, 1, {}), {})/*destructure_tuple_expr (**NULL EXPRESSION**), (**NULL EXPRESSION**)*/, x = $tuple && $tuple[0], y = $tuple && $tuple[1];
if(((_.arg2 = y).constructor.infix_33_61(_.arg2, _this.endpoints.storage.subscript$get(i, {})["1"], {}))) {
Int.infix_45_61({get: () => i, set: $val => i = $val}, 1, {});
_this.endpoints.storage.subscript$set({0: a.indexAfter(x, {}), 1: y}, i, {$setThis: $val => _this.endpoints.storage = $val});
isInsertion = Optional.none;
};
if((Optional.infix_33_61(isInsertion, Optional.some(false, {}), {}))) {
Int.infix_45_61({get: () => i, set: $val => i = $val}, 1, {});
};
_this.endpoints.storage.subscript$set({0: x, 1: y}, i, {$setThis: $val => _this.endpoints.storage = $val});
isInsertion = _injectIntoOptional(false);
Int.infix_45_61({get: () => k, set: $val => k = $val}, 1, {});
};
}
};
if((infix_33_61(pathStart, _this.endpoints.storage.subscript$get(i, {})/*destructure_tuple_expr (**NULL EXPRESSION**), (**NULL EXPRESSION**)*/, {}))) {
Int.infix_45_61({get: () => i, set: $val => i = $val}, 1, {});
_this.endpoints.storage.subscript$set(pathStart/*destructure_tuple_expr (**NULL EXPRESSION**), (**NULL EXPRESSION**)*/, i, {$setThis: $val => _this.endpoints.storage = $val});
};
const pathStorage = _cloneStruct(_this.endpoints.storage);
_this.endpoints.storage = _create(Array, 'initArrayLiteralArray', [], {});
return _create(_CollectionChanges, 'initPathStorageArrayPathStartIndexInt', pathStorage, i, {})
----Swift.(file)._CountingIndex.<infix(_:_CountingIndex<Base>,_:_CountingIndex<Base>)
let _this = this;
return infix_60({0: lhs.base, 1: infix_63_63(lhs.offset, () => Int.max, {})}, {0: rhs.base, 1: infix_63_63(rhs.offset, () => Int.max, {})}, {})
----Swift.(file)._CountingIndexCollection.Index

----Swift.(file)._CountingIndexCollection.startIndex
let _this = this;
return _create(_CountingIndexCollection.Index, 'initBaseOffsetOptional', _this.base.startIndex, (_this.base.isEmpty ? Optional.none : _injectIntoOptional(0)), {})
----Swift.(file)._CountingIndexCollection.endIndex
let _this = this;
return _create(_CountingIndexCollection.Index, 'initBaseOffsetOptional', _this.base.endIndex, Optional.none, {})
----Swift.(file)._CountingIndexCollection.index(after:_CountingIndexCollection<Base>.Index)
let _this = this;
const next = _this.base.indexAfter(i.base, {});
return _create(_CountingIndexCollection.Index, 'initBaseOffsetOptional', next, ((_.arg0 = next).constructor.infix_61_61(_.arg0, _this.base.endIndex, {}) ? Optional.none : _injectIntoOptional(Int.infix_43(i.offset[0], 1, {}))), {})
----Swift.(file)._CountingIndexCollection.index(before:_CountingIndexCollection<Base>.Index)
let _this = this;
const prev = _this.base.indexBefore(i.base, {});
return _create(_CountingIndexCollection.Index, 'initBaseOffsetOptional', prev, ((_.arg0 = prev).constructor.infix_61_61(_.arg0, _this.base.endIndex, {}) ? Optional.none : _injectIntoOptional(Int.infix_43(i.offset[0], 1, {}))), {})
----Swift.(file)._CountingIndexCollection.subscript(_:_CountingIndexCollection<Base>.Index)
let _this = this;
return _this.base.subscript$get(position.base, {})
----Swift.(file)._LowerTriangularMatrix.rowMajorOrder
let _this = this;
return _create(_LowerTriangularMatrix.RowMajorOrder, 'initBase_LowerTriangularMatrix', _this, {})
----Swift.(file)._LowerTriangularMatrix.subscript(row:Int)
let _this = this;
return _this.rowMajorOrder.subscriptRange$get(Int.infix_46_46_60(_triangularNumber(r, {}), _triangularNumber(Int.infix_43(r, 1, {}), {}), {}), {})
----Swift.(file)._LowerTriangularMatrix.description
let _this = this;
let rows = _create(Array, 'initArrayLiteralArray', [], {});
{
let $row$generator = _cloneStruct(Int.infix_46_46_60(0, _this.dimension, {}).makeIterator( {}));
while(true) {
const $ifLet0, row_1;
if(!((($ifLet0 = $row$generator.next( {$setThis: $val => $row$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((row_1 = $ifLet0[0])||true))) break
rows.append(_create(Array, 'initBuffer', _this.subscriptRow$get(row_1, {}), {}), {$setThis: $val => rows = $val});
}
};
return _create(String, 'initDescribing', rows, {})
----Swift.(file).LazyDropWhileSequence.Iterator.next()
let _this = this;
if((_this._predicateHasFailed)) {
return _this._base.next( {$setThis: $val => _this._base = $val});
};
while(true){
const $ifLet0, nextElement_1
if(!((($ifLet0 = _this._base.next( {$setThis: $val => _this._base = $val}))||true) && $ifLet0.rawValue == 'some' && ((nextElement_1 = $ifLet0[0])||true))) break
if((Bool.prefix_33(_this._predicate(nextElement_1, {}), {}))) {
_this._predicateHasFailed = true;
return _injectIntoOptional(nextElement_1);
};
};
return Optional.none
----Swift.(file).LazyDropWhileSequence.makeIterator()
let _this = this;
return _create(LazyDropWhileSequence.Iterator, 'init_basePredicatefunction_type', _this._base.makeIterator( {}), _this._predicate, {})
----Swift.(file).LazySequenceProtocol.drop(while:(Self.Elements.Element) -> Bool)
let _this = this;
return _create(LazyDropWhileSequence, 'init_basePredicatefunction_type', _this._elements, predicate, {})
----Swift.(file).LazyDropWhileCollection
const LazyDropWhileCollection = LazyDropWhileSequenc
----Swift.(file).LazyDropWhileCollection.SubSequence

----Swift.(file).LazyDropWhileCollection.startIndex
let _this = this;
let index = _this._base.startIndex;
while(true){
if(!((Bool.infix_38_38((_.arg0 = index).constructor.infix_33_61(_.arg0, _this._base.endIndex, {}), () => _this._predicate(_this._base.subscript$get(index, {}), {}), {})))) break
_this._base.formIndexAfter({get: () => index, set: $val => index = $val}, {});
};
return index
----Swift.(file).LazyDropWhileCollection.endIndex
let _this = this;
return _this._base.endIndex
----Swift.(file).LazyDropWhileCollection.index(after:LazyDropWhileSequence<Base>.Index)
let _this = this;
preconditionFileLine(() => (_.arg0 = i).constructor.infix_60(_.arg0, _this._base.endIndex, {}), () => "Can't advance past endIndex", '?3', '?3', {});
return _this._base.indexAfter(i, {})
----Swift.(file).LazyDropWhileCollection.subscript(_:LazyDropWhileSequence<Base>.Index)
let _this = this;
return _this._base.subscript$get(position, {})
----Swift.(file).LazyDropWhileCollection.index(before:LazyDropWhileSequence<Base>.Index)
let _this = this;
preconditionFileLine(() => (_.arg0 = i).constructor.infix_62(_.arg0, _this.startIndex, {}), () => "Can't move before startIndex", '?3', '?3', {});
return _this._base.indexBefore(i, {})
----Swift.(file).dump(_:T,to:TargetStream,name:String?,indent:Int,maxDepth:Int,maxItems:Int)
let target = target$inout.get()
const $result = (() => {
let maxItemCounter = maxItems;
let visitedItems = _create(Dictionary, 'init', {});
target._lock( {$setThis: $val => target = $val});
let $defer = () => {
target._unlock( {$setThis: $val => target = $val});
}
const $result = (() => {
try {;
_dump_unlockedToNameIndentMaxDepthMaxItemCounterVisitedItems(value, {get: () => target, set: $val => target = $val}, _name, indent, maxDepth, {get: () => maxItemCounter, set: $val => maxItemCounter = $val}, {get: () => visitedItems, set: $val => visitedItems = $val}, {});
return value;}catch($error){$defer( {});throw $error}})();$defer( {});return $result;})()
target$inout.set(target)
return $result
----Swift.(file).dump(_:T,name:String?,indent:Int,maxDepth:Int,maxItems:Int)
let stdoutStream = _create(_Stdout, 'init', {});
return dumpToNameIndentMaxDepthMaxItems(value, {get: () => stdoutStream, set: $val => stdoutStream = $val}, _name, indent, maxDepth, maxItems, {})
----Swift.(file).EmptyCollection.init()
let _this = this;
return
----Swift.(file).EmptyCollection.Iterator.init()
let _this = this;
return
----Swift.(file).EmptyCollection.Iterator.next()
let _this = this;
return Optional.none
----Swift.(file).EmptyCollection.makeIterator()
let _this = this;
return _create(EmptyCollection.Iterator, 'init', {})
----Swift.(file).EmptyCollection.Indices

----Swift.(file).EmptyCollection.SubSequence

----Swift.(file).EmptyCollection.startIndex
let _this = this;
return 0
----Swift.(file).EmptyCollection.endIndex
let _this = this;
return 0
----Swift.(file).EmptyCollection.index(after:EmptyCollection<Element>.Index)
let _this = this;
preconditionFailureFileLine(() => "EmptyCollection can't advance indices", '?3', '?3', {})
----Swift.(file).EmptyCollection.index(before:EmptyCollection<Element>.Index)
let _this = this;
preconditionFailureFileLine(() => "EmptyCollection can't advance indices", '?3', '?3', {})
----Swift.(file).EmptyCollection.subscript(_:EmptyCollection<Element>.Index)#ASS

let _this = this;
preconditionFailureFileLine(() => "Index out of range", '?3', '?3', {})
----Swift.(file).EmptyCollection.subscript(_:EmptyCollection<Element>.Index)
let _this = this;
preconditionFailureFileLine(() => "Index out of range", '?3', '?3', {});

----Swift.(file).EmptyCollection.subscript(_:Range<EmptyCollection<Element>.Index>)#ASS

let _this = this;
preconditionFileLine(() => Bool.infix_38_38(Int.infix_61_61(bounds.lowerBound, 0, {}), () => Int.infix_61_61(bounds.upperBound, 0, {}), {}), () => "Index out of range", '?3', '?3', {})
----Swift.(file).EmptyCollection.subscript(_:Range<EmptyCollection<Element>.Index>)
let _this = this;
preconditionFileLine(() => Bool.infix_38_38(Int.infix_61_61(bounds.lowerBound, 0, {}), () => Int.infix_61_61(bounds.upperBound, 0, {}), {}), () => "Index out of range", '?3', '?3', {});
return _this;

----Swift.(file).EmptyCollection.count
let _this = this;
return 0
----Swift.(file).EmptyCollection.index(_:EmptyCollection<Element>.Index,offsetBy:Int)
let _this = this;
preconditionFileLine(() => Bool.infix_38_38(Int.infix_61_61(i, _this.startIndex, {}), () => Int.infix_61_61(n, 0, {}), {}), () => "Index out of range", '?3', '?3', {});
return i
----Swift.(file).EmptyCollection.index(_:EmptyCollection<Element>.Index,offsetBy:Int,limitedBy:EmptyCollection<Element>.Index)
let _this = this;
preconditionFileLine(() => Bool.infix_38_38(Int.infix_61_61(i, _this.startIndex, {}), () => Int.infix_61_61(limit, _this.startIndex, {}), {}), () => "Index out of range", '?3', '?3', {});
return (Int.infix_61_61(n, 0, {}) ? _injectIntoOptional(i) : Optional.none)
----Swift.(file).EmptyCollection.distance(from:EmptyCollection<Element>.Index,to:EmptyCollection<Element>.Index)
let _this = this;
preconditionFileLine(() => Int.infix_61_61(start, 0, {}), () => "From must be startIndex (or endIndex)", '?3', '?3', {});
preconditionFileLine(() => Int.infix_61_61(end, 0, {}), () => "To must be endIndex (or startIndex)", '?3', '?3', {});
return 0
----Swift.(file).EmptyCollection.==infix(_:EmptyCollection<Element>,_:EmptyCollection<Element>)
let _this = this;
return true
----Swift.(file).Equatable.!=infix(_:Self,_:Self)
let _this = this;
return Bool.prefix_33((_.arg0 = lhs).constructor.infix_61_61(_.arg0, rhs, {}), {})
----Swift.(file).===infix(_:AnyObject?,_:AnyObject?)
const $match = {0: lhs, 1: rhs}
if((($match[0].rawValue == 'some' && $match[1].rawValue == 'some'))) {
const l = $match[0][0]
const r = $match[1][0]
return ObjectIdentifier.infix_61_61(_create(ObjectIdentifier, 'initAnyObject', l, {}), _create(ObjectIdentifier, 'initAnyObject', r, {}), {});
}
else if((($match[0].rawValue == Optional.none.rawValue && $match[1].rawValue == Optional.none.rawValue))) {
return true;
}
else if(((true))) {
return false;
}
----Swift.(file).!==infix(_:AnyObject?,_:AnyObject?)
return Bool.prefix_33(infix_61_61_61(lhs, rhs, {}), {})
----Swift.(file).LazyFilterSequence.Iterator.base
let _this = this;
return _this._base
----Swift.(file).LazyFilterSequence.Iterator.next()
let _this = this;
while(true){
const $ifLet0, n_1
if(!((($ifLet0 = _this._base.next( {$setThis: $val => _this._base = $val}))||true) && $ifLet0.rawValue == 'some' && ((n_1 = $ifLet0[0])||true))) break
if((_this._predicate(n_1, {}))) {
return _injectIntoOptional(n_1);
};
};
return Optional.none
----Swift.(file).LazyFilterSequence.makeIterator()
let _this = this;
return _create(LazyFilterSequence.Iterator, 'init_basefunction_type', _this._base.makeIterator( {}), _this._predicate, {})
----Swift.(file).LazyFilterCollection
const LazyFilterCollection = LazyFilterSequenc
----Swift.(file).LazyFilterCollection.SubSequence

----Swift.(file).LazyFilterCollection.underestimatedCount
let _this = this;
return 0
----Swift.(file).LazyFilterCollection.startIndex
let _this = this;
let index = _this._base.startIndex;
while(true){
if(!((Bool.infix_38_38((_.arg0 = index).constructor.infix_33_61(_.arg0, _this._base.endIndex, {}), () => Bool.prefix_33(_this._predicate(_this._base.subscript$get(index, {}), {}), {}), {})))) break
_this._base.formIndexAfter({get: () => index, set: $val => index = $val}, {});
};
return index
----Swift.(file).LazyFilterCollection.endIndex
let _this = this;
return _this._base.endIndex
----Swift.(file).LazyFilterCollection.index(after:LazyFilterSequence<Base>.Index)
let _this = this;
let i_dupl = i;
_this.formIndexAfter({get: () => i_dupl, set: $val => i_dupl = $val}, {});
return i_dupl
----Swift.(file).LazyFilterCollection.formIndex(after:LazyFilterSequence<Base>.Index)
let _this = this;
let i = i$inout.get()
const $result = (() => {
let index = i;
preconditionFileLine(() => (_.arg0 = index).constructor.infix_33_61(_.arg0, _this._base.endIndex, {}), () => "Can't advance past endIndex", '?3', '?3', {});
do {
_this._base.formIndexAfter({get: () => index, set: $val => index = $val}, {});
} while(Bool.infix_38_38((_.arg1 = index).constructor.infix_33_61(_.arg1, _this._base.endIndex, {}), () => Bool.prefix_33(_this._predicate(_this._base.subscript$get(index, {}), {}), {}), {}));
i = index;})()
i$inout.set(i)
return $result
----Swift.(file).LazyFilterCollection.distance(from:LazyFilterSequence<Base>.Index,to:LazyFilterSequence<Base>.Index)
let _this = this;
_.discardAssignment = _this._base.distanceFromTo(start, end, {});
let _start;
const _end;
const step;
if(((_.arg0 = start).constructor.infix_62(_.arg0, end, {}))) {
_start = end;
_end = start;
step = -1;
}
else {
_start = start;
_end = end;
step = 1;
};
let count = 0;
while(true){
if(!((LazyFilterSequence.Index.infix_33_61(_start, _end, {})))) break
Int.infix_43_61({get: () => count, set: $val => count = $val}, step, {});
_this.formIndexAfter({get: () => _start, set: $val => _start = $val}, {});
};
return count
----Swift.(file).LazyFilterCollection.index(_:LazyFilterSequence<Base>.Index,offsetBy:Int)
let _this = this;
let i_dupl = i;
const step = Int.prototype.signum.call(n, {});
_this._ensureBidirectionalStep(step, {});
{
let $generator = _cloneStruct(Int.infix_46_46_60(0, abs(numericCast(n, {T: Int, U: Int}), {}), {}).makeIterator( {}));
while(true) {
const $ifLet0;
if(!((($ifLet0 = $generator.next( {$setThis: $val => $generator = $val}))||true) && $ifLet0.rawValue == 'some')) break
_this._advanceIndexStep({get: () => i_dupl, set: $val => i_dupl = $val}, step, {});
}
};
return i_dupl
----Swift.(file).LazyFilterCollection.formIndex(_:LazyFilterSequence<Base>.Index,offsetBy:Int)
let _this = this;
let i = i$inout.get()
const $result = (() => {
i = _this.indexOffsetBy(i, n, {});})()
i$inout.set(i)
return $result
----Swift.(file).LazyFilterCollection.index(_:LazyFilterSequence<Base>.Index,offsetBy:Int,limitedBy:LazyFilterSequence<Base>.Index)
let _this = this;
let i_dupl = i;
const step = Int.prototype.signum.call(n, {});
_this._ensureBidirectionalStep(step, {});
{
let $generator = _cloneStruct(Int.infix_46_46_60(0, abs(numericCast(n, {T: Int, U: Int}), {}), {}).makeIterator( {}));
while(true) {
const $ifLet0;
if(!((($ifLet0 = $generator.next( {$setThis: $val => $generator = $val}))||true) && $ifLet0.rawValue == 'some')) break
if(((_.arg0 = i_dupl).constructor.infix_61_61(_.arg0, limit, {}))) {
return Optional.none;
};
_this._advanceIndexStep({get: () => i_dupl, set: $val => i_dupl = $val}, step, {});
}
};
return _injectIntoOptional(i_dupl)
----Swift.(file).LazyFilterCollection.formIndex(_:LazyFilterSequence<Base>.Index,offsetBy:Int,limitedBy:LazyFilterSequence<Base>.Index)
let _this = this;
let i = i$inout.get()
const $result = (() => {
const $ifLet0, advancedIndex_1
if((($ifLet0 = _this.indexOffsetByLimitedBy(i, n, limit, {}))||true) && $ifLet0.rawValue == 'some' && ((advancedIndex_1 = $ifLet0[0])||true)) {
i = advancedIndex_1;
return true;
};
i = limit;
return false;})()
i$inout.set(i)
return $result
----Swift.(file).LazyFilterCollection.subscript(_:LazyFilterSequence<Base>.Index)
let _this = this;
return _this._base.subscript$get(position, {})
----Swift.(file).LazyFilterCollection.subscript(_:Range<LazyFilterSequence<Base>.Index>)
let _this = this;
return _create(LazyFilterSequence.SubSequence, 'init_basefunction_type', _this._base.subscriptRange$get(bounds, {}), _this._predicate, {})
----Swift.(file).LazyFilterCollection.index(before:LazyFilterSequence<Base>.Index)
let _this = this;
let i_dupl = i;
_this.formIndexBefore({get: () => i_dupl, set: $val => i_dupl = $val}, {});
return i_dupl
----Swift.(file).LazyFilterCollection.formIndex(before:LazyFilterSequence<Base>.Index)
let _this = this;
let i = i$inout.get()
const $result = (() => {
let index = i;
preconditionFileLine(() => (_.arg0 = index).constructor.infix_33_61(_.arg0, _this._base.startIndex, {}), () => "Can't retreat before startIndex", '?3', '?3', {});
do {
_this._base.formIndexBefore({get: () => index, set: $val => index = $val}, {});
} while(Bool.prefix_33(_this._predicate(_this._base.subscript$get(index, {}), {}), {}));
i = index;})()
i$inout.set(i)
return $result
----Swift.(file).LazySequenceProtocol.filter(_:(Self.Elements.Element) -> Bool)
let _this = this;
return _create(LazyFilterSequence, 'init_basefunction_type', _this._elements, isIncluded, {})
----Swift.(file).LazyFilterSequence.filter(_:(LazyFilterSequence<Base>.Element) -> Bool)
let _this = this;
return _create(LazyFilterSequence, 'init_basefunction_type', _this._base, (($0, $info?) => Bool.infix_38_38(isIncluded($0, {}), () => _this._predicate($0, {}), {})), {})
----Swift.(file).LazySequenceProtocol.flatMap(_:(Self.Elements.Element) -> SegmentOfResult)
let _this = this;
return _this.mapSwift(transform, {}).joined( {})
----Swift.(file).LazySequenceProtocol.compactMap(_:(Self.Elements.Element) -> ElementOfResult?)
let _this = this;
return _this.mapSwift(transform, {}).filterSwift((($0, $info?) => Optional.wrappedNotEqualsOptionalNilComparisonType($0, _create(_OptionalNilComparisonType, 'initNilLiteraltuple_type', {}), {})), {}).mapSwift((($0, $info?) => $0[0]), {})
----Swift.(file).FlattenSequence.init(_base:Base)
let _this = this;
_this._base = _base;
return
----Swift.(file).FlattenSequence.Iterator.init(_base:Base.Iterator)
let _this = this;
_this._base = _base;
return
----Swift.(file).FlattenSequence.Iterator.next()
let _this = this;
do {
if((_fastPath(Optional.wrappedNotEqualsOptionalNilComparisonType(_this._inner, _create(_OptionalNilComparisonType, 'initNilLiteraltuple_type', {}), {}), {}))) {
const ret = _this._inner[0].next( {$setThis: $val => _this._inner[0] = $val});
if((_fastPath(Optional.wrappedNotEqualsOptionalNilComparisonType(ret, _create(_OptionalNilComparisonType, 'initNilLiteraltuple_type', {}), {}), {}))) {
return ret;
};
};
const s = _this._base.next( {$setThis: $val => _this._base = $val});
if((_slowPath(Optional.wrappedEqualsOptionalNilComparisonType(s, _create(_OptionalNilComparisonType, 'initNilLiteraltuple_type', {}), {}), {}))) {
return Optional.none;
};
_this._inner = _injectIntoOptional(s[0].makeIterator( {}));
} while(true)
----Swift.(file).FlattenSequence.makeIterator()
let _this = this;
return _create(FlattenSequence.Iterator, 'init_base', _this._base.makeIterator( {}), {})
----Swift.(file).Sequence.joined()
let _this = this;
return _create(FlattenSequence, 'init_base', _this, {})
----Swift.(file).LazySequenceProtocol.joined()
let _this = this;
return _create(FlattenSequence, 'init_base', _this._elements, {}).lazy
----Swift.(file).FlattenSequence.Index.==infix(_:FlattenCollection<Base>.Index,_:FlattenCollection<Base>.Index)
let _this = this;
return Bool.infix_38_38((_.arg0 = lhs._outer).constructor.infix_61_61(_.arg0, rhs._outer, {}), () => Optional.infix_61_61(lhs._inner, rhs._inner, {}), {})
----Swift.(file).FlattenSequence.Index.<infix(_:FlattenCollection<Base>.Index,_:FlattenCollection<Base>.Index)
let _this = this;
if(((_.arg0 = lhs._outer).constructor.infix_33_61(_.arg0, rhs._outer, {}))) {
return (_.arg1 = lhs._outer).constructor.infix_60(_.arg1, rhs._outer, {});
};
const $ifLet0, lhsInner_1
const $ifLet2, rhsInner_3
if((($ifLet0 = lhs._inner)||true) && $ifLet0.rawValue == 'some' && ((lhsInner_1 = $ifLet0[0])||true) && (($ifLet2 = rhs._inner)||true) && $ifLet2.rawValue == 'some' && ((rhsInner_3 = $ifLet2[0])||true)) {
return (_.arg2 = lhsInner_1).constructor.infix_60(_.arg2, rhsInner_3, {});
};
preconditionFileLine(() => Bool.infix_38_38(Optional.wrappedEqualsOptionalNilComparisonType(lhs._inner, _create(_OptionalNilComparisonType, 'initNilLiteraltuple_type', {}), {}), () => Optional.wrappedEqualsOptionalNilComparisonType(rhs._inner, _create(_OptionalNilComparisonType, 'initNilLiteraltuple_type', {}), {}), {}), () => String()/*!default_value*/, '?3', '?3', {});
return false
----Swift.(file).FlattenSequence.Index.hash(into:Hasher)
let _this = this;
let hasher = hasher$inout.get()
const $result = (() => {
hasher.combine(_this._outer, {$setThis: $val => hasher = $val});
hasher.combine(_this._inner, {$setThis: $val => hasher = $val});})()
hasher$inout.set(hasher)
return $result
----Swift.(file).FlattenCollection.startIndex
let _this = this;
const end = _this._base.endIndex;
let outer = _this._base.startIndex;
while(true){
if(!(((_.arg0 = outer).constructor.infix_33_61(_.arg0, end, {})))) break
const innerCollection = _this._base.subscript$get(outer, {});
if((Bool.prefix_33(innerCollection.isEmpty, {}))) {
return _create(FlattenSequence.Index, 'initOptional', outer, _injectIntoOptional(innerCollection.startIndex), {});
};
_this._base.formIndexAfter({get: () => outer, set: $val => outer = $val}, {});
};
return _this.endIndex
----Swift.(file).FlattenCollection.endIndex
let _this = this;
return _create(FlattenSequence.Index, 'initOptional', _this._base.endIndex, Optional.none, {})
----Swift.(file).FlattenCollection.index(after:FlattenSequence<Base>.Index)
let _this = this;
return _this._indexAfter(i, {})
----Swift.(file).FlattenCollection.formIndex(after:FlattenSequence<Base>.Index)
let _this = this;
let i = i$inout.get()
const $result = (() => {
i = _cloneStruct(_this.indexAfter(i, {}));})()
i$inout.set(i)
return $result
----Swift.(file).FlattenCollection.distance(from:FlattenSequence<Base>.Index,to:FlattenSequence<Base>.Index)
let _this = this;
if((FlattenSequence.Index.infix_60(end, start, {}))) {
_.discardAssignment = _this._base.distanceFromTo(_this._base.endIndex, _this._base.startIndex, {});
};
let _start;
const _end;
const step;
if((FlattenSequence.Index.infix_62(start, end, {}))) {
_start = _cloneStruct(end);
_end = _cloneStruct(start);
step = -1;
}
else {
_start = _cloneStruct(start);
_end = _cloneStruct(end);
step = 1;
};
let count = 0;
while(true){
if(!((FlattenSequence.Index.infix_33_61(_start, _end, {})))) break
Int.infix_43_61({get: () => count, set: $val => count = $val}, step, {});
_this.formIndexAfter({get: () => _start, set: $val => _start = $val}, {});
};
return count
----Swift.(file).FlattenCollection.index(_:FlattenSequence<Base>.Index,offsetBy:Int)
let _this = this;
let i_dupl = _cloneStruct(i);
const step = Int.prototype.signum.call(n, {});
_this._ensureBidirectionalStep(step, {});
{
let $generator = _cloneStruct(Int.infix_46_46_60(0, abs(n, {}), {}).makeIterator( {}));
while(true) {
const $ifLet0;
if(!((($ifLet0 = $generator.next( {$setThis: $val => $generator = $val}))||true) && $ifLet0.rawValue == 'some')) break
_this._advanceIndexStep({get: () => i_dupl, set: $val => i_dupl = $val}, step, {});
}
};
return i_dupl
----Swift.(file).FlattenCollection.formIndex(_:FlattenSequence<Base>.Index,offsetBy:Int)
let _this = this;
let i = i$inout.get()
const $result = (() => {
i = _cloneStruct(_this.indexOffsetBy(i, n, {}));})()
i$inout.set(i)
return $result
----Swift.(file).FlattenCollection.index(_:FlattenSequence<Base>.Index,offsetBy:Int,limitedBy:FlattenSequence<Base>.Index)
let _this = this;
let i_dupl = _cloneStruct(i);
const step = Int.prototype.signum.call(n, {});
_this._ensureBidirectionalStep(step, {});
{
let $generator = _cloneStruct(Int.infix_46_46_60(0, abs(n, {}), {}).makeIterator( {}));
while(true) {
const $ifLet0;
if(!((($ifLet0 = $generator.next( {$setThis: $val => $generator = $val}))||true) && $ifLet0.rawValue == 'some')) break
if((FlattenSequence.Index.infix_61_61(i_dupl, limit, {}))) {
return Optional.none;
};
_this._advanceIndexStep({get: () => i_dupl, set: $val => i_dupl = $val}, step, {});
}
};
return _injectIntoOptional(i_dupl)
----Swift.(file).FlattenCollection.formIndex(_:FlattenSequence<Base>.Index,offsetBy:Int,limitedBy:FlattenSequence<Base>.Index)
let _this = this;
let i = i$inout.get()
const $result = (() => {
const $ifLet0, advancedIndex_1
if((($ifLet0 = _this.indexOffsetByLimitedBy(i, n, limit, {}))||true) && $ifLet0.rawValue == 'some' && ((advancedIndex_1 = $ifLet0[0])||true)) {
i = _cloneStruct(advancedIndex_1);
return true;
};
i = _cloneStruct(limit);
return false;})()
i$inout.set(i)
return $result
----Swift.(file).FlattenCollection.subscript(_:FlattenSequence<Base>.Index)
let _this = this;
return _this._base.subscript$get(position._outer, {}).subscript$get(position._inner[0], {})
----Swift.(file).FlattenCollection.subscript(_:Range<FlattenSequence<Base>.Index>)
let _this = this;
return _create(Slice, 'initBaseBoundsRange', _this, bounds, {})
----Swift.(file).FlattenCollection.index(before:FlattenSequence<Base>.Index)
let _this = this;
return _this._indexBefore(i, {})
----Swift.(file).FlattenCollection.formIndex(before:FlattenSequence<Base>.Index)
let _this = this;
let i = i$inout.get()
const $result = (() => {
i = _cloneStruct(_this.indexBefore(i, {}));})()
i$inout.set(i)
return $result
----Swift.(file).FloatingPointSign.init(rawValue:Int)
let _this = this;
const $match = rawValue
if((((infix_126_61(0, $match, {}))))) {
$info.$setThis(_this = _cloneStruct(FloatingPointSign.plus));
}
else if((((infix_126_61(1, $match, {}))))) {
$info.$setThis(_this = _cloneStruct(FloatingPointSign.minus));
}
else if(((true))) {
return (this.$failed = true);
};
return
----Swift.(file).FloatingPointSign.rawValue
let _this = this;
const $match = _this
if((($match.rawValue == FloatingPointSign.plus.rawValue))) {
return 0;
}
else if((($match.rawValue == FloatingPointSign.minus.rawValue))) {
return 1;
}
----Swift.(file).FloatingPointSign.hashValue
let _this = this;
return Int.prototype.hashValue$get.call(_this.rawValue)
----Swift.(file).FloatingPointSign.hash(into:Hasher)
let _this = this;
let hasher = hasher$inout.get()
const $result = (() => {
hasher.combine(_this.rawValue, {$setThis: $val => hasher = $val});})()
hasher$inout.set(hasher)
return $result
----Swift.(file).FloatingPoint.ulpOfOne
let _this = this;
return 1.ulp;
}
static get ulpOfOne() { return this.ulpOfOne$get()
----Swift.(file).FloatingPoint.rounded(_:FloatingPointRoundingRule)
let _this = this;
let lhs = _this;
lhs.round(rule, {$setThis: $val => lhs = $val});
return lhs
----Swift.(file).FloatingPoint.rounded()
let _this = this;
return _this.constructor.prototype.rounded.call(_this, FloatingPointRoundingRule.toNearestOrAwayFromZero, {})
----Swift.(file).FloatingPoint.round()
let _this = this;
_this.round(FloatingPointRoundingRule.toNearestOrAwayFromZero, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
----Swift.(file).FloatingPoint.nextDown
let _this = this;
return _this.constructor.prefix_45(_this.constructor.prefix_45(_this, {}).nextUp, {})
----Swift.(file).FloatingPoint.truncatingRemainder(dividingBy:Self)
let _this = this;
let lhs = _this;
lhs.formTruncatingRemainderDividingBy(other, {$setThis: $val => lhs = $val});
return lhs
----Swift.(file).FloatingPoint.remainder(dividingBy:Self)
let _this = this;
let lhs = _this;
lhs.formRemainderDividingBy(other, {$setThis: $val => lhs = $val});
return lhs
----Swift.(file).FloatingPoint.squareRoot()
let _this = this;
let lhs = _this;
lhs.formSquareRoot( {$setThis: $val => lhs = $val});
return lhs
----Swift.(file).FloatingPoint.addingProduct(_:Self,_:Self)
let _this = this;
let addend = _this;
addend.addProduct(lhs, rhs, {$setThis: $val => addend = $val});
return addend
----Swift.(file).FloatingPoint.minimum(_:Self,_:Self)
let _this = this;
if((Bool.infix_124_124(_this.prototype.isSignalingNaN$get.call(x), () => _this.prototype.isSignalingNaN$get.call(y), {}))) {
return _this.infix_43(x, y, {});
};
if((Bool.infix_124_124(_this.infix_60_61(x, y, {}), () => _this.prototype._isNaN$get.call(y), {}))) {
return x;
};
return y
----Swift.(file).FloatingPoint.maximum(_:Self,_:Self)
let _this = this;
if((Bool.infix_124_124(_this.prototype.isSignalingNaN$get.call(x), () => _this.prototype.isSignalingNaN$get.call(y), {}))) {
return _this.infix_43(x, y, {});
};
if((Bool.infix_124_124(_this.infix_62(x, y, {}), () => _this.prototype._isNaN$get.call(y), {}))) {
return x;
};
return y
----Swift.(file).FloatingPoint.minimumMagnitude(_:Self,_:Self)
let _this = this;
if((Bool.infix_124_124(_this.prototype.isSignalingNaN$get.call(x), () => _this.prototype.isSignalingNaN$get.call(y), {}))) {
return _this.infix_43(x, y, {});
};
if((Bool.infix_124_124(_this.infix_60_61(_this.prototype.magnitude$get.call(x), _this.prototype.magnitude$get.call(y), {}), () => _this.prototype._isNaN$get.call(y), {}))) {
return x;
};
return y
----Swift.(file).FloatingPoint.maximumMagnitude(_:Self,_:Self)
let _this = this;
if((Bool.infix_124_124(_this.prototype.isSignalingNaN$get.call(x), () => _this.prototype.isSignalingNaN$get.call(y), {}))) {
return _this.infix_43(x, y, {});
};
if((Bool.infix_124_124(_this.infix_62(_this.prototype.magnitude$get.call(x), _this.prototype.magnitude$get.call(y), {}), () => _this.prototype._isNaN$get.call(y), {}))) {
return x;
};
return y
----Swift.(file).FloatingPoint.floatingPointClass
let _this = this;
if((_this.constructor.prototype.isSignalingNaN$get.call(_this))) {
return FloatingPointClassification.signalingNaN;
};
if((_this.constructor.prototype._isNaN$get.call(_this))) {
return FloatingPointClassification.quietNaN;
};
if((_this.constructor.prototype.isInfinite$get.call(_this))) {
return (FloatingPointSign.infix_61_61(_this.constructor.prototype.sign$get.call(_this), FloatingPointSign.minus, {}) ? FloatingPointClassification.negativeInfinity : FloatingPointClassification.positiveInfinity);
};
if((_this.constructor.prototype.isNormal$get.call(_this))) {
return (FloatingPointSign.infix_61_61(_this.constructor.prototype.sign$get.call(_this), FloatingPointSign.minus, {}) ? FloatingPointClassification.negativeNormal : FloatingPointClassification.positiveNormal);
};
if((_this.constructor.prototype.isSubnormal$get.call(_this))) {
return (FloatingPointSign.infix_61_61(_this.constructor.prototype.sign$get.call(_this), FloatingPointSign.minus, {}) ? FloatingPointClassification.negativeSubnormal : FloatingPointClassification.positiveSubnormal);
};
return (FloatingPointSign.infix_61_61(_this.constructor.prototype.sign$get.call(_this), FloatingPointSign.minus, {}) ? FloatingPointClassification.negativeZero : FloatingPointClassification.positiveZero)
----Swift.(file).BinaryFloatingPoint.radix
let _this = this;
return 2;
}
static get radix() { return this.radix$get()
----Swift.(file).BinaryFloatingPoint.init(signOf:Self,magnitudeOf:Self)
let _this = this;
_this.initSignFloatingPointSignExponentBitPatternSignificandBitPattern(_this.constructor.prototype.sign$get.call(signOf), _this.constructor.prototype.exponentBitPattern$get.call(magnitudeOf), _this.constructor.prototype.significandBitPattern$get.call(magnitudeOf), {});
return
----Swift.(file).BinaryFloatingPoint.init(_:Source)
let _this = this;
return _cloneStruct(_this.constructor._convertFrom(value, {})["0"]);
return
----Swift.(file).BinaryFloatingPoint.init(exactly:Source)
let _this = this;
const $tuple = _this.constructor._convertFrom(value, {})/*destructure_tuple_expr (**NULL EXPRESSION**), (**NULL EXPRESSION**)*/, value_ = $tuple && $tuple[0], exact = $tuple && $tuple[1];
if(!((exact))) {
return (this.$failed = true);
};
return _cloneStruct(value_);
return
----Swift.(file).BinaryFloatingPoint.isTotallyOrdered(belowOrEqualTo:Self)
let _this = this;
if((_this.constructor.infix_60(_this, other, {}))) {
return true;
};
if((_this.constructor.infix_62(other, _this, {}))) {
return false;
};
if((FloatingPointSign.infix_33_61(_this.constructor.prototype.sign$get.call(_this), _this.constructor.prototype.sign$get.call(other), {}))) {
return FloatingPointSign.infix_61_61(_this.constructor.prototype.sign$get.call(_this), FloatingPointSign.minus, {});
};
if((((function(){throw '!unclarifiedGeneric:Self.RawExponent'})()).infix_62(_this.constructor.prototype.exponentBitPattern$get.call(_this), _this.constructor.prototype.exponentBitPattern$get.call(other), {}))) {
return FloatingPointSign.infix_61_61(_this.constructor.prototype.sign$get.call(_this), FloatingPointSign.minus, {});
};
if((((function(){throw '!unclarifiedGeneric:Self.RawExponent'})()).infix_60(_this.constructor.prototype.exponentBitPattern$get.call(_this), _this.constructor.prototype.exponentBitPattern$get.call(other), {}))) {
return FloatingPointSign.infix_61_61(_this.constructor.prototype.sign$get.call(_this), FloatingPointSign.plus, {});
};
if((((function(){throw '!unclarifiedGeneric:Self.RawSignificand'})()).infix_62(_this.constructor.prototype.significandBitPattern$get.call(_this), _this.constructor.prototype.significandBitPattern$get.call(other), {}))) {
return FloatingPointSign.infix_61_61(_this.constructor.prototype.sign$get.call(_this), FloatingPointSign.minus, {});
};
if((((function(){throw '!unclarifiedGeneric:Self.RawSignificand'})()).infix_60(_this.constructor.prototype.significandBitPattern$get.call(_this), _this.constructor.prototype.significandBitPattern$get.call(other), {}))) {
return FloatingPointSign.infix_61_61(_this.constructor.prototype.sign$get.call(_this), FloatingPointSign.plus, {});
};
return true
----Swift.(file).BinaryFloatingPoint.init(_:Source)
let _this = this;
return _cloneStruct(_this.constructor._convertFrom(value, {})["0"]);
return
----Swift.(file).BinaryFloatingPoint.init(exactly:Source)
let _this = this;
const $tuple = _this.constructor._convertFrom(value, {})/*destructure_tuple_expr (**NULL EXPRESSION**), (**NULL EXPRESSION**)*/, value_ = $tuple && $tuple[0], exact = $tuple && $tuple[1];
if(!((exact))) {
return (this.$failed = true);
};
return _cloneStruct(value_);
return
----Swift.(file).BinaryFloatingPoint.random(in:Range<Self>,using:T)
let _this = this;
let generator = generator$inout.get()
const $result = (() => {
preconditionFileLine(() => Bool.prefix_33(range.isEmpty, {}), () => "Can't get random value with an empty range", '?3', '?3', {});
const delta = _this.infix_45(range.upperBound, range.lowerBound, {});
preconditionFileLine(() => _this.prototype._isFinite$get.call(delta), () => "There is no uniform distribution on an infinite range", '?3', '?3', {});
const rand;
if((Int.infix_61_61(((function(){throw '!unclarifiedGeneric:Self.RawSignificand'})()).bitWidth, Int.infix_43(_this.significandBitCount, 1, {}), {}))) {
rand = generator.next( {$setThis: $val => generator = $val});
}
else {
const significandCount = Int.infix_43(_this.significandBitCount, 1, {});
const maxSignificand = ((function(){throw '!unclarifiedGeneric:Self.RawSignificand'})()).infix_60_60(1, significandCount, {});
rand = ((function(){throw '!unclarifiedGeneric:Self.RawSignificand'})()).infix_38(generator.next( {$setThis: $val => generator = $val}), ((function(){throw '!unclarifiedGeneric:Self.RawSignificand'})()).infix_45(maxSignificand, 1, {}), {});
};
const unitRandom = _this.infix_42(_create(_this, 'initSource', rand, {}), _this.infix_47(_this.ulpOfOne, 2, {}), {});
const randFloat = _this.infix_43(_this.infix_42(delta, unitRandom, {}), range.lowerBound, {});
if((_this.infix_61_61(randFloat, range.upperBound, {}))) {
return _this.randomInUsing(range, {get: () => generator, set: $val => generator = $val}, {});
};
return randFloat;})()
generator$inout.set(generator)
return $result
----Swift.(file).BinaryFloatingPoint.random(in:Range<Self>)
let _this = this;
let g = _create(SystemRandomNumberGenerator, 'init', {});
return _this.randomInUsing(range, {get: () => g, set: $val => g = $val}, {})
----Swift.(file).BinaryFloatingPoint.random(in:ClosedRange<Self>,using:T)
let _this = this;
let generator = generator$inout.get()
const $result = (() => {
preconditionFileLine(() => Bool.prefix_33(range.isEmpty, {}), () => "Can't get random value with an empty range", '?3', '?3', {});
const delta = _this.infix_45(range.upperBound, range.lowerBound, {});
preconditionFileLine(() => _this.prototype._isFinite$get.call(delta), () => "There is no uniform distribution on an infinite range", '?3', '?3', {});
const rand;
if((Int.infix_61_61(((function(){throw '!unclarifiedGeneric:Self.RawSignificand'})()).bitWidth, Int.infix_43(_this.significandBitCount, 1, {}), {}))) {
rand = generator.next( {$setThis: $val => generator = $val});
const tmp = UInt8.infix_38(generator.next( {$setThis: $val => generator = $val}), 1, {});
if((Bool.infix_38_38(((function(){throw '!unclarifiedGeneric:Self.RawSignificand'})()).infix_61_61(rand, ((function(){throw '!unclarifiedGeneric:Self.RawSignificand'})()).max, {}), () => UInt8.infix_61_61(tmp, 1, {}), {}))) {
return range.upperBound;
};
}
else {
const significandCount = Int.infix_43(_this.significandBitCount, 1, {});
const maxSignificand = ((function(){throw '!unclarifiedGeneric:Self.RawSignificand'})()).infix_60_60(1, significandCount, {});
rand = generator.nextUpperBound(((function(){throw '!unclarifiedGeneric:Self.RawSignificand'})()).infix_43(maxSignificand, 1, {}), {$setThis: $val => generator = $val});
if((((function(){throw '!unclarifiedGeneric:Self.RawSignificand'})()).infix_61_61(rand, maxSignificand, {}))) {
return range.upperBound;
};
};
const unitRandom = _this.infix_42(_create(_this, 'initSource', rand, {}), _this.infix_47(_this.ulpOfOne, 2, {}), {});
const randFloat = _this.infix_43(_this.infix_42(delta, unitRandom, {}), range.lowerBound, {});
return randFloat;})()
generator$inout.set(generator)
return $result
----Swift.(file).BinaryFloatingPoint.random(in:ClosedRange<Self>)
let _this = this;
let g = _create(SystemRandomNumberGenerator, 'init', {});
return _this.randomInUsing(range, {get: () => g, set: $val => g = $val}, {})
----Swift.(file)._HashTable.maxLoadFactor
let _this = this;
return Double.infix_47(3, 4, {});
}
static get maxLoadFactor() { return this.maxLoadFactor$get()
----Swift.(file)._HashTable.capacity(forScale:Int8)
let _this = this;
const bucketCount = Int.infix_38_60_60(1, scale, {});
return _create(Int, 'initDouble', Double.infix_42(_create(Double, 'initInt', bucketCount, {}), _this.maxLoadFactor, {}), {})
----Swift.(file)._HashTable.scale(forCapacity:Int)
let _this = this;
const capacity = /*dot_syntax_base_ignored*/max(capacity, 1, {});
const minimumEntries = /*dot_syntax_base_ignored*/max(_create(Int, 'initDouble', Double.prototype.rounded.call(Double.infix_47(_create(Double, 'initInt', capacity, {}), _this.maxLoadFactor, {}), FloatingPointRoundingRule.up, {}), {}), Int.infix_43(capacity, 1, {}), {});
const exponent = Int.infix_43(Int.prototype._binaryLogarithm.call(Int.infix_45(/*dot_syntax_base_ignored*/max(minimumEntries, 2, {}), 1, {}), {}), 1, {});
const scale = _create(Int8, 'initTruncatingIfNeeded', exponent, {});
return scale
----Swift.(file)._HashTable.age(for:AnyObject)
let _this = this;
const hash = _create(ObjectIdentifier, 'initAnyObject', cocoa, {}).hashValue;
return _create(Int32, 'initTruncatingIfNeeded', hash, {})
----Swift.(file)._HashTable.hashSeed(for:AnyObject,scale:Int8)
let _this = this;
if((Hasher._isDeterministic)) {
return _create(Int, 'initT', scale, {});
};
return unsafeBitCastTo(object, Int, {})
----Swift.(file)._HashTable.Bucket.==infix(_:_HashTable.Bucket,_:_HashTable.Bucket)
let _this = this;
return Int.infix_61_61(lhs.offset, rhs.offset, {})
----Swift.(file)._HashTable.Bucket.<infix(_:_HashTable.Bucket,_:_HashTable.Bucket)
let _this = this;
return Int.infix_60(lhs.offset, rhs.offset, {})
----Swift.(file)._HashTable.Index.==infix(_:_HashTable.Index,_:_HashTable.Index)
let _this = this;
preconditionFileLine(() => Int32.infix_61_61(lhs.age, rhs.age, {}), () => "Can't compare indices belonging to different collections", '?3', '?3', {});
return _HashTable.Bucket.infix_61_61(lhs.bucket, rhs.bucket, {})
----Swift.(file)._HashTable.Index.<infix(_:_HashTable.Index,_:_HashTable.Index)
let _this = this;
preconditionFileLine(() => Int32.infix_61_61(lhs.age, rhs.age, {}), () => "Can't compare indices belonging to different collections", '?3', '?3', {});
return _HashTable.Bucket.infix_60(lhs.bucket, rhs.bucket, {})
----Swift.(file)._HashTable.makeIterator()
let _this = this;
return _create(_HashTable.Iterator, 'init_HashTable', _this, {})
----Swift.(file)._HashTable.isValid(_:_HashTable.Bucket)
let _this = this;
return Bool.infix_38_38(Int.infix_62_61(bucket.offset, 0, {}), () => Int.infix_60(bucket.offset, _this.bucketCount, {}), {})
----Swift.(file)._HashTable.isOccupied(_:_HashTable.Bucket)
let _this = this;
return Bool.infix_38_38(_this.isValid(bucket, {}), () => _this._isOccupied(bucket, {}), {})
----Swift.(file)._HashTable.checkOccupied(_:_HashTable.Bucket)
let _this = this;
preconditionFileLine(() => _this.isOccupied(bucket, {}), () => "Attempting to access Collection elements using an invalid Index", '?3', '?3', {})
----Swift.(file)._HashTable.occupiedBucket(after:_HashTable.Bucket)
let _this = this;
const word = bucket.word;
const $ifLet0, bit_1
if((($ifLet0 = _this.words.subscript$get(word, {}).intersectingElementsAbove(bucket.bit, {}).minimum)||true) && $ifLet0.rawValue == 'some' && ((bit_1 = $ifLet0[0])||true)) {
return _create(_HashTable.Bucket, 'initWordIntBitInt', word, bit_1, {});
};
return _this._firstOccupiedBucketFromWord(Int.infix_43(word, 1, {}), {})
----Swift.(file)._HashTable.startBucket
let _this = this;
return _this._firstOccupiedBucketFromWord(0, {})
----Swift.(file)._HashTable.endBucket
let _this = this;
return _create(_HashTable.Bucket, 'initOffsetInt', _this.bucketCount, {})
----Swift.(file)._HashTable.idealBucket(forHashValue:Int)
let _this = this;
return _create(_HashTable.Bucket, 'initOffsetInt', Int.infix_38(hashValue, _this.bucketMask, {}), {})
----Swift.(file)._HashTable.bucket(wrappedAfter:_HashTable.Bucket)
let _this = this;
return _create(_HashTable.Bucket, 'initOffsetInt', Int.infix_38(Int.infix_38_43(bucket.offset, 1, {}), _this.bucketMask, {}), {})
----Swift.(file)._HashTable.previousHole(before:_HashTable.Bucket)
let _this = this;
let word = bucket.word;
const $ifLet0, bit_1
if((($ifLet0 = _this.words.subscript$get(word, {}).complement.intersectingElementsBelow(bucket.bit, {}).maximum)||true) && $ifLet0.rawValue == 'some' && ((bit_1 = $ifLet0[0])||true)) {
return _create(_HashTable.Bucket, 'initWordIntBitInt', word, bit_1, {});
};
let wrap = false;
while(true){
if(!((true))) break
Int.infix_45_61({get: () => word, set: $val => word = $val}, 1, {});
if((Int.infix_60(word, 0, {}))) {
preconditionFileLine(() => Bool.prefix_33(wrap, {}), () => "Hash table has no holes", '?3', '?3', {});
wrap = true;
word = Int.infix_45(_this.wordCount, 1, {});
};
const $ifLet2, bit_3
if((($ifLet2 = _this.words.subscript$get(word, {}).complement.maximum)||true) && $ifLet2.rawValue == 'some' && ((bit_3 = $ifLet2[0])||true)) {
return _create(_HashTable.Bucket, 'initWordIntBitInt', word, bit_3, {});
};
}
----Swift.(file)._HashTable.nextHole(atOrAfter:_HashTable.Bucket)
let _this = this;
let word = bucket.word;
const $ifLet0, bit_1
if((($ifLet0 = _this.words.subscript$get(word, {}).complement.subtractingElementsBelow(bucket.bit, {}).minimum)||true) && $ifLet0.rawValue == 'some' && ((bit_1 = $ifLet0[0])||true)) {
return _create(_HashTable.Bucket, 'initWordIntBitInt', word, bit_1, {});
};
let wrap = false;
while(true){
if(!((true))) break
Int.infix_38_43_61({get: () => word, set: $val => word = $val}, 1, {});
if((Int.infix_61_61(word, _this.wordCount, {}))) {
preconditionFileLine(() => Bool.prefix_33(wrap, {}), () => "Hash table has no holes", '?3', '?3', {});
wrap = true;
word = 0;
};
const $ifLet2, bit_3
if((($ifLet2 = _this.words.subscript$get(word, {}).complement.minimum)||true) && $ifLet2.rawValue == 'some' && ((bit_3 = $ifLet2[0])||true)) {
return _create(_HashTable.Bucket, 'initWordIntBitInt', word, bit_3, {});
};
}
----Swift.(file)._HashTable.copyContents(of:_HashTable)
let _this = this;
_this.words.assignFromCount(/*pointer_to_pointer*/other.words, _this.wordCount, {})
----Swift.(file)._HashTable.insertNew(hashValue:Int)
let _this = this;
const hole = _cloneStruct(_this.nextHoleAtOrAfter(_this.idealBucketForHashValue(hashValue, {}), {}));
_this.insert(hole, {});
return hole
----Swift.(file)._HashTable.insert(_:_HashTable.Bucket)
let _this = this;
_this.words.subscript$get(bucket.word, {}).uncheckedInsert(bucket.bit, {$setThis: $val => _this.words.subscript$set($val, bucket.word, {$setThis: $val => _this.words = _cloneStruct($val)})})
----Swift.(file)._HashTable.clear()
let _this = this;
if((Int.infix_60(_this.bucketCount, _HashTable.Word.capacity, {}))) {
_this.words.subscript$set(_cloneStruct(_HashTable.Word.allBits.subtractingElementsBelow(_this.bucketCount, {})), 0, {$setThis: $val => _this.words = _cloneStruct($val)});
}
else {
_this.words.assignRepeatingCount(_HashTable.Word.empty, _this.wordCount, {});
}
----Swift.(file)._HashTable.delete(at:_HashTable.Bucket,with:D)
let _this = this;
let hole = _cloneStruct(bucket);
let candidate = _cloneStruct(_this.bucketWrappedAfter(hole, {}));
if(!((_this._isOccupied(candidate, {})))) {
_this.words.subscript$get(hole.word, {}).uncheckedRemove(hole.bit, {$setThis: $val => _this.words.subscript$set($val, hole.word, {$setThis: $val => _this.words = _cloneStruct($val)})});
return ;
};
const start = _cloneStruct(_this.bucketWrappedAfter(_this.previousHoleBefore(bucket, {}), {}));
while(true){
if(!((_this._isOccupied(candidate, {})))) break
const candidateHash = delegate.hashValueAt(candidate, {});
const ideal = _cloneStruct(_this.idealBucketForHashValue(candidateHash, {}));
const c0 = _HashTable.Bucket.infix_62_61(ideal, start, {});
const c1 = _HashTable.Bucket.infix_60_61(ideal, hole, {});
if(((_HashTable.Bucket.infix_60_61(start, hole, {}) ? Bool.infix_38_38(c0, () => c1, {}) : Bool.infix_124_124(c0, () => c1, {})))) {
delegate.moveEntryFromTo(candidate, hole, {});
hole = _cloneStruct(candidate);
};
candidate = _cloneStruct(_this.bucketWrappedAfter(candidate, {}));
};
_this.words.subscript$get(hole.word, {}).uncheckedRemove(hole.bit, {$setThis: $val => _this.words.subscript$set($val, hole.word, {$setThis: $val => _this.words = _cloneStruct($val)})})
----Swift.(file).Hashable_isEqual_indirect(_:UnsafePointer<T>,_:UnsafePointer<T>)
return (_.arg0 = lhs.pointee).constructor.infix_61_61(_.arg0, rhs.pointee, {})
----Swift.(file).Hashable_hashValue_indirect(_:UnsafePointer<T>)
return value.pointee.hashValue
----Swift.(file).Hasher.init()
let _this = this;
_this._core = _create(Hasher._Core, 'init', {});
return
----Swift.(file).Hasher.init(_seed:Int)
let _this = this;
_this._core = _create(Hasher._Core, 'initSeedInt', _seed, {});
return
----Swift.(file).Hasher.init(_rawSeed:(UInt64, UInt64))
let _this = this;
_this._core = _create(Hasher._Core, 'initStateHasher_State', _create(Hasher._State, 'initRawSeedtuple_type', _rawSeed, {}), {});
return
----Swift.(file).Hasher.combine(_:H)
let _this = this;
value.hashInto({get: () => _this, set: $val => $info.$setThis(_this = _cloneStruct($val))}, {})
----Swift.(file).Hasher.combine(bytes:UnsafeRawBufferPointer)
let _this = this;
_this._core.combineBytes(bytes, {$setThis: $val => _this._core = $val})
----Swift.(file).Hasher.finalize()
let _this = this;
let core = _cloneStruct(_this._core);
return _create(Int, 'initTruncatingIfNeeded', core.finalize( {$setThis: $val => core = $val}), {})
----Swift.(file).DefaultIndices.init(_elements:Elements,startIndex:Elements.Index,endIndex:Elements.Index)
let _this = this;
_this._elements = _elements;
_this._startIndex = startIndex;
_this._endIndex = endIndex;
return
----Swift.(file).DefaultIndices.Indices

----Swift.(file).DefaultIndices.SubSequence

----Swift.(file).DefaultIndices.Iterator

----Swift.(file).DefaultIndices.startIndex
let _this = this;
return _this._startIndex
----Swift.(file).DefaultIndices.endIndex
let _this = this;
return _this._endIndex
----Swift.(file).DefaultIndices.subscript(_:DefaultIndices<Elements>.Index)
let _this = this;
return i
----Swift.(file).DefaultIndices.subscript(_:Range<DefaultIndices<Elements>.Index>)
let _this = this;
return _create(DefaultIndices, 'init_elementsStartIndexEndIndex', _this._elements, bounds.lowerBound, bounds.upperBound, {})
----Swift.(file).DefaultIndices.index(after:DefaultIndices<Elements>.Index)
let _this = this;
return _this._elements.indexAfter(i, {})
----Swift.(file).DefaultIndices.formIndex(after:DefaultIndices<Elements>.Index)
let _this = this;
let i = i$inout.get()
const $result = (() => {
_this._elements.formIndexAfter({get: () => i, set: $val => i = $val}, {});})()
i$inout.set(i)
return $result
----Swift.(file).DefaultIndices.indices
let _this = this;
return _this
----Swift.(file).DefaultIndices.index(before:DefaultIndices<Elements>.Index)
let _this = this;
return _this._elements.indexBefore(i, {})
----Swift.(file).DefaultIndices.formIndex(before:DefaultIndices<Elements>.Index)
let _this = this;
let i = i$inout.get()
const $result = (() => {
_this._elements.formIndexBefore({get: () => i, set: $val => i = $val}, {});})()
i$inout.set(i)
return $result
----Swift.(file).Collection.indices
let _this = this;
return _create(DefaultIndices, 'init_elementsStartIndexEndIndex', _this, _this.startIndex, _this.endIndex, {})
----Swift.(file).FixedWidthInteger.init(_:String)
let _this = this;
_this.initRadixInt(description, 10, {});
return
----Swift.(file).ExpressibleByIntegerLiteral.init(integerLiteral:Self)
let _this = this;
return _cloneStruct(value);
return
----Swift.(file).AdditiveArithmetic.zero
let _this = this;
return 0;
}
static get zero() { return this.zero$get()
----Swift.(file).SignedNumeric.negate()
let _this = this;
$info.$setThis(_this = _cloneStruct(_this.constructor.infix_45(0, _this, {})))
----Swift.(file).abs(_:T)
if((infix_61_61(_injectIntoOptional(((function(){throw '!unclarifiedGeneric:T'})())), _injectIntoOptional(((function(){throw '!unclarifiedGeneric:T.Magnitude'})())), {}))) {
return unsafeBitCastTo(((function(){throw '!unclarifiedGeneric:T'})()).prototype.magnitude$get.call(x), ((function(){throw '!unclarifiedGeneric:T'})()), {});
};
return (((function(){throw '!unclarifiedGeneric:T'})()).infix_60(x, 0, {}) ? ((function(){throw '!unclarifiedGeneric:T'})()).prefix_45(x, {}) : x)
----Swift.(file).BinaryInteger.init()
let _this = this;
return _cloneStruct(0);
return
----Swift.(file).BinaryInteger.signum()
let _this = this;
return _this.constructor.infix_45((_this.constructor.infix_62(_this, 0, {}) ? 1 : 0), (_this.constructor.infix_60(_this, 0, {}) ? 1 : 0), {})
----Swift.(file).BinaryInteger.quotientAndRemainder(dividingBy:Self)
let _this = this;
return {0: _this.constructor.infix_47(_this, rhs, {}), 1: _this.constructor.infix_37(_this, rhs, {})}
----Swift.(file).BinaryInteger.isMultiple(of:Self)
let _this = this;
if((_this.constructor.infix_61_61(other, 0, {}))) {
return _this.constructor.infix_61_61(_this, 0, {});
};
return ((function(){throw '!unclarifiedGeneric:Self.Magnitude'})()).infix_61_61(((function(){throw '!unclarifiedGeneric:Self.Magnitude'})()).infix_37(_this.constructor.prototype.magnitude$get.call(_this), _this.constructor.prototype.magnitude$get.call(other), {}), 0, {})
----Swift.(file).BinaryInteger.description
let _this = this;
return _this.constructor.prototype._descriptionRadixUppercase.call(_this, 10, false, {})
----Swift.(file).BinaryInteger.distance(to:Self)
let _this = this;
if((Bool.prefix_33(_this.constructor.isSigned, {}))) {
if((_this.constructor.infix_62(_this, other, {}))) {
const $ifLet0, result_1
if((($ifLet0 = _create(Int, 'initExactly', _this.constructor.infix_45(_this, other, {}), {}))||true) && $ifLet0.rawValue == 'some' && ((result_1 = $ifLet0[0])||true)) {
return Int.prefix_45(result_1, {});
};
}
else {
const $ifLet2, result_3
if((($ifLet2 = _create(Int, 'initExactly', _this.constructor.infix_45(other, _this, {}), {}))||true) && $ifLet2.rawValue == 'some' && ((result_3 = $ifLet2[0])||true)) {
return result_3;
};
};
}
else {
const isNegative = _this.constructor.infix_60(_this, 0, {});
if((Bool.infix_61_61(isNegative, _this.constructor.infix_60(other, 0, {}), {}))) {
const $ifLet4, result_5
if((($ifLet4 = _create(Int, 'initExactly', _this.constructor.infix_45(other, _this, {}), {}))||true) && $ifLet4.rawValue == 'some' && ((result_5 = $ifLet4[0])||true)) {
return result_5;
};
}
else {
const $ifLet6, result_7
if((($ifLet6 = _create(Int, 'initExactly', ((function(){throw '!unclarifiedGeneric:Self.Magnitude'})()).infix_43(_this.constructor.prototype.magnitude$get.call(_this), _this.constructor.prototype.magnitude$get.call(other), {}), {}))||true) && $ifLet6.rawValue == 'some' && ((result_7 = $ifLet6[0])||true)) {
return (isNegative ? result_7 : Int.prefix_45(result_7, {}));
};
};
};
preconditionFailureFileLine(() => "Distance is not representable in Int", '?3', '?3', {})
----Swift.(file).BinaryInteger.advanced(by:Int)
let _this = this;
if((Bool.prefix_33(_this.constructor.isSigned, {}))) {
return (Int.infix_60(n, 0, {}) ? _this.constructor.infix_45(_this, _create(_this.constructor, 'initT', Int.prefix_45(n, {}), {}), {}) : _this.constructor.infix_43(_this, _create(_this.constructor, 'initT', n, {}), {}));
};
if((Bool.infix_61_61(_this.constructor.infix_60(_this, 0, {}), Int.infix_60(n, 0, {}), {}))) {
return _this.constructor.infix_43(_this, _create(_this.constructor, 'initT', n, {}), {});
};
return (((function(){throw '!unclarifiedGeneric:Self.Magnitude'})()).infix_60(_this.constructor.prototype.magnitude$get.call(_this), Int.prototype.magnitude$get.call(n), {}) ? _create(_this.constructor, 'initT', Int.infix_43(_create(Int, 'initT', _this, {}), n, {}), {}) : _this.constructor.infix_43(_this, _create(_this.constructor, 'initT', n, {}), {}))
----Swift.(file).FixedWidthInteger.bitWidth
let _this = this;
return _this.constructor.bitWidth
----Swift.(file).FixedWidthInteger.init(littleEndian:Self)
let _this = this;
return _cloneStruct(value);
return
----Swift.(file).FixedWidthInteger.init(bigEndian:Self)
let _this = this;
return _cloneStruct(_this.constructor.prototype.byteSwapped$get.call(value));
return
----Swift.(file).FixedWidthInteger.littleEndian
let _this = this;
return _this
----Swift.(file).FixedWidthInteger.bigEndian
let _this = this;
return _this.constructor.prototype.byteSwapped$get.call(_this)
----Swift.(file).FixedWidthInteger.random(in:Range<Self>,using:T)
let _this = this;
let generator = generator$inout.get()
const $result = (() => {
preconditionFileLine(() => Bool.prefix_33(range.isEmpty, {}), () => "Can't get random value with an empty range", '?3', '?3', {});
const delta = _create(((function(){throw '!unclarifiedGeneric:Self.Magnitude'})()), 'initTruncatingIfNeeded', _this.infix_38_45(range.upperBound, range.lowerBound, {}), {});
return _create(_this, 'initTruncatingIfNeeded', ((function(){throw '!unclarifiedGeneric:Self.Magnitude'})()).infix_38_43(_create(((function(){throw '!unclarifiedGeneric:Self.Magnitude'})()), 'initTruncatingIfNeeded', range.lowerBound, {}), generator.nextUpperBound(delta, {$setThis: $val => generator = $val}), {}), {});})()
generator$inout.set(generator)
return $result
----Swift.(file).FixedWidthInteger.random(in:Range<Self>)
let _this = this;
let g = _create(SystemRandomNumberGenerator, 'init', {});
return _this.randomInUsing(range, {get: () => g, set: $val => g = $val}, {})
----Swift.(file).FixedWidthInteger.random(in:ClosedRange<Self>,using:T)
let _this = this;
let generator = generator$inout.get()
const $result = (() => {
preconditionFileLine(() => Bool.prefix_33(range.isEmpty, {}), () => "Can't get random value with an empty range", '?3', '?3', {});
let delta = _create(((function(){throw '!unclarifiedGeneric:Self.Magnitude'})()), 'initTruncatingIfNeeded', _this.infix_38_45(range.upperBound, range.lowerBound, {}), {});
if((((function(){throw '!unclarifiedGeneric:Self.Magnitude'})()).infix_61_61(delta, ((function(){throw '!unclarifiedGeneric:Self.Magnitude'})()).max, {}))) {
return _create(_this, 'initTruncatingIfNeeded', generator.next( {$setThis: $val => generator = $val}), {});
};
((function(){throw '!unclarifiedGeneric:Self.Magnitude'})()).infix_43_61({get: () => delta, set: $val => delta = $val}, 1, {});
return _create(_this, 'initTruncatingIfNeeded', ((function(){throw '!unclarifiedGeneric:Self.Magnitude'})()).infix_38_43(_create(((function(){throw '!unclarifiedGeneric:Self.Magnitude'})()), 'initTruncatingIfNeeded', range.lowerBound, {}), generator.nextUpperBound(delta, {$setThis: $val => generator = $val}), {}), {});})()
generator$inout.set(generator)
return $result
----Swift.(file).FixedWidthInteger.random(in:ClosedRange<Self>)
let _this = this;
let g = _create(SystemRandomNumberGenerator, 'init', {});
return _this.randomInUsing(range, {get: () => g, set: $val => g = $val}, {})
----Swift.(file).FixedWidthInteger.init(_:T)
let _this = this;
const $ifLet0, value_1
if(!((($ifLet0 = _this.constructor._convertFrom(source, {})["0"])||true) && $ifLet0.rawValue == 'some' && ((value_1 = $ifLet0[0])||true))) {
fatalErrorFileLine(() => (("") + (((function(){throw '!unclarifiedGeneric:T'})())) + (" value cannot be converted to ") + (_this.constructor) + (" because it is outside the representable range")), '?3', '?3', {});
};
return _cloneStruct(value_1);
return
----Swift.(file).FixedWidthInteger.init(exactly:T)
let _this = this;
const $tuple = _this.constructor._convertFrom(source, {})/*destructure_tuple_expr (**NULL EXPRESSION**), (**NULL EXPRESSION**)*/, temporary = $tuple && $tuple[0], exact = $tuple && $tuple[1];
const $ifLet0, value_1
if(!((exact) && (($ifLet0 = temporary)||true) && $ifLet0.rawValue == 'some' && ((value_1 = $ifLet0[0])||true))) {
return (this.$failed = true);
};
return _cloneStruct(value_1);
return
----Swift.(file).FixedWidthInteger.init(clamping:Other)
let _this = this;
if((_slowPath(((function(){throw '!unclarifiedGeneric:Other'})()).infix_60(source, _this.constructor.min, {}), {}))) {
return _cloneStruct(_this.constructor.min);
}
else {
if((_slowPath(((function(){throw '!unclarifiedGeneric:Other'})()).infix_62(source, _this.constructor.max, {}), {}))) {
return _cloneStruct(_this.constructor.max);
}
else {
return _cloneStruct(_create(_this.constructor, 'initTruncatingIfNeeded', source, {}));
}
};
return
----Swift.(file).FixedWidthInteger.init(truncatingIfNeeded:T)
let _this = this;
if((Int.infix_60_61(_this.constructor.bitWidth, Int.bitWidth, {}))) {
return _cloneStruct(_create(_this.constructor, 'init_truncatingBitsUInt', ((function(){throw '!unclarifiedGeneric:T'})()).prototype._lowWord$get.call(source), {}));
}
else {
const neg = ((function(){throw '!unclarifiedGeneric:T'})()).infix_60(source, 0, {});
let result = (neg ? _this.constructor.prefix_126(0, {}) : 0);
let shift = 0;
const width = _create(_this.constructor, 'init_truncatingBitsUInt', Int.prototype._lowWord$get.call(_this.constructor.bitWidth), {});
{
let $word$generator = ((function(){throw '!unclarifiedGeneric:T'})()).prototype.words$get.call(source).makeIterator( {});
while(true) {
const $ifLet0, word_1;
if(!((($ifLet0 = $word$generator.next( {$setThis: $val => $word$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((word_1 = $ifLet0[0])||true))) break
if(!((_this.constructor.infix_60(shift, width, {})))) {
break;
};
_this.constructor.infix_94_61({get: () => result, set: $val => result = $val}, _this.constructor.infix_38_60_60(_create(_this.constructor, 'init_truncatingBitsUInt', (neg ? UInt.prefix_126(word_1, {}) : word_1), {}), shift, {}), {});
_this.constructor.infix_43_61({get: () => shift, set: $val => shift = $val}, _create(_this.constructor, 'init_truncatingBitsUInt', Int.prototype._lowWord$get.call(Int.bitWidth), {}), {});
}
};
return _cloneStruct(result);
};
return
----Swift.(file).UnsignedInteger.magnitude
let _this = this;
return _this
----Swift.(file).UnsignedInteger.isSigned
let _this = this;
return false;
}
static get isSigned() { return this.isSigned$get()
----Swift.(file).UnsignedInteger.init(_:T)
let _this = this;
if((((function(){throw '!unclarifiedGeneric:T'})()).isSigned)) {
preconditionFileLine(() => ((function(){throw '!unclarifiedGeneric:T'})()).infix_62_61(source, 0, {}), () => "Negative value is not representable", '?3', '?3', {});
};
if((Int.infix_62_61(((function(){throw '!unclarifiedGeneric:T'})()).prototype.bitWidth$get.call(source), _this.constructor.bitWidth, {}))) {
preconditionFileLine(() => ((function(){throw '!unclarifiedGeneric:T'})()).infix_60_61(source, _this.constructor.max, {}), () => "Not enough bits to represent the passed value", '?3', '?3', {});
};
_this.initTruncatingIfNeeded(source, {});
return
----Swift.(file).UnsignedInteger.init(exactly:T)
let _this = this;
if((Bool.infix_38_38(((function(){throw '!unclarifiedGeneric:T'})()).isSigned, () => ((function(){throw '!unclarifiedGeneric:T'})()).infix_60(source, 0, {}), {}))) {
return (this.$failed = true);
};
if((Bool.infix_38_38(Int.infix_62_61(((function(){throw '!unclarifiedGeneric:T'})()).prototype.bitWidth$get.call(source), _this.constructor.bitWidth, {}), () => ((function(){throw '!unclarifiedGeneric:T'})()).infix_62(source, _this.constructor.max, {}), {}))) {
return (this.$failed = true);
};
_this.initTruncatingIfNeeded(source, {});
return
----Swift.(file).UnsignedInteger.max
let _this = this;
return _this.prefix_126(0, {});
}
static get max() { return this.max$get()
----Swift.(file).UnsignedInteger.min
let _this = this;
return 0;
}
static get min() { return this.min$get()
----Swift.(file).SignedInteger.isSigned
let _this = this;
return true;
}
static get isSigned() { return this.isSigned$get()
----Swift.(file).SignedInteger.init(_:T)
let _this = this;
if((Bool.infix_38_38(((function(){throw '!unclarifiedGeneric:T'})()).isSigned, () => Int.infix_62(((function(){throw '!unclarifiedGeneric:T'})()).prototype.bitWidth$get.call(source), _this.constructor.bitWidth, {}), {}))) {
preconditionFileLine(() => ((function(){throw '!unclarifiedGeneric:T'})()).infix_62_61(source, _this.constructor.min, {}), () => "Not enough bits to represent a signed value", '?3', '?3', {});
};
if((Bool.infix_124_124(Int.infix_62(((function(){throw '!unclarifiedGeneric:T'})()).prototype.bitWidth$get.call(source), _this.constructor.bitWidth, {}), () => Bool.infix_38_38(Int.infix_61_61(((function(){throw '!unclarifiedGeneric:T'})()).prototype.bitWidth$get.call(source), _this.constructor.bitWidth, {}), () => Bool.prefix_33(((function(){throw '!unclarifiedGeneric:T'})()).isSigned, {}), {}), {}))) {
preconditionFileLine(() => ((function(){throw '!unclarifiedGeneric:T'})()).infix_60_61(source, _this.constructor.max, {}), () => "Not enough bits to represent the passed value", '?3', '?3', {});
};
_this.initTruncatingIfNeeded(source, {});
return
----Swift.(file).SignedInteger.init(exactly:T)
let _this = this;
if((Bool.infix_38_38(Bool.infix_38_38(((function(){throw '!unclarifiedGeneric:T'})()).isSigned, () => Int.infix_62(((function(){throw '!unclarifiedGeneric:T'})()).prototype.bitWidth$get.call(source), _this.constructor.bitWidth, {}), {}), () => ((function(){throw '!unclarifiedGeneric:T'})()).infix_60(source, _this.constructor.min, {}), {}))) {
return (this.$failed = true);
};
if((Bool.infix_38_38(Bool.infix_124_124(Int.infix_62(((function(){throw '!unclarifiedGeneric:T'})()).prototype.bitWidth$get.call(source), _this.constructor.bitWidth, {}), () => Bool.infix_38_38(Int.infix_61_61(((function(){throw '!unclarifiedGeneric:T'})()).prototype.bitWidth$get.call(source), _this.constructor.bitWidth, {}), () => Bool.prefix_33(((function(){throw '!unclarifiedGeneric:T'})()).isSigned, {}), {}), {}), () => ((function(){throw '!unclarifiedGeneric:T'})()).infix_62(source, _this.constructor.max, {}), {}))) {
return (this.$failed = true);
};
_this.initTruncatingIfNeeded(source, {});
return
----Swift.(file).SignedInteger.max
let _this = this;
return _this.prefix_126(_this.min, {});
}
static get max() { return this.max$get()
----Swift.(file).SignedInteger.min
let _this = this;
return _this.infix_38_60_60(-1, _this._highBitIndex, {});
}
static get min() { return this.min$get()
----Swift.(file).SignedInteger.isMultiple(of:Self)
let _this = this;
if((_this.constructor.infix_61_61(other, 0, {}))) {
return _this.constructor.infix_61_61(_this, 0, {});
};
if((_this.constructor.infix_61_61(other, -1, {}))) {
return true;
};
return _this.constructor.infix_61_61(_this.constructor.infix_37(_this, other, {}), 0, {})
----Swift.(file).numericCast(_:T)
return _create($info.U, 'initT', x, {})
----Swift.(file).JoinedSequence.init(base:Base,separator:Separator)
let _this = this;
_this._base = base;
_this._separator = _create(ContiguousArray, 'initBuffer', separator, {});
return
----Swift.(file).JoinedSequence.Iterator.init(base:Base.Iterator,separator:Separator)
let _this = this;
_this._base = base;
_this._separatorData = _create(ContiguousArray, 'initBuffer', separator, {});
return
----Swift.(file).JoinedSequence.Iterator.next()
let _this = this;
while(true){
if(!((true))) break
const $match = _this._state
if((($match.rawValue == JoinedSequence.Iterator._JoinIteratorState.start.rawValue))) {
const $ifLet0, nextSubSequence_1
if((($ifLet0 = _this._base.next( {$setThis: $val => _this._base = $val}))||true) && $ifLet0.rawValue == 'some' && ((nextSubSequence_1 = $ifLet0[0])||true)) {
_this._inner = _injectIntoOptional(nextSubSequence_1.makeIterator( {}));
_this._state = JoinedSequence.Iterator._JoinIteratorState.generatingElements;
}
else {
_this._state = JoinedSequence.Iterator._JoinIteratorState.end;
return Optional.none;
};
}
else if((($match.rawValue == JoinedSequence.Iterator._JoinIteratorState.generatingElements.rawValue))) {
const result = _this._inner[0].next( {$setThis: $val => _this._inner[0] = $val});
if((_fastPath(Optional.wrappedNotEqualsOptionalNilComparisonType(result, _create(_OptionalNilComparisonType, 'initNilLiteraltuple_type', {}), {}), {}))) {
return result;
};
_this._inner = _injectIntoOptional(((_.tmp0 = _this._base.next( {$setThis: $val => _this._base = $val})).rawValue === 'some') ? (_.tmp0[0].makeIterator( {})) : null);
if((Optional.wrappedEqualsOptionalNilComparisonType(_this._inner, _create(_OptionalNilComparisonType, 'initNilLiteraltuple_type', {}), {}))) {
_this._state = JoinedSequence.Iterator._JoinIteratorState.end;
return Optional.none;
};
if((Bool.prefix_33(_this._separatorData.isEmpty, {}))) {
_this._separator = _injectIntoOptional(_this._separatorData.makeIterator( {}));
_this._state = JoinedSequence.Iterator._JoinIteratorState.generatingSeparator;
};
}
else if((($match.rawValue == JoinedSequence.Iterator._JoinIteratorState.generatingSeparator.rawValue))) {
const result = _this._separator[0].next( {$setThis: $val => _this._separator[0] = $val});
if((_fastPath(Optional.wrappedNotEqualsOptionalNilComparisonType(result, _create(_OptionalNilComparisonType, 'initNilLiteraltuple_type', {}), {}), {}))) {
return result;
};
_this._state = JoinedSequence.Iterator._JoinIteratorState.generatingElements;
}
else if((($match.rawValue == JoinedSequence.Iterator._JoinIteratorState.end.rawValue))) {
return Optional.none;
};
}
----Swift.(file).JoinedSequence.makeIterator()
let _this = this;
return _create(JoinedSequence.Iterator, 'initBaseSeparator', _this._base.makeIterator( {}), _this._separator, {})
----Swift.(file).Sequence.joined(separator:Separator)
let _this = this;
return _create(JoinedSequence, 'initBaseSeparator', _this, separator, {})
----Swift.(file).AnyKeyPath.rootType
let _this = this;
return _this._rootAndValueType["0"];
}
static get rootType() { return this.rootType$get()
----Swift.(file).AnyKeyPath.valueType
let _this = this;
return _this._rootAndValueType["1"];
}
static get valueType() { return this.valueType$get()
----Swift.(file).AnyKeyPath.hashValue
let _this = this;
return _hashValueFor(_this, {})
----Swift.(file).AnyKeyPath.hash(into:Hasher)
let _this = this;
let hasher = hasher$inout.get()
const $result = (() => {
_create(ObjectIdentifier, 'initprotocol_composition_type', AnyKeyPath, {}).hashInto({get: () => hasher, set: $val => hasher = $val}, {});
return _this.withBuffer((($0, $info?) => { 
let buffer = _cloneStruct($0);
if((buffer.data.isEmpty)) {
return ;
};
while(true){
if(!((true))) break
const $tuple = buffer.next( {$setThis: $val => buffer = $val}), component = $tuple && $tuple[0], type = $tuple && $tuple[1];
hasher.combine(component.value, {$setThis: $val => hasher = $val});
const $ifLet0, type_1
if((($ifLet0 = type)||true) && $ifLet0.rawValue == 'some' && ((type_1 = $ifLet0[0])||true)) {
hasher.combine(unsafeBitCastTo(type_1, Int, {}), {$setThis: $val => hasher = $val});
}
else {
break;
};
}; }), {});})()
hasher$inout.set(hasher)
return $result
----Swift.(file).AnyKeyPath.==infix(_:AnyKeyPath,_:AnyKeyPath)
let _this = this;
if((infix_61_61_61(_injectIntoOptional(a), _injectIntoOptional(b), {}))) {
return true;
};
if((infix_33_61(_injectIntoOptional(AnyKeyPath), _injectIntoOptional(AnyKeyPath), {}))) {
return false;
};
return a.withBuffer((($0, $info?) => { 
let aBuffer = _cloneStruct($0);
return b.withBuffer((($0, $info?) => { 
let bBuffer = _cloneStruct($0);
if((Bool.infix_33_61(aBuffer.hasReferencePrefix, bBuffer.hasReferencePrefix, {}))) {
return false;
};
if((aBuffer.data.isEmpty)) {
return bBuffer.data.isEmpty;
};
while(true){
if(!((true))) break
const $tuple = aBuffer.next( {$setThis: $val => aBuffer = $val}), aComponent = $tuple && $tuple[0], aType = $tuple && $tuple[1];
const $tuple = bBuffer.next( {$setThis: $val => bBuffer = $val}), bComponent = $tuple && $tuple[0], bType = $tuple && $tuple[1];
if((Bool.infix_124_124(Bool.infix_124_124(Bool.infix_33_61(aComponent.header.endOfReferencePrefix, bComponent.header.endOfReferencePrefix, {}), () => KeyPathComponent.infix_33_61(aComponent.value, bComponent.value, {}), {}), () => infix_33_61(aType, bType, {}), {}))) {
return false;
};
if((infix_61_61(aType, Optional.none, {}))) {
return true;
};
}; }), {}); }), {})
----Swift.(file).KeyPath.kind
let _this = this;
return KeyPath.Kind.readOnly;
}
static get kind() { return this.kind$get()
----Swift.(file).KeyPath.appendedType(with:KeyPath<Value, AppendedValue>.Type)
let _this = this;
const resultKind;
const $match = {0: _this.kind, 1: t.kind}
if((($match[1].rawValue == KeyPath.Kind.reference.rawValue))) {
resultKind = KeyPath.Kind.reference;
}
else if((($match[1].rawValue == KeyPath.Kind.value.rawValue))) {
const x = $match[0]
resultKind = x;
}
else if(((true))) {
resultKind = KeyPath.Kind.readOnly;
};
const $match = resultKind
if((($match.rawValue == KeyPath.Kind.readOnly.rawValue))) {
return KeyPath;
}
else if((($match.rawValue == KeyPath.Kind.value.rawValue))) {
return WritableKeyPath;
}
else if((($match.rawValue == KeyPath.Kind.reference.rawValue))) {
return ReferenceWritableKeyPath;
}
----Swift.(file).KeyPathComputedArgumentLayoutFn
const KeyPathComputedArgumentLayoutFn = '?function_type
----Swift.(file).KeyPathComputedArgumentInitializerFn
const KeyPathComputedArgumentInitializerFn = '?function_type
----Swift.(file)._AppendKeyPath.appending(path:AnyKeyPath)
let _this = this;
return _tryToAppendKeyPathsRootLeaf(_this, path, {})
----Swift.(file)._AppendKeyPath.appending(path:AnyKeyPath)
let _this = this;
return _tryToAppendKeyPathsRootLeaf(/*derived_to_base_expr*/_this, path, {})
----Swift.(file)._AppendKeyPath.appending(path:KeyPath<AppendedRoot, AppendedValue>)
let _this = this;
return _tryToAppendKeyPathsRootLeaf(/*derived_to_base_expr*/_this, /*derived_to_base_expr*/path, {})
----Swift.(file)._AppendKeyPath.appending(path:ReferenceWritableKeyPath<AppendedRoot, AppendedValue>)
let _this = this;
return _tryToAppendKeyPathsRootLeaf(/*derived_to_base_expr*/_this, /*derived_to_base_expr*/path, {})
----Swift.(file)._AppendKeyPath.appending(path:KeyPath<Value, AppendedValue>)
let _this = this;
return _appendingKeyPathsRootLeaf(/*archetype_to_super_expr*/_this, path, {})
----Swift.(file)._AppendKeyPath.appending(path:ReferenceWritableKeyPath<Value, AppendedValue>)
let _this = this;
return _appendingKeyPathsRootLeaf(_this, /*derived_to_base_expr*/path, {})
----Swift.(file)._AppendKeyPath.appending(path:WritableKeyPath<Value, AppendedValue>)
let _this = this;
return _appendingKeyPathsRootLeaf(/*derived_to_base_expr*/_this, /*derived_to_base_expr*/path, {})
----Swift.(file)._AppendKeyPath.appending(path:ReferenceWritableKeyPath<Value, AppendedValue>)
let _this = this;
return _appendingKeyPathsRootLeaf(/*derived_to_base_expr*/_this, /*derived_to_base_expr*/path, {})
----Swift.(file)._AppendKeyPath.appending(path:WritableKeyPath<Value, AppendedValue>)
let _this = this;
return _appendingKeyPathsRootLeaf(/*derived_to_base_expr*/_this, /*derived_to_base_expr*/path, {})
----Swift.(file).keyPathPatternHeaderSize
let keyPathPatternHeaderSize
----Swift.(file).KeyValuePairs.Element

----Swift.(file).KeyValuePairs.Indices

----Swift.(file).KeyValuePairs.SubSequence

----Swift.(file).KeyValuePairs.startIndex
let _this = this;
return 0
----Swift.(file).KeyValuePairs.endIndex
let _this = this;
return _this._elements.endIndex
----Swift.(file).KeyValuePairs.subscript(_:KeyValuePairs<Key, Value>.Index)
let _this = this;
return _this._elements.subscript$get(position, {})/*destructure_tuple_expr (**NULL EXPRESSION**), (**NULL EXPRESSION**)*/
----Swift.(file).KeyValuePairs.description
let _this = this;
return _this._makeKeyValuePairDescriptionWithTypeName(nil/*!default_value*/, {})
----Swift.(file).KeyValuePairs.debugDescription
let _this = this;
return _this._makeKeyValuePairDescriptionWithTypeName(nil/*!default_value*/, {})
----Swift.(file).LazyCollectionProtocol.lazy
let _this = this;
return _this._elements.lazy
----Swift.(file).LazyCollectionProtocol.lazy
let _this = this;
return _this._elements
----Swift.(file).LazyCollection
const LazyCollection = LazySequenc
----Swift.(file).LazyCollection.SubSequence

----Swift.(file).LazyCollection.startIndex
let _this = this;
return _this._base.startIndex
----Swift.(file).LazyCollection.endIndex
let _this = this;
return _this._base.endIndex
----Swift.(file).LazyCollection.indices
let _this = this;
return _this._base.indices
----Swift.(file).LazyCollection.index(after:LazySequence<Base>.Index)
let _this = this;
return _this._base.indexAfter(i, {})
----Swift.(file).LazyCollection.subscript(_:LazySequence<Base>.Index)
let _this = this;
return _this._base.subscript$get(position, {})
----Swift.(file).LazyCollection.isEmpty
let _this = this;
return _this._base.isEmpty
----Swift.(file).LazyCollection.count
let _this = this;
return _this._base.count
----Swift.(file).LazyCollection.index(_:LazySequence<Base>.Index,offsetBy:Int)
let _this = this;
return _this._base.indexOffsetBy(i, n, {})
----Swift.(file).LazyCollection.index(_:LazySequence<Base>.Index,offsetBy:Int,limitedBy:LazySequence<Base>.Index)
let _this = this;
return _this._base.indexOffsetByLimitedBy(i, n, limit, {})
----Swift.(file).LazyCollection.distance(from:LazySequence<Base>.Index,to:LazySequence<Base>.Index)
let _this = this;
return _this._base.distanceFromTo(start, end, {})
----Swift.(file).LazyCollection.index(before:LazySequence<Base>.Index)
let _this = this;
return _this._base.indexBefore(i, {})
----Swift.(file).LazySequenceProtocol.lazy
let _this = this;
return _this._elements.lazy
----Swift.(file).LazySequenceProtocol.lazy
let _this = this;
return _this._elements
----Swift.(file).LazySequence.init(_base:Base)
let _this = this;
_this._base = _base;
return
----Swift.(file).LazySequence.makeIterator()
let _this = this;
return _this._base.makeIterator( {})
----Swift.(file).LazySequence.underestimatedCount
let _this = this;
return _this._base.underestimatedCount
----Swift.(file).Sequence.lazy
let _this = this;
return _create(LazySequence, 'init_base', _this, {})
----Swift.(file).withExtendedLifetime(_:T,_:() throws -> Result)
let $defer = () => {
_fixLifetime(x, {});
}
const $result = (() => {
try {;
return body( {});}catch($error){$defer( {});throw $error}})();$defer( {});return $result
----Swift.(file).withExtendedLifetime(_:T,_:(T) throws -> Result)
let $defer = () => {
_fixLifetime(x, {});
}
const $result = (() => {
try {;
return body(x, {});}catch($error){$defer( {});throw $error}})();$defer( {});return $result
----Swift.(file).ManagedBuffer.withUnsafeMutablePointerToHeader(_:(UnsafeMutablePointer<Header>) throws -> R)
let _this = this;
return _this.withUnsafeMutablePointers(((v, _, $info?) => body(v, {})), {})
----Swift.(file).ManagedBuffer.withUnsafeMutablePointerToElements(_:(UnsafeMutablePointer<Element>) throws -> R)
let _this = this;
return _this.withUnsafeMutablePointers((($0, $1, $info?) => body($1, {})), {})
----Swift.(file).ManagedBuffer.withUnsafeMutablePointers(_:(UnsafeMutablePointer<Header>, UnsafeMutablePointer<Element>) throws -> R)
let _this = this;
let $defer = () => {
_fixLifetime(_this, {});
}
const $result = (() => {
try {;
return body(_this.headerAddress, _this.firstElementAddress, {});}catch($error){$defer( {});throw $error}})();$defer( {});return $result
----Swift.(file).ManagedBufferPointer.init(bufferClass:AnyClass,minimumCapacity:Int,makingHeaderWith:(AnyObject, (AnyObject) -> Int) throws -> Header)
let _this = this;
$info.$setThis(_this = _cloneStruct(_create(ManagedBufferPointer, 'initBufferClassAnyClassMinimumCapacityInt', bufferClass, minimumCapacity, {})));
_this.withUnsafeMutablePointerToHeader((($0, $info?) => $0.initializeTo(factory(_this.buffer, (($0, $info?) => _create(ManagedBufferPointer, 'initUnsafeBufferObjectAnyObject', $0, {}).capacity), {}), {})), {});
_.discardAssignment = _this.header;
return
----Swift.(file).ManagedBufferPointer.init(bufferClass:AnyClass,minimumCapacity:Int)
let _this = this;
ManagedBufferPointer._checkValidBufferClassCreating(bufferClass, true, {});
preconditionFileLine(() => Int.infix_62_61(minimumCapacity, 0, {}), () => "ManagedBufferPointer must have non-negative capacity", '?3', '?3', {});
_this.init_uncheckedBufferClassAnyClassMinimumCapacityInt(bufferClass, minimumCapacity, {});
return
----Swift.(file).ManagedBufferPointer.header
 return this.header$internal
----Swift.(file).ManagedBufferPointer.capacity
let _this = this;
return Int.infix_47(Int.infix_38_45(_this._capacityInBytes, ManagedBufferPointer._elementOffset, {}), MemoryLayout.stride, {})
----Swift.(file).ManagedBufferPointer.withUnsafeMutablePointerToHeader(_:(UnsafeMutablePointer<Header>) throws -> R)
let _this = this;
return _this.withUnsafeMutablePointers(((v, _, $info?) => body(v, {})), {})
----Swift.(file).ManagedBufferPointer.withUnsafeMutablePointerToElements(_:(UnsafeMutablePointer<Element>) throws -> R)
let _this = this;
return _this.withUnsafeMutablePointers((($0, $1, $info?) => body($1, {})), {})
----Swift.(file).ManagedBufferPointer.withUnsafeMutablePointers(_:(UnsafeMutablePointer<Header>, UnsafeMutablePointer<Element>) throws -> R)
let _this = this;
let $defer = () => {
_fixLifetime(_this._nativeBuffer, {});
}
const $result = (() => {
try {;
return body(_this._headerPointer, _this._elementPointer, {});}catch($error){$defer( {});throw $error}})();$defer( {});return $result
----Swift.(file).ManagedBufferPointer.isUniqueReference()
let _this = this;
return _isUnique({get: () => _this._nativeBuffer, set: $val => _this._nativeBuffer = $val}, {})
----Swift.(file).ManagedBufferPointer.==infix(_:ManagedBufferPointer<Header, Element>,_:ManagedBufferPointer<Header, Element>)
let _this = this;
return UnsafeMutableRawPointer.infix_61_61(lhs._address, rhs._address, {})
----Swift.(file).isKnownUniquelyReferenced(_:T)
let object = object$inout.get()
const $result = (() => {
return _isUnique({get: () => object, set: $val => object = $val}, {});})()
object$inout.set(object)
return $result
----Swift.(file).isKnownUniquelyReferenced(_:T?)
let object = object$inout.get()
const $result = (() => {
return _isUnique({get: () => object, set: $val => object = $val}, {});})()
object$inout.set(object)
return $result
----Swift.(file).LazyMapSequence.Iterator.base
let _this = this;
return _this._base
----Swift.(file).LazyMapSequence.Iterator.next()
let _this = this;
return _this._base.next( {$setThis: $val => _this._base = $val}).mapSwift(_this._transform, {})
----Swift.(file).LazyMapSequence.makeIterator()
let _this = this;
return _create(LazyMapSequence.Iterator, 'init_base_transformfunction_type', _this._base.makeIterator( {}), _this._transform, {})
----Swift.(file).LazyMapSequence.underestimatedCount
let _this = this;
return _this._base.underestimatedCount
----Swift.(file).LazyMapCollection
const LazyMapCollection = LazyMapSequenc
----Swift.(file).LazyMapCollection.SubSequence

----Swift.(file).LazyMapCollection.startIndex
let _this = this;
return _this._base.startIndex
----Swift.(file).LazyMapCollection.endIndex
let _this = this;
return _this._base.endIndex
----Swift.(file).LazyMapCollection.index(after:LazyMapSequence<Base, Element>.Index)
let _this = this;
return _this._base.indexAfter(i, {})
----Swift.(file).LazyMapCollection.formIndex(after:LazyMapSequence<Base, Element>.Index)
let _this = this;
let i = i$inout.get()
const $result = (() => {
_this._base.formIndexAfter({get: () => i, set: $val => i = $val}, {});})()
i$inout.set(i)
return $result
----Swift.(file).LazyMapCollection.subscript(_:Base.Index)
let _this = this;
return _this._transform(_this._base.subscript$get(position, {}), {})
----Swift.(file).LazyMapCollection.subscript(_:Range<Base.Index>)
let _this = this;
return _create(LazyMapSequence.SubSequence, 'init_baseTransformfunction_type', _this._base.subscriptRange$get(bounds, {}), _this._transform, {})
----Swift.(file).LazyMapCollection.indices
let _this = this;
return _this._base.indices
----Swift.(file).LazyMapCollection.isEmpty
let _this = this;
return _this._base.isEmpty
----Swift.(file).LazyMapCollection.count
let _this = this;
return _this._base.count
----Swift.(file).LazyMapCollection.index(_:LazyMapSequence<Base, Element>.Index,offsetBy:Int)
let _this = this;
return _this._base.indexOffsetBy(i, n, {})
----Swift.(file).LazyMapCollection.index(_:LazyMapSequence<Base, Element>.Index,offsetBy:Int,limitedBy:LazyMapSequence<Base, Element>.Index)
let _this = this;
return _this._base.indexOffsetByLimitedBy(i, n, limit, {})
----Swift.(file).LazyMapCollection.distance(from:LazyMapSequence<Base, Element>.Index,to:LazyMapSequence<Base, Element>.Index)
let _this = this;
return _this._base.distanceFromTo(start, end, {})
----Swift.(file).LazyMapCollection.index(before:LazyMapSequence<Base, Element>.Index)
let _this = this;
return _this._base.indexBefore(i, {})
----Swift.(file).LazyMapCollection.formIndex(before:LazyMapSequence<Base, Element>.Index)
let _this = this;
let i = i$inout.get()
const $result = (() => {
_this._base.formIndexBefore({get: () => i, set: $val => i = $val}, {});})()
i$inout.set(i)
return $result
----Swift.(file).LazySequenceProtocol.map(_:(Self.Element) -> U)
let _this = this;
return _create(LazyMapSequence, 'init_baseTransformfunction_type', _this._elements, transform, {})
----Swift.(file).LazyMapSequence.map(_:(Element) -> ElementOfResult)
let _this = this;
return _create(LazyMapSequence, 'init_baseTransformfunction_type', _this._base, (($0, $info?) => transform(_this._transform($0, {}), {})), {})
----Swift.(file).LazyMapCollection.map(_:(Element) -> ElementOfResult)
let _this = this;
return _create(LazyMapCollection, 'init_baseTransformfunction_type', _this._base, (($0, $info?) => transform(_this._transform($0, {}), {})), {})
----Swift.(file).MemoryLayout.size(ofValue:T)
let _this = this;
return MemoryLayout.size
----Swift.(file).MemoryLayout.stride(ofValue:T)
let _this = this;
return MemoryLayout.stride
----Swift.(file).MemoryLayout.alignment(ofValue:T)
let _this = this;
return MemoryLayout.alignment
----Swift.(file).MemoryLayout.offset(of:PartialKeyPath<T>)
let _this = this;
return /*derived_to_base_expr*/key._storedInlineOffset
----Swift.(file).ReversedRandomAccessCollection
const ReversedRandomAccessCollection = ReversedCollectio
----Swift.(file).ReversedIndex
const ReversedIndex = ReversedCollectio
----Swift.(file).ImplicitlyUnwrappedOptional
const ImplicitlyUnwrappedOptional = Optiona
----Swift.(file).Range.init(_:Range<Bound>)
let _this = this;
$info.$setThis(_this = _cloneStruct(_cloneStruct(other)));
return
----Swift.(file).ClosedRange.init(_:ClosedRange<Bound>)
let _this = this;
$info.$setThis(_this = _cloneStruct(_cloneStruct(other)));
return
----Swift.(file).DictionaryLiteral
const DictionaryLiteral = KeyValuePair
----Swift.(file).LazySequenceProtocol.flatMap(_:(Self.Elements.Element) -> ElementOfResult?)
let _this = this;
return _this.compactMap(transform, {})
----Swift.(file).String.characters
let _this = this;
return _this
----Swift.(file).String.withMutableCharacters(_:(inout String) -> R)
let _this = this;
return body({get: () => _this, set: $val => $info.$setThis(_this = _cloneStruct($val))}, {})
----Swift.(file).String.UnicodeScalarView.customPlaygroundQuickLook
let _this = this;
return _PlaygroundQuickLook._text(_this.description, {})
----Swift.(file).String.UTF16View.customPlaygroundQuickLook
let _this = this;
return _PlaygroundQuickLook._text(_this.description, {})
----Swift.(file).String.UTF8View.customPlaygroundQuickLook
let _this = this;
return _PlaygroundQuickLook._text(_this.description, {})
----Swift.(file).Substring.characters
let _this = this;
return _this
----Swift.(file).Substring.withMutableCharacters(_:(inout Substring) -> R)
let _this = this;
return body({get: () => _this, set: $val => $info.$setThis(_this = _cloneStruct($val))}, {})
----Swift.(file).Substring.customPlaygroundQuickLook
let _this = this;
return _create(String, 'initSubstring', _this, {}).customPlaygroundQuickLook
----Swift.(file).Collection.index(_:Self.Index,offsetBy:T)
let _this = this;
return _this.indexOffsetBy(i, _create(Int, 'initT', n, {}), {})
----Swift.(file).Collection.formIndex(_:Self.Index,offsetBy:T)
let _this = this;
let i = i$inout.get()
const $result = (() => {
return _this.formIndexOffsetBy({get: () => i, set: $val => i = $val}, _create(Int, 'initT', n, {}), {});})()
i$inout.set(i)
return $result
----Swift.(file).Collection.index(_:Self.Index,offsetBy:T,limitedBy:Self.Index)
let _this = this;
return _this.indexOffsetByLimitedBy(i, _create(Int, 'initT', n, {}), limit, {})
----Swift.(file).Collection.formIndex(_:Self.Index,offsetBy:T,limitedBy:Self.Index)
let _this = this;
let i = i$inout.get()
const $result = (() => {
return _this.formIndexOffsetByLimitedBy({get: () => i, set: $val => i = $val}, _create(Int, 'initT', n, {}), limit, {});})()
i$inout.set(i)
return $result
----Swift.(file).Collection.distance(from:Self.Index,to:Self.Index)
let _this = this;
return numericCast(_this.distanceFromTo(start, end, {}), {T: Int, U: ((function(){throw '!unclarifiedGeneric:T'})())})
----Swift.(file).UnsafeMutablePointer.initialize(to:Pointee,count:Int)
let _this = this;
_this.initializeRepeatingCount(newValue, count, {})
----Swift.(file).UnsafeMutablePointer.deinitialize()
let _this = this;
return _this.deinitializeCount(1, {})
----Swift.(file).UnsafeMutablePointer.deallocate(capacity:Int)
let _this = this;
_this.deallocate( {})
----Swift.(file).UnsafeMutablePointer.initialize(from:C)
let _this = this;
const buf = _create(UnsafeMutableBufferPointer, 'initStartOptionalCountInt', _injectIntoOptional(/*pointer_to_pointer*/_this), numericCast(source.count, {T: Int, U: Int}), {});
let $tuple = source._copyContentsInitializing(buf, {}), remainders = $tuple && $tuple[0], writtenUpTo = $tuple && $tuple[1];
preconditionFileLine(() => Optional.wrappedEqualsOptionalNilComparisonType(remainders.next( {$setThis: $val => remainders = $val}), _create(_OptionalNilComparisonType, 'initNilLiteraltuple_type', {}), {}), () => "rhs underreported its count", '?3', '?3', {});
preconditionFileLine(() => Int.infix_61_61(writtenUpTo, buf.endIndex, {}), () => "rhs overreported its count", '?3', '?3', {})
----Swift.(file).UnsafeRawPointer.customPlaygroundQuickLook
let _this = this;
return _PlaygroundQuickLook._text(_this.summary, {})
----Swift.(file).UnsafeMutableRawPointer.customPlaygroundQuickLook
let _this = this;
return _PlaygroundQuickLook._text(_this.summary, {})
----Swift.(file).UnsafePointer.customPlaygroundQuickLook
let _this = this;
return PlaygroundQuickLook._text(_this.summary, {})
----Swift.(file).UnsafeMutablePointer.customPlaygroundQuickLook
let _this = this;
return PlaygroundQuickLook._text(_this.summary, {})
----Swift.(file).UnsafeMutableRawPointer.allocate(bytes:Int,alignedTo:Int)
let _this = this;
return UnsafeMutableRawPointer.allocateByteCountAlignment(size, alignment, {})
----Swift.(file).UnsafeMutableRawPointer.deallocate(bytes:Int,alignedTo:Int)
let _this = this;
_this.deallocate( {})
----Swift.(file).UnsafeMutableRawPointer.copyBytes(from:UnsafeRawPointer,count:Int)
let _this = this;
_this.copyMemoryFromByteCount(source, count, {})
----Swift.(file).UnsafeMutableRawPointer.initializeMemory(as:T.Type,at:Int,count:Int,to:T)
let _this = this;
return UnsafeMutableRawPointer.infix_43(_this, Int.infix_42(offset, MemoryLayout.stride, {}), {}).initializeMemoryAsRepeatingCount(type, repeatedValue, count, {})
----Swift.(file).UnsafeMutableRawPointer.initializeMemory(as:C.Element.Type,from:C)
let _this = this;
let ptr = _cloneStruct(_this);
{
let $element$generator = source.makeIterator( {});
while(true) {
const $ifLet0, _element_1;
if(!((($ifLet0 = $element$generator.next( {$setThis: $val => $element$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((_element_1 = $ifLet0[0])||true))) break
ptr.initializeMemoryAsRepeatingCount(((function(){throw '!unclarifiedGeneric:C.Element'})()), _element_1, 1, {});
UnsafeMutableRawPointer.infix_43_61({get: () => ptr, set: $val => ptr = $val}, MemoryLayout.stride, {});
}
};
return _create(UnsafeMutablePointer, 'initRawPointer', _this._rawValue, {})
----Swift.(file).UnsafeMutableRawBufferPointer.allocate(count:Int)
let _this = this;
return UnsafeMutableRawBufferPointer.allocateByteCountAlignment(count, MemoryLayout.alignment, {})
----Swift.(file).UnsafeMutableRawBufferPointer.copyBytes(from:UnsafeRawBufferPointer)
let _this = this;
_this.copyMemoryFrom(source, {})
----Swift.(file).Sequence.flatMap(_:(Self.Element) throws -> ElementOfResult?)
let _this = this;
return _this._compactMap(transform, {})
----Swift.(file).Collection.flatMap(_:(Self.Element) throws -> String?)
let _this = this;
return _this._compactMap(transform, {})
----Swift.(file).Collection.index(where:(Self.Element) throws -> Bool)
let _this = this;
return _this.firstIndexWhere(_predicate, {})
----Swift.(file).Collection.index(of:Self.Element)
let _this = this;
return _this.firstIndexOf(_element, {})
----Swift.(file)._PlaygroundQuickLook.init(reflecting:Any)
let _this = this;
const $ifLet0, customized_1
if((($ifLet0 = _injectIntoOptional(subject))||true) && $ifLet0.rawValue == 'some' && ((customized_1 = $ifLet0[0])||true)) {
$info.$setThis(_this = _cloneStruct(customized_1.customPlaygroundQuickLook));
}
else {const $ifLet2, customized_3
if((($ifLet2 = _injectIntoOptional(subject))||true) && $ifLet2.rawValue == 'some' && ((customized_3 = $ifLet2[0])||true)) {
$info.$setThis(_this = _cloneStruct(customized_3._defaultCustomPlaygroundQuickLook));
}
else {
const $ifLet4, q_5
if((($ifLet4 = Mirror.quickLookObject(subject, {}))||true) && $ifLet4.rawValue == 'some' && ((q_5 = $ifLet4[0])||true)) {
$info.$setThis(_this = _cloneStruct(q_5));
}
else {
$info.$setThis(_this = _cloneStruct(_PlaygroundQuickLook._text(_create(String, 'initReflecting', subject, {}), {})));
};
}
};
return
----Swift.(file).Mirror.init(reflecting:Any)
let _this = this;
const $ifLet0, customized_1
if((($ifLet0 = subject)||true) && $ifLet0 instanceof CustomReflectable && ((customized_1 = $ifLet0)||true)) {
$info.$setThis(_this = _cloneStruct(_cloneStruct(customized_1.customMirror)));
}
else {
$info.$setThis(_this = _cloneStruct(_create(Mirror, 'initInternalReflectingprotocol_composition_typeSubjectTypeOptionalCustomAncestorOptional', subject, nil/*!default_value*/, nil/*!default_value*/, {})));
};
return
----Swift.(file).Mirror.Child

----Swift.(file).Mirror.Children

----Swift.(file).Mirror.superclassMirror
let _this = this;
return _this._makeSuperclassMirror( {})
----Swift.(file).Mirror.descendant(_:MirrorPath,_:[MirrorPath])
let _this = this;
let result = _cloneStruct(_create(Mirror._Dummy, 'initMirrorMirror', _this, {}));
{
let $e$generator = _cloneStruct(Array.infix_43(_create(Array, 'initArrayLiteralArray', [first], {}), rest, {}).makeIterator( {}));
while(true) {
const $ifLet0, e_1;
if(!((($ifLet0 = $e$generator.next( {$setThis: $val => $e$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((e_1 = $ifLet0[0])||true))) break
const children = _cloneStruct(_create(Mirror, 'initReflectingprotocol_composition_type', result, {}).children);
const position;
const $ifLet2, label_3
if((($ifLet2 = e_1)||true) && $ifLet2 instanceof String && ((label_3 = $ifLet2)||true)) {
position = _cloneStruct(infix_63_63(children.firstIndexWhere((($0, $info?) => Optional.infix_61_61($0["0"], _injectIntoOptional(label_3), {})), {}), () => children.endIndex, {}));
}
else {const $ifLet4, offset_5
if((($ifLet4 = _injectIntoOptional(e_1))||true) && $ifLet4.rawValue == 'some' && ((offset_5 = $ifLet4[0])||true)) {
position = _cloneStruct(infix_63_63(children.indexOffsetByLimitedBy(children.startIndex, offset_5, children.endIndex, {}), () => children.endIndex, {}));
}
else {
preconditionFailureFileLine(() => "Someone added a conformance to MirrorPath; that privilege is reserved to the standard library", '?3', '?3', {});
}
};
if((AnyIndex.infix_61_61(position, children.endIndex, {}))) {
return Optional.none;
};
result = _cloneStruct(children.subscript$get(position, {})["1"]);
}
};
return _injectIntoOptional(result)
----Swift.(file).String.init(describing:Subject)
let _this = this;
_this.init( {});
_print_unlocked(instance, {get: () => _this, set: $val => return _cloneStruct($val)}, {});
return
----Swift.(file).String.init(describing:Subject)
let _this = this;
return _cloneStruct(instance.description);
return
----Swift.(file).String.init(describing:Subject)
let _this = this;
_this.init( {});
instance.writeTo({get: () => _this, set: $val => return _cloneStruct($val)}, {});
return
----Swift.(file).String.init(describing:Subject)
let _this = this;
return _cloneStruct(instance.description);
return
----Swift.(file).String.init(reflecting:Subject)
let _this = this;
_this.init( {});
_debugPrint_unlocked(subject, {get: () => _this, set: $val => return _cloneStruct($val)}, {});
return
----Swift.(file).Mirror.description
let _this = this;
return (("Mirror for ") + (_this.subjectType) + (""))
----Swift.(file).Mirror.customMirror
let _this = this;
return _create(Mirror, 'initChildrenKeyValuePairsDisplayStyleOptionalAncestorRepresentationMirrorAncestorRepresentation', _this, new Map([]), nil/*!default_value*/, .generated/*!default_value*/, {})
----Swift.(file).MutableCollection.withContiguousMutableStorageIfAvailable(_:(inout UnsafeMutableBufferPointer<Self.Element>) throws -> R)
let _this = this;
return Optional.none
----Swift.(file).MutableCollection.subscript(_:Range<Self.Index>)#ASS

let _this = this;
_writeBackMutableSliceBoundsSlice({get: () => _this, set: $val => $info.$setThis(_this = _cloneStruct($val))}, bounds, newValue, {})
----Swift.(file).MutableCollection.subscript(_:Range<Self.Index>)
let _this = this;
return _create(Slice, 'initBaseBoundsRange', _this, bounds, {});

----Swift.(file).MutableCollection.swapAt(_:Self.Index,_:Self.Index)
let _this = this;
if(!(((_.arg0 = i).constructor.infix_33_61(_.arg0, j, {})))) {
return ;
};
const tmp = _this.subscript$get(i, {});
_this.subscript$set(_this.subscript$get(j, {}), i, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
_this.subscript$set(tmp, j, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
----Swift.(file)._NativeDictionary.capacity
let _this = this;
return _assumeNonNegative(_this._storage._capacity, {})
----Swift.(file)._NativeDictionary.hashTable
let _this = this;
return _this._storage._hashTable
----Swift.(file)._NativeDictionary.age
let _this = this;
return _this._storage._age
----Swift.(file)._NativeDictionary.invalidateIndices()
let _this = this;
Int32.infix_38_43_61({get: () => _this._storage._age, set: $val => _this._storage._age = $val}, 1, {})
----Swift.(file)._NativeDictionary.uncheckedKey(at:<<error type>>)
let _this = this;
let $defer = () => {
_fixLifetime(_this, {});
}
const $result = (() => {
try {;
return _this._keys.subscript$get(bucket.offset, {});}catch($error){$defer( {});throw $error}})();$defer( {});return $result
----Swift.(file)._NativeDictionary.uncheckedValue(at:<<error type>>)
let _this = this;
let $defer = () => {
_fixLifetime(_this, {});
}
const $result = (() => {
try {;
return _this._values.subscript$get(bucket.offset, {});}catch($error){$defer( {});throw $error}})();$defer( {});return $result
----Swift.(file)._NativeDictionary.uncheckedInitialize(at:<<error type>>,toKey:Key,value:Value)
let _this = this;
let $defer = () => {
_fixLifetime(_this, {});
}
const $result = (() => {
try {;
UnsafeMutablePointer.infix_43(_this._keys, bucket.offset, {}).initializeTo(key, {});
UnsafeMutablePointer.infix_43(_this._values, bucket.offset, {}).initializeTo(value, {});}catch($error){$defer( {});throw $error}})();$defer( {});return $result
----Swift.(file)._NativeDictionary.uncheckedDestroy(at:<<error type>>)
let _this = this;
let $defer = () => {
_fixLifetime(_this, {});
}
const $result = (() => {
try {;
UnsafeMutablePointer.infix_43(_this._keys, bucket.offset, {}).deinitializeCount(1, {});
UnsafeMutablePointer.infix_43(_this._values, bucket.offset, {}).deinitializeCount(1, {});}catch($error){$defer( {});throw $error}})();$defer( {});return $result
----Swift.(file)._NativeDictionary.hashValue(for:Key)
let _this = this;
return key._rawHashValueSeed(_this._storage._seed, {})
----Swift.(file)._NativeDictionary.find(_:Key)
let _this = this;
return _this.findHashValue(key, _this.hashValueFor(key, {}), {})
----Swift.(file)._NativeDictionary.find(_:Key,hashValue:Int)
let _this = this;
const hashTable = _cloneStruct(_this.hashTable);
let bucket = _cloneStruct(hashTable.idealBucketForHashValue(hashValue, {}));
while(true){
if(!((hashTable._isOccupied(bucket, {})))) break
if(((_.arg0 = _this.uncheckedKeyAt(bucket, {})).constructor.infix_61_61(_.arg0, key, {}))) {
return {0: bucket, 1: true};
};
bucket = _cloneStruct(hashTable.bucketWrappedAfter(bucket, {}));
};
return {0: bucket, 1: false}
----Swift.(file)._NativeDictionary.resize(capacity:Int)
let _this = this;
const capacity = /*dot_syntax_base_ignored*/max(capacity, _this.capacity, {});
const newStorage = _DictionaryStorage.resizeOriginalCapacityMove(_this._storage, capacity, true, {});
const result = _create(_NativeDictionary, 'init__RawDictionaryStorage', /*derived_to_base_expr*/newStorage, {});
if((Int.infix_62(_this.count, 0, {}))) {
{
let $bucket$generator = _cloneStruct(_this.hashTable.makeIterator( {}));
while(true) {
const $ifLet0, bucket_1;
if(!((($ifLet0 = $bucket$generator.next( {$setThis: $val => $bucket$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((bucket_1 = $ifLet0[0])||true))) break
const key = UnsafeMutablePointer.infix_43(_this._keys, bucket_1.offset, {}).move( {});
const value = UnsafeMutablePointer.infix_43(_this._values, bucket_1.offset, {}).move( {});
result._unsafeInsertNewKeyValue(key, value, {});
}
};
_this._storage._hashTable.clear( {});
_this._storage._count = 0;
};
_this._storage = result._storage
----Swift.(file)._NativeDictionary.copyAndResize(capacity:Int)
let _this = this;
const capacity = /*dot_syntax_base_ignored*/max(capacity, _this.capacity, {});
const newStorage = _DictionaryStorage.resizeOriginalCapacityMove(_this._storage, capacity, false, {});
const result = _create(_NativeDictionary, 'init__RawDictionaryStorage', /*derived_to_base_expr*/newStorage, {});
if((Int.infix_62(_this.count, 0, {}))) {
{
let $bucket$generator = _cloneStruct(_this.hashTable.makeIterator( {}));
while(true) {
const $ifLet0, bucket_1;
if(!((($ifLet0 = $bucket$generator.next( {$setThis: $val => $bucket$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((bucket_1 = $ifLet0[0])||true))) break
result._unsafeInsertNewKeyValue(_this.uncheckedKeyAt(bucket_1, {}), _this.uncheckedValueAt(bucket_1, {}), {});
}
};
};
_this._storage = result._storage
----Swift.(file)._NativeDictionary.copy()
let _this = this;
const newStorage = _DictionaryStorage.copyOriginal(_this._storage, {});
const result = _create(_NativeDictionary, 'init__RawDictionaryStorage', /*derived_to_base_expr*/newStorage, {});
if((Int.infix_62(_this.count, 0, {}))) {
result.hashTable.copyContentsOf(_this.hashTable, {});
result._storage._count = _this.count;
{
let $bucket$generator = _cloneStruct(_this.hashTable.makeIterator( {}));
while(true) {
const $ifLet0, bucket_1;
if(!((($ifLet0 = $bucket$generator.next( {$setThis: $val => $bucket$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((bucket_1 = $ifLet0[0])||true))) break
const key = _this.uncheckedKeyAt(bucket_1, {});
const value = _this.uncheckedValueAt(bucket_1, {});
result.uncheckedInitializeAtToKeyValue(bucket_1, key, value, {});
}
};
};
_this._storage = result._storage
----Swift.(file)._NativeDictionary.ensureUnique(isUnique:Bool,capacity:Int)
let _this = this;
if((_fastPath(Bool.infix_38_38(Int.infix_60_61(capacity, _this.capacity, {}), () => isUnique, {}), {}))) {
return false;
};
if((isUnique)) {
_this.resizeCapacity(capacity, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
return true;
};
if((Int.infix_60_61(capacity, _this.capacity, {}))) {
_this.copy( {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
return false;
};
_this.copyAndResizeCapacity(capacity, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
return true
----Swift.(file)._NativeDictionary.validatedBucket(for:<<error type>>)
let _this = this;
preconditionFileLine(() => Bool.infix_38_38(_this.hashTable.isOccupied(index.bucket, {}), () => Int32.infix_61_61(index.age, _this.age, {}), {}), () => "Attempting to access Dictionary elements using an invalid index", '?3', '?3', {});
return index.bucket
----Swift.(file)._NativeDictionary.validatedBucket(for:Dictionary<Key, Value>.Index)
let _this = this;
if(!((index._isNative))) {
index._cocoaPath( {});
const cocoa = _cloneStruct(index._asCocoa);
if((Int32.infix_61_61(cocoa.age, _this.age, {}))) {
const key = _forceBridgeFromObjectiveC(cocoa.key, ((function(){throw '!unclarifiedGeneric:Key'})()), {});
const $tuple = _this.find(key, {})/*destructure_tuple_expr (**NULL EXPRESSION**), (**NULL EXPRESSION**)*/, bucket = $tuple && $tuple[0], found = $tuple && $tuple[1];
if((found)) {
return bucket;
};
};
preconditionFailureFileLine(() => "Attempting to access Dictionary elements using an invalid index", '?3', '?3', {});
};
return _this.validatedBucketFor(index._asNative, {})
----Swift.(file)._NativeDictionary.startIndex
let _this = this;
const bucket = _cloneStruct(_this.hashTable.startBucket);
return _create(_NativeDictionary.Index, 'init_native_HashTableIndex', _create(_HashTable.Index, 'initBucket_HashTableBucketAgeInt32', bucket, _this.age, {}), {})
----Swift.(file)._NativeDictionary.endIndex
let _this = this;
const bucket = _cloneStruct(_this.hashTable.endBucket);
return _create(_NativeDictionary.Index, 'init_native_HashTableIndex', _create(_HashTable.Index, 'initBucket_HashTableBucketAgeInt32', bucket, _this.age, {}), {})
----Swift.(file)._NativeDictionary.index(after:_NativeDictionary<Key, Value>.Index)
let _this = this;
if(!((_fastPath(index._isNative, {})))) {
 const _ = _cloneStruct(_this.validatedBucketFor(index, {}));
const i = _cloneStruct(index._asCocoa);
return _create(_NativeDictionary.Index, 'init_cocoa__CocoaDictionaryIndex', i.dictionary.indexAfter(i, {}), {});
};
const bucket = _cloneStruct(_this.validatedBucketFor(index._asNative, {}));
const next = _cloneStruct(_this.hashTable.occupiedBucketAfter(bucket, {}));
return _create(_NativeDictionary.Index, 'init_native_HashTableIndex', _create(_HashTable.Index, 'initBucket_HashTableBucketAgeInt32', next, _this.age, {}), {})
----Swift.(file)._NativeDictionary.index(forKey:Key)
let _this = this;
if((Int.infix_61_61(_this.count, 0, {}))) {
return Optional.none;
};
const $tuple = _this.find(key, {})/*destructure_tuple_expr (**NULL EXPRESSION**), (**NULL EXPRESSION**)*/, bucket = $tuple && $tuple[0], found = $tuple && $tuple[1];
if(!((found))) {
return Optional.none;
};
return _injectIntoOptional(_create(_NativeDictionary.Index, 'init_native_HashTableIndex', _create(_HashTable.Index, 'initBucket_HashTableBucketAgeInt32', bucket, _this.age, {}), {}))
----Swift.(file)._NativeDictionary.count
let _this = this;
return _assumeNonNegative(_this._storage._count, {})
----Swift.(file)._NativeDictionary.contains(_:Key)
let _this = this;
return _this.find(key, {})["1"]
----Swift.(file)._NativeDictionary.lookup(_:Key)
let _this = this;
if((Int.infix_61_61(_this.count, 0, {}))) {
return Optional.none;
};
const $tuple = _this.find(key, {})/*destructure_tuple_expr (**NULL EXPRESSION**), (**NULL EXPRESSION**)*/, bucket = $tuple && $tuple[0], found = $tuple && $tuple[1];
if(!((found))) {
return Optional.none;
};
return _injectIntoOptional(_this.uncheckedValueAt(bucket, {}))
----Swift.(file)._NativeDictionary.lookup(_:_NativeDictionary<Key, Value>.Index)
let _this = this;
const bucket = _cloneStruct(_this.validatedBucketFor(index, {}));
const key = _this.uncheckedKeyAt(bucket, {});
const value = _this.uncheckedValueAt(bucket, {});
return {0: key, 1: value}
----Swift.(file)._NativeDictionary.key(at:_NativeDictionary<Key, Value>.Index)
let _this = this;
const bucket = _cloneStruct(_this.validatedBucketFor(index, {}));
return _this.uncheckedKeyAt(bucket, {})
----Swift.(file)._NativeDictionary.value(at:_NativeDictionary<Key, Value>.Index)
let _this = this;
const bucket = _cloneStruct(_this.validatedBucketFor(index, {}));
return _this.uncheckedValueAt(bucket, {})
----Swift.(file)._NativeDictionary.subscript(_:Key,isUnique:Bool)
let _this = this;
return _this.lookup(key, {});
}subscriptIsUnique$_modify(key, isUnique, $info?){
let _this = this;
const $tuple = _this.mutatingFindIsUnique(key, isUnique, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})/*destructure_tuple_expr (**NULL EXPRESSION**), (**NULL EXPRESSION**)*/, bucket = $tuple && $tuple[0], found = $tuple && $tuple[1];
if((found)) {
let value = _injectIntoOptional(UnsafeMutablePointer.infix_43(_this._values, bucket.offset, {}).move( {}));
let $defer = () => {
const $ifLet0, value_1
if((($ifLet0 = value)||true) && $ifLet0.rawValue == 'some' && ((value_1 = $ifLet0[0])||true)) {
UnsafeMutablePointer.infix_43(_this._values, bucket.offset, {}).initializeTo(value_1, {});
}
else {
UnsafeMutablePointer.infix_43(_this._keys, bucket.offset, {}).deinitializeCount(1, {});
_this._deleteAt(bucket, {});
};
}
const $result = (() => {
try {;
/*yield*/;}catch($error){$defer( {});throw $error}})();$defer( {});return $result;
}
else {
let value = Optional.none;
let $defer = () => {
const $ifLet2, value_3
if((($ifLet2 = value)||true) && $ifLet2.rawValue == 'some' && ((value_3 = $ifLet2[0])||true)) {
_this._insertAtKeyValue(bucket, key, value_3, {});
};
}
const $result = (() => {
try {;
/*yield*/;}catch($error){$defer( {});throw $error}})();$defer( {});return $result;
}
----Swift.(file)._NativeDictionary.insertNew(key:Key,value:Value)
let _this = this;
_.discardAssignment = _this.ensureUniqueIsUniqueCapacity(true, Int.infix_43(_this.count, 1, {}), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
_this._unsafeInsertNewKeyValue(key, value, {})
----Swift.(file)._NativeDictionary.mutatingFind(_:Key,isUnique:Bool)
let _this = this;
const $tuple = _this.find(key, {})/*destructure_tuple_expr (**NULL EXPRESSION**), (**NULL EXPRESSION**)*/, bucket = $tuple && $tuple[0], found = $tuple && $tuple[1];
const rehashed = _this.ensureUniqueIsUniqueCapacity(isUnique, Int.infix_43(_this.count, (found ? 0 : 1), {}), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
if(!((rehashed))) {
return {0: bucket, 1: found};
};
const $tuple = _this.find(key, {})/*destructure_tuple_expr (**NULL EXPRESSION**), (**NULL EXPRESSION**)*/, b = $tuple && $tuple[0], f = $tuple && $tuple[1];
if((Bool.infix_33_61(f, found, {}))) {
KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(((function(){throw '!unclarifiedGeneric:Key'})()), {});
};
return {0: b, 1: found}
----Swift.(file)._NativeDictionary.updateValue(_:Value,forKey:Key,isUnique:Bool)
let _this = this;
const $tuple = _this.mutatingFindIsUnique(key, isUnique, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})/*destructure_tuple_expr (**NULL EXPRESSION**), (**NULL EXPRESSION**)*/, bucket = $tuple && $tuple[0], found = $tuple && $tuple[1];
if((found)) {
const oldValue = UnsafeMutablePointer.infix_43(_this._values, bucket.offset, {}).move( {});
UnsafeMutablePointer.infix_43(_this._values, bucket.offset, {}).initializeTo(value, {});
return _injectIntoOptional(oldValue);
};
_this._insertAtKeyValue(bucket, key, value, {});
return Optional.none
----Swift.(file)._NativeDictionary.setValue(_:Value,forKey:Key,isUnique:Bool)
let _this = this;
const $tuple = _this.mutatingFindIsUnique(key, isUnique, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})/*destructure_tuple_expr (**NULL EXPRESSION**), (**NULL EXPRESSION**)*/, bucket = $tuple && $tuple[0], found = $tuple && $tuple[1];
if((found)) {
UnsafeMutablePointer.infix_43(_this._values, bucket.offset, {}).pointee = value;
}
else {
_this._insertAtKeyValue(bucket, key, value, {});
}
----Swift.(file)._NativeDictionary.swapValuesAt(_:<<error type>>,_:<<error type>>,isUnique:Bool)
let _this = this;
const rehashed = _this.ensureUniqueIsUniqueCapacity(isUnique, _this.capacity, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
const value = UnsafeMutablePointer.infix_43(_this._values, a.offset, {}).move( {});
UnsafeMutablePointer.infix_43(_this._values, a.offset, {}).moveInitializeFromCount(UnsafeMutablePointer.infix_43(_this._values, b.offset, {}), 1, {});
UnsafeMutablePointer.infix_43(_this._values, b.offset, {}).initializeTo(value, {})
----Swift.(file)._NativeDictionary.isEqual(to:_NativeDictionary<Key, Value>)
let _this = this;
if((infix_61_61_61(_injectIntoOptional(_this._storage), _injectIntoOptional(other._storage), {}))) {
return true;
};
if((Int.infix_33_61(_this.count, other.count, {}))) {
return false;
};
{
let $generator = _cloneStruct(_this.makeIterator( {}));
while(true) {
const $ifLet0, key_1, value_2;
if(!((($ifLet0 = _injectIntoOptional(((_.tmp0 = $generator.next( {$setThis: $val => $generator = $val})).rawValue === 'some') ? (_.tmp0[0]/*destructure_tuple_expr (**NULL EXPRESSION**), (**NULL EXPRESSION**)*/) : null))||true) && $ifLet0.rawValue == 'some' && ((key_1 = $ifLet0[0][0])||true) && ((value_2 = $ifLet0[0][1])||true))) break
const $tuple = other.find(key_1, {})/*destructure_tuple_expr (**NULL EXPRESSION**), (**NULL EXPRESSION**)*/, bucket = $tuple && $tuple[0], found = $tuple && $tuple[1];
if(!((found) && ((_.arg0 = other.uncheckedValueAt(bucket, {})).constructor.infix_61_61(_.arg0, value_2, {})))) {
return false;
};
}
};
return true
----Swift.(file)._NativeDictionary.isEqual(to:<<error type>>)
let _this = this;
if((Int.infix_33_61(_this.count, other.count, {}))) {
return false;
};
let $defer = () => {
_fixLifetime(_this, {});
}
const $result = (() => {
try {;
{
let $bucket$generator = _cloneStruct(_this.hashTable.makeIterator( {}));
while(true) {
const $ifLet0, bucket_1;
if(!((($ifLet0 = $bucket$generator.next( {$setThis: $val => $bucket$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((bucket_1 = $ifLet0[0])||true))) break
const key = _this.uncheckedKeyAt(bucket_1, {});
const value = _this.uncheckedValueAt(bucket_1, {});
const $ifLet2, cocoaValue_3
if(!((($ifLet2 = other.lookup(_bridgeAnythingToObjectiveC(key, {}), {}))||true) && $ifLet2.rawValue == 'some' && ((cocoaValue_3 = $ifLet2[0])||true) && ((_.arg0 = value).constructor.infix_61_61(_.arg0, _forceBridgeFromObjectiveC(cocoaValue_3, ((function(){throw '!unclarifiedGeneric:Value'})()), {}), {})))) {
return false;
};
}
};
return true;}catch($error){$defer( {});throw $error}})();$defer( {});return $result
----Swift.(file)._NativeDictionary.hashValue(at:<<error type>>)
let _this = this;
return _this.hashValueFor(_this.uncheckedKeyAt(bucket, {}), {})
----Swift.(file)._NativeDictionary.moveEntry(from:<<error type>>,to:<<error type>>)
let _this = this;
UnsafeMutablePointer.infix_43(_this._keys, target.offset, {}).moveInitializeFromCount(UnsafeMutablePointer.infix_43(_this._keys, source.offset, {}), 1, {});
UnsafeMutablePointer.infix_43(_this._values, target.offset, {}).moveInitializeFromCount(UnsafeMutablePointer.infix_43(_this._values, source.offset, {}), 1, {})
----Swift.(file)._NativeDictionary.swapEntry(_:<<error type>>,with:<<error type>>)
let _this = this;
swap({get: () => _this._keys.subscript$get(left.offset, {}), set: $val => _this._keys.subscript$set($val, left.offset, {$setThis: $val => _this._keys = _cloneStruct($val)})}, {get: () => _this._keys.subscript$get(right.offset, {}), set: $val => _this._keys.subscript$set($val, right.offset, {$setThis: $val => _this._keys = _cloneStruct($val)})}, {});
swap({get: () => _this._values.subscript$get(left.offset, {}), set: $val => _this._values.subscript$set($val, left.offset, {$setThis: $val => _this._values = _cloneStruct($val)})}, {get: () => _this._values.subscript$get(right.offset, {}), set: $val => _this._values.subscript$set($val, right.offset, {$setThis: $val => _this._values = _cloneStruct($val)})}, {})
----Swift.(file)._NativeDictionary.uncheckedRemove(at:<<error type>>,isUnique:Bool)
let _this = this;
const rehashed = _this.ensureUniqueIsUniqueCapacity(isUnique, _this.capacity, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
const oldKey = UnsafeMutablePointer.infix_43(_this._keys, bucket.offset, {}).move( {});
const oldValue = UnsafeMutablePointer.infix_43(_this._values, bucket.offset, {}).move( {});
_this._deleteAt(bucket, {});
return {0: oldKey, 1: oldValue}
----Swift.(file)._NativeDictionary.removeAll(isUnique:Bool)
let _this = this;
if(!((isUnique))) {
const scale = _this._storage._scale;
_this._storage = /*derived_to_base_expr*/_DictionaryStorage.allocateScaleAgeSeed(scale, Optional.none, Optional.none, {});
return ;
};
{
let $bucket$generator = _cloneStruct(_this.hashTable.makeIterator( {}));
while(true) {
const $ifLet0, bucket_1;
if(!((($ifLet0 = $bucket$generator.next( {$setThis: $val => $bucket$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((bucket_1 = $ifLet0[0])||true))) break
UnsafeMutablePointer.infix_43(_this._keys, bucket_1.offset, {}).deinitializeCount(1, {});
UnsafeMutablePointer.infix_43(_this._values, bucket_1.offset, {}).deinitializeCount(1, {});
}
};
_this.hashTable.clear( {});
_this._storage._count = 0;
_this.invalidateIndices( {})
----Swift.(file)._NativeDictionary.mapValues(_:(Value) throws -> T)
let _this = this;
const resultStorage = _DictionaryStorage.copyOriginal(_this._storage, {});
const result = _create(_NativeDictionary, 'init__RawDictionaryStorage', /*derived_to_base_expr*/resultStorage, {});
{
let $bucket$generator = _cloneStruct(_this.hashTable.makeIterator( {}));
while(true) {
const $ifLet0, bucket_1;
if(!((($ifLet0 = $bucket$generator.next( {$setThis: $val => $bucket$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((bucket_1 = $ifLet0[0])||true))) break
const key = _this.uncheckedKeyAt(bucket_1, {});
const value = _this.uncheckedValueAt(bucket_1, {});
result._insertAtKeyValue(bucket_1, key, transform(value, {}), {});
}
};
return result
----Swift.(file)._NativeDictionary.merge(_:S,isUnique:Bool,uniquingKeysWith:(Value, Value) throws -> Value)
let _this = this;
let isUnique_dupl = isUnique;
{
let $generator = keysAndValues.makeIterator( {});
while(true) {
const $ifLet0, key_1, value_2;
if(!((($ifLet0 = $generator.next( {$setThis: $val => $generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((key_1 = $ifLet0[0][0])||true) && ((value_2 = $ifLet0[0][1])||true))) break
const $tuple = _this.mutatingFindIsUnique(key_1, isUnique_dupl, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})/*destructure_tuple_expr (**NULL EXPRESSION**), (**NULL EXPRESSION**)*/, bucket = $tuple && $tuple[0], found = $tuple && $tuple[1];
isUnique_dupl = true;
if((found)) {
try {
const newValue = combine(_this.uncheckedValueAt(bucket, {}), value_2, {});
_this._values.subscript$set(newValue, bucket.offset, {$setThis: $val => _this._values = _cloneStruct($val)});
} catch(error) {
if((error instanceof _MergeError && error.rawValue == _MergeError.keyCollision.rawValue)) {
fatalErrorFileLine(() => (("Duplicate values for key: '") + (key_1) + ("'")), '?3', '?3', {});
}
else throw error
};
}
else {
_this._insertAtKeyValue(bucket, key_1, value_2, {});
};
}
}
----Swift.(file)._NativeDictionary.init(grouping:S,by:(S.Element) throws -> Key)
let _this = this;
_this.init( {});
{
let $value$generator = values.makeIterator( {});
while(true) {
const $ifLet0, value_1;
if(!((($ifLet0 = $value$generator.next( {$setThis: $val => $value$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((value_1 = $ifLet0[0])||true))) break
const key = keyForValue(value_1, {});
const $tuple = _this.mutatingFindIsUnique(key, true, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})/*destructure_tuple_expr (**NULL EXPRESSION**), (**NULL EXPRESSION**)*/, bucket = $tuple && $tuple[0], found = $tuple && $tuple[1];
if((found)) {
_this._values.subscript$get(bucket.offset, {}).append(value_1, {$setThis: $val => _this._values.subscript$set($val, bucket.offset, {$setThis: $val => _this._values = _cloneStruct($val)})});
}
else {
_this._insertAtKeyValue(bucket, key, _create(Array, 'initArrayLiteralArray', [value_1], {}), {});
};
}
};
return
----Swift.(file)._NativeDictionary.makeIterator()
let _this = this;
return _create(_NativeDictionary.Iterator, 'init_NativeDictionary', _this, {})
----Swift.(file)._NativeDictionary.Iterator.Element

----Swift.(file)._NativeDictionary.Iterator.nextKey()
let _this = this;
const $ifLet0, index_1
if(!((($ifLet0 = _this.iterator.next( {$setThis: $val => _this.iterator = $val}))||true) && $ifLet0.rawValue == 'some' && ((index_1 = $ifLet0[0])||true))) {
return Optional.none;
};
return _injectIntoOptional(_this.base.uncheckedKeyAt(index_1, {}))
----Swift.(file)._NativeDictionary.Iterator.nextValue()
let _this = this;
const $ifLet0, index_1
if(!((($ifLet0 = _this.iterator.next( {$setThis: $val => _this.iterator = $val}))||true) && $ifLet0.rawValue == 'some' && ((index_1 = $ifLet0[0])||true))) {
return Optional.none;
};
return _injectIntoOptional(_this.base.uncheckedValueAt(index_1, {}))
----Swift.(file)._NativeDictionary.Iterator.next()
let _this = this;
const $ifLet0, index_1
if(!((($ifLet0 = _this.iterator.next( {$setThis: $val => _this.iterator = $val}))||true) && $ifLet0.rawValue == 'some' && ((index_1 = $ifLet0[0])||true))) {
return Optional.none;
};
const key = _this.base.uncheckedKeyAt(index_1, {});
const value = _this.base.uncheckedValueAt(index_1, {});
return _injectIntoOptional({0: key, 1: value})
----Swift.(file)._NativeSet.capacity
let _this = this;
return _assumeNonNegative(_this._storage._capacity, {})
----Swift.(file)._NativeSet.hashTable
let _this = this;
return _this._storage._hashTable
----Swift.(file)._NativeSet.age
let _this = this;
return _this._storage._age
----Swift.(file)._NativeSet.invalidateIndices()
let _this = this;
Int32.infix_38_43_61({get: () => _this._storage._age, set: $val => _this._storage._age = $val}, 1, {})
----Swift.(file)._NativeSet.uncheckedElement(at:<<error type>>)
let _this = this;
let $defer = () => {
_fixLifetime(_this, {});
}
const $result = (() => {
try {;
return _this._elements.subscript$get(bucket.offset, {});}catch($error){$defer( {});throw $error}})();$defer( {});return $result
----Swift.(file)._NativeSet.uncheckedInitialize(at:<<error type>>,to:Element)
let _this = this;
UnsafeMutablePointer.infix_43(_this._elements, bucket.offset, {}).initializeTo(_element, {})
----Swift.(file)._NativeSet.hashValue(for:Element)
let _this = this;
return _element._rawHashValueSeed(_this._storage._seed, {})
----Swift.(file)._NativeSet.find(_:Element)
let _this = this;
return _this.findHashValue(_element, _this.hashValueFor(_element, {}), {})
----Swift.(file)._NativeSet.find(_:Element,hashValue:Int)
let _this = this;
const hashTable = _cloneStruct(_this.hashTable);
let bucket = _cloneStruct(hashTable.idealBucketForHashValue(hashValue, {}));
while(true){
if(!((hashTable._isOccupied(bucket, {})))) break
if(((_.arg0 = _this.uncheckedElementAt(bucket, {})).constructor.infix_61_61(_.arg0, _element, {}))) {
return {0: bucket, 1: true};
};
bucket = _cloneStruct(hashTable.bucketWrappedAfter(bucket, {}));
};
return {0: bucket, 1: false}
----Swift.(file)._NativeSet.resize(capacity:Int)
let _this = this;
const capacity = /*dot_syntax_base_ignored*/max(capacity, _this.capacity, {});
const result = _create(_NativeSet, 'init__RawSetStorage', /*derived_to_base_expr*/_SetStorage.resizeOriginalCapacityMove(_this._storage, capacity, true, {}), {});
if((Int.infix_62(_this.count, 0, {}))) {
{
let $bucket$generator = _cloneStruct(_this.hashTable.makeIterator( {}));
while(true) {
const $ifLet0, bucket_1;
if(!((($ifLet0 = $bucket$generator.next( {$setThis: $val => $bucket$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((bucket_1 = $ifLet0[0])||true))) break
const _element = UnsafeMutablePointer.infix_43(_this._elements, bucket_1.offset, {}).move( {});
result._unsafeInsertNew(_element, {});
}
};
_this._storage._hashTable.clear( {});
_this._storage._count = 0;
};
_this._storage = result._storage
----Swift.(file)._NativeSet.copyAndResize(capacity:Int)
let _this = this;
const capacity = /*dot_syntax_base_ignored*/max(capacity, _this.capacity, {});
const result = _create(_NativeSet, 'init__RawSetStorage', /*derived_to_base_expr*/_SetStorage.resizeOriginalCapacityMove(_this._storage, capacity, false, {}), {});
if((Int.infix_62(_this.count, 0, {}))) {
{
let $bucket$generator = _cloneStruct(_this.hashTable.makeIterator( {}));
while(true) {
const $ifLet0, bucket_1;
if(!((($ifLet0 = $bucket$generator.next( {$setThis: $val => $bucket$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((bucket_1 = $ifLet0[0])||true))) break
result._unsafeInsertNew(_this.uncheckedElementAt(bucket_1, {}), {});
}
};
};
_this._storage = result._storage
----Swift.(file)._NativeSet.copy()
let _this = this;
const newStorage = _SetStorage.copyOriginal(_this._storage, {});
const result = _create(_NativeSet, 'init__RawSetStorage', /*derived_to_base_expr*/newStorage, {});
if((Int.infix_62(_this.count, 0, {}))) {
result.hashTable.copyContentsOf(_this.hashTable, {});
result._storage._count = _this.count;
{
let $bucket$generator = _cloneStruct(_this.hashTable.makeIterator( {}));
while(true) {
const $ifLet0, bucket_1;
if(!((($ifLet0 = $bucket$generator.next( {$setThis: $val => $bucket$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((bucket_1 = $ifLet0[0])||true))) break
const _element = _this.uncheckedElementAt(bucket_1, {});
result.uncheckedInitializeAtTo(bucket_1, _element, {});
}
};
};
_this._storage = result._storage
----Swift.(file)._NativeSet.ensureUnique(isUnique:Bool,capacity:Int)
let _this = this;
if((_fastPath(Bool.infix_38_38(Int.infix_60_61(capacity, _this.capacity, {}), () => isUnique, {}), {}))) {
return false;
};
if((isUnique)) {
_this.resizeCapacity(capacity, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
return true;
};
if((Int.infix_60_61(capacity, _this.capacity, {}))) {
_this.copy( {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
return false;
};
_this.copyAndResizeCapacity(capacity, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
return true
----Swift.(file)._NativeSet.validatedBucket(for:<<error type>>)
let _this = this;
preconditionFileLine(() => Bool.infix_38_38(_this.hashTable.isOccupied(index.bucket, {}), () => Int32.infix_61_61(index.age, _this.age, {}), {}), () => "Attempting to access Set elements using an invalid index", '?3', '?3', {});
return index.bucket
----Swift.(file)._NativeSet.validatedBucket(for:Set<Element>.Index)
let _this = this;
if(!((index._isNative))) {
index._cocoaPath( {});
const cocoa = _cloneStruct(index._asCocoa);
if((Int32.infix_61_61(cocoa.age, _this.age, {}))) {
const _element = _forceBridgeFromObjectiveC(cocoa._element, ((function(){throw '!unclarifiedGeneric:Element'})()), {});
const $tuple = _this.find(_element, {})/*destructure_tuple_expr (**NULL EXPRESSION**), (**NULL EXPRESSION**)*/, bucket = $tuple && $tuple[0], found = $tuple && $tuple[1];
if((found)) {
return bucket;
};
};
preconditionFailureFileLine(() => "Attempting to access Set elements using an invalid index", '?3', '?3', {});
};
return _this.validatedBucketFor(index._asNative, {})
----Swift.(file)._NativeSet.startIndex
let _this = this;
const bucket = _cloneStruct(_this.hashTable.startBucket);
return _create(_NativeSet.Index, 'init_native_HashTableIndex', _create(_HashTable.Index, 'initBucket_HashTableBucketAgeInt32', bucket, _this.age, {}), {})
----Swift.(file)._NativeSet.endIndex
let _this = this;
const bucket = _cloneStruct(_this.hashTable.endBucket);
return _create(_NativeSet.Index, 'init_native_HashTableIndex', _create(_HashTable.Index, 'initBucket_HashTableBucketAgeInt32', bucket, _this.age, {}), {})
----Swift.(file)._NativeSet.index(after:_NativeSet<Element>.Index)
let _this = this;
const bucket = _cloneStruct(_this.validatedBucketFor(index._asNative, {}));
const next = _cloneStruct(_this.hashTable.occupiedBucketAfter(bucket, {}));
return _create(_NativeSet.Index, 'init_native_HashTableIndex', _create(_HashTable.Index, 'initBucket_HashTableBucketAgeInt32', next, _this.age, {}), {})
----Swift.(file)._NativeSet.index(for:Element)
let _this = this;
if((Int.infix_61_61(_this.count, 0, {}))) {
return Optional.none;
};
const $tuple = _this.find(_element, {})/*destructure_tuple_expr (**NULL EXPRESSION**), (**NULL EXPRESSION**)*/, bucket = $tuple && $tuple[0], found = $tuple && $tuple[1];
if(!((found))) {
return Optional.none;
};
return _injectIntoOptional(_create(_NativeSet.Index, 'init_native_HashTableIndex', _create(_HashTable.Index, 'initBucket_HashTableBucketAgeInt32', bucket, _this.age, {}), {}))
----Swift.(file)._NativeSet.count
let _this = this;
return _assumeNonNegative(_this._storage._count, {})
----Swift.(file)._NativeSet.contains(_:Element)
let _this = this;
if((Int.infix_61_61(_this.count, 0, {}))) {
return false;
};
return _this.find(member, {})["1"]
----Swift.(file)._NativeSet.element(at:_NativeSet<Element>.Index)
let _this = this;
const bucket = _cloneStruct(_this.validatedBucketFor(index, {}));
return _this.uncheckedElementAt(bucket, {})
----Swift.(file)._NativeSet.insertNew(_:Element,isUnique:Bool)
let _this = this;
_.discardAssignment = _this.ensureUniqueIsUniqueCapacity(isUnique, Int.infix_43(_this.count, 1, {}), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
_this._unsafeInsertNew(_element, {})
----Swift.(file)._NativeSet.insertNew(_:Element,at:<<error type>>,isUnique:Bool)
let _this = this;
let bucket_dupl = _cloneStruct(bucket);
const rehashed = _this.ensureUniqueIsUniqueCapacity(isUnique, Int.infix_43(_this.count, 1, {}), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
if((rehashed)) {
const $tuple = _this.find(_element, {})/*destructure_tuple_expr (**NULL EXPRESSION**), (**NULL EXPRESSION**)*/, b = $tuple && $tuple[0], f = $tuple && $tuple[1];
if((f)) {
ELEMENT_TYPE_OF_SET_VIOLATES_HASHABLE_REQUIREMENTS(((function(){throw '!unclarifiedGeneric:Element'})()), {});
};
bucket_dupl = _cloneStruct(b);
};
_this._unsafeInsertNewAt(_element, bucket_dupl, {})
----Swift.(file)._NativeSet.update(with:Element,isUnique:Bool)
let _this = this;
let $tuple = _this.find(_element, {})/*destructure_tuple_expr (**NULL EXPRESSION**), (**NULL EXPRESSION**)*/, bucket = $tuple && $tuple[0], found = $tuple && $tuple[1];
const rehashed = _this.ensureUniqueIsUniqueCapacity(isUnique, Int.infix_43(_this.count, (found ? 0 : 1), {}), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
if((rehashed)) {
const $tuple = _this.find(_element, {})/*destructure_tuple_expr (**NULL EXPRESSION**), (**NULL EXPRESSION**)*/, b = $tuple && $tuple[0], f = $tuple && $tuple[1];
if((Bool.infix_33_61(f, found, {}))) {
ELEMENT_TYPE_OF_SET_VIOLATES_HASHABLE_REQUIREMENTS(((function(){throw '!unclarifiedGeneric:Element'})()), {});
};
bucket = _cloneStruct(b);
};
if((found)) {
const old = UnsafeMutablePointer.infix_43(_this._elements, bucket.offset, {}).move( {});
_this.uncheckedInitializeAtTo(bucket, _element, {});
return _injectIntoOptional(old);
};
_this._unsafeInsertNewAt(_element, bucket, {});
return Optional.none
----Swift.(file)._NativeSet.isEqual(to:_NativeSet<Element>)
let _this = this;
if((infix_61_61_61(_injectIntoOptional(_this._storage), _injectIntoOptional(other._storage), {}))) {
return true;
};
if((Int.infix_33_61(_this.count, other.count, {}))) {
return false;
};
{
let $member$generator = _cloneStruct(_this.makeIterator( {}));
while(true) {
const $ifLet0, member_1;
if(!((($ifLet0 = $member$generator.next( {$setThis: $val => $member$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((member_1 = $ifLet0[0])||true))) break
if(!((other.find(member_1, {})["1"]))) {
return false;
};
}
};
return true
----Swift.(file)._NativeSet.isEqual(to:<<error type>>)
let _this = this;
if((Int.infix_33_61(_this.count, other.count, {}))) {
return false;
};
let $defer = () => {
_fixLifetime(_this, {});
}
const $result = (() => {
try {;
{
let $bucket$generator = _cloneStruct(_this.hashTable.makeIterator( {}));
while(true) {
const $ifLet0, bucket_1;
if(!((($ifLet0 = $bucket$generator.next( {$setThis: $val => $bucket$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((bucket_1 = $ifLet0[0])||true))) break
const key = _this.uncheckedElementAt(bucket_1, {});
const bridgedKey = _cloneStruct(_bridgeAnythingToObjectiveC(key, {}));
if(!((other.contains(bridgedKey, {})))) {
return false;
};
}
};
return true;}catch($error){$defer( {});throw $error}})();$defer( {});return $result
----Swift.(file)._NativeSet.hashValue(at:<<error type>>)
let _this = this;
return _this.hashValueFor(_this.uncheckedElementAt(bucket, {}), {})
----Swift.(file)._NativeSet.moveEntry(from:<<error type>>,to:<<error type>>)
let _this = this;
UnsafeMutablePointer.infix_43(_this._elements, target.offset, {}).moveInitializeFromCount(UnsafeMutablePointer.infix_43(_this._elements, source.offset, {}), 1, {})
----Swift.(file)._NativeSet.uncheckedRemove(at:<<error type>>,isUnique:Bool)
let _this = this;
const rehashed = _this.ensureUniqueIsUniqueCapacity(isUnique, _this.capacity, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
const old = UnsafeMutablePointer.infix_43(_this._elements, bucket.offset, {}).move( {});
_this._deleteAt(bucket, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
return old
----Swift.(file)._NativeSet.removeAll(isUnique:Bool)
let _this = this;
if(!((isUnique))) {
const scale = _this._storage._scale;
_this._storage = /*derived_to_base_expr*/_SetStorage.allocateScaleAgeSeed(scale, Optional.none, Optional.none, {});
return ;
};
{
let $bucket$generator = _cloneStruct(_this.hashTable.makeIterator( {}));
while(true) {
const $ifLet0, bucket_1;
if(!((($ifLet0 = $bucket$generator.next( {$setThis: $val => $bucket$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((bucket_1 = $ifLet0[0])||true))) break
UnsafeMutablePointer.infix_43(_this._elements, bucket_1.offset, {}).deinitializeCount(1, {});
}
};
_this.hashTable.clear( {});
_this._storage._count = 0;
_this.invalidateIndices( {})
----Swift.(file)._NativeSet.makeIterator()
let _this = this;
return _create(_NativeSet.Iterator, 'init_NativeSet', _this, {})
----Swift.(file)._NativeSet.Iterator.next()
let _this = this;
const $ifLet0, index_1
if(!((($ifLet0 = _this.iterator.next( {$setThis: $val => _this.iterator = $val}))||true) && $ifLet0.rawValue == 'some' && ((index_1 = $ifLet0[0])||true))) {
return Optional.none;
};
return _injectIntoOptional(_this.base.uncheckedElementAt(index_1, {}))
----Swift.(file)._SwiftNewtypeWrapper.hashValue
let _this = this;
return _this.rawValue.hashValue
----Swift.(file)._SwiftNewtypeWrapper.hash(into:Hasher)
let _this = this;
let hasher = hasher$inout.get()
const $result = (() => {
hasher.combine(_this.rawValue, {$setThis: $val => hasher = $val});})()
hasher$inout.set(hasher)
return $result
----Swift.(file)._StringGuts.foreignHasNormalizationBoundary(before:String.Index)
let _this = this;
const offset = index.encodedOffset;
if((Bool.infix_124_124(Int.infix_61_61(offset, 0, {}), () => Int.infix_61_61(offset, _this.count, {}), {}))) {
return true;
};
const scalar = _cloneStruct(_this.foreignErrorCorrectedScalarStartingAt(index, {})["0"]);
return scalar._hasNormalizationBoundaryBefore
----Swift.(file).UnsafeBufferPointer.hasNormalizationBoundary(before:Int)
let _this = this;
if((Bool.infix_124_124(Int.infix_61_61(index, 0, {}), () => Int.infix_61_61(index, _this.count, {}), {}))) {
return true;
};
assertFileLine(() => Bool.prefix_33(_isContinuation(_this.subscript_unchecked$get(index, {}), {}), {}), () => String()/*!default_value*/, '?3', '?3', {});
if((UInt8.infix_60(_this.subscript_unchecked$get(index, {}), 0xCC, {}))) {
return true;
};
const cu = _cloneStruct(_decodeScalarStartingAt(_this, index, {})["0"]);
return cu._hasNormalizationBoundaryBefore
----Swift.(file).ObjectIdentifier.debugDescription
let _this = this;
return (("ObjectIdentifier(") + (_rawPointerToString(_this._value, {})) + (")"))
----Swift.(file).ObjectIdentifier.<infix(_:ObjectIdentifier,_:ObjectIdentifier)
let _this = this;
return UInt.infix_60(_create(UInt, 'initBitPatternObjectIdentifier', lhs, {}), _create(UInt, 'initBitPatternObjectIdentifier', rhs, {}), {})
----Swift.(file).Int.init(bitPattern:ObjectIdentifier)
let _this = this;
_this.initBitPatternUInt(_create(UInt, 'initBitPatternObjectIdentifier', objectID, {}), {});
return
----Swift.(file).OptionSet.union(_:Self)
let _this = this;
let r = _create(_this.constructor, 'initRawValue', _this.rawValue, {});
r.formUnion(other, {$setThis: $val => r = $val});
return r
----Swift.(file).OptionSet.intersection(_:Self)
let _this = this;
let r = _create(_this.constructor, 'initRawValue', _this.rawValue, {});
r.formIntersection(other, {$setThis: $val => r = $val});
return r
----Swift.(file).OptionSet.symmetricDifference(_:Self)
let _this = this;
let r = _create(_this.constructor, 'initRawValue', _this.rawValue, {});
r.formSymmetricDifference(other, {$setThis: $val => r = $val});
return r
----Swift.(file).OptionSet.contains(_:Self)
let _this = this;
return _this.isSupersetOf(member, {})
----Swift.(file).OptionSet.insert(_:Self.Element)
let _this = this;
const oldMember = _this.intersection(newMember, {});
const shouldInsert = (_.arg0 = oldMember).constructor.infix_33_61(_.arg0, newMember, {});
const result = {0: shouldInsert, 1: (shouldInsert ? newMember : oldMember)};
if((shouldInsert)) {
_this.formUnion(newMember, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
};
return result
----Swift.(file).OptionSet.remove(_:Self.Element)
let _this = this;
const r = (_this.isSupersetOf(member, {}) ? _create(Optional, 'init', member, {}) : Optional.none);
_this.subtract(member, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
return r
----Swift.(file).OptionSet.update(with:Self.Element)
let _this = this;
const r = _this.intersection(newMember, {});
_this.formUnion(newMember, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
return (r.isEmpty ? Optional.none : _injectIntoOptional(r))
----Swift.(file).OptionSet.init()
let _this = this;
_this.initRawValue(0, {});
return
----Swift.(file).OptionSet.formUnion(_:Self)
let _this = this;
$info.$setThis(_this = _cloneStruct(_create(_this.constructor, 'initRawValue', ((function(){throw '!unclarifiedGeneric:Self.RawValue'})()).infix_124(_this.rawValue, other.rawValue, {}), {})))
----Swift.(file).OptionSet.formIntersection(_:Self)
let _this = this;
$info.$setThis(_this = _cloneStruct(_create(_this.constructor, 'initRawValue', ((function(){throw '!unclarifiedGeneric:Self.RawValue'})()).infix_38(_this.rawValue, other.rawValue, {}), {})))
----Swift.(file).OptionSet.formSymmetricDifference(_:Self)
let _this = this;
$info.$setThis(_this = _cloneStruct(_create(_this.constructor, 'initRawValue', ((function(){throw '!unclarifiedGeneric:Self.RawValue'})()).infix_94(_this.rawValue, other.rawValue, {}), {})))
----Swift.(file).Optional.init(_:Wrapped)
let _this = this;
$info.$setThis(_this = _cloneStruct(Optional.some(some, {})));
return
----Swift.(file).Optional.map(_:(Wrapped) throws -> U)
let _this = this;
const $match = _this
if((($match.rawValue == Optional.some().rawValue))) {
const y = $match[0]
return Optional.some(transform(y, {}), {});
}
else if((($match.rawValue == Optional.none.rawValue))) {
return Optional.none;
}
----Swift.(file).Optional.flatMap(_:(Wrapped) throws -> U?)
let _this = this;
const $match = _this
if((($match.rawValue == Optional.some().rawValue))) {
const y = $match[0]
return transform(y, {});
}
else if((($match.rawValue == Optional.none.rawValue))) {
return Optional.none;
}
----Swift.(file).Optional.init(nilLiteral:())
let _this = this;
$info.$setThis(_this = _cloneStruct(Optional.none));
return
----Swift.(file).Optional.unsafelyUnwrapped
let _this = this;
const $ifLet0, x_1
if((($ifLet0 = _this)||true) && $ifLet0.rawValue == 'some' && ((x_1 = $ifLet0[0])||true)) {
return x_1;
};
preconditionFailureFileLine(() => "unsafelyUnwrapped of nil optional", '?3', '?3', {})
----Swift.(file).Optional.debugDescription
let _this = this;
const $match = _this
if((($match.rawValue == Optional.some().rawValue))) {
const value = $match[0]
let result = "Optional(";
debugPrintSeparatorTerminatorTo(_create(Array, 'initBuffer', [value], {}), " "/*!default_value*/, "", {get: () => result, set: $val => result = $val}, {});
String.infix_43_61({get: () => result, set: $val => result = $val}, ")", {});
return result;
}
else if((($match.rawValue == Optional.none.rawValue))) {
return "nil";
}
----Swift.(file).Optional.customMirror
let _this = this;
const $match = _this
if((($match.rawValue == Optional.some().rawValue))) {
const value = $match[0]
return _create(Mirror, 'initChildrenKeyValuePairsDisplayStyleOptionalAncestorRepresentationMirrorAncestorRepresentation', _this, new Map([["some", value]]), _injectIntoOptional(Mirror.DisplayStyle.optional), .generated/*!default_value*/, {});
}
else if((($match.rawValue == Optional.none.rawValue))) {
return _create(Mirror, 'initChildrenKeyValuePairsDisplayStyleOptionalAncestorRepresentationMirrorAncestorRepresentation', _this, new Map([]), _injectIntoOptional(Mirror.DisplayStyle.optional), .generated/*!default_value*/, {});
}
----Swift.(file).Optional.==infix(_:Wrapped?,_:Wrapped?)
let _this = this;
const $match = {0: lhs, 1: rhs}
if((($match[0].rawValue == 'some' && $match[1].rawValue == 'some'))) {
const l = $match[0][0]
const r = $match[1][0]
return (_.arg0 = l).constructor.infix_61_61(_.arg0, r, {});
}
else if((($match[0].rawValue == Optional.none.rawValue && $match[1].rawValue == Optional.none.rawValue))) {
return true;
}
else if(((true))) {
return false;
}
----Swift.(file).Optional.hash(into:Hasher)
let _this = this;
let hasher = hasher$inout.get()
const $result = (() => {
const $match = _this
if((($match.rawValue == Optional.none.rawValue))) {
hasher.combine(0, {$setThis: $val => hasher = $val});
}
else if((($match.rawValue == Optional.some().rawValue))) {
const wrapped = $match[0]
hasher.combine(1, {$setThis: $val => hasher = $val});
hasher.combine(wrapped, {$setThis: $val => hasher = $val});
};})()
hasher$inout.set(hasher)
return $result
----Swift.(file).Optional.~=infix(_:_OptionalNilComparisonType,_:Wrapped?)
let _this = this;
const $match = rhs
if((($match.rawValue == Optional.some().rawValue))) {
return false;
}
else if((($match.rawValue == Optional.none.rawValue))) {
return true;
}
----Swift.(file).Optional.==infix(_:Wrapped?,_:_OptionalNilComparisonType)
let _this = this;
const $match = lhs
if((($match.rawValue == Optional.some().rawValue))) {
return false;
}
else if((($match.rawValue == Optional.none.rawValue))) {
return true;
}
----Swift.(file).Optional.!=infix(_:Wrapped?,_:_OptionalNilComparisonType)
let _this = this;
const $match = lhs
if((($match.rawValue == Optional.some().rawValue))) {
return true;
}
else if((($match.rawValue == Optional.none.rawValue))) {
return false;
}
----Swift.(file).Optional.==infix(_:_OptionalNilComparisonType,_:Wrapped?)
let _this = this;
const $match = rhs
if((($match.rawValue == Optional.some().rawValue))) {
return false;
}
else if((($match.rawValue == Optional.none.rawValue))) {
return true;
}
----Swift.(file).Optional.!=infix(_:_OptionalNilComparisonType,_:Wrapped?)
let _this = this;
const $match = rhs
if((($match.rawValue == Optional.some().rawValue))) {
return true;
}
else if((($match.rawValue == Optional.none.rawValue))) {
return false;
}
----Swift.(file).??infix(_:T?,_:() throws -> T)
const $match = optional
if((($match.rawValue == Optional.some().rawValue))) {
const value = $match[0]
return value;
}
else if((($match.rawValue == Optional.none.rawValue))) {
return defaultValue( {});
}
----Swift.(file).??infix(_:T?,_:() throws -> T?)
const $match = optional
if((($match.rawValue == Optional.some().rawValue))) {
const value = $match[0]
return _injectIntoOptional(value);
}
else if((($match.rawValue == Optional.none.rawValue))) {
return defaultValue( {});
}
----Swift.(file).String.write(_:String)
let _this = this;
String.infix_43_61({get: () => _this, set: $val => $info.$setThis(_this = _cloneStruct($val))}, other, {})
----Swift.(file).String.write(to:Target)
let _this = this;
let target = target$inout.get()
const $result = (() => {
target.write(_this, {$setThis: $val => target = $val});})()
target$inout.set(target)
return $result
----Swift.(file).Character.write(to:Target)
let _this = this;
let target = target$inout.get()
const $result = (() => {
target.write(_create(String, 'initCharacter', _this, {}), {$setThis: $val => target = $val});})()
target$inout.set(target)
return $result
----Swift.(file).Unicode.Scalar.write(to:Target)
let _this = this;
let target = target$inout.get()
const $result = (() => {
target.write(_create(String, 'initCharacter', _create(Character, 'initUnicodeScalar', _this, {}), {}), {$setThis: $val => target = $val});})()
target$inout.set(target)
return $result
----Swift.(file)._Pointer.init(_:OpaquePointer)
let _this = this;
_this.initRawPointer(from._rawValue, {});
return
----Swift.(file)._Pointer.init(_:OpaquePointer?)
let _this = this;
const $ifLet0, unwrapped_1
if(!((($ifLet0 = from)||true) && $ifLet0.rawValue == 'some' && ((unwrapped_1 = $ifLet0[0])||true))) {
return (this.$failed = true);
};
_this.initOpaquePointer(unwrapped_1, {});
return
----Swift.(file)._Pointer.init(_:Self)
let _this = this;
_this.initRawPointer(other._rawValue, {});
return
----Swift.(file)._Pointer.init(_:Self?)
let _this = this;
const $ifLet0, unwrapped_1
if(!((($ifLet0 = other)||true) && $ifLet0.rawValue == 'some' && ((unwrapped_1 = $ifLet0[0])||true))) {
return (this.$failed = true);
};
_this.initRawPointer(unwrapped_1._rawValue, {});
return
----Swift.(file)._Pointer.successor()
let _this = this;
return _this.advancedBy(1, {})
----Swift.(file)._Pointer.predecessor()
let _this = this;
return _this.advancedBy(-1, {})
----Swift.(file)._Pointer.hash(into:Hasher)
let _this = this;
let hasher = hasher$inout.get()
const $result = (() => {
hasher.combine(_create(UInt, 'initBitPatternOptional', _injectIntoOptional(_this), {}), {$setThis: $val => hasher = $val});})()
hasher$inout.set(hasher)
return $result
----Swift.(file)._Pointer.debugDescription
let _this = this;
return _rawPointerToString(_this._rawValue, {})
----Swift.(file).Strideable.+infix(_:Self,_:Self.Stride)
let _this = this;
return lhs.advancedBy(rhs, {})
----Swift.(file).Strideable.+infix(_:Self.Stride,_:Self)
let _this = this;
return rhs.advancedBy(lhs, {})
----Swift.(file).Strideable.-infix(_:Self,_:Self.Stride)
let _this = this;
return lhs.advancedBy(((function(){throw '!unclarifiedGeneric:Self.Stride'})()).prefix_45(rhs, {}), {})
----Swift.(file).Strideable.-infix(_:Self,_:Self)
let _this = this;
return rhs.distanceTo(lhs, {})
----Swift.(file).Strideable.+=infix(_:Self,_:Self.Stride)
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs = lhs.advancedBy(rhs, {});})()
lhs$inout.set(lhs)
return $result
----Swift.(file).Strideable.-=infix(_:Self,_:Self.Stride)
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs = lhs.advancedBy(((function(){throw '!unclarifiedGeneric:Self.Stride'})()).prefix_45(rhs, {}), {});})()
lhs$inout.set(lhs)
return $result
----Swift.(file).Never.<infix(_:Never,_:Never)
let _this = this
----Swift.(file).Void
const Void = '?tuple_type
----Swift.(file).~=infix(_:T,_:T)
return (_.arg0 = a).constructor.infix_61_61(_.arg0, b, {})
----Swift.(file).LazyPrefixWhileSequence.Iterator.next()
let _this = this;
const $ifLet0, nextElement_1
if((Bool.prefix_33(_this._predicateHasFailed, {})) && (($ifLet0 = _this._base.next( {$setThis: $val => _this._base = $val}))||true) && $ifLet0.rawValue == 'some' && ((nextElement_1 = $ifLet0[0])||true)) {
if((_this._predicate(nextElement_1, {}))) {
return _injectIntoOptional(nextElement_1);
}
else {
_this._predicateHasFailed = true;
};
};
return Optional.none
----Swift.(file).LazyPrefixWhileSequence.makeIterator()
let _this = this;
return _create(LazyPrefixWhileSequence.Iterator, 'init_basePredicatefunction_type', _this._base.makeIterator( {}), _this._predicate, {})
----Swift.(file).LazySequenceProtocol.prefix(while:(Self.Elements.Element) -> Bool)
let _this = this;
return _create(LazyPrefixWhileSequence, 'init_basePredicatefunction_type', _this._elements, predicate, {})
----Swift.(file).LazyPrefixWhileCollection
const LazyPrefixWhileCollection = LazyPrefixWhileSequenc
----Swift.(file).LazyPrefixWhileSequence.Index.==infix(_:LazyPrefixWhileCollection<Base>.Index,_:LazyPrefixWhileCollection<Base>.Index)
let _this = this;
const $match = {0: lhs._value, 1: rhs._value}
if((($match[0].rawValue == LazyPrefixWhileSequence._IndexRepresentation.index().rawValue && $match[1].rawValue == LazyPrefixWhileSequence._IndexRepresentation.index().rawValue))) {
const l = $match[0][0]
const r = $match[1][0]
return ((function(){throw '!unclarifiedGeneric:Base.Index'})()).infix_61_61(l, r, {});
}
else if((($match[0].rawValue == LazyPrefixWhileSequence._IndexRepresentation.pastEnd.rawValue && $match[1].rawValue == LazyPrefixWhileSequence._IndexRepresentation.pastEnd.rawValue))) {
return true;
}
else if((($match[0].rawValue == LazyPrefixWhileSequence._IndexRepresentation.pastEnd.rawValue && $match[1].rawValue == LazyPrefixWhileSequence._IndexRepresentation.index().rawValue) || ($match[0].rawValue == LazyPrefixWhileSequence._IndexRepresentation.index().rawValue && $match[1].rawValue == LazyPrefixWhileSequence._IndexRepresentation.pastEnd.rawValue))) {
return false;
}
----Swift.(file).LazyPrefixWhileSequence.Index.<infix(_:LazyPrefixWhileCollection<Base>.Index,_:LazyPrefixWhileCollection<Base>.Index)
let _this = this;
const $match = {0: lhs._value, 1: rhs._value}
if((($match[0].rawValue == LazyPrefixWhileSequence._IndexRepresentation.index().rawValue && $match[1].rawValue == LazyPrefixWhileSequence._IndexRepresentation.index().rawValue))) {
const l = $match[0][0]
const r = $match[1][0]
return ((function(){throw '!unclarifiedGeneric:Base.Index'})()).infix_60(l, r, {});
}
else if((($match[0].rawValue == LazyPrefixWhileSequence._IndexRepresentation.index().rawValue && $match[1].rawValue == LazyPrefixWhileSequence._IndexRepresentation.pastEnd.rawValue))) {
return true;
}
else if((($match[0].rawValue == LazyPrefixWhileSequence._IndexRepresentation.pastEnd.rawValue))) {
return false;
}
----Swift.(file).LazyPrefixWhileSequence.Index.hash(into:Hasher)
let _this = this;
let hasher = hasher$inout.get()
const $result = (() => {
const $match = _this._value
if((($match.rawValue == LazyPrefixWhileSequence._IndexRepresentation.index().rawValue))) {
const value = $match[0]
hasher.combine(value, {$setThis: $val => hasher = $val});
}
else if((($match.rawValue == LazyPrefixWhileSequence._IndexRepresentation.pastEnd.rawValue))) {
hasher.combine(Int.max, {$setThis: $val => hasher = $val});
};})()
hasher$inout.set(hasher)
return $result
----Swift.(file).LazyPrefixWhileCollection.SubSequence

----Swift.(file).LazyPrefixWhileCollection.startIndex
let _this = this;
return _create(LazyPrefixWhileSequence.Index, 'init', _this._base.startIndex, {})
----Swift.(file).LazyPrefixWhileCollection.endIndex
let _this = this;
const $ifLet0, first_1
if((($ifLet0 = _this._base.first)||true) && $ifLet0.rawValue == 'some' && ((first_1 = $ifLet0[0])||true) && (_this._predicate(first_1, {}))) {
return _create(LazyPrefixWhileSequence.Index, 'initEndOf', _this._base, {});
};
return _this.startIndex
----Swift.(file).LazyPrefixWhileCollection.index(after:LazyPrefixWhileSequence<Base>.Index)
let _this = this;
preconditionFileLine(() => LazyPrefixWhileSequence.Index.infix_33_61(i, _this.endIndex, {}), () => "Can't advance past endIndex", '?3', '?3', {});
const $ifLet0, i_1
if(!((($ifLet0 = i._value)||true) && $ifLet0.rawValue == LazyPrefixWhileSequence._IndexRepresentation.index().rawValue && ((i_1 = $ifLet0[0])||true))) {
preconditionFailureFileLine(() => "Invalid index passed to index(after:)", '?3', '?3', {});
};
const nextIndex = _this._base.indexAfter(i_1, {});
if(!((Bool.infix_38_38((_.arg0 = nextIndex).constructor.infix_33_61(_.arg0, _this._base.endIndex, {}), () => _this._predicate(_this._base.subscript$get(nextIndex, {}), {}), {})))) {
return _create(LazyPrefixWhileSequence.Index, 'initEndOf', _this._base, {});
};
return _create(LazyPrefixWhileSequence.Index, 'init', nextIndex, {})
----Swift.(file).LazyPrefixWhileCollection.subscript(_:LazyPrefixWhileSequence<Base>.Index)
let _this = this;
const $match = position._value
if((($match.rawValue == LazyPrefixWhileSequence._IndexRepresentation.index().rawValue))) {
const i = $match[0]
return _this._base.subscript$get(i, {});
}
else if((($match.rawValue == LazyPrefixWhileSequence._IndexRepresentation.pastEnd.rawValue))) {
preconditionFailureFileLine(() => "Index out of range", '?3', '?3', {});
}
----Swift.(file).LazyPrefixWhileCollection.index(before:LazyPrefixWhileSequence<Base>.Index)
let _this = this;
const $match = i._value
if((($match.rawValue == LazyPrefixWhileSequence._IndexRepresentation.index().rawValue))) {
const i = $match[0]
preconditionFileLine(() => (_.arg0 = _this._base.startIndex).constructor.infix_33_61(i, _.arg0, {}), () => "Can't move before startIndex", '?3', '?3', {});
return _create(LazyPrefixWhileSequence.Index, 'init', _this._base.indexBefore(i, {}), {});
}
else if((($match.rawValue == LazyPrefixWhileSequence._IndexRepresentation.pastEnd.rawValue))) {
let result = _this._base.startIndex;
while(true){
if(!((true))) break
const next = _this._base.indexAfter(result, {});
if((Bool.infix_124_124((_.arg1 = next).constructor.infix_61_61(_.arg1, _this._base.endIndex, {}), () => Bool.prefix_33(_this._predicate(_this._base.subscript$get(next, {}), {}), {}), {}))) {
break;
};
result = next;
};
return _create(LazyPrefixWhileSequence.Index, 'init', result, {});
}
----Swift.(file).print(_:[Any],separator:String,terminator:String)
const $ifLet0, hook_1
if((($ifLet0 = _playgroundPrintHook)||true) && $ifLet0.rawValue == 'some' && ((hook_1 = $ifLet0[0])||true)) {
let output = _create(_TeeStream, 'initLeftRight', "", _create(_Stdout, 'init', {}), {});
_printSeparatorTerminatorTo(items, separator, terminator, {get: () => output, set: $val => output = $val}, {});
hook_1(output.left, {});
}
else {
let output = _create(_Stdout, 'init', {});
_printSeparatorTerminatorTo(items, separator, terminator, {get: () => output, set: $val => output = $val}, {});
}
----Swift.(file).debugPrint(_:[Any],separator:String,terminator:String)
const $ifLet0, hook_1
if((($ifLet0 = _playgroundPrintHook)||true) && $ifLet0.rawValue == 'some' && ((hook_1 = $ifLet0[0])||true)) {
let output = _create(_TeeStream, 'initLeftRight', "", _create(_Stdout, 'init', {}), {});
_debugPrintSeparatorTerminatorTo(items, separator, terminator, {get: () => output, set: $val => output = $val}, {});
hook_1(output.left, {});
}
else {
let output = _create(_Stdout, 'init', {});
_debugPrintSeparatorTerminatorTo(items, separator, terminator, {get: () => output, set: $val => output = $val}, {});
}
----Swift.(file).print(_:[Any],separator:String,terminator:String,to:Target)
let output = output$inout.get()
const $result = (() => {
_printSeparatorTerminatorTo(items, separator, terminator, {get: () => output, set: $val => output = $val}, {});})()
output$inout.set(output)
return $result
----Swift.(file).debugPrint(_:[Any],separator:String,terminator:String,to:Target)
let output = output$inout.get()
const $result = (() => {
_debugPrintSeparatorTerminatorTo(items, separator, terminator, {get: () => output, set: $val => output = $val}, {});})()
output$inout.set(output)
return $result
----Swift.(file).RandomNumberGenerator.next()
let _this = this;
return ((function(){throw '!unclarifiedGeneric:T'})())._randomUsing({get: () => _this, set: $val => $info.$setThis(_this = _cloneStruct($val))}, {})
----Swift.(file).RandomNumberGenerator.next(upperBound:T)
let _this = this;
preconditionFileLine(() => ((function(){throw '!unclarifiedGeneric:T'})()).infix_33_61(upperBound, 0, {}), () => "upperBound cannot be zero.", '?3', '?3', {});
const tmp = ((function(){throw '!unclarifiedGeneric:T'})()).infix_43(((function(){throw '!unclarifiedGeneric:T'})()).infix_37(((function(){throw '!unclarifiedGeneric:T'})()).max, upperBound, {}), 1, {});
const range = (((function(){throw '!unclarifiedGeneric:T'})()).infix_61_61(tmp, upperBound, {}) ? 0 : tmp);
let random = 0;
do {
random = _this.next( {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
} while(((function(){throw '!unclarifiedGeneric:T'})()).infix_60(random, range, {}));
return ((function(){throw '!unclarifiedGeneric:T'})()).infix_37(random, upperBound, {})
----Swift.(file).SystemRandomNumberGenerator.init()
let _this = this;
return
----Swift.(file).RandomAccessCollection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)
let _this = this;
const l = _this.distanceFromTo(i, limit, {});
if(((Int.infix_62(distance, 0, {}) ? Bool.infix_38_38(Int.infix_62_61(l, 0, {}), () => Int.infix_60(l, distance, {}), {}) : Bool.infix_38_38(Int.infix_60_61(l, 0, {}), () => Int.infix_60(distance, l, {}), {})))) {
return Optional.none;
};
return _injectIntoOptional(_this.indexOffsetBy(i, distance, {}))
----Swift.(file).RandomAccessCollection.indices
let _this = this;
return (_.arg0 = _this.startIndex).constructor.infix_46_46_60(_.arg0, _this.endIndex, {})
----Swift.(file).RangeExpression.~=infix(_:Self,_:Self.Bound)
let _this = this;
return pattern.contains(value, {})
----Swift.(file).Range.contains(_:Bound)
let _this = this;
return Bool.infix_38_38((_.arg0 = _this.lowerBound).constructor.infix_60_61(_.arg0, _element, {}), () => (_.arg1 = _element).constructor.infix_60(_.arg1, _this.upperBound, {}), {})
----Swift.(file).Range.isEmpty
let _this = this;
return (_.arg0 = _this.lowerBound).constructor.infix_61_61(_.arg0, _this.upperBound, {})
----Swift.(file).Range.Iterator

----Swift.(file).Range.Indices

----Swift.(file).Range.SubSequence

----Swift.(file).Range.startIndex
let _this = this;
return _this.lowerBound
----Swift.(file).Range.endIndex
let _this = this;
return _this.upperBound
----Swift.(file).Range.index(after:Range<Bound>.Index)
let _this = this;
return i.advancedBy(1, {})
----Swift.(file).Range.index(before:Range<Bound>.Index)
let _this = this;
preconditionFileLine(() => (_.arg0 = i).constructor.infix_62(_.arg0, _this.lowerBound, {}), () => String()/*!default_value*/, '?3', '?3', {});
preconditionFileLine(() => (_.arg1 = i).constructor.infix_60_61(_.arg1, _this.upperBound, {}), () => String()/*!default_value*/, '?3', '?3', {});
return i.advancedBy(-1, {})
----Swift.(file).Range.index(_:Range<Bound>.Index,offsetBy:Int)
let _this = this;
const r = i.advancedBy(numericCast(n, {T: Int, U: ((function(){throw '!unclarifiedGeneric:Bound.Stride'})())}), {});
preconditionFileLine(() => (_.arg0 = r).constructor.infix_62_61(_.arg0, _this.lowerBound, {}), () => String()/*!default_value*/, '?3', '?3', {});
preconditionFileLine(() => (_.arg1 = r).constructor.infix_60_61(_.arg1, _this.upperBound, {}), () => String()/*!default_value*/, '?3', '?3', {});
return r
----Swift.(file).Range.distance(from:Range<Bound>.Index,to:Range<Bound>.Index)
let _this = this;
return numericCast(start.distanceTo(end, {}), {T: ((function(){throw '!unclarifiedGeneric:Bound.Stride'})()), U: Int})
----Swift.(file).Range.subscript(_:Range<Range<Bound>.Index>)
let _this = this;
return bounds
----Swift.(file).Range.indices
let _this = this;
return _this
----Swift.(file).Range.subscript(_:Range<Bound>.Index)
let _this = this;
preconditionFileLine(() => _this.contains(position, {}), () => "Index out of range", '?3', '?3', {});
return position
----Swift.(file).Range.init(_:ClosedRange<Bound>)
let _this = this;
const upperBound = other.upperBound.advancedBy(1, {});
_this.initUncheckedBoundstuple_type({0: other.lowerBound, 1: upperBound}, {});
return
----Swift.(file).Range.relative(to:C)
let _this = this;
return _create(Range, 'initUncheckedBoundstuple_type', {0: _this.lowerBound, 1: _this.upperBound}, {})
----Swift.(file).Range.clamped(to:Range<Bound>)
let _this = this;
const lower = ((_.arg0 = limits.lowerBound).constructor.infix_62(_.arg0, _this.lowerBound, {}) ? limits.lowerBound : ((_.arg1 = limits.upperBound).constructor.infix_60(_.arg1, _this.lowerBound, {}) ? limits.upperBound : _this.lowerBound));
const upper = ((_.arg2 = limits.upperBound).constructor.infix_60(_.arg2, _this.upperBound, {}) ? limits.upperBound : ((_.arg3 = limits.lowerBound).constructor.infix_62(_.arg3, _this.upperBound, {}) ? limits.lowerBound : _this.upperBound));
return _create(Range, 'initUncheckedBoundstuple_type', {0: lower, 1: upper}, {})
----Swift.(file).Range.description
let _this = this;
return (("") + (_this.lowerBound) + ("..<") + (_this.upperBound) + (""))
----Swift.(file).Range.debugDescription
let _this = this;
return String.infix_43((("Range(") + (_create(String, 'initReflecting', _this.lowerBound, {})) + ("")), (("..<") + (_create(String, 'initReflecting', _this.upperBound, {})) + (")")), {})
----Swift.(file).Range.customMirror
let _this = this;
return _create(Mirror, 'initChildrenKeyValuePairsDisplayStyleOptionalAncestorRepresentationMirrorAncestorRepresentation', _this, new Map([["lowerBound", _this.lowerBound], ["upperBound", _this.upperBound]]), nil/*!default_value*/, .generated/*!default_value*/, {})
----Swift.(file).Range.==infix(_:Range<Bound>,_:Range<Bound>)
let _this = this;
return Bool.infix_38_38((_.arg0 = lhs.lowerBound).constructor.infix_61_61(_.arg0, rhs.lowerBound, {}), () => (_.arg1 = lhs.upperBound).constructor.infix_61_61(_.arg1, rhs.upperBound, {}), {})
----Swift.(file).Range.hash(into:Hasher)
let _this = this;
let hasher = hasher$inout.get()
const $result = (() => {
hasher.combine(_this.lowerBound, {$setThis: $val => hasher = $val});
hasher.combine(_this.upperBound, {$setThis: $val => hasher = $val});})()
hasher$inout.set(hasher)
return $result
----Swift.(file).Range.init(from:Decoder)
let _this = this;
let container = _cloneStruct(decoder.unkeyedContainer( {}));
const lowerBound = container.decode(((function(){throw '!unclarifiedGeneric:Bound'})()), {$setThis: $val => container = $val});
const upperBound = container.decode(((function(){throw '!unclarifiedGeneric:Bound'})()), {$setThis: $val => container = $val});
if(!(((_.arg0 = lowerBound).constructor.infix_60_61(_.arg0, upperBound, {})))) {
throw DecodingError.dataCorrupted(_create(DecodingError.Context, 'initCodingPathArrayDebugDescriptionStringUnderlyingErrorOptional', decoder.codingPath, (("Cannot initialize ") + (Range) + (" with a lowerBound (") + (lowerBound) + (") greater than upperBound (") + (upperBound) + (")")), nil/*!default_value*/, {}), {});
};
_this.initUncheckedBoundstuple_type({0: lowerBound, 1: upperBound}, {});
return
----Swift.(file).Range.encode(to:Encoder)
let _this = this;
let container = _cloneStruct(encoder.unkeyedContainer( {}));
container.encode(_this.lowerBound, {$setThis: $val => container = $val});
container.encode(_this.upperBound, {$setThis: $val => container = $val})
----Swift.(file).PartialRangeUpTo.relative(to:C)
let _this = this;
return (_.arg0 = collection.startIndex).constructor.infix_46_46_60(_.arg0, _this.upperBound, {})
----Swift.(file).PartialRangeUpTo.contains(_:Bound)
let _this = this;
return (_.arg0 = _element).constructor.infix_60(_.arg0, _this.upperBound, {})
----Swift.(file).PartialRangeUpTo.init(from:Decoder)
let _this = this;
let container = _cloneStruct(decoder.unkeyedContainer( {}));
_this.init(container.decode(((function(){throw '!unclarifiedGeneric:Bound'})()), {$setThis: $val => container = $val}), {});
return
----Swift.(file).PartialRangeUpTo.encode(to:Encoder)
let _this = this;
let container = _cloneStruct(encoder.unkeyedContainer( {}));
container.encode(_this.upperBound, {$setThis: $val => container = $val})
----Swift.(file).PartialRangeThrough.relative(to:C)
let _this = this;
return (_.arg0 = collection.startIndex).constructor.infix_46_46_60(_.arg0, collection.indexAfter(_this.upperBound, {}), {})
----Swift.(file).PartialRangeThrough.contains(_:Bound)
let _this = this;
return (_.arg0 = _element).constructor.infix_60_61(_.arg0, _this.upperBound, {})
----Swift.(file).PartialRangeThrough.init(from:Decoder)
let _this = this;
let container = _cloneStruct(decoder.unkeyedContainer( {}));
_this.init(container.decode(((function(){throw '!unclarifiedGeneric:Bound'})()), {$setThis: $val => container = $val}), {});
return
----Swift.(file).PartialRangeThrough.encode(to:Encoder)
let _this = this;
let container = _cloneStruct(encoder.unkeyedContainer( {}));
container.encode(_this.upperBound, {$setThis: $val => container = $val})
----Swift.(file).PartialRangeFrom.relative(to:C)
let _this = this;
return (_.arg0 = _this.lowerBound).constructor.infix_46_46_60(_.arg0, collection.endIndex, {})
----Swift.(file).PartialRangeFrom.contains(_:Bound)
let _this = this;
return (_.arg0 = _this.lowerBound).constructor.infix_60_61(_.arg0, _element, {})
----Swift.(file).PartialRangeFrom.Iterator.init(_current:Bound)
let _this = this;
_this._current = _current;
return
----Swift.(file).PartialRangeFrom.Iterator.next()
let _this = this;
let $defer = () => {
_this._current = _this._current.advancedBy(1, {});
}
const $result = (() => {
try {;
return _injectIntoOptional(_this._current);}catch($error){$defer( {});throw $error}})();$defer( {});return $result
----Swift.(file).PartialRangeFrom.makeIterator()
let _this = this;
return _create(PartialRangeFrom.Iterator, 'init_current', _this.lowerBound, {})
----Swift.(file).PartialRangeFrom.init(from:Decoder)
let _this = this;
let container = _cloneStruct(decoder.unkeyedContainer( {}));
_this.init(container.decode(((function(){throw '!unclarifiedGeneric:Bound'})()), {$setThis: $val => container = $val}), {});
return
----Swift.(file).PartialRangeFrom.encode(to:Encoder)
let _this = this;
let container = _cloneStruct(encoder.unkeyedContainer( {}));
container.encode(_this.lowerBound, {$setThis: $val => container = $val})
----Swift.(file).Comparable...<infix(_:Self,_:Self)
let _this = this;
preconditionFileLine(() => (_.arg0 = minimum).constructor.infix_60_61(_.arg0, maximum, {}), () => "Can't form Range with upperBound < lowerBound", '?3', '?3', {});
return _create(Range, 'initUncheckedBoundstuple_type', {0: minimum, 1: maximum}, {})
----Swift.(file).Comparable...<prefix(_:Self)
let _this = this;
return _create(PartialRangeUpTo, 'init', maximum, {})
----Swift.(file).Comparable....prefix(_:Self)
let _this = this;
return _create(PartialRangeThrough, 'init', maximum, {})
----Swift.(file).Comparable....postfix(_:Self)
let _this = this;
return _create(PartialRangeFrom, 'init', minimum, {})
----Swift.(file).UnboundedRange
const UnboundedRange = '?function_type
----Swift.(file).Collection.subscript(_:R)
let _this = this;
return _this.subscriptRange$get(r.relativeTo(_this, {}), {})
----Swift.(file).Collection.subscript(_:(UnboundedRange_) -> ())
let _this = this;
return _this.subscript$get(((function(){throw '!unclarifiedGeneric:Self.Index'})()).postfix_46_46_46(_this.startIndex, {}), {})
----Swift.(file).MutableCollection.subscript(_:R)#ASS

let _this = this;
_this.subscriptRange$set(newValue, r.relativeTo(_this, {}), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
----Swift.(file).MutableCollection.subscript(_:R)
let _this = this;
return _this.subscriptRange$get(r.relativeTo(_this, {}), {});

----Swift.(file).MutableCollection.subscript(_:(UnboundedRange_) -> ())#ASS

let _this = this;
_this.subscriptRange$set(newValue, ((function(){throw '!unclarifiedGeneric:Self.Index'})()).postfix_46_46_46(_this.startIndex, {}), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
----Swift.(file).MutableCollection.subscript(_:(UnboundedRange_) -> ())
let _this = this;
return _this.subscriptRange$get(((function(){throw '!unclarifiedGeneric:Self.Index'})()).postfix_46_46_46(_this.startIndex, {}), {});

----Swift.(file).Range.overlaps(_:Range<Bound>)
let _this = this;
return Bool.infix_124_124(Bool.infix_38_38(Bool.prefix_33(other.isEmpty, {}), () => _this.contains(other.lowerBound, {}), {}), () => Bool.infix_38_38(Bool.prefix_33(_this.isEmpty, {}), () => other.contains(_this.lowerBound, {}), {}), {})
----Swift.(file).Range.overlaps(_:ClosedRange<Bound>)
let _this = this;
return Bool.infix_124_124(_this.contains(other.lowerBound, {}), () => Bool.infix_38_38(Bool.prefix_33(_this.isEmpty, {}), () => other.contains(_this.lowerBound, {}), {}), {})
----Swift.(file).RangeReplaceableCollection.reserveCapacity(_:Int)

----Swift.(file).RangeReplaceableCollection.init(repeating:Self.Element,count:Int)
let _this = this;
_this.init( {});
if((Int.infix_33_61(count, 0, {}))) {
const _elements = _create(Repeated, 'init_repeatingCountInt', repeatedValue, count, {});
_this.appendContentsOf(_elements, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
};
return
----Swift.(file).RangeReplaceableCollection.init(_:S)
let _this = this;
_this.init( {});
_this.appendContentsOf(_elements, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
return
----Swift.(file).RangeReplaceableCollection.append(_:Self.Element)
let _this = this;
_this.insertAt(newElement, _this.endIndex, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
----Swift.(file).RangeReplaceableCollection.append(contentsOf:S)
let _this = this;
const approximateCapacity = Int.infix_43(_this.count, numericCast(newElements.underestimatedCount, {T: Int, U: Int}), {});
{
let $element$generator = newElements.makeIterator( {});
while(true) {
const $ifLet0, _element_1;
if(!((($ifLet0 = $element$generator.next( {$setThis: $val => $element$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((_element_1 = $ifLet0[0])||true))) break
_this.append(_element_1, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
}
}
----Swift.(file).RangeReplaceableCollection.insert(_:Self.Element,at:Self.Index)
let _this = this;
_this.replaceSubrangeWith((_.arg0 = i).constructor.infix_46_46_60(_.arg0, i, {}), _create(CollectionOfOne, 'init', newElement, {}), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
----Swift.(file).RangeReplaceableCollection.insert(contentsOf:C,at:Self.Index)
let _this = this;
_this.replaceSubrangeWith((_.arg0 = i).constructor.infix_46_46_60(_.arg0, i, {}), newElements, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
----Swift.(file).RangeReplaceableCollection.remove(at:Self.Index)
let _this = this;
preconditionFileLine(() => Bool.prefix_33(_this.isEmpty, {}), () => "Can't remove from an empty collection", '?3', '?3', {});
const result = _this.subscript$get(position, {});
_this.replaceSubrangeWith((_.arg0 = position).constructor.infix_46_46_60(_.arg0, _this.indexAfter(position, {}), {}), _create(EmptyCollection, 'init', {}), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
return result
----Swift.(file).RangeReplaceableCollection.removeSubrange(_:Range<Self.Index>)
let _this = this;
_this.replaceSubrangeWith(bounds, _create(EmptyCollection, 'init', {}), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
----Swift.(file).RangeReplaceableCollection.removeFirst(_:Int)
let _this = this;
if((Int.infix_61_61(k, 0, {}))) {
return ;
};
preconditionFileLine(() => Int.infix_62_61(k, 0, {}), () => "Number of elements to remove should be non-negative", '?3', '?3', {});
preconditionFileLine(() => Int.infix_62_61(_this.count, k, {}), () => "Can't remove more items from a collection than it has", '?3', '?3', {});
const end = _this.indexOffsetBy(_this.startIndex, k, {});
_this.removeSubrangeRange((_.arg0 = _this.startIndex).constructor.infix_46_46_60(_.arg0, end, {}), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
----Swift.(file).RangeReplaceableCollection.removeFirst()
let _this = this;
preconditionFileLine(() => Bool.prefix_33(_this.isEmpty, {}), () => "Can't remove first element from an empty collection", '?3', '?3', {});
const firstElement = _this.first[0];
_this.removeFirstMultiple(1, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
return firstElement
----Swift.(file).RangeReplaceableCollection.removeAll(keepingCapacity:Bool)
let _this = this;
if((Bool.prefix_33(keepCapacity, {}))) {
$info.$setThis(_this = _cloneStruct(_create(_this.constructor, 'init', {})));
}
else {
_this.replaceSubrangeWith((_.arg0 = _this.startIndex).constructor.infix_46_46_60(_.arg0, _this.endIndex, {}), _create(EmptyCollection, 'init', {}), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
}
----Swift.(file).RangeReplaceableCollection.reserveCapacity(_:Int)

----Swift.(file).RangeReplaceableCollection.removeFirst()
let _this = this;
preconditionFileLine(() => Bool.prefix_33(_this.isEmpty, {}), () => "Can't remove items from an empty collection", '?3', '?3', {});
const _element = _this.first[0];
$info.$setThis(_this = _cloneStruct(_this.subscriptRange$get((_.arg0 = _this.indexAfter(_this.startIndex, {})).constructor.infix_46_46_60(_.arg0, _this.endIndex, {}), {})));
return _element
----Swift.(file).RangeReplaceableCollection.removeFirst(_:Int)
let _this = this;
if((Int.infix_61_61(k, 0, {}))) {
return ;
};
preconditionFileLine(() => Int.infix_62_61(k, 0, {}), () => "Number of elements to remove should be non-negative", '?3', '?3', {});
preconditionFileLine(() => Int.infix_62_61(_this.count, k, {}), () => "Can't remove more items from a collection than it contains", '?3', '?3', {});
$info.$setThis(_this = _cloneStruct(_this.subscriptRange$get((_.arg0 = _this.indexOffsetBy(_this.startIndex, k, {})).constructor.infix_46_46_60(_.arg0, _this.endIndex, {}), {})))
----Swift.(file).RangeReplaceableCollection.replaceSubrange(_:R,with:C)
let _this = this;
_this.replaceSubrangeWith(subrange.relativeTo(_this, {}), newElements, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
----Swift.(file).RangeReplaceableCollection.removeSubrange(_:R)
let _this = this;
_this.removeSubrangeRange(bounds.relativeTo(_this, {}), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
----Swift.(file).RangeReplaceableCollection.popLast()
let _this = this;
if((_this.isEmpty)) {
return Optional.none;
};
return _injectIntoOptional(_this.removeAt(_this.indexBefore(_this.endIndex, {}), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))}))
----Swift.(file).RangeReplaceableCollection.removeLast()
let _this = this;
preconditionFileLine(() => Bool.prefix_33(_this.isEmpty, {}), () => "Can't remove last element from an empty collection", '?3', '?3', {});
return _this.removeAt(_this.indexBefore(_this.endIndex, {}), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
----Swift.(file).RangeReplaceableCollection.popLast()
let _this = this;
if((_this.isEmpty)) {
return Optional.none;
};
return _injectIntoOptional(_this.removeAt(_this.indexBefore(_this.endIndex, {}), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))}))
----Swift.(file).RangeReplaceableCollection.removeLast()
let _this = this;
preconditionFileLine(() => Bool.prefix_33(_this.isEmpty, {}), () => "Can't remove last element from an empty collection", '?3', '?3', {});
return _this.removeAt(_this.indexBefore(_this.endIndex, {}), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
----Swift.(file).RangeReplaceableCollection.+infix(_:Self,_:Other)
let _this = this;
let lhs_dupl = lhs;
lhs_dupl.appendContentsOf(rhs, {$setThis: $val => lhs_dupl = $val});
return lhs_dupl
----Swift.(file).RangeReplaceableCollection.+infix(_:Other,_:Self)
let _this = this;
let result = _create(_this, 'init', {});
result.appendContentsOf(lhs, {$setThis: $val => result = $val});
result.appendContentsOf(rhs, {$setThis: $val => result = $val});
return result
----Swift.(file).RangeReplaceableCollection.+=infix(_:Self,_:Other)
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs.appendContentsOf(rhs, {$setThis: $val => lhs = $val});})()
lhs$inout.set(lhs)
return $result
----Swift.(file).RangeReplaceableCollection.+infix(_:Self,_:Other)
let _this = this;
let lhs_dupl = lhs;
lhs_dupl.appendContentsOf(rhs, {$setThis: $val => lhs_dupl = $val});
return lhs_dupl
----Swift.(file).RangeReplaceableCollection.filter(_:(Self.Element) throws -> Bool)
let _this = this;
return _create(_this.constructor, 'initBuffer', _this.lazy.filterSwift(isIncluded, {}), {})
----Swift.(file).RangeReplaceableCollection.removeAll(where:(Self.Element) throws -> Bool)
let _this = this;
const suffixStart = _this._halfStablePartitionIsSuffixElement(shouldBeRemoved, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
_this.removeSubrange(((function(){throw '!unclarifiedGeneric:Self.Index'})()).postfix_46_46_46(suffixStart, {}), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
----Swift.(file).RangeReplaceableCollection.removeAll(where:(Self.Element) throws -> Bool)
let _this = this;
$info.$setThis(_this = _cloneStruct(_create(_this.constructor, 'initBuffer', _this.lazy.filterSwift((($0, $info?) => Bool.prefix_33(shouldBeRemoved($0, {}), {})), {}), {})))
----Swift.(file).getChild(of:T,type:Any.Type,index:Int)
let nameC = Optional.none;
let freeFunc = Optional.none;
const value = _cloneStruct(_getChildOfTypeIndexOutNameOutFreeFunc(value, type, index, /**/{get: () => nameC, set: $val => nameC = $val}, /**/{get: () => freeFunc, set: $val => freeFunc = $val}, {}));
const _name = nameC.flatMap((($0, $info?) => _create(String, 'initValidatingUTF8UnsafePointer', $0, {})), {});
_injectIntoOptional(((_.tmp0 = freeFunc).rawValue === 'some') ? (_.tmp0[0](nameC, {})) : null);
return {0: _name, 1: value}
----Swift.(file).Mirror.quickLookObject(_:Any)
let _this = this;
const object = _getQuickLookObject(subject, {});
return object.flatMap(_getClassPlaygroundQuickLook, {})
----Swift.(file).Repeated.Indices

----Swift.(file).Repeated.startIndex
let _this = this;
return 0
----Swift.(file).Repeated.endIndex
let _this = this;
return _this.count
----Swift.(file).Repeated.subscript(_:Int)
let _this = this;
preconditionFileLine(() => Bool.infix_38_38(Int.infix_62_61(position, 0, {}), () => Int.infix_60(position, _this.count, {}), {}), () => "Index out of range", '?3', '?3', {});
return _this.repeatedValue
----Swift.(file).repeatElement(_:T,count:Int)
return _create(Repeated, 'init_repeatingCountInt', _element, n, {})
----Swift.(file).Result.map(_:(Success) -> NewSuccess)
let _this = this;
const $match = _this
if((($match.rawValue == Result.success().rawValue))) {
const success = $match[0]
return Result.success(transform(success, {}), {});
}
else if((($match.rawValue == Result.failure().rawValue))) {
const failure = $match[0]
return Result.failure(failure, {});
}
----Swift.(file).Result.mapError(_:(Failure) -> NewFailure)
let _this = this;
const $match = _this
if((($match.rawValue == Result.success().rawValue))) {
const success = $match[0]
return Result.success(success, {});
}
else if((($match.rawValue == Result.failure().rawValue))) {
const failure = $match[0]
return Result.failure(transform(failure, {}), {});
}
----Swift.(file).Result.flatMap(_:(Success) -> Result<NewSuccess, Failure>)
let _this = this;
const $match = _this
if((($match.rawValue == Result.success().rawValue))) {
const success = $match[0]
return transform(success, {});
}
else if((($match.rawValue == Result.failure().rawValue))) {
const failure = $match[0]
return Result.failure(failure, {});
}
----Swift.(file).Result.flatMapError(_:(Failure) -> Result<Success, NewFailure>)
let _this = this;
const $match = _this
if((($match.rawValue == Result.success().rawValue))) {
const success = $match[0]
return Result.success(success, {});
}
else if((($match.rawValue == Result.failure().rawValue))) {
const failure = $match[0]
return transform(failure, {});
}
----Swift.(file).Result.get()
let _this = this;
const $match = _this
if((($match.rawValue == Result.success().rawValue))) {
const success = $match[0]
return success;
}
else if((($match.rawValue == Result.failure().rawValue))) {
const failure = $match[0]
throw failure;
}
----Swift.(file).Result.init(catching:() throws -> Success)
let _this = this;
try {
$info.$setThis(_this = _cloneStruct(Result.success(body( {}), {})));
} catch(error) {
if((true)) {
$info.$setThis(_this = _cloneStruct(Result.failure(error, {})));
}
else throw error
};
return
----Swift.(file).MutableCollection.reverse()
let _this = this;
if((_this.isEmpty)) {
return ;
};
let f = _this.startIndex;
let l = _this.indexBefore(_this.endIndex, {});
while(true){
if(!(((_.arg0 = f).constructor.infix_60(_.arg0, l, {})))) break
_this.swapAt(f, l, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
_this.formIndexAfter({get: () => f, set: $val => f = $val}, {});
_this.formIndexBefore({get: () => l, set: $val => l = $val}, {});
}
----Swift.(file).ReversedCollection.Iterator.next()
let _this = this;
if(!((_fastPath((_.arg0 = _this._position).constructor.infix_33_61(_.arg0, _this._base.startIndex, {}), {})))) {
return Optional.none;
};
_this._base.formIndexBefore({get: () => _this._position, set: $val => _this._position = $val}, {});
return _injectIntoOptional(_this._base.subscript$get(_this._position, {}))
----Swift.(file).ReversedCollection.makeIterator()
let _this = this;
return _create(ReversedCollection.Iterator, 'init_base', _this._base, {})
----Swift.(file).ReversedCollection.Index.==infix(_:ReversedCollection<Base>.Index,_:ReversedCollection<Base>.Index)
let _this = this;
return (_.arg0 = lhs.base).constructor.infix_61_61(_.arg0, rhs.base, {})
----Swift.(file).ReversedCollection.Index.<infix(_:ReversedCollection<Base>.Index,_:ReversedCollection<Base>.Index)
let _this = this;
return (_.arg0 = lhs.base).constructor.infix_62(_.arg0, rhs.base, {})
----Swift.(file).ReversedCollection.Index.hash(into:Hasher)
let _this = this;
let hasher = hasher$inout.get()
const $result = (() => {
hasher.combine(_this.base, {$setThis: $val => hasher = $val});})()
hasher$inout.set(hasher)
return $result
----Swift.(file).ReversedCollection.startIndex
let _this = this;
return _create(ReversedCollection.Index, 'init', _this._base.endIndex, {})
----Swift.(file).ReversedCollection.endIndex
let _this = this;
return _create(ReversedCollection.Index, 'init', _this._base.startIndex, {})
----Swift.(file).ReversedCollection.index(after:ReversedCollection<Base>.Index)
let _this = this;
return _create(ReversedCollection.Index, 'init', _this._base.indexBefore(i.base, {}), {})
----Swift.(file).ReversedCollection.index(before:ReversedCollection<Base>.Index)
let _this = this;
return _create(ReversedCollection.Index, 'init', _this._base.indexAfter(i.base, {}), {})
----Swift.(file).ReversedCollection.index(_:ReversedCollection<Base>.Index,offsetBy:Int)
let _this = this;
return _create(ReversedCollection.Index, 'init', _this._base.indexOffsetBy(i.base, Int.prefix_45(n, {}), {}), {})
----Swift.(file).ReversedCollection.index(_:ReversedCollection<Base>.Index,offsetBy:Int,limitedBy:ReversedCollection<Base>.Index)
let _this = this;
return _this._base.indexOffsetByLimitedBy(i.base, Int.prefix_45(n, {}), limit.base, {}).mapSwift(init(ReversedCollection.Index, {}), {})
----Swift.(file).ReversedCollection.distance(from:ReversedCollection<Base>.Index,to:ReversedCollection<Base>.Index)
let _this = this;
return _this._base.distanceFromTo(end.base, start.base, {})
----Swift.(file).ReversedCollection.subscript(_:ReversedCollection<Base>.Index)
let _this = this;
return _this._base.subscript$get(_this._base.indexBefore(position.base, {}), {})
----Swift.(file).ReversedCollection.reversed()
let _this = this;
return _this._base
----Swift.(file).BidirectionalCollection.reversed()
let _this = this;
return _create(ReversedCollection, 'init_base', _this, {})
----Swift.(file).SIMD.indices
let _this = this;
return Int.infix_46_46_60(0, _this.scalarCount, {})
----Swift.(file).SIMD.init(repeating:Self.Scalar)
let _this = this;
_this.init( {});
{
let $i$generator = _cloneStruct(_this.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
_this.subscript$set(value, i_1, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
}
};
return
----Swift.(file).SIMD.==infix(_:Self,_:Self)
let _this = this;
let result = true;
{
let $i$generator = _cloneStruct(lhs.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result = Bool.infix_38_38(result, () => (_.arg0 = lhs.subscript$get(i_1, {})).constructor.infix_61_61(_.arg0, rhs.subscript$get(i_1, {}), {}), {});
}
};
return result
----Swift.(file).SIMD.hash(into:Hasher)
let _this = this;
let hasher = hasher$inout.get()
const $result = (() => {
{
let $i$generator = _cloneStruct(_this.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
hasher.combine(_this.subscript$get(i_1, {}), {$setThis: $val => hasher = $val});
}
};})()
hasher$inout.set(hasher)
return $result
----Swift.(file).SIMD.encode(to:Encoder)
let _this = this;
let container = _cloneStruct(encoder.unkeyedContainer( {}));
{
let $i$generator = _cloneStruct(_this.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
container.encode(_this.subscript$get(i_1, {}), {$setThis: $val => container = $val});
}
}
----Swift.(file).SIMD.init(from:Decoder)
let _this = this;
_this.init( {});
let container = _cloneStruct(decoder.unkeyedContainer( {}));
if(!((Optional.infix_61_61(container.count, _injectIntoOptional(_this.scalarCount), {})))) {
throw DecodingError.dataCorrupted(_create(DecodingError.Context, 'initCodingPathArrayDebugDescriptionStringUnderlyingErrorOptional', decoder.codingPath, (("Expected vector with exactly ") + (Int.prototype.description$get.call(_this.scalarCount)) + (" elements.")), nil/*!default_value*/, {}), {});
};
{
let $i$generator = _cloneStruct(_this.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
_this.subscript$set(container.decode(((function(){throw '!unclarifiedGeneric:Self.Scalar'})()), {$setThis: $val => container = $val}), i_1, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
}
};
return
----Swift.(file).SIMD.description
let _this = this;
return String.infix_43(String.infix_43((("") + (_this.constructor) + ("(")), _this.indices.mapSwift((($0, $info?) => (("") + (_this.subscript$get($0, {})) + (""))), {}).joinedSeparator(", ", {}), {}), ")", {})
----Swift.(file).SIMD..==infix(_:Self,_:Self)
let _this = this;
let result = _create(SIMDMask, 'init', {});
{
let $i$generator = _cloneStruct(result.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set((_.arg0 = lhs.subscript$get(i_1, {})).constructor.infix_61_61(_.arg0, rhs.subscript$get(i_1, {}), {}), i_1, {$setThis: $val => result = $val});
}
};
return result
----Swift.(file).SIMD..!=infix(_:Self,_:Self)
let _this = this;
let result = _create(SIMDMask, 'init', {});
{
let $i$generator = _cloneStruct(result.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set((_.arg0 = lhs.subscript$get(i_1, {})).constructor.infix_33_61(_.arg0, rhs.subscript$get(i_1, {}), {}), i_1, {$setThis: $val => result = $val});
}
};
return result
----Swift.(file).SIMD.replace(with:Self,where:SIMDMask<Self.MaskStorage>)
let _this = this;
{
let $i$generator = _cloneStruct(_this.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
_this.subscript$set((mask.subscript$get(i_1, {}) ? other.subscript$get(i_1, {}) : _this.subscript$get(i_1, {})), i_1, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
}
}
----Swift.(file).SIMD.init(arrayLiteral:[Self.Scalar])
let _this = this;
_this.init(scalars, {});
return
----Swift.(file).SIMD.init(_:S)
let _this = this;
_this.init( {});
let index = 0;
{
let $scalar$generator = scalars.makeIterator( {});
while(true) {
const $ifLet0, scalar_1;
if(!((($ifLet0 = $scalar$generator.next( {$setThis: $val => $scalar$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((scalar_1 = $ifLet0[0])||true))) break
if((Int.infix_61_61(index, _this.scalarCount, {}))) {
preconditionFailureFileLine(() => "Too many elements in sequence.", '?3', '?3', {});
};
_this.subscript$set(scalar_1, index, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
Int.infix_43_61({get: () => index, set: $val => index = $val}, 1, {});
}
};
if((Int.infix_60(index, _this.scalarCount, {}))) {
preconditionFailureFileLine(() => "Not enough elements in sequence.", '?3', '?3', {});
};
return
----Swift.(file).SIMD..<infix(_:Self,_:Self)
let _this = this;
let result = _create(SIMDMask, 'init', {});
{
let $i$generator = _cloneStruct(result.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set((_.arg0 = lhs.subscript$get(i_1, {})).constructor.infix_60(_.arg0, rhs.subscript$get(i_1, {}), {}), i_1, {$setThis: $val => result = $val});
}
};
return result
----Swift.(file).SIMD..<=infix(_:Self,_:Self)
let _this = this;
let result = _create(SIMDMask, 'init', {});
{
let $i$generator = _cloneStruct(result.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set((_.arg0 = lhs.subscript$get(i_1, {})).constructor.infix_60_61(_.arg0, rhs.subscript$get(i_1, {}), {}), i_1, {$setThis: $val => result = $val});
}
};
return result
----Swift.(file).SIMD..==infix(_:Self.Scalar,_:Self)
let _this = this;
return (_.arg0 = _create(_this, 'initRepeating', lhs, {})).constructor.infix_46_61_61(_.arg0, rhs, {})
----Swift.(file).SIMD..!=infix(_:Self.Scalar,_:Self)
let _this = this;
return (_.arg0 = _create(_this, 'initRepeating', lhs, {})).constructor.infix_46_33_61(_.arg0, rhs, {})
----Swift.(file).SIMD..==infix(_:Self,_:Self.Scalar)
let _this = this;
return (_.arg0 = lhs).constructor.infix_46_61_61(_.arg0, _create(_this, 'initRepeating', rhs, {}), {})
----Swift.(file).SIMD..!=infix(_:Self,_:Self.Scalar)
let _this = this;
return (_.arg0 = lhs).constructor.infix_46_33_61(_.arg0, _create(_this, 'initRepeating', rhs, {}), {})
----Swift.(file).SIMD.replace(with:Self.Scalar,where:SIMDMask<Self.MaskStorage>)
let _this = this;
_this.replaceWithWhere(_create(_this.constructor, 'initRepeating', other, {}), mask, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
----Swift.(file).SIMD.replacing(with:Self,where:SIMDMask<Self.MaskStorage>)
let _this = this;
let result = _this;
result.replaceWithWhere(other, mask, {$setThis: $val => result = $val});
return result
----Swift.(file).SIMD.replacing(with:Self.Scalar,where:SIMDMask<Self.MaskStorage>)
let _this = this;
return _this.replacingWithWhere(_create(_this.constructor, 'initRepeating', other, {}), mask, {})
----Swift.(file).SIMD..>=infix(_:Self,_:Self)
let _this = this;
return (_.arg0 = rhs).constructor.infix_46_60_61(_.arg0, lhs, {})
----Swift.(file).SIMD..>infix(_:Self,_:Self)
let _this = this;
return (_.arg0 = rhs).constructor.infix_46_60(_.arg0, lhs, {})
----Swift.(file).SIMD..<infix(_:Self.Scalar,_:Self)
let _this = this;
return (_.arg0 = _create(_this, 'initRepeating', lhs, {})).constructor.infix_46_60(_.arg0, rhs, {})
----Swift.(file).SIMD..<=infix(_:Self.Scalar,_:Self)
let _this = this;
return (_.arg0 = _create(_this, 'initRepeating', lhs, {})).constructor.infix_46_60_61(_.arg0, rhs, {})
----Swift.(file).SIMD..>=infix(_:Self.Scalar,_:Self)
let _this = this;
return (_.arg0 = _create(_this, 'initRepeating', lhs, {})).constructor.infix_46_62_61(_.arg0, rhs, {})
----Swift.(file).SIMD..>infix(_:Self.Scalar,_:Self)
let _this = this;
return (_.arg0 = _create(_this, 'initRepeating', lhs, {})).constructor.infix_46_62(_.arg0, rhs, {})
----Swift.(file).SIMD..<infix(_:Self,_:Self.Scalar)
let _this = this;
return (_.arg0 = lhs).constructor.infix_46_60(_.arg0, _create(_this, 'initRepeating', rhs, {}), {})
----Swift.(file).SIMD..<=infix(_:Self,_:Self.Scalar)
let _this = this;
return (_.arg0 = lhs).constructor.infix_46_60_61(_.arg0, _create(_this, 'initRepeating', rhs, {}), {})
----Swift.(file).SIMD..>=infix(_:Self,_:Self.Scalar)
let _this = this;
return (_.arg0 = lhs).constructor.infix_46_62_61(_.arg0, _create(_this, 'initRepeating', rhs, {}), {})
----Swift.(file).SIMD..>infix(_:Self,_:Self.Scalar)
let _this = this;
return (_.arg0 = lhs).constructor.infix_46_62(_.arg0, _create(_this, 'initRepeating', rhs, {}), {})
----Swift.(file).SIMD.zero
let _this = this;
return _create(_this, 'init', {});
}
static get zero() { return this.zero$get()
----Swift.(file).SIMD.random(in:Range<Self.Scalar>,using:T)
let _this = this;
let generator = generator$inout.get()
const $result = (() => {
let result = _create(_this, 'init', {});
{
let $i$generator = _cloneStruct(result.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set(((function(){throw '!unclarifiedGeneric:Self.Scalar'})()).randomInUsing(range, {get: () => generator, set: $val => generator = $val}, {}), i_1, {$setThis: $val => result = $val});
}
};
return result;})()
generator$inout.set(generator)
return $result
----Swift.(file).SIMD.random(in:Range<Self.Scalar>)
let _this = this;
let g = _create(SystemRandomNumberGenerator, 'init', {});
return _this.randomInUsing(range, {get: () => g, set: $val => g = $val}, {})
----Swift.(file).SIMD.random(in:ClosedRange<Self.Scalar>,using:T)
let _this = this;
let generator = generator$inout.get()
const $result = (() => {
let result = _create(_this, 'init', {});
{
let $i$generator = _cloneStruct(result.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set(((function(){throw '!unclarifiedGeneric:Self.Scalar'})()).randomInUsing(range, {get: () => generator, set: $val => generator = $val}, {}), i_1, {$setThis: $val => result = $val});
}
};
return result;})()
generator$inout.set(generator)
return $result
----Swift.(file).SIMD.random(in:ClosedRange<Self.Scalar>)
let _this = this;
let g = _create(SystemRandomNumberGenerator, 'init', {});
return _this.randomInUsing(range, {get: () => g, set: $val => g = $val}, {})
----Swift.(file).SIMD.zero
let _this = this;
return _create(_this, 'init', {});
}
static get zero() { return this.zero$get()
----Swift.(file).SIMD.random(in:Range<Self.Scalar>,using:T)
let _this = this;
let generator = generator$inout.get()
const $result = (() => {
let result = _create(_this, 'init', {});
{
let $i$generator = _cloneStruct(result.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set(((function(){throw '!unclarifiedGeneric:Self.Scalar'})()).randomInUsing(range, {get: () => generator, set: $val => generator = $val}, {}), i_1, {$setThis: $val => result = $val});
}
};
return result;})()
generator$inout.set(generator)
return $result
----Swift.(file).SIMD.random(in:Range<Self.Scalar>)
let _this = this;
let g = _create(SystemRandomNumberGenerator, 'init', {});
return _this.randomInUsing(range, {get: () => g, set: $val => g = $val}, {})
----Swift.(file).SIMD.random(in:ClosedRange<Self.Scalar>,using:T)
let _this = this;
let generator = generator$inout.get()
const $result = (() => {
let result = _create(_this, 'init', {});
{
let $i$generator = _cloneStruct(result.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set(((function(){throw '!unclarifiedGeneric:Self.Scalar'})()).randomInUsing(range, {get: () => generator, set: $val => generator = $val}, {}), i_1, {$setThis: $val => result = $val});
}
};
return result;})()
generator$inout.set(generator)
return $result
----Swift.(file).SIMD.random(in:ClosedRange<Self.Scalar>)
let _this = this;
let g = _create(SystemRandomNumberGenerator, 'init', {});
return _this.randomInUsing(range, {get: () => g, set: $val => g = $val}, {})
----Swift.(file).SIMDMask.scalarCount
let _this = this;
return _this._storage.scalarCount
----Swift.(file).SIMDMask.init()
let _this = this;
_this._storage = _create(((function(){throw '!unclarifiedGeneric:Storage'})()), 'init', {});
return
----Swift.(file).SIMDMask.init(_:Storage)
let _this = this;
_this._storage = _storage;
return
----Swift.(file).SIMDMask.subscript(_:Int)#ASS

let _this = this;
preconditionFileLine(() => _this.indices.contains(index, {}), () => String()/*!default_value*/, '?3', '?3', {});
_this._storage.subscript$set((newValue ? -1 : 0), index, {$setThis: $val => _this._storage = $val})
----Swift.(file).SIMDMask.subscript(_:Int)
let _this = this;
preconditionFileLine(() => _this.indices.contains(index, {}), () => String()/*!default_value*/, '?3', '?3', {});
return ((function(){throw '!unclarifiedGeneric:Storage.Scalar'})()).infix_60(_this._storage.subscript$get(index, {}), 0, {});

----Swift.(file).SIMDMask.random(using:T)
let _this = this;
let generator = generator$inout.get()
const $result = (() => {
let result = _create(SIMDMask, 'init', {});
{
let $i$generator = _cloneStruct(result.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set(Bool.randomUsing({get: () => generator, set: $val => generator = $val}, {}), i_1, {$setThis: $val => result = $val});
}
};
return result;})()
generator$inout.set(generator)
return $result
----Swift.(file).SIMDMask.random()
let _this = this;
let g = _create(SystemRandomNumberGenerator, 'init', {});
return SIMDMask.randomUsing({get: () => g, set: $val => g = $val}, {})
----Swift.(file).SIMD.leadingZeroBitCount
let _this = this;
let result = _create(_this.constructor, 'init', {});
{
let $i$generator = _cloneStruct(_this.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set(_create(((function(){throw '!unclarifiedGeneric:Self.Scalar'})()), 'initT', ((function(){throw '!unclarifiedGeneric:Self.Scalar'})()).prototype.leadingZeroBitCount$get.call(_this.subscript$get(i_1, {})), {}), i_1, {$setThis: $val => result = $val});
}
};
return result
----Swift.(file).SIMD.trailingZeroBitCount
let _this = this;
let result = _create(_this.constructor, 'init', {});
{
let $i$generator = _cloneStruct(_this.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set(_create(((function(){throw '!unclarifiedGeneric:Self.Scalar'})()), 'initT', ((function(){throw '!unclarifiedGeneric:Self.Scalar'})()).prototype.trailingZeroBitCount$get.call(_this.subscript$get(i_1, {})), {}), i_1, {$setThis: $val => result = $val});
}
};
return result
----Swift.(file).SIMD.nonzeroBitCount
let _this = this;
let result = _create(_this.constructor, 'init', {});
{
let $i$generator = _cloneStruct(_this.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set(_create(((function(){throw '!unclarifiedGeneric:Self.Scalar'})()), 'initT', ((function(){throw '!unclarifiedGeneric:Self.Scalar'})()).prototype.nonzeroBitCount$get.call(_this.subscript$get(i_1, {})), {}), i_1, {$setThis: $val => result = $val});
}
};
return result
----Swift.(file).SIMD.~prefix(_:Self)
let _this = this;
let result = _create(_this, 'init', {});
{
let $i$generator = _cloneStruct(result.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set(((function(){throw '!unclarifiedGeneric:Self.Scalar'})()).prefix_126(rhs.subscript$get(i_1, {}), {}), i_1, {$setThis: $val => result = $val});
}
};
return result
----Swift.(file).SIMD.&infix(_:Self,_:Self)
let _this = this;
let result = _create(_this, 'init', {});
{
let $i$generator = _cloneStruct(result.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set(((function(){throw '!unclarifiedGeneric:Self.Scalar'})()).infix_38(lhs.subscript$get(i_1, {}), rhs.subscript$get(i_1, {}), {}), i_1, {$setThis: $val => result = $val});
}
};
return result
----Swift.(file).SIMD.^infix(_:Self,_:Self)
let _this = this;
let result = _create(_this, 'init', {});
{
let $i$generator = _cloneStruct(result.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set(((function(){throw '!unclarifiedGeneric:Self.Scalar'})()).infix_94(lhs.subscript$get(i_1, {}), rhs.subscript$get(i_1, {}), {}), i_1, {$setThis: $val => result = $val});
}
};
return result
----Swift.(file).SIMD.|infix(_:Self,_:Self)
let _this = this;
let result = _create(_this, 'init', {});
{
let $i$generator = _cloneStruct(result.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set(((function(){throw '!unclarifiedGeneric:Self.Scalar'})()).infix_124(lhs.subscript$get(i_1, {}), rhs.subscript$get(i_1, {}), {}), i_1, {$setThis: $val => result = $val});
}
};
return result
----Swift.(file).SIMD.&<<infix(_:Self,_:Self)
let _this = this;
let result = _create(_this, 'init', {});
{
let $i$generator = _cloneStruct(result.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set(((function(){throw '!unclarifiedGeneric:Self.Scalar'})()).infix_38_60_60(lhs.subscript$get(i_1, {}), rhs.subscript$get(i_1, {}), {}), i_1, {$setThis: $val => result = $val});
}
};
return result
----Swift.(file).SIMD.&>>infix(_:Self,_:Self)
let _this = this;
let result = _create(_this, 'init', {});
{
let $i$generator = _cloneStruct(result.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set(((function(){throw '!unclarifiedGeneric:Self.Scalar'})()).infix_38_62_62(lhs.subscript$get(i_1, {}), rhs.subscript$get(i_1, {}), {}), i_1, {$setThis: $val => result = $val});
}
};
return result
----Swift.(file).SIMD.&+infix(_:Self,_:Self)
let _this = this;
let result = _create(_this, 'init', {});
{
let $i$generator = _cloneStruct(result.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set(((function(){throw '!unclarifiedGeneric:Self.Scalar'})()).infix_38_43(lhs.subscript$get(i_1, {}), rhs.subscript$get(i_1, {}), {}), i_1, {$setThis: $val => result = $val});
}
};
return result
----Swift.(file).SIMD.&-infix(_:Self,_:Self)
let _this = this;
let result = _create(_this, 'init', {});
{
let $i$generator = _cloneStruct(result.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set(((function(){throw '!unclarifiedGeneric:Self.Scalar'})()).infix_38_45(lhs.subscript$get(i_1, {}), rhs.subscript$get(i_1, {}), {}), i_1, {$setThis: $val => result = $val});
}
};
return result
----Swift.(file).SIMD.&*infix(_:Self,_:Self)
let _this = this;
let result = _create(_this, 'init', {});
{
let $i$generator = _cloneStruct(result.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set(((function(){throw '!unclarifiedGeneric:Self.Scalar'})()).infix_38_42(lhs.subscript$get(i_1, {}), rhs.subscript$get(i_1, {}), {}), i_1, {$setThis: $val => result = $val});
}
};
return result
----Swift.(file).SIMD./infix(_:Self,_:Self)
let _this = this;
let result = _create(_this, 'init', {});
{
let $i$generator = _cloneStruct(result.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set(((function(){throw '!unclarifiedGeneric:Self.Scalar'})()).infix_47(lhs.subscript$get(i_1, {}), rhs.subscript$get(i_1, {}), {}), i_1, {$setThis: $val => result = $val});
}
};
return result
----Swift.(file).SIMD.%infix(_:Self,_:Self)
let _this = this;
let result = _create(_this, 'init', {});
{
let $i$generator = _cloneStruct(result.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set(((function(){throw '!unclarifiedGeneric:Self.Scalar'})()).infix_37(lhs.subscript$get(i_1, {}), rhs.subscript$get(i_1, {}), {}), i_1, {$setThis: $val => result = $val});
}
};
return result
----Swift.(file).SIMD.+infix(_:Self,_:Self)
let _this = this;
let result = _create(_this, 'init', {});
{
let $i$generator = _cloneStruct(result.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set(((function(){throw '!unclarifiedGeneric:Self.Scalar'})()).infix_43(lhs.subscript$get(i_1, {}), rhs.subscript$get(i_1, {}), {}), i_1, {$setThis: $val => result = $val});
}
};
return result
----Swift.(file).SIMD.-infix(_:Self,_:Self)
let _this = this;
let result = _create(_this, 'init', {});
{
let $i$generator = _cloneStruct(result.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set(((function(){throw '!unclarifiedGeneric:Self.Scalar'})()).infix_45(lhs.subscript$get(i_1, {}), rhs.subscript$get(i_1, {}), {}), i_1, {$setThis: $val => result = $val});
}
};
return result
----Swift.(file).SIMD.*infix(_:Self,_:Self)
let _this = this;
let result = _create(_this, 'init', {});
{
let $i$generator = _cloneStruct(result.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set(((function(){throw '!unclarifiedGeneric:Self.Scalar'})()).infix_42(lhs.subscript$get(i_1, {}), rhs.subscript$get(i_1, {}), {}), i_1, {$setThis: $val => result = $val});
}
};
return result
----Swift.(file).SIMD./infix(_:Self,_:Self)
let _this = this;
let result = _create(_this, 'init', {});
{
let $i$generator = _cloneStruct(result.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set(((function(){throw '!unclarifiedGeneric:Self.Scalar'})()).infix_47(lhs.subscript$get(i_1, {}), rhs.subscript$get(i_1, {}), {}), i_1, {$setThis: $val => result = $val});
}
};
return result
----Swift.(file).SIMD.addingProduct(_:Self,_:Self)
let _this = this;
let result = _create(_this.constructor, 'init', {});
{
let $i$generator = _cloneStruct(result.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set(((function(){throw '!unclarifiedGeneric:Self.Scalar'})()).prototype.addingProduct.call(_this.subscript$get(i_1, {}), lhs.subscript$get(i_1, {}), rhs.subscript$get(i_1, {}), {}), i_1, {$setThis: $val => result = $val});
}
};
return result
----Swift.(file).SIMD.squareRoot()
let _this = this;
let result = _create(_this.constructor, 'init', {});
{
let $i$generator = _cloneStruct(result.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set(((function(){throw '!unclarifiedGeneric:Self.Scalar'})()).prototype.squareRoot.call(_this.subscript$get(i_1, {}), {}), i_1, {$setThis: $val => result = $val});
}
};
return result
----Swift.(file).SIMD.rounded(_:FloatingPointRoundingRule)
let _this = this;
let result = _create(_this.constructor, 'init', {});
{
let $i$generator = _cloneStruct(result.indices.makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.subscript$set(((function(){throw '!unclarifiedGeneric:Self.Scalar'})()).prototype.rounded.call(_this.subscript$get(i_1, {}), rule, {}), i_1, {$setThis: $val => result = $val});
}
};
return result
----Swift.(file).SIMDMask..!prefix(_:SIMDMask<Storage>)
let _this = this;
return _create(SIMDMask, 'init', ((function(){throw '!unclarifiedGeneric:Storage'})()).prefix_126(rhs._storage, {}), {})
----Swift.(file).SIMDMask..&infix(_:SIMDMask<Storage>,_:SIMDMask<Storage>)
let _this = this;
return _create(SIMDMask, 'init', (_.arg0 = lhs._storage).constructor.infix_38(_.arg0, rhs._storage, {}), {})
----Swift.(file).SIMDMask..^infix(_:SIMDMask<Storage>,_:SIMDMask<Storage>)
let _this = this;
return _create(SIMDMask, 'init', (_.arg0 = lhs._storage).constructor.infix_94(_.arg0, rhs._storage, {}), {})
----Swift.(file).SIMDMask..|infix(_:SIMDMask<Storage>,_:SIMDMask<Storage>)
let _this = this;
return _create(SIMDMask, 'init', (_.arg0 = lhs._storage).constructor.infix_124(_.arg0, rhs._storage, {}), {})
----Swift.(file).SIMD.&infix(_:Self.Scalar,_:Self)
let _this = this;
return (_.arg0 = _create(_this, 'initRepeating', lhs, {})).constructor.infix_38(_.arg0, rhs, {})
----Swift.(file).SIMD.^infix(_:Self.Scalar,_:Self)
let _this = this;
return (_.arg0 = _create(_this, 'initRepeating', lhs, {})).constructor.infix_94(_.arg0, rhs, {})
----Swift.(file).SIMD.|infix(_:Self.Scalar,_:Self)
let _this = this;
return (_.arg0 = _create(_this, 'initRepeating', lhs, {})).constructor.infix_124(_.arg0, rhs, {})
----Swift.(file).SIMD.&<<infix(_:Self.Scalar,_:Self)
let _this = this;
return (_.arg0 = _create(_this, 'initRepeating', lhs, {})).constructor.infix_38_60_60(_.arg0, rhs, {})
----Swift.(file).SIMD.&>>infix(_:Self.Scalar,_:Self)
let _this = this;
return (_.arg0 = _create(_this, 'initRepeating', lhs, {})).constructor.infix_38_62_62(_.arg0, rhs, {})
----Swift.(file).SIMD.&+infix(_:Self.Scalar,_:Self)
let _this = this;
return (_.arg0 = _create(_this, 'initRepeating', lhs, {})).constructor.infix_38_43(_.arg0, rhs, {})
----Swift.(file).SIMD.&-infix(_:Self.Scalar,_:Self)
let _this = this;
return (_.arg0 = _create(_this, 'initRepeating', lhs, {})).constructor.infix_38_45(_.arg0, rhs, {})
----Swift.(file).SIMD.&*infix(_:Self.Scalar,_:Self)
let _this = this;
return (_.arg0 = _create(_this, 'initRepeating', lhs, {})).constructor.infix_38_42(_.arg0, rhs, {})
----Swift.(file).SIMD./infix(_:Self.Scalar,_:Self)
let _this = this;
return (_.arg0 = _create(_this, 'initRepeating', lhs, {})).constructor.infix_47(_.arg0, rhs, {})
----Swift.(file).SIMD.%infix(_:Self.Scalar,_:Self)
let _this = this;
return (_.arg0 = _create(_this, 'initRepeating', lhs, {})).constructor.infix_37(_.arg0, rhs, {})
----Swift.(file).SIMD.&infix(_:Self,_:Self.Scalar)
let _this = this;
return (_.arg0 = lhs).constructor.infix_38(_.arg0, _create(_this, 'initRepeating', rhs, {}), {})
----Swift.(file).SIMD.^infix(_:Self,_:Self.Scalar)
let _this = this;
return (_.arg0 = lhs).constructor.infix_94(_.arg0, _create(_this, 'initRepeating', rhs, {}), {})
----Swift.(file).SIMD.|infix(_:Self,_:Self.Scalar)
let _this = this;
return (_.arg0 = lhs).constructor.infix_124(_.arg0, _create(_this, 'initRepeating', rhs, {}), {})
----Swift.(file).SIMD.&<<infix(_:Self,_:Self.Scalar)
let _this = this;
return (_.arg0 = lhs).constructor.infix_38_60_60(_.arg0, _create(_this, 'initRepeating', rhs, {}), {})
----Swift.(file).SIMD.&>>infix(_:Self,_:Self.Scalar)
let _this = this;
return (_.arg0 = lhs).constructor.infix_38_62_62(_.arg0, _create(_this, 'initRepeating', rhs, {}), {})
----Swift.(file).SIMD.&+infix(_:Self,_:Self.Scalar)
let _this = this;
return (_.arg0 = lhs).constructor.infix_38_43(_.arg0, _create(_this, 'initRepeating', rhs, {}), {})
----Swift.(file).SIMD.&-infix(_:Self,_:Self.Scalar)
let _this = this;
return (_.arg0 = lhs).constructor.infix_38_45(_.arg0, _create(_this, 'initRepeating', rhs, {}), {})
----Swift.(file).SIMD.&*infix(_:Self,_:Self.Scalar)
let _this = this;
return (_.arg0 = lhs).constructor.infix_38_42(_.arg0, _create(_this, 'initRepeating', rhs, {}), {})
----Swift.(file).SIMD./infix(_:Self,_:Self.Scalar)
let _this = this;
return (_.arg0 = lhs).constructor.infix_47(_.arg0, _create(_this, 'initRepeating', rhs, {}), {})
----Swift.(file).SIMD.%infix(_:Self,_:Self.Scalar)
let _this = this;
return (_.arg0 = lhs).constructor.infix_37(_.arg0, _create(_this, 'initRepeating', rhs, {}), {})
----Swift.(file).SIMD.&=infix(_:Self,_:Self)
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs = (_.arg0 = lhs).constructor.infix_38(_.arg0, rhs, {});})()
lhs$inout.set(lhs)
return $result
----Swift.(file).SIMD.^=infix(_:Self,_:Self)
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs = (_.arg0 = lhs).constructor.infix_94(_.arg0, rhs, {});})()
lhs$inout.set(lhs)
return $result
----Swift.(file).SIMD.|=infix(_:Self,_:Self)
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs = (_.arg0 = lhs).constructor.infix_124(_.arg0, rhs, {});})()
lhs$inout.set(lhs)
return $result
----Swift.(file).SIMD.&<<=infix(_:Self,_:Self)
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs = (_.arg0 = lhs).constructor.infix_38_60_60(_.arg0, rhs, {});})()
lhs$inout.set(lhs)
return $result
----Swift.(file).SIMD.&>>=infix(_:Self,_:Self)
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs = (_.arg0 = lhs).constructor.infix_38_62_62(_.arg0, rhs, {});})()
lhs$inout.set(lhs)
return $result
----Swift.(file).SIMD.&+=infix(_:Self,_:Self)
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs = (_.arg0 = lhs).constructor.infix_38_43(_.arg0, rhs, {});})()
lhs$inout.set(lhs)
return $result
----Swift.(file).SIMD.&-=infix(_:Self,_:Self)
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs = (_.arg0 = lhs).constructor.infix_38_45(_.arg0, rhs, {});})()
lhs$inout.set(lhs)
return $result
----Swift.(file).SIMD.&*=infix(_:Self,_:Self)
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs = (_.arg0 = lhs).constructor.infix_38_42(_.arg0, rhs, {});})()
lhs$inout.set(lhs)
return $result
----Swift.(file).SIMD./=infix(_:Self,_:Self)
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs = (_.arg0 = lhs).constructor.infix_47(_.arg0, rhs, {});})()
lhs$inout.set(lhs)
return $result
----Swift.(file).SIMD.%=infix(_:Self,_:Self)
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs = (_.arg0 = lhs).constructor.infix_37(_.arg0, rhs, {});})()
lhs$inout.set(lhs)
return $result
----Swift.(file).SIMD.&=infix(_:Self,_:Self.Scalar)
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs = (_.arg0 = lhs).constructor.infix_38(_.arg0, rhs, {});})()
lhs$inout.set(lhs)
return $result
----Swift.(file).SIMD.^=infix(_:Self,_:Self.Scalar)
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs = (_.arg0 = lhs).constructor.infix_94(_.arg0, rhs, {});})()
lhs$inout.set(lhs)
return $result
----Swift.(file).SIMD.|=infix(_:Self,_:Self.Scalar)
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs = (_.arg0 = lhs).constructor.infix_124(_.arg0, rhs, {});})()
lhs$inout.set(lhs)
return $result
----Swift.(file).SIMD.&<<=infix(_:Self,_:Self.Scalar)
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs = (_.arg0 = lhs).constructor.infix_38_60_60(_.arg0, rhs, {});})()
lhs$inout.set(lhs)
return $result
----Swift.(file).SIMD.&>>=infix(_:Self,_:Self.Scalar)
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs = (_.arg0 = lhs).constructor.infix_38_62_62(_.arg0, rhs, {});})()
lhs$inout.set(lhs)
return $result
----Swift.(file).SIMD.&+=infix(_:Self,_:Self.Scalar)
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs = (_.arg0 = lhs).constructor.infix_38_43(_.arg0, rhs, {});})()
lhs$inout.set(lhs)
return $result
----Swift.(file).SIMD.&-=infix(_:Self,_:Self.Scalar)
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs = (_.arg0 = lhs).constructor.infix_38_45(_.arg0, rhs, {});})()
lhs$inout.set(lhs)
return $result
----Swift.(file).SIMD.&*=infix(_:Self,_:Self.Scalar)
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs = (_.arg0 = lhs).constructor.infix_38_42(_.arg0, rhs, {});})()
lhs$inout.set(lhs)
return $result
----Swift.(file).SIMD./=infix(_:Self,_:Self.Scalar)
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs = (_.arg0 = lhs).constructor.infix_47(_.arg0, rhs, {});})()
lhs$inout.set(lhs)
return $result
----Swift.(file).SIMD.%=infix(_:Self,_:Self.Scalar)
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs = (_.arg0 = lhs).constructor.infix_37(_.arg0, rhs, {});})()
lhs$inout.set(lhs)
return $result
----Swift.(file).SIMD.+infix(_:Self,_:Self)
let _this = this;
fatalErrorFileLine(() => String()/*!default_value*/, '?3', '?3', {})
----Swift.(file).SIMD.-infix(_:Self,_:Self)
let _this = this;
fatalErrorFileLine(() => String()/*!default_value*/, '?3', '?3', {})
----Swift.(file).SIMD.*infix(_:Self,_:Self)
let _this = this;
fatalErrorFileLine(() => String()/*!default_value*/, '?3', '?3', {})
----Swift.(file).SIMD.+infix(_:Self,_:Self.Scalar)
let _this = this;
fatalErrorFileLine(() => String()/*!default_value*/, '?3', '?3', {})
----Swift.(file).SIMD.-infix(_:Self,_:Self.Scalar)
let _this = this;
fatalErrorFileLine(() => String()/*!default_value*/, '?3', '?3', {})
----Swift.(file).SIMD.*infix(_:Self,_:Self.Scalar)
let _this = this;
fatalErrorFileLine(() => String()/*!default_value*/, '?3', '?3', {})
----Swift.(file).SIMD.+infix(_:Self.Scalar,_:Self)
let _this = this;
fatalErrorFileLine(() => String()/*!default_value*/, '?3', '?3', {})
----Swift.(file).SIMD.-infix(_:Self.Scalar,_:Self)
let _this = this;
fatalErrorFileLine(() => String()/*!default_value*/, '?3', '?3', {})
----Swift.(file).SIMD.*infix(_:Self.Scalar,_:Self)
let _this = this;
fatalErrorFileLine(() => String()/*!default_value*/, '?3', '?3', {})
----Swift.(file).SIMD.+=infix(_:Self,_:Self)
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
fatalErrorFileLine(() => String()/*!default_value*/, '?3', '?3', {});})()
lhs$inout.set(lhs)
return $result
----Swift.(file).SIMD.-=infix(_:Self,_:Self)
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
fatalErrorFileLine(() => String()/*!default_value*/, '?3', '?3', {});})()
lhs$inout.set(lhs)
return $result
----Swift.(file).SIMD.*=infix(_:Self,_:Self)
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
fatalErrorFileLine(() => String()/*!default_value*/, '?3', '?3', {});})()
lhs$inout.set(lhs)
return $result
----Swift.(file).SIMD.+=infix(_:Self,_:Self.Scalar)
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
fatalErrorFileLine(() => String()/*!default_value*/, '?3', '?3', {});})()
lhs$inout.set(lhs)
return $result
----Swift.(file).SIMD.-=infix(_:Self,_:Self.Scalar)
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
fatalErrorFileLine(() => String()/*!default_value*/, '?3', '?3', {});})()
lhs$inout.set(lhs)
return $result
----Swift.(file).SIMD.*=infix(_:Self,_:Self.Scalar)
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
fatalErrorFileLine(() => String()/*!default_value*/, '?3', '?3', {});})()
lhs$inout.set(lhs)
return $result
----Swift.(file).SIMD.-prefix(_:Self)
let _this = this;
return (_.arg0 = rhs).constructor.infix_45(0, _.arg0, {})
----Swift.(file).SIMD.+infix(_:Self.Scalar,_:Self)
let _this = this;
return (_.arg0 = _create(_this, 'initRepeating', lhs, {})).constructor.infix_43(_.arg0, rhs, {})
----Swift.(file).SIMD.-infix(_:Self.Scalar,_:Self)
let _this = this;
return (_.arg0 = _create(_this, 'initRepeating', lhs, {})).constructor.infix_45(_.arg0, rhs, {})
----Swift.(file).SIMD.*infix(_:Self.Scalar,_:Self)
let _this = this;
return (_.arg0 = _create(_this, 'initRepeating', lhs, {})).constructor.infix_42(_.arg0, rhs, {})
----Swift.(file).SIMD./infix(_:Self.Scalar,_:Self)
let _this = this;
return (_.arg0 = _create(_this, 'initRepeating', lhs, {})).constructor.infix_47(_.arg0, rhs, {})
----Swift.(file).SIMD.+infix(_:Self,_:Self.Scalar)
let _this = this;
return (_.arg0 = lhs).constructor.infix_43(_.arg0, _create(_this, 'initRepeating', rhs, {}), {})
----Swift.(file).SIMD.-infix(_:Self,_:Self.Scalar)
let _this = this;
return (_.arg0 = lhs).constructor.infix_45(_.arg0, _create(_this, 'initRepeating', rhs, {}), {})
----Swift.(file).SIMD.*infix(_:Self,_:Self.Scalar)
let _this = this;
return (_.arg0 = lhs).constructor.infix_42(_.arg0, _create(_this, 'initRepeating', rhs, {}), {})
----Swift.(file).SIMD./infix(_:Self,_:Self.Scalar)
let _this = this;
return (_.arg0 = lhs).constructor.infix_47(_.arg0, _create(_this, 'initRepeating', rhs, {}), {})
----Swift.(file).SIMD.+=infix(_:Self,_:Self)
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs = (_.arg0 = lhs).constructor.infix_43(_.arg0, rhs, {});})()
lhs$inout.set(lhs)
return $result
----Swift.(file).SIMD.-=infix(_:Self,_:Self)
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs = (_.arg0 = lhs).constructor.infix_45(_.arg0, rhs, {});})()
lhs$inout.set(lhs)
return $result
----Swift.(file).SIMD.*=infix(_:Self,_:Self)
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs = (_.arg0 = lhs).constructor.infix_42(_.arg0, rhs, {});})()
lhs$inout.set(lhs)
return $result
----Swift.(file).SIMD./=infix(_:Self,_:Self)
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs = (_.arg0 = lhs).constructor.infix_47(_.arg0, rhs, {});})()
lhs$inout.set(lhs)
return $result
----Swift.(file).SIMD.+=infix(_:Self,_:Self.Scalar)
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs = (_.arg0 = lhs).constructor.infix_43(_.arg0, rhs, {});})()
lhs$inout.set(lhs)
return $result
----Swift.(file).SIMD.-=infix(_:Self,_:Self.Scalar)
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs = (_.arg0 = lhs).constructor.infix_45(_.arg0, rhs, {});})()
lhs$inout.set(lhs)
return $result
----Swift.(file).SIMD.*=infix(_:Self,_:Self.Scalar)
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs = (_.arg0 = lhs).constructor.infix_42(_.arg0, rhs, {});})()
lhs$inout.set(lhs)
return $result
----Swift.(file).SIMD./=infix(_:Self,_:Self.Scalar)
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs = (_.arg0 = lhs).constructor.infix_47(_.arg0, rhs, {});})()
lhs$inout.set(lhs)
return $result
----Swift.(file).SIMD.addingProduct(_:Self.Scalar,_:Self)
let _this = this;
return _this.addingProduct(_create(_this.constructor, 'initRepeating', lhs, {}), rhs, {})
----Swift.(file).SIMD.addingProduct(_:Self,_:Self.Scalar)
let _this = this;
return _this.addingProduct(lhs, _create(_this.constructor, 'initRepeating', rhs, {}), {})
----Swift.(file).SIMD.addProduct(_:Self,_:Self)
let _this = this;
$info.$setThis(_this = _cloneStruct(_this.addingProduct(lhs, rhs, {})))
----Swift.(file).SIMD.addProduct(_:Self.Scalar,_:Self)
let _this = this;
$info.$setThis(_this = _cloneStruct(_this.addingProduct(lhs, rhs, {})))
----Swift.(file).SIMD.addProduct(_:Self,_:Self.Scalar)
let _this = this;
$info.$setThis(_this = _cloneStruct(_this.addingProduct(lhs, rhs, {})))
----Swift.(file).SIMD.formSquareRoot()
let _this = this;
$info.$setThis(_this = _cloneStruct(_this.squareRoot( {})))
----Swift.(file).SIMD.round(_:FloatingPointRoundingRule)
let _this = this;
$info.$setThis(_this = _cloneStruct(_this.rounded(rule, {})))
----Swift.(file).SIMDMask..&infix(_:Bool,_:SIMDMask<Storage>)
let _this = this;
return SIMDMask.infix_46_38(_create(SIMDMask, 'initRepeating', lhs, {}), rhs, {})
----Swift.(file).SIMDMask..^infix(_:Bool,_:SIMDMask<Storage>)
let _this = this;
return SIMDMask.infix_46_94(_create(SIMDMask, 'initRepeating', lhs, {}), rhs, {})
----Swift.(file).SIMDMask..|infix(_:Bool,_:SIMDMask<Storage>)
let _this = this;
return SIMDMask.infix_46_124(_create(SIMDMask, 'initRepeating', lhs, {}), rhs, {})
----Swift.(file).SIMDMask..&infix(_:SIMDMask<Storage>,_:Bool)
let _this = this;
return SIMDMask.infix_46_38(lhs, _create(SIMDMask, 'initRepeating', rhs, {}), {})
----Swift.(file).SIMDMask..^infix(_:SIMDMask<Storage>,_:Bool)
let _this = this;
return SIMDMask.infix_46_94(lhs, _create(SIMDMask, 'initRepeating', rhs, {}), {})
----Swift.(file).SIMDMask..|infix(_:SIMDMask<Storage>,_:Bool)
let _this = this;
return SIMDMask.infix_46_124(lhs, _create(SIMDMask, 'initRepeating', rhs, {}), {})
----Swift.(file).SIMDMask..&=infix(_:SIMDMask<Storage>,_:SIMDMask<Storage>)
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs = _cloneStruct(SIMDMask.infix_46_38(lhs, rhs, {}));})()
lhs$inout.set(lhs)
return $result
----Swift.(file).SIMDMask..^=infix(_:SIMDMask<Storage>,_:SIMDMask<Storage>)
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs = _cloneStruct(SIMDMask.infix_46_94(lhs, rhs, {}));})()
lhs$inout.set(lhs)
return $result
----Swift.(file).SIMDMask..|=infix(_:SIMDMask<Storage>,_:SIMDMask<Storage>)
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs = _cloneStruct(SIMDMask.infix_46_124(lhs, rhs, {}));})()
lhs$inout.set(lhs)
return $result
----Swift.(file).SIMDMask..&=infix(_:SIMDMask<Storage>,_:Bool)
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs = _cloneStruct(SIMDMask.infix_46_38(lhs, rhs, {}));})()
lhs$inout.set(lhs)
return $result
----Swift.(file).SIMDMask..^=infix(_:SIMDMask<Storage>,_:Bool)
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs = _cloneStruct(SIMDMask.infix_46_94(lhs, rhs, {}));})()
lhs$inout.set(lhs)
return $result
----Swift.(file).SIMDMask..|=infix(_:SIMDMask<Storage>,_:Bool)
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs = _cloneStruct(SIMDMask.infix_46_124(lhs, rhs, {}));})()
lhs$inout.set(lhs)
return $result
----Swift.(file).Sequence.makeIterator()
let _this = this;
return _this
----Swift.(file).DropFirstSequence.SubSequence

----Swift.(file).DropFirstSequence.makeIterator()
let _this = this;
let it = _this._base.makeIterator( {});
let dropped = 0;
while(true){
if(!((Int.infix_60(dropped, _this._limit, {})) && (Optional.wrappedNotEqualsOptionalNilComparisonType(it.next( {$setThis: $val => it = $val}), _create(_OptionalNilComparisonType, 'initNilLiteraltuple_type', {}), {})))) break
Int.infix_38_43_61({get: () => dropped, set: $val => dropped = $val}, 1, {});
};
return it
----Swift.(file).DropFirstSequence.dropFirst(_:Int)
let _this = this;
return _create(DropFirstSequence, 'initDroppingInt', _this._base, Int.infix_43(_this._limit, k, {}), {})
----Swift.(file).PrefixSequence.Iterator.init(_:Base.Iterator,maxLength:Int)
let _this = this;
_this._base = base;
_this._remaining = maxLength;
return
----Swift.(file).PrefixSequence.Iterator.next()
let _this = this;
if((Int.infix_33_61(_this._remaining, 0, {}))) {
Int.infix_38_45_61({get: () => _this._remaining, set: $val => _this._remaining = $val}, 1, {});
return _this._base.next( {$setThis: $val => _this._base = $val});
}
else {
return Optional.none;
}
----Swift.(file).PrefixSequence.makeIterator()
let _this = this;
return _create(PrefixSequence.Iterator, 'initMaxLengthInt', _this._base.makeIterator( {}), _this._maxLength, {})
----Swift.(file).PrefixSequence.prefix(_:Int)
let _this = this;
const _length = /*dot_syntax_base_ignored*/min(maxLength, _this._maxLength, {});
return _create(PrefixSequence, 'initMaxLengthInt', _this._base, _length, {})
----Swift.(file).DropWhileSequence.init(iterator:Base.Iterator,predicate:(Base.Element) throws -> Bool)
let _this = this;
_this._iterator = iterator;
_this._nextElement = _this._iterator.next( {$setThis: $val => _this._iterator = $val});
while(true){
const $ifLet0, x_1
if(!((($ifLet0 = _this._nextElement)||true) && $ifLet0.rawValue == 'some' && ((x_1 = $ifLet0[0])||true) && (predicate(x_1, {})))) break
_this._nextElement = _this._iterator.next( {$setThis: $val => _this._iterator = $val});
};
return
----Swift.(file).DropWhileSequence.init(_:Base,predicate:(Base.Element) throws -> Bool)
let _this = this;
$info.$setThis(_this = _cloneStruct(_cloneStruct(_create(DropWhileSequence, 'initIteratorPredicatefunction_type', base.makeIterator( {}), predicate, {}))));
return
----Swift.(file).DropWhileSequence.Iterator.init(_:Base.Iterator,nextElement:DropWhileSequence<Base>.Iterator.Element?)
let _this = this;
_this._iterator = iterator;
_this._nextElement = nextElement;
return
----Swift.(file).DropWhileSequence.Iterator.next()
let _this = this;
const $ifLet0, next_1
if(!((($ifLet0 = _this._nextElement)||true) && $ifLet0.rawValue == 'some' && ((next_1 = $ifLet0[0])||true))) {
return Optional.none;
};
_this._nextElement = _this._iterator.next( {$setThis: $val => _this._iterator = $val});
return _injectIntoOptional(next_1)
----Swift.(file).DropWhileSequence.makeIterator()
let _this = this;
return _create(DropWhileSequence.Iterator, 'initNextElementOptional', _this._iterator, _this._nextElement, {})
----Swift.(file).DropWhileSequence.drop(while:(Base.Element) throws -> Bool)
let _this = this;
const $ifLet0, x_1
if(!((($ifLet0 = _this._nextElement)||true) && $ifLet0.rawValue == 'some' && ((x_1 = $ifLet0[0])||true) && (predicate(x_1, {})))) {
return _this;
};
return _create(DropWhileSequence, 'initIteratorPredicatefunction_type', _this._iterator, predicate, {})
----Swift.(file).Sequence.map(_:(Self.Element) throws -> T)
let _this = this;
const initialCapacity = _this.underestimatedCount;
let result = _create(ContiguousArray, 'init', {});
let iterator = _this.makeIterator( {});
{
let $generator = _cloneStruct(Int.infix_46_46_60(0, initialCapacity, {}).makeIterator( {}));
while(true) {
const $ifLet0;
if(!((($ifLet0 = $generator.next( {$setThis: $val => $generator = $val}))||true) && $ifLet0.rawValue == 'some')) break
result.append(transform(iterator.next( {$setThis: $val => iterator = $val})[0], {}), {$setThis: $val => result = $val});
}
};
while(true){
const $ifLet1, _element_2
if(!((($ifLet1 = iterator.next( {$setThis: $val => iterator = $val}))||true) && $ifLet1.rawValue == 'some' && ((_element_2 = $ifLet1[0])||true))) break
result.append(transform(_element_2, {}), {$setThis: $val => result = $val});
};
return _create(Array, 'initBuffer', result, {})
----Swift.(file).Sequence.filter(_:(Self.Element) throws -> Bool)
let _this = this;
return _this._filter(isIncluded, {})
----Swift.(file).Sequence.underestimatedCount
let _this = this;
return 0
----Swift.(file).Sequence.forEach(_:(Self.Element) throws -> Void)
let _this = this;
{
let $element$generator = _this.makeIterator( {});
while(true) {
const $ifLet0, _element_1;
if(!((($ifLet0 = $element$generator.next( {$setThis: $val => $element$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((_element_1 = $ifLet0[0])||true))) break
body(_element_1, {});
}
}
----Swift.(file).Sequence.first(where:(Self.Element) throws -> Bool)
let _this = this;
{
let $element$generator = _this.makeIterator( {});
while(true) {
const $ifLet0, _element_1;
if(!((($ifLet0 = $element$generator.next( {$setThis: $val => $element$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((_element_1 = $ifLet0[0])||true))) break
if((predicate(_element_1, {}))) {
return _injectIntoOptional(_element_1);
};
}
};
return Optional.none
----Swift.(file).Sequence.split(separator:Self.Element,maxSplits:Int,omittingEmptySubsequences:Bool)
let _this = this;
return _this.splitMaxSplitsOmittingEmptySubsequencesWhereSeparator(maxSplits, omittingEmptySubsequences, (($0, $info?) => (_.arg0 = $0).constructor.infix_61_61(_.arg0, separator, {})), {})
----Swift.(file).Sequence.split(maxSplits:Int,omittingEmptySubsequences:Bool,whereSeparator:(Self.Element) throws -> Bool)
let _this = this;
preconditionFileLine(() => Int.infix_62_61(maxSplits, 0, {}), () => "Must take zero or more splits", '?3', '?3', {});
const whole = _create(Array, 'initBuffer', _this, {});
return whole.splitMaxSplitsOmittingEmptySubsequencesWhereSeparator(maxSplits, omittingEmptySubsequences, isSeparator, {})
----Swift.(file).Sequence.suffix(_:Int)
let _this = this;
preconditionFileLine(() => Int.infix_62_61(maxLength, 0, {}), () => "Can't take a suffix of negative length from a sequence", '?3', '?3', {});
if(!((Int.infix_33_61(maxLength, 0, {})))) {
return _create(Array, 'initArrayLiteralArray', [], {});
};
let ringBuffer = _create(ContiguousArray, 'init', {});
let i = 0;
{
let $element$generator = _this.makeIterator( {});
while(true) {
const $ifLet0, _element_1;
if(!((($ifLet0 = $element$generator.next( {$setThis: $val => $element$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((_element_1 = $ifLet0[0])||true))) break
if((Int.infix_60(ringBuffer.count, maxLength, {}))) {
ringBuffer.append(_element_1, {$setThis: $val => ringBuffer = $val});
}
else {
ringBuffer.subscript$set(_element_1, i, {$setThis: $val => ringBuffer = $val});
i = Int.infix_37(Int.infix_43(i, 1, {}), maxLength, {});
};
}
};
if((Int.infix_33_61(i, ringBuffer.startIndex, {}))) {
let rotated = _create(ContiguousArray, 'init', {});
ContiguousArray.infix_43_61({get: () => rotated, set: $val => rotated = $val}, ringBuffer.subscriptRange$get(Int.infix_46_46_60(i, ringBuffer.endIndex, {}), {}), {});
ContiguousArray.infix_43_61({get: () => rotated, set: $val => rotated = $val}, ringBuffer.subscriptRange$get(Int.infix_46_46_60(0, i, {}), {}), {});
return _create(Array, 'initBuffer', rotated, {});
}
else {
return _create(Array, 'initBuffer', ringBuffer, {});
}
----Swift.(file).Sequence.dropFirst(_:Int)
let _this = this;
return _create(DropFirstSequence, 'initDroppingInt', _this, k, {})
----Swift.(file).Sequence.dropLast(_:Int)
let _this = this;
preconditionFileLine(() => Int.infix_62_61(k, 0, {}), () => "Can't drop a negative number of elements from a sequence", '?3', '?3', {});
if(!((Int.infix_33_61(k, 0, {})))) {
return _create(Array, 'initBuffer', _this, {});
};
let result = _create(ContiguousArray, 'init', {});
let ringBuffer = _create(ContiguousArray, 'init', {});
let i = ringBuffer.startIndex;
{
let $element$generator = _this.makeIterator( {});
while(true) {
const $ifLet0, _element_1;
if(!((($ifLet0 = $element$generator.next( {$setThis: $val => $element$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((_element_1 = $ifLet0[0])||true))) break
if((Int.infix_60(ringBuffer.count, k, {}))) {
ringBuffer.append(_element_1, {$setThis: $val => ringBuffer = $val});
}
else {
result.append(ringBuffer.subscript$get(i, {}), {$setThis: $val => result = $val});
ringBuffer.subscript$set(_element_1, i, {$setThis: $val => ringBuffer = $val});
i = Int.infix_37(Int.infix_43(i, 1, {}), k, {});
};
}
};
return _create(Array, 'initBuffer', result, {})
----Swift.(file).Sequence.drop(while:(Self.Element) throws -> Bool)
let _this = this;
return _create(DropWhileSequence, 'initPredicatefunction_type', _this, predicate, {})
----Swift.(file).Sequence.prefix(_:Int)
let _this = this;
return _create(PrefixSequence, 'initMaxLengthInt', _this, maxLength, {})
----Swift.(file).Sequence.prefix(while:(Self.Element) throws -> Bool)
let _this = this;
let result = _create(ContiguousArray, 'init', {});
{
let $element$generator = _this.makeIterator( {});
while(true) {
const $ifLet0, _element_1;
if(!((($ifLet0 = $element$generator.next( {$setThis: $val => $element$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((_element_1 = $ifLet0[0])||true))) break
if(!((predicate(_element_1, {})))) {
break;
};
result.append(_element_1, {$setThis: $val => result = $val});
}
};
return _create(Array, 'initBuffer', result, {})
----Swift.(file).Sequence.withContiguousStorageIfAvailable(_:(UnsafeBufferPointer<Self.Element>) throws -> R)
let _this = this;
return Optional.none
----Swift.(file).IteratorSequence.init(_:Base)
let _this = this;
_this._base = base;
return
----Swift.(file).IteratorSequence.next()
let _this = this;
return _this._base.next( {$setThis: $val => _this._base = $val})
----Swift.(file).Sequence.enumerated()
let _this = this;
return _create(EnumeratedSequence, 'init_base', _this, {})
----Swift.(file).Sequence.min(by:(Self.Element, Self.Element) throws -> Bool)
let _this = this;
let it = _this.makeIterator( {});
const $ifLet0, result_1
if(!((($ifLet0 = it.next( {$setThis: $val => it = $val}))||true) && $ifLet0.rawValue == 'some' && ((result_1 = $ifLet0[0])||true))) {
return Optional.none;
};
while(true){
const $ifLet2, e_3
if(!((($ifLet2 = it.next( {$setThis: $val => it = $val}))||true) && $ifLet2.rawValue == 'some' && ((e_3 = $ifLet2[0])||true))) break
if((areInIncreasingOrder(e_3, result_1, {}))) {
result_1 = e_3;
};
};
return _injectIntoOptional(result_1)
----Swift.(file).Sequence.max(by:(Self.Element, Self.Element) throws -> Bool)
let _this = this;
let it = _this.makeIterator( {});
const $ifLet0, result_1
if(!((($ifLet0 = it.next( {$setThis: $val => it = $val}))||true) && $ifLet0.rawValue == 'some' && ((result_1 = $ifLet0[0])||true))) {
return Optional.none;
};
while(true){
const $ifLet2, e_3
if(!((($ifLet2 = it.next( {$setThis: $val => it = $val}))||true) && $ifLet2.rawValue == 'some' && ((e_3 = $ifLet2[0])||true))) break
if((areInIncreasingOrder(result_1, e_3, {}))) {
result_1 = e_3;
};
};
return _injectIntoOptional(result_1)
----Swift.(file).Sequence.min()
let _this = this;
return _this.minBy(this.first[0].constructor.infix_60, {})
----Swift.(file).Sequence.max()
let _this = this;
return _this.maxBy(this.first[0].constructor.infix_60, {})
----Swift.(file).Sequence.starts(with:PossiblePrefix,by:(Self.Element, PossiblePrefix.Element) throws -> Bool)
let _this = this;
let possiblePrefixIterator = possiblePrefix.makeIterator( {});
{
let $e0$generator = _this.makeIterator( {});
while(true) {
const $ifLet0, e0_1;
if(!((($ifLet0 = $e0$generator.next( {$setThis: $val => $e0$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((e0_1 = $ifLet0[0])||true))) break
const $ifLet2, e1_3
if((($ifLet2 = possiblePrefixIterator.next( {$setThis: $val => possiblePrefixIterator = $val}))||true) && $ifLet2.rawValue == 'some' && ((e1_3 = $ifLet2[0])||true)) {
if((Bool.prefix_33(areEquivalent(e0_1, e1_3, {}), {}))) {
return false;
};
}
else {
return true;
};
}
};
return Optional.wrappedEqualsOptionalNilComparisonType(possiblePrefixIterator.next( {$setThis: $val => possiblePrefixIterator = $val}), _create(_OptionalNilComparisonType, 'initNilLiteraltuple_type', {}), {})
----Swift.(file).Sequence.starts(with:PossiblePrefix)
let _this = this;
return _this.startsWithBy(possiblePrefix, this.first[0].constructor.infix_61_61, {})
----Swift.(file).Sequence.elementsEqual(_:OtherSequence,by:(Self.Element, OtherSequence.Element) throws -> Bool)
let _this = this;
let iter1 = _this.makeIterator( {});
let iter2 = other.makeIterator( {});
while(true){
if(!((true))) break
const $match = {0: iter1.next( {$setThis: $val => iter1 = $val}), 1: iter2.next( {$setThis: $val => iter2 = $val})}
if((($match[0].rawValue == 'some' && $match[1].rawValue == 'some'))) {
const e1 = $match[0][0]
const e2 = $match[1][0]
if((Bool.prefix_33(areEquivalent(e1, e2, {}), {}))) {
return false;
};
}
else if((($match[0].rawValue == 'some' && $match[1].rawValue == Optional.none.rawValue) || ($match[0].rawValue == Optional.none.rawValue && $match[1].rawValue == 'some'))) {
return false;
}
else if((($match[0].rawValue == Optional.none.rawValue && $match[1].rawValue == Optional.none.rawValue))) {
return true;
};
}
----Swift.(file).Sequence.elementsEqual(_:OtherSequence)
let _this = this;
return _this.elementsEqualBy(other, this.first[0].constructor.infix_61_61, {})
----Swift.(file).Sequence.lexicographicallyPrecedes(_:OtherSequence,by:(Self.Element, Self.Element) throws -> Bool)
let _this = this;
let iter1 = _this.makeIterator( {});
let iter2 = other.makeIterator( {});
while(true){
if(!((true))) break
const $ifLet0, e1_1
if((($ifLet0 = iter1.next( {$setThis: $val => iter1 = $val}))||true) && $ifLet0.rawValue == 'some' && ((e1_1 = $ifLet0[0])||true)) {
const $ifLet2, e2_3
if((($ifLet2 = iter2.next( {$setThis: $val => iter2 = $val}))||true) && $ifLet2.rawValue == 'some' && ((e2_3 = $ifLet2[0])||true)) {
if((areInIncreasingOrder(e1_1, e2_3, {}))) {
return true;
};
if((areInIncreasingOrder(e2_3, e1_1, {}))) {
return false;
};
continue;
};
return false;
};
return Optional.wrappedNotEqualsOptionalNilComparisonType(iter2.next( {$setThis: $val => iter2 = $val}), _create(_OptionalNilComparisonType, 'initNilLiteraltuple_type', {}), {});
}
----Swift.(file).Sequence.lexicographicallyPrecedes(_:OtherSequence)
let _this = this;
return _this.lexicographicallyPrecedesBy(other, this.first[0].constructor.infix_60, {})
----Swift.(file).Sequence.contains(where:(Self.Element) throws -> Bool)
let _this = this;
{
let $e$generator = _this.makeIterator( {});
while(true) {
const $ifLet0, e_1;
if(!((($ifLet0 = $e$generator.next( {$setThis: $val => $e$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((e_1 = $ifLet0[0])||true))) break
if((predicate(e_1, {}))) {
return true;
};
}
};
return false
----Swift.(file).Sequence.allSatisfy(_:(Self.Element) throws -> Bool)
let _this = this;
return Bool.prefix_33(_this.containsWhere((($0, $info?) => Bool.prefix_33(predicate($0, {}), {})), {}), {})
----Swift.(file).Sequence.contains(_:Self.Element)
let _this = this;
const $ifLet0, result_1
if((($ifLet0 = _this._customContainsEquatableElement(_element, {}))||true) && $ifLet0.rawValue == 'some' && ((result_1 = $ifLet0[0])||true)) {
return result_1;
}
else {
return _this.containsWhere((($0, $info?) => (_.arg0 = $0).constructor.infix_61_61(_.arg0, _element, {})), {});
}
----Swift.(file).Sequence.reduce(_:Result,_:(Result, Self.Element) throws -> Result)
let _this = this;
let accumulator = initialResult;
{
let $element$generator = _this.makeIterator( {});
while(true) {
const $ifLet0, _element_1;
if(!((($ifLet0 = $element$generator.next( {$setThis: $val => $element$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((_element_1 = $ifLet0[0])||true))) break
accumulator = nextPartialResult(accumulator, _element_1, {});
}
};
return accumulator
----Swift.(file).Sequence.reduce(into:Result,_:(inout Result, Self.Element) throws -> ())
let _this = this;
let accumulator = initialResult;
{
let $element$generator = _this.makeIterator( {});
while(true) {
const $ifLet0, _element_1;
if(!((($ifLet0 = $element$generator.next( {$setThis: $val => $element$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((_element_1 = $ifLet0[0])||true))) break
updateAccumulatingResult({get: () => accumulator, set: $val => accumulator = $val}, _element_1, {});
}
};
return accumulator
----Swift.(file).Sequence.reversed()
let _this = this;
let result = _create(Array, 'initBuffer', _this, {});
const count = result.count;
{
let $i$generator = _cloneStruct(Int.infix_46_46_60(0, Int.infix_47(count, 2, {}), {}).makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
result.swapAt(i_1, Int.infix_45(count, Int.infix_43(i_1, 1, {}), {}), {$setThis: $val => result = $val});
}
};
return result
----Swift.(file).Sequence.flatMap(_:(Self.Element) throws -> SegmentOfResult)
let _this = this;
let result = _create(Array, 'initArrayLiteralArray', [], {});
{
let $element$generator = _this.makeIterator( {});
while(true) {
const $ifLet0, _element_1;
if(!((($ifLet0 = $element$generator.next( {$setThis: $val => $element$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((_element_1 = $ifLet0[0])||true))) break
result.appendContentsOf(transform(_element_1, {}), {$setThis: $val => result = $val});
}
};
return result
----Swift.(file).Sequence.compactMap(_:(Self.Element) throws -> ElementOfResult?)
let _this = this;
return _this._compactMap(transform, {})
----Swift.(file).SetAlgebra.init(_:S)
let _this = this;
_this.init( {});
{
let $e$generator = sequence.makeIterator( {});
while(true) {
const $ifLet0, e_1;
if(!((($ifLet0 = $e$generator.next( {$setThis: $val => $e$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((e_1 = $ifLet0[0])||true))) break
_this.insert(e_1, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
}
};
return
----Swift.(file).SetAlgebra.subtract(_:Self)
let _this = this;
_this.formIntersection(_this.symmetricDifference(other, {}), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
----Swift.(file).SetAlgebra.isSubset(of:Self)
let _this = this;
return (_.arg0 = _this.intersection(other, {})).constructor.infix_61_61(_.arg0, _this, {})
----Swift.(file).SetAlgebra.isSuperset(of:Self)
let _this = this;
return other.isSubsetOf(_this, {})
----Swift.(file).SetAlgebra.isDisjoint(with:Self)
let _this = this;
return _this.intersection(other, {}).isEmpty
----Swift.(file).SetAlgebra.subtracting(_:Self)
let _this = this;
return _this.intersection(_this.symmetricDifference(other, {}), {})
----Swift.(file).SetAlgebra.isEmpty
let _this = this;
return (_.arg0 = _this).constructor.infix_61_61(_.arg0, _create(_this.constructor, 'init', {}), {})
----Swift.(file).SetAlgebra.isStrictSuperset(of:Self)
let _this = this;
return Bool.infix_38_38(_this.isSupersetOf(other, {}), () => (_.arg0 = _this).constructor.infix_33_61(_.arg0, other, {}), {})
----Swift.(file).SetAlgebra.isStrictSubset(of:Self)
let _this = this;
return other.isStrictSupersetOf(_this, {})
----Swift.(file).SetAlgebra.init(arrayLiteral:[Self.Element])
let _this = this;
_this.initSource(arrayLiteral, {});
return
----Swift.(file).Set.insert(_:ConcreteElement)
let _this = this;
const $tuple = _this.insert(_create(AnyHashable, 'init', newMember, {}), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})/*destructure_tuple_expr (**NULL EXPRESSION**), (**NULL EXPRESSION**)*/, inserted = $tuple && $tuple[0], memberAfterInsert = $tuple && $tuple[1];
return {0: inserted, 1: memberAfterInsert.base}
----Swift.(file).Set.update(with:ConcreteElement)
let _this = this;
return _this.updateWith(_create(AnyHashable, 'init', newMember, {}), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))}).mapSwift((($0, $info?) => $0.base), {})
----Swift.(file).Set.remove(_:ConcreteElement)
let _this = this;
return _this.remove(_create(AnyHashable, 'init', member, {}), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))}).mapSwift((($0, $info?) => $0.base), {})
----Swift.(file)..(error_type).bridged()
let _this = this;
const nsSet;
if((Bool.infix_124_124(infix_61_61_61(_injectIntoOptional(_this._storage), _injectIntoOptional(__RawSetStorage.empty), {}), () => Int.infix_61_61(_this.count, 0, {}), {}))) {
nsSet = _cloneStruct(__RawSetStorage.empty);
}
else {
if((_isBridgedVerbatimToObjectiveC(((function(){throw '!unclarifiedGeneric:Element'})()), {}))) {
nsSet = _cloneStruct(unsafeDowncastTo(_this._storage, _SetStorage, {}));
}
else {
nsSet = _cloneStruct(_create(_SwiftDeferredNSSet, 'init_NativeSet', _this, {}));
}
};
return nsSet
----Swift.(file).__CocoaSet.member(for:__CocoaSet.Index)
let _this = this;
return index._element
----Swift.(file).__CocoaSet.member(for:AnyObject)
let _this = this;
const nss = _cloneStruct(unsafeBitCastTo(_this.object, _NSSet, {}));
return nss.member(_element, {})
----Swift.(file).__CocoaSet.isEqual(to:__CocoaSet)
let _this = this;
return _stdlib_NSObject_isEqual(_this.object, other.object, {})
----Swift.(file).__CocoaSet.startIndex
let _this = this;
const allKeys = _cloneStruct(_stdlib_NSSet_allObjects(_this.object, {}));
return _create(__CocoaSet.Index, 'init__CocoaSetIndexStorageOffsetInt', _create(__CocoaSet.Index.Storage, 'init__CocoaSet_BridgingBuffer', _this, allKeys, {}), 0, {})
----Swift.(file).__CocoaSet.endIndex
let _this = this;
const allKeys = _cloneStruct(_stdlib_NSSet_allObjects(_this.object, {}));
return _create(__CocoaSet.Index, 'init__CocoaSetIndexStorageOffsetInt', _create(__CocoaSet.Index.Storage, 'init__CocoaSet_BridgingBuffer', _this, allKeys, {}), allKeys.count, {})
----Swift.(file).__CocoaSet.index(after:__CocoaSet.Index)
let _this = this;
_this.validate(index, {});
let result = _cloneStruct(index);
Int.infix_43_61({get: () => result._offset, set: $val => result._offset = $val}, 1, {});
return result
----Swift.(file).__CocoaSet.validate(_:__CocoaSet.Index)
let _this = this;
preconditionFileLine(() => infix_61_61_61(_injectIntoOptional(index.storage.base.object), _injectIntoOptional(_this.object), {}), () => "Invalid index", '?3', '?3', {});
preconditionFileLine(() => Int.infix_60(index._offset, index.storage.allKeys.count, {}), () => "Attempt to access endIndex", '?3', '?3', {})
----Swift.(file).__CocoaSet.formIndex(after:__CocoaSet.Index,isUnique:Bool)
let _this = this;
let index = index$inout.get()
const $result = (() => {
_this.validate(index, {});
Int.infix_43_61({get: () => index._offset, set: $val => index._offset = $val}, 1, {});})()
index$inout.set(index)
return $result
----Swift.(file).__CocoaSet.count
let _this = this;
const nss = _cloneStruct(unsafeBitCastTo(_this.object, _NSSet, {}));
return nss.count
----Swift.(file).__CocoaSet.contains(_:AnyObject)
let _this = this;
const nss = _cloneStruct(unsafeBitCastTo(_this.object, _NSSet, {}));
return Optional.wrappedNotEqualsOptionalNilComparisonType(nss.member(_element, {}), _create(_OptionalNilComparisonType, 'initNilLiteraltuple_type', {}), {})
----Swift.(file).__CocoaSet.element(at:__CocoaSet.Index)
let _this = this;
const _element = _injectIntoOptional(i._element);
return _element[0]
----Swift.(file).__CocoaSet.Index.handleBitPattern
let _this = this;
return unsafeBitCastTo(_this.storage, UInt, {})
----Swift.(file).__CocoaSet.Index.age
let _this = this;
return _HashTable.ageFor(_this.storage.base.object, {})
----Swift.(file).__CocoaSet.Index.==infix(_:__CocoaSet.Index,_:__CocoaSet.Index)
let _this = this;
preconditionFileLine(() => infix_61_61_61(_injectIntoOptional(lhs.storage.base.object), _injectIntoOptional(rhs.storage.base.object), {}), () => "Comparing indexes from different sets", '?3', '?3', {});
return Int.infix_61_61(lhs._offset, rhs._offset, {})
----Swift.(file).__CocoaSet.Index.<infix(_:__CocoaSet.Index,_:__CocoaSet.Index)
let _this = this;
preconditionFileLine(() => infix_61_61_61(_injectIntoOptional(lhs.storage.base.object), _injectIntoOptional(rhs.storage.base.object), {}), () => "Comparing indexes from different sets", '?3', '?3', {});
return Int.infix_60(lhs._offset, rhs._offset, {})
----Swift.(file).__CocoaSet.makeIterator()
let _this = this;
return _create(__CocoaSet.Iterator, 'init__CocoaSet', _this, {})
----Swift.(file).__CocoaSet.Iterator.next()
let _this = this;
if((Int.infix_60(_this.itemIndex, 0, {}))) {
return Optional.none;
};
const base = _cloneStruct(_this.base);
if((Int.infix_61_61(_this.itemIndex, _this.itemCount, {}))) {
const stackBufCount = _this._fastEnumerationStackBuf.count;
_this.itemCount = /*dynamic_member_ref_expr*/base.object[0](_this._fastEnumerationStatePtr, _create(UnsafeMutableRawPointer, 'initUnsafeMutablePointer', _this._fastEnumerationStackBufPtr, {}).assumingMemoryBoundTo(AnyObject, {}), stackBufCount, {});
if((Int.infix_61_61(_this.itemCount, 0, {}))) {
_this.itemIndex = -1;
return Optional.none;
};
_this.itemIndex = 0;
};
const itemsPtrUP = _cloneStruct(_create(UnsafeMutableRawPointer, 'initAutoreleasingUnsafeMutablePointer', _this._fastEnumerationState.itemsPtr[0], {}).assumingMemoryBoundTo(AnyObject, {}));
const itemsPtr = _create(_UnmanagedAnyObjectArray, 'initUnsafeMutablePointer', itemsPtrUP, {});
const key = _cloneStruct(itemsPtr.subscript$get(_this.itemIndex, {}));
Int.infix_43_61({get: () => _this.itemIndex, set: $val => _this.itemIndex = $val}, 1, {});
return _injectIntoOptional(key)
----Swift.(file).__EmptySetSingleton.copy(with:<<error type>>)
let _this = this;
return _this
----Swift.(file).__EmptySetSingleton.count
let _this = this;
return 0
----Swift.(file).__EmptySetSingleton.member(_:AnyObject)
let _this = this;
return Optional.none
----Swift.(file).__EmptySetSingleton.objectEnumerator()
let _this = this;
return _create(__SwiftEmptyNSEnumerator, 'init', {})
----Swift.(file)._SetStorage.copy(original:__RawSetStorage)
let _this = this;
return _SetStorage.allocateScaleAgeSeed(original._scale, _injectIntoOptional(original._age), _injectIntoOptional(original._seed), {})
----Swift.(file)._SetStorage.resize(original:__RawSetStorage,capacity:Int,move:Bool)
let _this = this;
const scale = _HashTable.scaleForCapacity(capacity, {});
return _this.allocateScaleAgeSeed(scale, Optional.none, Optional.none, {})
----Swift.(file)._SetStorage.allocate(capacity:Int)
let _this = this;
const scale = _HashTable.scaleForCapacity(capacity, {});
return _this.allocateScaleAgeSeed(scale, Optional.none, Optional.none, {})
----Swift.(file)._SetStorage.convert(_:<<error type>>,capacity:Int)
let _this = this;
const scale = _HashTable.scaleForCapacity(capacity, {});
const age = _HashTable.ageFor(cocoa.object, {});
return _this.allocateScaleAgeSeed(scale, _injectIntoOptional(age), Optional.none, {})
----Swift.(file).Hasher._State.compress(_:UInt64)
let _this = this;
UInt64.infix_94_61({get: () => _this.v3, set: $val => _this.v3 = $val}, m, {});
_this._round( {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
UInt64.infix_94_61({get: () => _this.v0, set: $val => _this.v0 = $val}, m, {})
----Swift.(file).Hasher._State.finalize(tailAndByteCount:UInt64)
let _this = this;
_this.compress(tailAndByteCount, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
UInt64.infix_94_61({get: () => _this.v2, set: $val => _this.v2 = $val}, 0xff, {});
{
let $generator = _cloneStruct(Int.infix_46_46_60(0, 3, {}).makeIterator( {}));
while(true) {
const $ifLet0;
if(!((($ifLet0 = $generator.next( {$setThis: $val => $generator = $val}))||true) && $ifLet0.rawValue == 'some')) break
_this._round( {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
}
};
return _this._extract( {})
----Swift.(file).Hasher._State.init()
let _this = this;
_this.initRawSeedtuple_type(Hasher._executionSeed, {});
return
----Swift.(file).Hasher._State.init(seed:Int)
let _this = this;
const executionSeed = Hasher._executionSeed;
const seed = _create(UInt, 'initBitPatternInt', seed, {});
_this.initRawSeedtuple_type({0: UInt64.infix_94(executionSeed["0"], _create(UInt64, 'initTruncatingIfNeeded', seed, {}), {}), 1: executionSeed["1"]}, {});
return
----Swift.(file).Slice.init(base:Base,bounds:Range<Base.Index>)
let _this = this;
_this._base = base;
_this._startIndex = bounds.lowerBound;
_this._endIndex = bounds.upperBound;
return
----Swift.(file).Slice.base
let _this = this;
return _this._base
----Swift.(file).Slice.SubSequence

----Swift.(file).Slice.Iterator

----Swift.(file).Slice.startIndex
let _this = this;
return _this._startIndex
----Swift.(file).Slice.endIndex
let _this = this;
return _this._endIndex
----Swift.(file).Slice.subscript(_:Slice<Base>.Index)
let _this = this;
return _this._base.subscript$get(index, {})
----Swift.(file).Slice.subscript(_:Range<Slice<Base>.Index>)
let _this = this;
return _create(Slice, 'initBaseBoundsRange', _this._base, bounds, {})
----Swift.(file).Slice.indices
let _this = this;
return _this._base.indices.subscriptRange$get((_.arg0 = _this._startIndex).constructor.infix_46_46_60(_.arg0, _this._endIndex, {}), {})
----Swift.(file).Slice.index(after:Slice<Base>.Index)
let _this = this;
return _this._base.indexAfter(i, {})
----Swift.(file).Slice.formIndex(after:Slice<Base>.Index)
let _this = this;
let i = i$inout.get()
const $result = (() => {
_this._base.formIndexAfter({get: () => i, set: $val => i = $val}, {});})()
i$inout.set(i)
return $result
----Swift.(file).Slice.index(_:Slice<Base>.Index,offsetBy:Int)
let _this = this;
return _this._base.indexOffsetBy(i, n, {})
----Swift.(file).Slice.index(_:Slice<Base>.Index,offsetBy:Int,limitedBy:Slice<Base>.Index)
let _this = this;
return _this._base.indexOffsetByLimitedBy(i, n, limit, {})
----Swift.(file).Slice.distance(from:Slice<Base>.Index,to:Slice<Base>.Index)
let _this = this;
return _this._base.distanceFromTo(start, end, {})
----Swift.(file).Slice.index(before:Slice<Base>.Index)
let _this = this;
return _this._base.indexBefore(i, {})
----Swift.(file).Slice.formIndex(before:Slice<Base>.Index)
let _this = this;
let i = i$inout.get()
const $result = (() => {
_this._base.formIndexBefore({get: () => i, set: $val => i = $val}, {});})()
i$inout.set(i)
return $result
----Swift.(file).Slice.subscript(_:Slice<Base>.Index)#ASS

let _this = this;
_this._base.subscript$set(newValue, index, {$setThis: $val => _this._base = $val})
----Swift.(file).Slice.subscript(_:Slice<Base>.Index)
let _this = this;
return _this._base.subscript$get(index, {});

----Swift.(file).Slice.subscript(_:Range<Slice<Base>.Index>)#ASS

let _this = this;
_writeBackMutableSliceBoundsSlice({get: () => _this, set: $val => $info.$setThis(_this = _cloneStruct($val))}, bounds, newValue, {})
----Swift.(file).Slice.subscript(_:Range<Slice<Base>.Index>)
let _this = this;
return _create(Slice, 'initBaseBoundsRange', _this._base, bounds, {});

----Swift.(file).Slice.init()
let _this = this;
_this._base = _create(((function(){throw '!unclarifiedGeneric:Base'})()), 'init', {});
_this._startIndex = _this._base.startIndex;
_this._endIndex = _this._base.endIndex;
return
----Swift.(file).Slice.init(repeating:Base.Element,count:Int)
let _this = this;
_this._base = _create(((function(){throw '!unclarifiedGeneric:Base'})()), 'initRepeatingCountInt', repeatedValue, count, {});
_this._startIndex = _this._base.startIndex;
_this._endIndex = _this._base.endIndex;
return
----Swift.(file).Slice.init(_:S)
let _this = this;
_this._base = _create(((function(){throw '!unclarifiedGeneric:Base'})()), 'initBuffer', _elements, {});
_this._startIndex = _this._base.startIndex;
_this._endIndex = _this._base.endIndex;
return
----Swift.(file).Slice.replaceSubrange(_:Range<Slice<Base>.Index>,with:C)
let _this = this;
const sliceOffset = _this._base.distanceFromTo(_this._base.startIndex, _this._startIndex, {});
const newSliceCount = Int.infix_43(Int.infix_43(_this._base.distanceFromTo(_this._startIndex, subRange.lowerBound, {}), _this._base.distanceFromTo(subRange.upperBound, _this._endIndex, {}), {}), numericCast(newElements.count, {T: Int, U: Int}), {});
_this._base.replaceSubrangeWith(subRange, newElements, {$setThis: $val => _this._base = $val});
_this._startIndex = _this._base.indexOffsetBy(_this._base.startIndex, sliceOffset, {});
_this._endIndex = _this._base.indexOffsetBy(_this._startIndex, newSliceCount, {})
----Swift.(file).Slice.insert(_:Base.Element,at:Slice<Base>.Index)
let _this = this;
const sliceOffset = _this._base.distanceFromTo(_this._base.startIndex, _this._startIndex, {});
const newSliceCount = Int.infix_43(_this.count, 1, {});
_this._base.insertAt(newElement, i, {$setThis: $val => _this._base = $val});
_this._startIndex = _this._base.indexOffsetBy(_this._base.startIndex, sliceOffset, {});
_this._endIndex = _this._base.indexOffsetBy(_this._startIndex, newSliceCount, {})
----Swift.(file).Slice.insert(contentsOf:S,at:Slice<Base>.Index)
let _this = this;
const sliceOffset = _this._base.distanceFromTo(_this._base.startIndex, _this._startIndex, {});
const newSliceCount = Int.infix_43(_this.count, newElements.count, {});
_this._base.insertContentsOfAt(newElements, i, {$setThis: $val => _this._base = $val});
_this._startIndex = _this._base.indexOffsetBy(_this._base.startIndex, sliceOffset, {});
_this._endIndex = _this._base.indexOffsetBy(_this._startIndex, newSliceCount, {})
----Swift.(file).Slice.remove(at:Slice<Base>.Index)
let _this = this;
const sliceOffset = _this._base.distanceFromTo(_this._base.startIndex, _this._startIndex, {});
const newSliceCount = Int.infix_45(_this.count, 1, {});
const result = _this._base.removeAt(i, {$setThis: $val => _this._base = $val});
_this._startIndex = _this._base.indexOffsetBy(_this._base.startIndex, sliceOffset, {});
_this._endIndex = _this._base.indexOffsetBy(_this._startIndex, newSliceCount, {});
return result
----Swift.(file).Slice.removeSubrange(_:Range<Slice<Base>.Index>)
let _this = this;
const sliceOffset = _this._base.distanceFromTo(_this._base.startIndex, _this._startIndex, {});
const newSliceCount = Int.infix_45(_this.count, _this.distanceFromTo(bounds.lowerBound, bounds.upperBound, {}), {});
_this._base.removeSubrangeRange(bounds, {$setThis: $val => _this._base = $val});
_this._startIndex = _this._base.indexOffsetBy(_this._base.startIndex, sliceOffset, {});
_this._endIndex = _this._base.indexOffsetBy(_this._startIndex, newSliceCount, {})
----Swift.(file).Slice.replaceSubrange(_:Range<Slice<Base>.Index>,with:C)
let _this = this;
if(((_.arg0 = subRange.lowerBound).constructor.infix_61_61(_.arg0, _this._base.startIndex, {}))) {
const newSliceCount = Int.infix_43(Int.infix_43(_this._base.distanceFromTo(_this._startIndex, subRange.lowerBound, {}), _this._base.distanceFromTo(subRange.upperBound, _this._endIndex, {}), {}), numericCast(newElements.count, {T: Int, U: Int}), {});
_this._base.replaceSubrangeWith(subRange, newElements, {$setThis: $val => _this._base = $val});
_this._startIndex = _this._base.startIndex;
_this._endIndex = _this._base.indexOffsetBy(_this._startIndex, newSliceCount, {});
}
else {
const shouldUpdateStartIndex = (_.arg1 = subRange.lowerBound).constructor.infix_61_61(_.arg1, _this._startIndex, {});
const lastValidIndex = _this._base.indexBefore(subRange.lowerBound, {});
const newEndIndexOffset = Int.infix_43(Int.infix_43(_this._base.distanceFromTo(subRange.upperBound, _this._endIndex, {}), numericCast(newElements.count, {T: Int, U: Int}), {}), 1, {});
_this._base.replaceSubrangeWith(subRange, newElements, {$setThis: $val => _this._base = $val});
if((shouldUpdateStartIndex)) {
_this._startIndex = _this._base.indexAfter(lastValidIndex, {});
};
_this._endIndex = _this._base.indexOffsetBy(lastValidIndex, newEndIndexOffset, {});
}
----Swift.(file).Slice.insert(_:Base.Element,at:Slice<Base>.Index)
let _this = this;
if(((_.arg0 = i).constructor.infix_61_61(_.arg0, _this._base.startIndex, {}))) {
const newSliceCount = Int.infix_43(_this.count, 1, {});
_this._base.insertAt(newElement, i, {$setThis: $val => _this._base = $val});
_this._startIndex = _this._base.startIndex;
_this._endIndex = _this._base.indexOffsetBy(_this._startIndex, newSliceCount, {});
}
else {
const shouldUpdateStartIndex = (_.arg1 = i).constructor.infix_61_61(_.arg1, _this._startIndex, {});
const lastValidIndex = _this._base.indexBefore(i, {});
const newEndIndexOffset = Int.infix_43(_this._base.distanceFromTo(i, _this._endIndex, {}), 2, {});
_this._base.insertAt(newElement, i, {$setThis: $val => _this._base = $val});
if((shouldUpdateStartIndex)) {
_this._startIndex = _this._base.indexAfter(lastValidIndex, {});
};
_this._endIndex = _this._base.indexOffsetBy(lastValidIndex, newEndIndexOffset, {});
}
----Swift.(file).Slice.insert(contentsOf:S,at:Slice<Base>.Index)
let _this = this;
if(((_.arg0 = i).constructor.infix_61_61(_.arg0, _this._base.startIndex, {}))) {
const newSliceCount = Int.infix_43(_this.count, numericCast(newElements.count, {T: Int, U: Int}), {});
_this._base.insertContentsOfAt(newElements, i, {$setThis: $val => _this._base = $val});
_this._startIndex = _this._base.startIndex;
_this._endIndex = _this._base.indexOffsetBy(_this._startIndex, newSliceCount, {});
}
else {
const shouldUpdateStartIndex = (_.arg1 = i).constructor.infix_61_61(_.arg1, _this._startIndex, {});
const lastValidIndex = _this._base.indexBefore(i, {});
const newEndIndexOffset = Int.infix_43(Int.infix_43(_this._base.distanceFromTo(i, _this._endIndex, {}), numericCast(newElements.count, {T: Int, U: Int}), {}), 1, {});
_this._base.insertContentsOfAt(newElements, i, {$setThis: $val => _this._base = $val});
if((shouldUpdateStartIndex)) {
_this._startIndex = _this._base.indexAfter(lastValidIndex, {});
};
_this._endIndex = _this._base.indexOffsetBy(lastValidIndex, newEndIndexOffset, {});
}
----Swift.(file).Slice.remove(at:Slice<Base>.Index)
let _this = this;
if(((_.arg0 = i).constructor.infix_61_61(_.arg0, _this._base.startIndex, {}))) {
const newSliceCount = Int.infix_45(_this.count, 1, {});
const result = _this._base.removeAt(i, {$setThis: $val => _this._base = $val});
_this._startIndex = _this._base.startIndex;
_this._endIndex = _this._base.indexOffsetBy(_this._startIndex, newSliceCount, {});
return result;
}
else {
const shouldUpdateStartIndex = (_.arg1 = i).constructor.infix_61_61(_.arg1, _this._startIndex, {});
const lastValidIndex = _this._base.indexBefore(i, {});
const newEndIndexOffset = _this._base.distanceFromTo(i, _this._endIndex, {});
const result = _this._base.removeAt(i, {$setThis: $val => _this._base = $val});
if((shouldUpdateStartIndex)) {
_this._startIndex = _this._base.indexAfter(lastValidIndex, {});
};
_this._endIndex = _this._base.indexOffsetBy(lastValidIndex, newEndIndexOffset, {});
return result;
}
----Swift.(file).Slice.removeSubrange(_:Range<Slice<Base>.Index>)
let _this = this;
if(((_.arg0 = bounds.lowerBound).constructor.infix_61_61(_.arg0, _this._base.startIndex, {}))) {
const newSliceCount = Int.infix_45(_this.count, _this._base.distanceFromTo(bounds.lowerBound, bounds.upperBound, {}), {});
_this._base.removeSubrangeRange(bounds, {$setThis: $val => _this._base = $val});
_this._startIndex = _this._base.startIndex;
_this._endIndex = _this._base.indexOffsetBy(_this._startIndex, newSliceCount, {});
}
else {
const shouldUpdateStartIndex = (_.arg1 = bounds.lowerBound).constructor.infix_61_61(_.arg1, _this._startIndex, {});
const lastValidIndex = _this._base.indexBefore(bounds.lowerBound, {});
const newEndIndexOffset = Int.infix_43(Int.infix_45(_this._base.distanceFromTo(bounds.lowerBound, _this._endIndex, {}), _this._base.distanceFromTo(bounds.lowerBound, bounds.upperBound, {}), {}), 1, {});
_this._base.removeSubrangeRange(bounds, {$setThis: $val => _this._base = $val});
if((shouldUpdateStartIndex)) {
_this._startIndex = _this._base.indexAfter(lastValidIndex, {});
};
_this._endIndex = _this._base.indexOffsetBy(lastValidIndex, newEndIndexOffset, {});
}
----Swift.(file)._SmallBuffer.stride
let _this = this;
return MemoryLayout.stride
----Swift.(file)._SmallBuffer.byteCapacity
let _this = this;
return MemoryLayout.strideOfValue(_this._inlineStorage, {})
----Swift.(file)._SmallBuffer.capacity
let _this = this;
return Int.infix_47(_this.byteCapacity, _this.stride, {})
----Swift.(file)._SmallBuffer.subscript(_:Int)#ASS

let _this = this;
const capacity = _this.capacity;
withUnsafeMutableBytesOf({get: () => _this._inlineStorage, set: $val => _this._inlineStorage = $val}, (($0, $info?) => { 
const rawPtr = _cloneStruct($0.baseAddress._unsafelyUnwrappedUnchecked);
const bufPtr = _create(UnsafeMutableBufferPointer, 'initStartOptionalCountInt', _injectIntoOptional(/*pointer_to_pointer*/rawPtr.assumingMemoryBoundTo(((function(){throw '!unclarifiedGeneric:T'})()), {})), capacity, {});
bufPtr.subscript_unchecked$set(newValue, i, {$setThis: $val => bufPtr = _cloneStruct($val)}); }), {})
----Swift.(file)._SmallBuffer.subscript(_:Int)
let _this = this;
const capacity = _this.capacity;
return withUnsafeBytesOf(_this._inlineStorage, (($0, $info?) => { 
const rawPtr = _cloneStruct($0.baseAddress._unsafelyUnwrappedUnchecked);
const bufPtr = _create(UnsafeBufferPointer, 'initStartOptionalCountInt', _injectIntoOptional(/*pointer_to_pointer*/rawPtr.assumingMemoryBoundTo(((function(){throw '!unclarifiedGeneric:T'})()), {})), capacity, {});
return bufPtr.subscript_unchecked$get(i, {}); }), {});

----Swift.(file)._SmallString.capacity
let _this = this;
return 15;
}
static get capacity() { return this.capacity$get()
----Swift.(file)._SmallString.rawDiscriminatedObject
let _this = this;
return UInt64.prototype.littleEndian$get.call(_this._storage["1"])
----Swift.(file)._SmallString.count
let _this = this;
return _StringObject.getSmallCountFromRaw(_this.rawDiscriminatedObject, {})
----Swift.(file)._SmallString.unusedCapacity
let _this = this;
return Int.infix_38_45(_this.capacity, _this.count, {})
----Swift.(file)._SmallString.isASCII
let _this = this;
return _StringObject.getSmallIsASCIIFromRaw(_this.rawDiscriminatedObject, {})
----Swift.(file)._SmallString.zeroTerminatedRawCodeUnits
let _this = this;
const smallStringCodeUnitMask = UInt64.prefix_126(UInt64.prototype.bigEndian$get.call(0xFF), {});
return {0: _this._storage["0"], 1: UInt64.infix_38(_this._storage["1"], smallStringCodeUnitMask, {})}
----Swift.(file)._SmallString.computeIsASCII()
let _this = this;
const asciiMask = 0x8080808080808080;
const raw = _this.zeroTerminatedRawCodeUnits;
return UInt64.infix_61_61(UInt64.infix_38(UInt64.infix_124(raw["0"], raw["1"], {}), asciiMask, {}), 0, {})
----Swift.(file)._SmallString.startIndex
let _this = this;
return 0
----Swift.(file)._SmallString.endIndex
let _this = this;
return _this.count
----Swift.(file)._SmallString.subscript(_:Int)#ASS

let _this = this;
if((Int.infix_60(idx, 8, {}))) {
_this.leadingRawBits._uncheckedSetByteAtTo(idx, newValue, {$setThis: $val => _this.leadingRawBits = $val});
}
else {
_this.trailingRawBits._uncheckedSetByteAtTo(Int.infix_38_45(idx, 8, {}), newValue, {$setThis: $val => _this.trailingRawBits = $val});
}
----Swift.(file)._SmallString.subscript(_:Int)
let _this = this;
if((Int.infix_60(idx, 8, {}))) {
return UInt64.prototype._uncheckedGetByteAt.call(_this.leadingRawBits, idx, {});
}
else {
return UInt64.prototype._uncheckedGetByteAt.call(_this.trailingRawBits, Int.infix_38_45(idx, 8, {}), {});
};

----Swift.(file)._SmallString.subscript(_:Range<_SmallString.Index>)
let _this = this;
return _this.withUTF8(((utf8, $info?) => { 
const rebased = _create(UnsafeBufferPointer, 'initRebasingSlice', utf8.subscriptRange$get(bounds, {}), {});
return _create(_SmallString, 'initUnsafeBufferPointer', rebased, {})._unsafelyUnwrappedUnchecked; }), {})
----Swift.(file)._SmallString.withUTF8(_:(UnsafeBufferPointer<UInt8>) throws -> Result)
let _this = this;
let raw = _this.zeroTerminatedRawCodeUnits;
return /*dot_syntax_base_ignored*/withUnsafeBytesOf({get: () => raw, set: $val => raw = $val}, ((rawBufPtr, $info?) => { 
const ptr = _cloneStruct(rawBufPtr.baseAddress._unsafelyUnwrappedUnchecked.assumingMemoryBoundTo(UInt8, {}));
return f(_create(UnsafeBufferPointer, 'initStartOptionalCountInt', _injectIntoOptional(/*pointer_to_pointer*/ptr), _this.count, {}), {}); }), {})
----Swift.(file)._SmallString.withMutableCapacity(_:(UnsafeMutableBufferPointer<UInt8>) throws -> Int)
let _this = this;
const len = withUnsafeMutableBytesOf({get: () => _this._storage, set: $val => _this._storage = $val}, ((rawBufPtr, $info?) => { 
const ptr = _cloneStruct(rawBufPtr.baseAddress._unsafelyUnwrappedUnchecked.assumingMemoryBoundTo(UInt8, {}));
return f(_create(UnsafeMutableBufferPointer, 'initStartOptionalCountInt', _injectIntoOptional(/*pointer_to_pointer*/ptr), _SmallString.capacity, {}), {}); }), {});
const $tuple = _this.zeroTerminatedRawCodeUnits, leading = $tuple && $tuple[0], trailing = $tuple && $tuple[1];
$info.$setThis(_this = _cloneStruct(_create(_SmallString, 'initLeadingUInt64TrailingUInt64CountInt', leading, trailing, len, {})))
----Swift.(file)._SmallString.init(leading:UInt64,trailing:UInt64,count:Int)
let _this = this;
const isASCII = UInt64.infix_61_61(UInt64.infix_38(UInt64.infix_124(leading, trailing, {}), 0x8080808080808080, {}), 0, {});
const discriminator = UInt64.prototype.littleEndian$get.call(_StringObject.Nibbles.smallWithCountIsASCII(count, isASCII, {}));
_this.initRaw_SmallStringRawBitPattern({0: leading, 1: UInt64.infix_124(trailing, discriminator, {})}, {});
return
----Swift.(file)._SmallString.init(_:UnsafeBufferPointer<UInt8>)
let _this = this;
if((input.isEmpty)) {
_this.init( {});
return ;
};
const count = input.count;
if(!((Int.infix_60_61(count, _SmallString.capacity, {})))) {
return (this.$failed = true);
};
const ptr = _cloneStruct(input.baseAddress._unsafelyUnwrappedUnchecked);
const leading = _bytesToUInt64(ptr, /*dot_syntax_base_ignored*/min(input.count, 8, {}), {});
const trailing = (Int.infix_62(count, 8, {}) ? _bytesToUInt64(UnsafePointer.infix_43(ptr, 8, {}), Int.infix_38_45(count, 8, {}), {}) : 0);
_this.initLeadingUInt64TrailingUInt64CountInt(leading, trailing, count, {});
return
----Swift.(file)._SmallString.init(_:_SmallString,appending:_SmallString)
let _this = this;
const totalCount = Int.infix_43(base.count, other.count, {});
if(!((Int.infix_60_61(totalCount, _SmallString.capacity, {})))) {
return (this.$failed = true);
};
let result = _cloneStruct(base);
let writeIdx = base.count;
{
let $readIdx$generator = _cloneStruct(Int.infix_46_46_60(0, other.count, {}).makeIterator( {}));
while(true) {
const $ifLet0, readIdx_1;
if(!((($ifLet0 = $readIdx$generator.next( {$setThis: $val => $readIdx$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((readIdx_1 = $ifLet0[0])||true))) break
result.subscript$set(other.subscript$get(readIdx_1, {}), writeIdx, {$setThis: $val => result = $val});
Int.infix_38_43_61({get: () => writeIdx, set: $val => writeIdx = $val}, 1, {});
}
};
const $tuple = result.zeroTerminatedRawCodeUnits, leading = $tuple && $tuple[0], trailing = $tuple && $tuple[1];
_this.initLeadingUInt64TrailingUInt64CountInt(leading, trailing, totalCount, {});
return
----Swift.(file).Sequence.sorted()
let _this = this;
return _this.sortedBy(this.first[0].constructor.infix_60, {})
----Swift.(file).Sequence.sorted(by:(Self.Element, Self.Element) throws -> Bool)
let _this = this;
let result = _create(ContiguousArray, 'initBuffer', _this, {});
result.sortBy(areInIncreasingOrder, {$setThis: $val => result = $val});
return _create(Array, 'initBuffer', result, {})
----Swift.(file).MutableCollection.sort()
let _this = this;
_this.sortBy(this.first[0].constructor.infix_60, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
----Swift.(file).MutableCollection.sort(by:(Self.Element, Self.Element) throws -> Bool)
let _this = this;
const didSortUnsafeBuffer = _this._withUnsafeMutableBufferPointerIfSupported(((buffer$inout, $info?) => _injectIntoOptional(buffer._stableSortImplBy(areInIncreasingOrder, {$setThis: $val => buffer = $val}))), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
if((Optional.wrappedEqualsOptionalNilComparisonType(didSortUnsafeBuffer, _create(_OptionalNilComparisonType, 'initNilLiteraltuple_type', {}), {}))) {
const sortedElements = _cloneStruct(_this.sortedBy(areInIncreasingOrder, {}));
{
let $generator = _cloneStruct(zip(_this.indices, sortedElements.indices, {}).makeIterator( {}));
while(true) {
const $ifLet0, i_1, j_2;
if(!((($ifLet0 = $generator.next( {$setThis: $val => $generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0][0])||true) && ((j_2 = $ifLet0[0][1])||true))) break
_this.subscript$set(sortedElements.subscript$get(j_2, {}), i_1, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
}
};
}
----Swift.(file).StaticString.utf8Start
let _this = this;
preconditionFileLine(() => _this.hasPointerRepresentation, () => "StaticString should have pointer representation", '?3', '?3', {});
return _create(UnsafePointer, 'initBitPatternUInt', _create(UInt, 'initWord', _this._startPtrOrData, {}), {})[0]
----Swift.(file).StaticString.unicodeScalar
let _this = this;
preconditionFileLine(() => Bool.prefix_33(_this.hasPointerRepresentation, {}), () => "StaticString should have Unicode scalar representation", '?3', '?3', {});
return _create(Unicode.Scalar, 'initUInt32', _create(UInt32, 'initT', _create(UInt, 'initWord', _this._startPtrOrData, {}), {}), {})[0]
----Swift.(file).StaticString.utf8CodeUnitCount
let _this = this;
preconditionFileLine(() => _this.hasPointerRepresentation, () => "StaticString should have pointer representation", '?3', '?3', {});
return _create(Int, 'initWord', _this._utf8CodeUnitCount, {})
----Swift.(file).StaticString.hasPointerRepresentation
let _this = this;
return UInt8.infix_61_61(UInt8.infix_38(_create(UInt8, 'initInt8', _this._flags, {}), 0x1, {}), 0, {})
----Swift.(file).StaticString.isASCII
let _this = this;
return UInt8.infix_33_61(UInt8.infix_38(_create(UInt8, 'initInt8', _this._flags, {}), 0x2, {}), 0, {})
----Swift.(file).StaticString.init()
let _this = this;
$info.$setThis(_this = _cloneStruct(_cloneStruct("")));
return
----Swift.(file).StaticString.init(unicodeScalarLiteral:StaticString)
let _this = this;
$info.$setThis(_this = _cloneStruct(_cloneStruct(value)));
return
----Swift.(file).StaticString.init(extendedGraphemeClusterLiteral:StaticString)
let _this = this;
$info.$setThis(_this = _cloneStruct(_cloneStruct(value)));
return
----Swift.(file).StaticString.init(stringLiteral:StaticString)
let _this = this;
$info.$setThis(_this = _cloneStruct(_cloneStruct(value)));
return
----Swift.(file).StaticString.description
let _this = this;
return _this.withUTF8Buffer((($0, $info?) => String._uncheckedFromUTF8($0, {})), {})
----Swift.(file).StaticString.debugDescription
let _this = this;
return _this.description.debugDescription
----Swift.(file).StaticString.customMirror
let _this = this;
return _create(Mirror, 'initReflectingprotocol_composition_type', _this.description, {})
----Swift.(file).Strideable.<infix(_:Self,_:Self)
let _this = this;
return ((function(){throw '!unclarifiedGeneric:Self.Stride'})()).infix_62(x.distanceTo(y, {}), 0, {})
----Swift.(file).Strideable.==infix(_:Self,_:Self)
let _this = this;
return ((function(){throw '!unclarifiedGeneric:Self.Stride'})()).infix_61_61(x.distanceTo(y, {}), 0, {})
----Swift.(file).StrideToIterator.next()
let _this = this;
const result = _this._current["1"];
if(((((function(){throw '!unclarifiedGeneric:Element.Stride'})()).infix_62(_this._stride, 0, {}) ? (_.arg0 = result).constructor.infix_62_61(_.arg0, _this._end, {}) : (_.arg1 = result).constructor.infix_60_61(_.arg1, _this._end, {})))) {
return Optional.none;
};
_this._current = ((function(){throw '!unclarifiedGeneric:Element'})())._stepAfterFromBy(_this._current, _this._start, _this._stride, {});
return _injectIntoOptional(result)
----Swift.(file).StrideTo.makeIterator()
let _this = this;
return _create(StrideToIterator, 'init_startEndStride', _this._start, _this._end, _this._stride, {})
----Swift.(file).StrideTo.underestimatedCount
let _this = this;
let it = _cloneStruct(_this.makeIterator( {}));
let count = 0;
while(true){
if(!((Optional.wrappedNotEqualsOptionalNilComparisonType(it.next( {$setThis: $val => it = $val}), _create(_OptionalNilComparisonType, 'initNilLiteraltuple_type', {}), {})))) break
Int.infix_43_61({get: () => count, set: $val => count = $val}, 1, {});
};
return count
----Swift.(file).StrideTo.customMirror
let _this = this;
return _create(Mirror, 'initChildrenKeyValuePairsDisplayStyleOptionalAncestorRepresentationMirrorAncestorRepresentation', _this, new Map([["from", _this._start], ["to", _this._end], ["by", _this._stride]]), nil/*!default_value*/, .generated/*!default_value*/, {})
----Swift.(file).stride(from:T,to:T,by:T.Stride)
return _create(StrideTo, 'init_startEndStride', start, end, stride, {})
----Swift.(file).StrideThroughIterator.next()
let _this = this;
const result = _this._current["1"];
if(((((function(){throw '!unclarifiedGeneric:Element.Stride'})()).infix_62(_this._stride, 0, {}) ? (_.arg0 = result).constructor.infix_62_61(_.arg0, _this._end, {}) : (_.arg1 = result).constructor.infix_60_61(_.arg1, _this._end, {})))) {
if((Bool.infix_38_38((_.arg2 = result).constructor.infix_61_61(_.arg2, _this._end, {}), () => Bool.prefix_33(_this._didReturnEnd, {}), {}))) {
_this._didReturnEnd = true;
return _injectIntoOptional(result);
};
return Optional.none;
};
_this._current = ((function(){throw '!unclarifiedGeneric:Element'})())._stepAfterFromBy(_this._current, _this._start, _this._stride, {});
return _injectIntoOptional(result)
----Swift.(file).StrideThrough.makeIterator()
let _this = this;
return _create(StrideThroughIterator, 'init_startEndStride', _this._start, _this._end, _this._stride, {})
----Swift.(file).StrideThrough.underestimatedCount
let _this = this;
let it = _cloneStruct(_this.makeIterator( {}));
let count = 0;
while(true){
if(!((Optional.wrappedNotEqualsOptionalNilComparisonType(it.next( {$setThis: $val => it = $val}), _create(_OptionalNilComparisonType, 'initNilLiteraltuple_type', {}), {})))) break
Int.infix_43_61({get: () => count, set: $val => count = $val}, 1, {});
};
return count
----Swift.(file).StrideThrough.customMirror
let _this = this;
return _create(Mirror, 'initChildrenKeyValuePairsDisplayStyleOptionalAncestorRepresentationMirrorAncestorRepresentation', _this, new Map([["from", _this._start], ["through", _this._end], ["by", _this._stride]]), nil/*!default_value*/, .generated/*!default_value*/, {})
----Swift.(file).stride(from:T,through:T,by:T.Stride)
return _create(StrideThrough, 'init_startEndStride', start, end, stride, {})
----Swift.(file).unimplemented_utf8_32bit(_:String,file:StaticString,line:UInt)
fatalErrorFileLine(() => "32-bit: Unimplemented for UTF-8 support", file, line, {})
----Swift.(file).String.init()
let _this = this;
_this.init_StringGuts(_create(_StringGuts, 'init', {}), {});
return
----Swift.(file).String.init(decoding:C,as:Encoding.Type)
let _this = this;
if(!((_fastPath(infix_61_61(_injectIntoOptional(sourceEncoding), _injectIntoOptional(UTF8), {}), {})))) {
return _cloneStruct(String._fromCodeUnitsEncodingRepair(codeUnits, sourceEncoding, true, {})[0]["0"]);
return ;
};
const $ifLet0, contigBytes_1
if((($ifLet0 = _injectIntoOptional(codeUnits))||true) && $ifLet0.rawValue == 'some' && ((contigBytes_1 = $ifLet0[0])||true) && (contigBytes_1._providesContiguousBytesNoCopy)) {
return _cloneStruct(contigBytes_1.withUnsafeBytes(((rawBufPtr, $info?) => String._fromUTF8Repairing(_create(UnsafeBufferPointer, 'initStartOptionalCountInt', _injectIntoOptional(((_.tmp0 = rawBufPtr.baseAddress).rawValue === 'some') ? (_.tmp0[0].assumingMemoryBoundTo(UInt8, {})) : null), rawBufPtr.count, {}), {})["0"]), {}));
return ;
};
return _cloneStruct(_create(Array, 'initBuffer', codeUnits, {}).withUnsafeBufferPointer((($0, $info?) => { 
const raw = _create(UnsafeRawBufferPointer, 'initUnsafeBufferPointer', $0, {});
return String._fromUTF8Repairing(raw.bindMemoryTo(UInt8, {}), {})["0"]; }), {}));
return
----Swift.(file).String.withCString(encodedAs:TargetEncoding.Type,_:(UnsafePointer<TargetEncoding.CodeUnit>) throws -> Result)
let _this = this;
if((infix_61_61(_injectIntoOptional(targetEncoding), _injectIntoOptional(UTF8), {}))) {
return _this.withCString(((cPtr, $info?) => { 
const ptr = _cloneStruct(_create(UnsafeRawPointer, 'init', /*pointer_to_pointer*/cPtr, {}).assumingMemoryBoundTo(((function(){throw '!unclarifiedGeneric:TargetEncoding.CodeUnit'})()), {}));
return body(ptr, {}); }), {});
};
return _this._slowWithCStringEncodedAs(targetEncoding, body, {})
----Swift.(file).String.init(_:Unicode.Scalar)
let _this = this;
return _cloneStruct(scalar.withUTF8CodeUnits((($0, $info?) => String._uncheckedFromUTF8($0, {})), {}));
return
----Swift.(file).String.init(stringLiteral:String)
let _this = this;
return _cloneStruct(value);
return
----Swift.(file).String.debugDescription
let _this = this;
let result = "\"";
{
let $us$generator = _cloneStruct(_this.unicodeScalars.makeIterator( {}));
while(true) {
const $ifLet0, us_1;
if(!((($ifLet0 = $us$generator.next( {$setThis: $val => $us$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((us_1 = $ifLet0[0])||true))) break
String.infix_43_61({get: () => result, set: $val => result = $val}, us_1.escapedAsASCII(false, {}), {});
}
};
String.infix_43_61({get: () => result, set: $val => result = $val}, "\"", {});
return result
----Swift.(file).String.+infix(_:String,_:String)
let _this = this;
let result = lhs;
result.append(rhs, {$setThis: $val => result = $val});
return result
----Swift.(file).String.+=infix(_:String,_:String)
let _this = this;
let lhs = lhs$inout.get()
const $result = (() => {
lhs.append(rhs, {$setThis: $val => lhs = $val});})()
lhs$inout.set(lhs)
return $result
----Swift.(file).Sequence.joined(separator:String)
let _this = this;
return _this._joinedSeparator(separator, {})
----Swift.(file).BidirectionalCollection.joined(separator:String)
let _this = this;
return _this._joinedSeparator(separator, {})
----Swift.(file).String.init(_:T)
let _this = this;
return _cloneStruct(value.description);
return
----Swift.(file).String.description
let _this = this;
return _this
----Swift.(file)._StringBreadcrumbs.stride
let _this = this;
return _StringBreadcrumbs.breadcrumbStride
----Swift.(file)._StringBreadcrumbs.getBreadcrumb(forOffset:Int)
let _this = this;
return {0: _this.crumbs.subscript$get(Int.infix_47(offset, _this.stride, {}), {}), 1: Int.infix_37(offset, _this.stride, {})}
----Swift.(file)._StringBreadcrumbs.getBreadcrumb(forIndex:String.Index)
let _this = this;
let lowerBound = Int.infix_47(Int.infix_47(idx._encodedOffset, 3, {}), _this.stride, {});
let upperBound = /*dot_syntax_base_ignored*/min(Int.infix_43(1, Int.infix_47(idx._encodedOffset, _this.stride, {}), {}), _this.crumbs.count, {});
while(true){
if(!((Int.infix_62(Int.infix_38_45(upperBound, lowerBound, {}), 1, {})))) break
const mid = Int.infix_43(lowerBound, Int.infix_47(Int.infix_38_45(upperBound, lowerBound, {}), 2, {}), {});
if((String.Index.infix_60_61(_this.crumbs.subscript$get(mid, {}), idx, {}))) {
lowerBound = mid;
}
else {
upperBound = mid;
};
};
const crumb = _cloneStruct(_this.crumbs.subscript$get(lowerBound, {}));
return {0: crumb, 1: Int.infix_38_42(lowerBound, _this.stride, {})}
----Swift.(file)._StringGuts.populateBreadcrumbs(_:UnsafeMutablePointer<_StringBreadcrumbs?>)
let _this = this;
const crumbs = _create(_StringBreadcrumbs, 'initString', _create(String, 'init_StringGuts', _this, {}), {});
_stdlib_atomicInitializeARCRefObjectDesired(_create(UnsafeMutableRawPointer, 'initUnsafeMutablePointer', mutPtr, {}).assumingMemoryBoundTo(Optional, {}), crumbs, {})
----Swift.(file).String.count
let _this = this;
return _this.distanceFromTo(_this.startIndex, _this.endIndex, {})
----Swift.(file).String.index(after:String.Index)
let _this = this;
preconditionFileLine(() => String.Index.infix_60(i, _this.endIndex, {}), () => "String index is out of bounds", '?3', '?3', {});
const stride = _this._characterStrideStartingAt(i, {});
const nextOffset = Int.infix_38_43(i._encodedOffset, stride, {});
const nextStride = _this._characterStrideStartingAt(_create(String.Index, 'init_encodedOffsetInt', nextOffset, {}), {});
return _create(String.Index, 'initEncodedOffsetIntCharacterStrideInt', nextOffset, nextStride, {})
----Swift.(file).String.index(before:String.Index)
let _this = this;
preconditionFileLine(() => String.Index.infix_62(i, _this.startIndex, {}), () => "String index is out of bounds", '?3', '?3', {});
const stride = _this._characterStrideEndingAt(i, {});
const priorOffset = Int.infix_38_45(i._encodedOffset, stride, {});
return _create(String.Index, 'initEncodedOffsetIntCharacterStrideInt', priorOffset, stride, {})
----Swift.(file).String.index(_:String.Index,offsetBy:String.IndexDistance)
let _this = this;
return _this._indexOffsetBy(i, n, {})
----Swift.(file).String.index(_:String.Index,offsetBy:String.IndexDistance,limitedBy:String.Index)
let _this = this;
return _this._indexOffsetByLimitedBy(i, n, limit, {})
----Swift.(file).String.distance(from:String.Index,to:String.Index)
let _this = this;
return _this._distanceFromTo(start, end, {})
----Swift.(file).StringProtocol.!=infix(_:Self,_:RHS)
let _this = this;
return Bool.prefix_33((_.arg0 = lhs).constructor.infix_61_61(_.arg0, rhs, {}), {})
----Swift.(file).StringProtocol.>infix(_:Self,_:RHS)
let _this = this;
return (_.arg0 = rhs).constructor.infix_60(_.arg0, lhs, {})
----Swift.(file).StringProtocol.<=infix(_:Self,_:RHS)
let _this = this;
return Bool.prefix_33((_.arg0 = rhs).constructor.infix_60(_.arg0, lhs, {}), {})
----Swift.(file).StringProtocol.>=infix(_:Self,_:RHS)
let _this = this;
return Bool.prefix_33((_.arg0 = lhs).constructor.infix_60(_.arg0, rhs, {}), {})
----Swift.(file)._StringGuts.isOnGraphemeClusterBoundary(_:String.Index)
let _this = this;
if(!((Int.infix_61_61(i.transcodedOffset, 0, {})))) {
return false;
};
const offset = i._encodedOffset;
if((Bool.infix_124_124(Int.infix_61_61(offset, 0, {}), () => Int.infix_61_61(offset, _this.count, {}), {}))) {
return true;
};
if(!((_this.isOnUnicodeScalarBoundary(i, {})))) {
return false;
};
const str = _create(String, 'init_StringGuts', _this, {});
return String.Index.infix_61_61(i, str.indexBefore(str.indexAfter(i, {}), {}), {})
----Swift.(file)._StringGuts.rawBits
let _this = this;
return _this._object.rawBits
----Swift.(file)._StringGuts.init(_:<<error type>>)
let _this = this;
_this.init_StringObject(_create(_StringObject, 'init_SmallString', smol, {}), {});
return
----Swift.(file)._StringGuts.init(_:UnsafeBufferPointer<UInt8>,isASCII:Bool)
let _this = this;
_this.init_StringObject(_create(_StringObject, 'initImmortalUnsafeBufferPointerIsASCIIBool', bufPtr, isASCII, {}), {});
return
----Swift.(file)._StringGuts.init(_:<<error type>>)
let _this = this;
_this.init_StringObject(_create(_StringObject, 'init__StringStorage', storage, {}), {});
return
----Swift.(file)._StringGuts.init(_:<<error type>>)
let _this = this;
_this.init_StringObject(_create(_StringObject, 'init__SharedStringStorage', storage, {}), {});
return
----Swift.(file)._StringGuts.init(cocoa:AnyObject,providesFastUTF8:Bool,isASCII:Bool,length:Int)
let _this = this;
_this.init_StringObject(_create(_StringObject, 'initCocoaAnyObjectProvidesFastUTF8BoolIsASCIIBoolLengthInt', cocoa, providesFastUTF8, isASCII, _length, {}), {});
return
----Swift.(file)._StringGuts.count
let _this = this;
return _this._object.count
----Swift.(file)._StringGuts.isEmpty
let _this = this;
return Int.infix_61_61(_this.count, 0, {})
----Swift.(file)._StringGuts.isSmall
let _this = this;
return _this._object.isSmall
----Swift.(file)._StringGuts.isSmallASCII
let _this = this;
return Bool.infix_38_38(_this._object.isSmall, () => _this._object.smallIsASCII, {})
----Swift.(file)._StringGuts.asSmall
let _this = this;
return _create(_SmallString, 'init_StringObject', _this._object, {})
----Swift.(file)._StringGuts.isASCII
let _this = this;
return _this._object.isASCII
----Swift.(file)._StringGuts.isFastASCII
let _this = this;
return Bool.infix_38_38(_this.isFastUTF8, () => _this._object.isASCII, {})
----Swift.(file)._StringGuts.isNFC
let _this = this;
return _this._object.isNFC
----Swift.(file)._StringGuts.isNFCFastUTF8
let _this = this;
return Bool.infix_38_38(_this._object.isNFC, () => _this.isFastUTF8, {})
----Swift.(file)._StringGuts.hasNativeStorage
let _this = this;
return _this._object.hasNativeStorage
----Swift.(file)._StringGuts.hasSharedStorage
let _this = this;
return _this._object.hasSharedStorage
----Swift.(file)._StringGuts.hasBreadcrumbs
let _this = this;
return Bool.infix_124_124(_this.hasNativeStorage, () => _this.hasSharedStorage, {})
----Swift.(file)._StringGuts.isFastUTF8
let _this = this;
return _fastPath(_this._object.providesFastUTF8, {})
----Swift.(file)._StringGuts.isForeign
let _this = this;
return _slowPath(_this._object.isForeign, {})
----Swift.(file)._StringGuts.withFastUTF8(_:(UnsafeBufferPointer<UInt8>) throws -> R)
let _this = this;
if((_this.isSmall)) {
return _create(_SmallString, 'init_StringObject', _this._object, {}).withUTF8(f, {});
};
let $defer = () => {
_fixLifetime(_this, {});
}
const $result = (() => {
try {;
return f(_this._object.fastUTF8, {});}catch($error){$defer( {});throw $error}})();$defer( {});return $result
----Swift.(file)._StringGuts.withFastUTF8(range:Range<Int>,_:(UnsafeBufferPointer<UInt8>) throws -> R)
let _this = this;
return _this.withFastUTF8(((wholeUTF8, $info?) => f(_create(UnsafeBufferPointer, 'initRebasingSlice', wholeUTF8.subscriptRange$get(range, {}), {}), {})), {})
----Swift.(file)._StringGuts.withFastCChar(_:(UnsafeBufferPointer<CChar>) throws -> R)
let _this = this;
return _this.withFastUTF8(((utf8, $info?) => { 
const ptr = _cloneStruct(utf8.baseAddress._unsafelyUnwrappedUnchecked._asCChar);
return f(_create(UnsafeBufferPointer, 'initStartOptionalCountInt', _injectIntoOptional(/*pointer_to_pointer*/ptr), utf8.count, {}), {}); }), {})
----Swift.(file)._StringGuts.withCString(_:(UnsafePointer<Int8>) throws -> Result)
let _this = this;
if((_slowPath(Bool.prefix_33(_this._object.isFastZeroTerminated, {}), {}))) {
return _this._slowWithCString(body, {});
};
return _this.withFastCChar((($0, $info?) => body($0.baseAddress._unsafelyUnwrappedUnchecked, {})), {})
----Swift.(file)._StringGuts.copyUTF8(into:UnsafeMutableBufferPointer<UInt8>)
let _this = this;
const ptr = _cloneStruct(mbp.baseAddress._unsafelyUnwrappedUnchecked);
if((_fastPath(_this.isFastUTF8, {}))) {
return _this.withFastUTF8(((utf8, $info?) => { 
if(!((Int.infix_60_61(utf8.count, mbp.count, {})))) {
return Optional.none;
};
const utf8Start = _cloneStruct(utf8.baseAddress._unsafelyUnwrappedUnchecked);
ptr.initializeFromCount(utf8Start, utf8.count, {});
return _injectIntoOptional(utf8.count); }), {});
};
return _this._foreignCopyUTF8Into(mbp, {})
----Swift.(file)._StringGuts.utf8Count
let _this = this;
if((_fastPath(_this.isFastUTF8, {}))) {
return _this.count;
};
return _create(String, 'init_StringGuts', _this, {}).utf8.count
----Swift.(file)._StringGuts.startIndex
let _this = this;
return _create(_StringGuts.Index, 'init_encodedOffsetInt', 0, {})
----Swift.(file)._StringGuts.endIndex
let _this = this;
return _create(_StringGuts.Index, 'init_encodedOffsetInt', _this.count, {})
----Swift.(file)._StringGuts.startASCII
let _this = this;
return _create(UnsafeMutablePointer, 'initMutatingUnsafePointer', _this._object.fastUTF8.baseAddress[0], {})
----Swift.(file)._StringGuts.startUTF16
let _this = this;
fatalErrorFileLine(() => "Not contiguous UTF-16", '?3', '?3', {})
----Swift.(file)._StringGuts.nativeCapacity
let _this = this;
if(!((_this.hasNativeStorage))) {
return Optional.none;
};
return _injectIntoOptional(_this._object.nativeStorage.capacity)
----Swift.(file)._StringGuts.nativeUnusedCapacity
let _this = this;
if(!((_this.hasNativeStorage))) {
return Optional.none;
};
return _injectIntoOptional(_this._object.nativeStorage.unusedCapacity)
----Swift.(file)._StringGuts.uniqueNativeCapacity
let _this = this;
if(!((_this.isUniqueNative))) {
return Optional.none;
};
return _injectIntoOptional(_this._object.nativeStorage.capacity)
----Swift.(file)._StringGuts.uniqueNativeUnusedCapacity
let _this = this;
if(!((_this.isUniqueNative))) {
return Optional.none;
};
return _injectIntoOptional(_this._object.nativeStorage.unusedCapacity)
----Swift.(file)._StringGuts.isUniqueNative
let _this = this;
if(!((_this.hasNativeStorage))) {
return false;
};
let $defer = () => {
_fixLifetime(_this, {});
}
const $result = (() => {
try {;
let bits = _this._object.largeAddressBits;
return _isUnique_native({get: () => bits, set: $val => bits = $val}, {});}catch($error){$defer( {});throw $error}})();$defer( {});return $result
----Swift.(file)._StringGuts.init(_initialCapacity:Int)
let _this = this;
_this.init( {});
if((_slowPath(Int.infix_62(capacity, _SmallString.capacity, {}), {}))) {
_this.grow(capacity, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
};
return
----Swift.(file)._StringGuts.append(_:_StringGuts)
let _this = this;
if((Bool.infix_38_38(_this.isSmall, () => other.isSmall, {}))) {
const $ifLet0, smol_1
if((($ifLet0 = _create(_SmallString, 'init_SmallStringAppending_SmallString', _this.asSmall, other.asSmall, {}))||true) && $ifLet0.rawValue == 'some' && ((smol_1 = $ifLet0[0])||true)) {
$info.$setThis(_this = _cloneStruct(_create(_StringGuts, 'init_SmallString', smol_1, {})));
return ;
};
};
_this.append(_create(_StringGutsSlice, 'init_StringGuts', other, {}), {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
----Swift.(file)._StringGuts.appendInPlace(_:UnsafeBufferPointer<UInt8>,isASCII:Bool)
let _this = this;
_this._object.nativeStorage.appendInPlaceIsASCII(other, isASCII, {});
$info.$setThis(_this = _cloneStruct(_create(_StringGuts, 'init__StringStorage', _this._object.nativeStorage, {})))
----Swift.(file)._StringGuts.clear()
let _this = this;
if(!((_this.isUniqueNative))) {
$info.$setThis(_this = _cloneStruct(_create(_StringGuts, 'init', {})));
return ;
};
_this._object.nativeStorage.clear( {});
$info.$setThis(_this = _cloneStruct(_create(_StringGuts, 'init__StringStorage', _this._object.nativeStorage, {})))
----Swift.(file)._StringGuts.uniqueNativeReplaceSubrange(_:<<error type>>,with:UnsafeBufferPointer<UInt8>,isASCII:Bool)
let _this = this;
const neededCapacity = Int.infix_43(Int.infix_43(bounds.lowerBound._encodedOffset, codeUnits.count, {}), Int.infix_45(_this.count, bounds.upperBound._encodedOffset, {}), {});
_this._object.nativeStorage.replaceFromToWith(bounds.lowerBound._encodedOffset, bounds.upperBound._encodedOffset, codeUnits, {});
$info.$setThis(_this = _cloneStruct(_create(_StringGuts, 'init__StringStorage', _this._object.nativeStorage, {})))
----Swift.(file)._StringGuts.uniqueNativeReplaceSubrange(_:<<error type>>,with:C)
let _this = this;
const replCount = codeUnits.count;
const neededCapacity = Int.infix_43(Int.infix_43(bounds.lowerBound._encodedOffset, replCount, {}), Int.infix_45(_this.count, bounds.upperBound._encodedOffset, {}), {});
_this._object.nativeStorage.replaceFromToWithReplacementCount(bounds.lowerBound._encodedOffset, bounds.upperBound._encodedOffset, codeUnits, replCount, {});
$info.$setThis(_this = _cloneStruct(_create(_StringGuts, 'init__StringStorage', _this._object.nativeStorage, {})))
----Swift.(file).String.Index.init(_:UInt64)
let _this = this;
_this._rawBits = raw;
_this._invariantCheck( {});
return
----Swift.(file)..(error_type).orderingValue
let _this = this;
return UInt64.infix_38_62_62(_this._rawBits, 14, {})
----Swift.(file)..(error_type).isZeroPosition
let _this = this;
return UInt64.infix_61_61(_this.orderingValue, 0, {})
----Swift.(file)..(error_type).utf16Offset(in:S)
let _this = this;
return s.utf16.distanceFromTo(s.utf16.startIndex, _this, {})
----Swift.(file)..(error_type).encodedOffset
let _this = this;
return _this._encodedOffset
----Swift.(file)..(error_type).transcodedOffset
let _this = this;
return _create(Int, 'initTruncatingIfNeeded', UInt64.infix_38(_this.orderingValue, 0x3, {}), {})
----Swift.(file)..(error_type).characterStride
let _this = this;
const value = UInt64.infix_38_62_62(UInt64.infix_38(_this._rawBits, 0x3F00, {}), 8, {});
return (UInt64.infix_62(value, 0, {}) ? _injectIntoOptional(_create(Int, 'initTruncatingIfNeeded', value, {})) : Optional.none)
----Swift.(file)..(error_type).init(encodedOffset:Int,transcodedOffset:Int)
let _this = this;
const pos = _create(UInt64, 'initTruncatingIfNeeded', encodedOffset, {});
const trans = _create(UInt64, 'initTruncatingIfNeeded', transcodedOffset, {});
_this.initUInt64(UInt64.infix_124(UInt64.infix_38_60_60(pos, 16, {}), UInt64.infix_38_60_60(trans, 14, {}), {}), {});
return
----Swift.(file)..(error_type).init(utf16Offset:Int,in:S)
let _this = this;
const $tuple = {0: s.utf16.startIndex, 1: s.utf16.endIndex}, start = $tuple && $tuple[0], end = $tuple && $tuple[1];
const $ifLet0, idx_1
if(!((Int.infix_62_61(offset, 0, {})) && (($ifLet0 = s.utf16.indexOffsetByLimitedBy(start, offset, end, {}))||true) && $ifLet0.rawValue == 'some' && ((idx_1 = $ifLet0[0])||true))) {
$info.$setThis(_this = _cloneStruct(_cloneStruct(end.nextEncoded)));
return ;
};
$info.$setThis(_this = _cloneStruct(_cloneStruct(idx_1)));
return
----Swift.(file)..(error_type).init(encodedOffset:Int)
let _this = this;
_this.init_encodedOffsetInt(offset, {});
return
----Swift.(file)..(error_type).init(_encodedOffset:Int)
let _this = this;
_this.initEncodedOffsetIntTranscodedOffsetInt(offset, 0, {});
return
----Swift.(file)..(error_type).init(encodedOffset:Int,transcodedOffset:Int,characterStride:Int)
let _this = this;
_this.initEncodedOffsetIntTranscodedOffsetInt(encodedOffset, transcodedOffset, {});
if((_slowPath(Int.infix_62(characterStride, 63, {}), {}))) {
return ;
};
UInt64.infix_124_61({get: () => _this._rawBits, set: $val => _this._rawBits = $val}, _create(UInt64, 'initTruncatingIfNeeded', Int.infix_38_60_60(characterStride, 8, {}), {}), {});
_this._invariantCheck( {});
return
----Swift.(file)..(error_type).init(encodedOffset:Int,characterStride:Int)
let _this = this;
_this.initEncodedOffsetIntTranscodedOffsetIntCharacterStrideInt(pos, 0, char, {});
return
----Swift.(file)..(error_type).strippingTranscoding
let _this = this;
return _create(String.Index, 'init_encodedOffsetInt', _this._encodedOffset, {})
----Swift.(file)..(error_type).nextEncoded
let _this = this;
return _create(String.Index, 'init_encodedOffsetInt', Int.infix_38_43(_this._encodedOffset, 1, {}), {})
----Swift.(file)..(error_type).priorEncoded
let _this = this;
return _create(String.Index, 'init_encodedOffsetInt', Int.infix_38_45(_this._encodedOffset, 1, {}), {})
----Swift.(file)..(error_type).nextTranscoded
let _this = this;
return _create(String.Index, 'initEncodedOffsetIntTranscodedOffsetInt', _this._encodedOffset, Int.infix_38_43(_this.transcodedOffset, 1, {}), {})
----Swift.(file)..(error_type).priorTranscoded
let _this = this;
return _create(String.Index, 'initEncodedOffsetIntTranscodedOffsetInt', _this._encodedOffset, Int.infix_38_45(_this.transcodedOffset, 1, {}), {})
----Swift.(file)..(error_type).encoded(offsetBy:Int)
let _this = this;
return _create(String.Index, 'init_encodedOffsetInt', Int.infix_38_43(_this._encodedOffset, n, {}), {})
----Swift.(file)..(error_type).transcoded(withOffset:Int)
let _this = this;
return _create(String.Index, 'initEncodedOffsetIntTranscodedOffsetInt', _this._encodedOffset, n, {})
----Swift.(file)..(error_type).==infix(_:<<error type>>,_:<<error type>>)
let _this = this;
return UInt64.infix_61_61(lhs.orderingValue, rhs.orderingValue, {})
----Swift.(file)..(error_type).<infix(_:<<error type>>,_:<<error type>>)
let _this = this;
return UInt64.infix_60(lhs.orderingValue, rhs.orderingValue, {})
----Swift.(file)..(error_type).hash(into:Hasher)
let _this = this;
let hasher = hasher$inout.get()
const $result = (() => {
hasher.combine(_this.orderingValue, {$setThis: $val => hasher = $val});})()
hasher$inout.set(hasher)
return $result
----Swift.(file).String.Index.samePosition(in:String.UTF8View)
let _this = this;
return _create(String.UTF8View.Index, 'initStringIndexWithinStringUTF8View', _this, utf8, {})
----Swift.(file).String.Index.samePosition(in:String.UTF16View)
let _this = this;
return _create(String.UTF16View.Index, 'initStringIndexWithinStringUTF16View', _this, utf16, {})
----Swift.(file).DefaultStringInterpolation.init(literalCapacity:Int,interpolationCount:Int)
let _this = this;
const capacityPerInterpolation = 2;
const initialCapacity = Int.infix_43(literalCapacity, Int.infix_42(interpolationCount, capacityPerInterpolation, {}), {});
_this._storage = _create(String, 'init_StringGuts', _create(_StringGuts, 'init_initialCapacityInt', initialCapacity, {}), {});
return
----Swift.(file).DefaultStringInterpolation.appendLiteral(_:String)
let _this = this;
literal.writeTo({get: () => _this, set: $val => $info.$setThis(_this = _cloneStruct($val))}, {})
----Swift.(file).DefaultStringInterpolation.appendInterpolation(_:T)
let _this = this;
value.writeTo({get: () => _this, set: $val => $info.$setThis(_this = _cloneStruct($val))}, {})
----Swift.(file).DefaultStringInterpolation.appendInterpolation(_:T)
let _this = this;
value.writeTo({get: () => _this, set: $val => $info.$setThis(_this = _cloneStruct($val))}, {})
----Swift.(file).DefaultStringInterpolation.appendInterpolation(_:T)
let _this = this;
value.description.writeTo({get: () => _this, set: $val => $info.$setThis(_this = _cloneStruct($val))}, {})
----Swift.(file).DefaultStringInterpolation.appendInterpolation(_:T)
let _this = this;
_print_unlocked(value, {get: () => _this, set: $val => $info.$setThis(_this = _cloneStruct($val))}, {})
----Swift.(file).DefaultStringInterpolation.make()
let _this = this;
return _this._storage
----Swift.(file).DefaultStringInterpolation.description
let _this = this;
return _this._storage
----Swift.(file).DefaultStringInterpolation.write(_:String)
let _this = this;
_this._storage.append(string, {$setThis: $val => _this._storage = $val})
----Swift.(file).String.init(stringInterpolation:DefaultStringInterpolation)
let _this = this;
return _cloneStruct(stringInterpolation.make( {}));
return
----Swift.(file).Substring.init(stringInterpolation:DefaultStringInterpolation)
let _this = this;
_this.initString(stringInterpolation.make( {}), {});
return
----Swift.(file).String.init(repeating:String,count:Int)
let _this = this;
preconditionFileLine(() => Int.infix_62_61(count, 0, {}), () => "Negative count not allowed", '?3', '?3', {});
if(!((Int.infix_62(count, 1, {})))) {
return _cloneStruct((Int.infix_61_61(count, 0, {}) ? "" : repeatedValue));
return ;
};
let result = _create(String, 'init', {});
{
let $generator = _cloneStruct(Int.infix_46_46_60(0, count, {}).makeIterator( {}));
while(true) {
const $ifLet0;
if(!((($ifLet0 = $generator.next( {$setThis: $val => $generator = $val}))||true) && $ifLet0.rawValue == 'some')) break
String.infix_43_61({get: () => result, set: $val => result = $val}, repeatedValue, {});
}
};
return _cloneStruct(result);
return
----Swift.(file).StringProtocol.hasPrefix(_:Prefix)
let _this = this;
return _this.startsWithSwift(prefix, {})
----Swift.(file).StringProtocol.hasSuffix(_:Suffix)
let _this = this;
return _this.reversed( {}).startsWithSwift(suffix.reversed( {}), {})
----Swift.(file).String.init(_:T,radix:Int,uppercase:Bool)
let _this = this;
return _cloneStruct(((function(){throw '!unclarifiedGeneric:T'})()).prototype._descriptionRadixUppercase.call(value, radix, uppercase, {}));
return
----Swift.(file)._StringGuts.foreignHasNormalizationBoundary(before:String.Index)
let _this = this;
const offset = index._encodedOffset;
if((Bool.infix_124_124(Int.infix_61_61(offset, 0, {}), () => Int.infix_61_61(offset, _this.count, {}), {}))) {
return true;
};
const scalar = _cloneStruct(_this.foreignErrorCorrectedScalarStartingAt(index, {})["0"]);
return scalar._hasNormalizationBoundaryBefore
----Swift.(file).UnsafeBufferPointer.hasNormalizationBoundary(before:Int)
let _this = this;
if((Bool.infix_124_124(Int.infix_61_61(index, 0, {}), () => Int.infix_61_61(index, _this.count, {}), {}))) {
return true;
};
assertFileLine(() => Bool.prefix_33(_isContinuation(_this.subscript_unchecked$get(index, {}), {}), {}), () => String()/*!default_value*/, '?3', '?3', {});
if((UInt8.infix_60(_this.subscript_unchecked$get(index, {}), 0xCC, {}))) {
return true;
};
const cu = _cloneStruct(_decodeScalarStartingAt(_this, index, {})["0"]);
return cu._hasNormalizationBoundaryBefore
----Swift.(file).UnsafeBufferPointer.isOnUnicodeScalarBoundary(_:Int)
let _this = this;
if(!((Int.infix_60(index, _this.count, {})))) {
return true;
};
return Bool.prefix_33(_isContinuation(_this.subscript$get(index, {}), {}), {})
----Swift.(file).copyUTF16Segment(boundedBy:Range<Int>,into:UnsafeMutableBufferPointer<UInt16>,_:(Int) -> (Unicode.Scalar, Int))
let readIndex = range.lowerBound;
let outputWriteIndex = 0;
const outputCount = outputBuffer.count;
while(true){
if(!((Int.infix_33_61(readIndex, range.upperBound, {})))) break
const $tuple = f(readIndex, {}), scalar = $tuple && $tuple[0], _length = $tuple && $tuple[1];
if((Bool.infix_38_38(scalar._hasNormalizationBoundaryBefore, () => Int.infix_33_61(readIndex, range.lowerBound, {}), {}))) {
break;
};
Int.infix_43_61({get: () => readIndex, set: $val => readIndex = $val}, _length, {});
{
let $cu$generator = _cloneStruct(scalar.utf16.makeIterator( {}));
while(true) {
const $ifLet0, cu_1;
if(!((($ifLet0 = $cu$generator.next( {$setThis: $val => $cu$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((cu_1 = $ifLet0[0])||true))) break
if((Int.infix_60(outputWriteIndex, outputCount, {}))) {
outputBuffer.subscript$set(cu_1, outputWriteIndex, {$setThis: $val => outputBuffer = _cloneStruct($val)});
Int.infix_43_61({get: () => outputWriteIndex, set: $val => outputWriteIndex = $val}, 1, {});
}
else {
return Optional.none;
};
}
};
};
return _injectIntoOptional({0: Int.infix_45(readIndex, range.lowerBound, {}), 1: outputWriteIndex})
----Swift.(file).transcodeValidUTF16ToUTF8(_:UnsafeBufferPointer<UInt16>,into:UnsafeMutableBufferPointer<UInt8>)
let readIndex = 0;
let writeIndex = 0;
const outputCount = outputBuffer.count;
const sourceCount = sourceBuffer.count;
while(true){
if(!((Int.infix_60(readIndex, sourceCount, {})))) break
const $tuple = _decodeScalarStartingAt(sourceBuffer, readIndex, {})/*destructure_tuple_expr (**NULL EXPRESSION**), (**NULL EXPRESSION**)*/, scalar = $tuple && $tuple[0], _length = $tuple && $tuple[1];
Int.infix_43_61({get: () => readIndex, set: $val => readIndex = $val}, _length, {});
{
let $cu$generator = _cloneStruct(UTF8.encode(scalar, {})._unsafelyUnwrappedUnchecked.makeIterator( {}));
while(true) {
const $ifLet0, cu_1;
if(!((($ifLet0 = $cu$generator.next( {$setThis: $val => $cu$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((cu_1 = $ifLet0[0])||true))) break
if((Int.infix_60(writeIndex, outputCount, {}))) {
outputBuffer.subscript$set(cu_1, writeIndex, {$setThis: $val => outputBuffer = _cloneStruct($val)});
Int.infix_38_43_61({get: () => writeIndex, set: $val => writeIndex = $val}, 1, {});
}
else {
return Optional.none;
};
}
};
};
return _injectIntoOptional(writeIndex)
----Swift.(file)._StringObject.RawBitPattern

----Swift.(file)._StringObject.rawBits
let _this = this;
return {0: _this._countAndFlagsBits, 1: _this.discriminatedObjectRawBits}
----Swift.(file)._StringObject.init(rawValue:_StringObject.RawBitPattern)
let _this = this;
_this.initRawUncheckedValue_StringObjectRawBitPattern(bits, {});
_this._invariantCheck( {});
return
----Swift.(file)._StringObject.CountAndFlags.rawBits
let _this = this;
return _this._storage
----Swift.(file)._StringObject.CountAndFlags.init(rawUnchecked:_StringObject.CountAndFlags.RawBitPattern)
let _this = this;
_this._storage = bits;
return
----Swift.(file)._StringObject.CountAndFlags.init(raw:_StringObject.CountAndFlags.RawBitPattern)
let _this = this;
_this.initRawUnchecked_StringObjectCountAndFlagsRawBitPattern(bits, {});
_this._invariantCheck( {});
return
----Swift.(file)._StringObject.Nibbles.emptyString
let _this = this;
return _StringObject.Nibbles.smallIsASCII(true, {});
}
static get emptyString() { return this.emptyString$get()
----Swift.(file)._StringObject.Nibbles.largeAddressMask
let _this = this;
return 0x0FFFFFFFFFFFFFFF;
}
static get largeAddressMask() { return this.largeAddressMask$get()
----Swift.(file)._StringObject.Nibbles.discriminatorMask
let _this = this;
return UInt64.prefix_126(_this.largeAddressMask, {});
}
static get discriminatorMask() { return this.discriminatorMask$get()
----Swift.(file)._StringObject.Nibbles.small(isASCII:Bool)
let _this = this;
return (isASCII ? 0xE000000000000000 : 0xA000000000000000)
----Swift.(file)._StringObject.Nibbles.small(withCount:Int,isASCII:Bool)
let _this = this;
return UInt64.infix_124(_this.smallIsASCII(isASCII, {}), UInt64.infix_38_60_60(_create(UInt64, 'initTruncatingIfNeeded', count, {}), 56, {}), {})
----Swift.(file)._StringObject.Nibbles.largeImmortal()
let _this = this;
return 0x8000000000000000
----Swift.(file)._StringObject.Nibbles.largeMortal()
let _this = this;
return 0x0000000000000000
----Swift.(file)._StringObject.Nibbles.largeCocoa(providesFastUTF8:Bool)
let _this = this;
return (providesFastUTF8 ? 0x4000000000000000 : 0x5000000000000000)
----Swift.(file)._StringObject.nativeBias
let _this = this;
return 32;
}
static get nativeBias() { return this.nativeBias$get()
----Swift.(file)._StringObject.isImmortal
let _this = this;
return UInt64.infix_33_61(UInt64.infix_38(_this.discriminatedObjectRawBits, 0x8000000000000000, {}), 0, {})
----Swift.(file)._StringObject.isMortal
let _this = this;
return Bool.prefix_33(_this.isImmortal, {})
----Swift.(file)._StringObject.isSmall
let _this = this;
return UInt64.infix_33_61(UInt64.infix_38(_this.discriminatedObjectRawBits, 0x2000000000000000, {}), 0, {})
----Swift.(file)._StringObject.isLarge
let _this = this;
return Bool.prefix_33(_this.isSmall, {})
----Swift.(file)._StringObject.providesFastUTF8
let _this = this;
return UInt64.infix_61_61(UInt64.infix_38(_this.discriminatedObjectRawBits, 0x1000000000000000, {}), 0, {})
----Swift.(file)._StringObject.isForeign
let _this = this;
return Bool.prefix_33(_this.providesFastUTF8, {})
----Swift.(file)._StringObject.hasStorage
let _this = this;
return UInt64.infix_61_61(UInt64.infix_38(_this.discriminatedObjectRawBits, 0xF000000000000000, {}), 0, {})
----Swift.(file)._StringObject.hasNativeStorage
let _this = this;
const bits = UInt64.infix_38(UInt64.prefix_126(_this.discriminatedObjectRawBits, {}), _this._countAndFlagsBits, {});
const result = UInt64.infix_33_61(UInt64.infix_38(bits, 0x2000000000000000, {}), 0, {});
return result
----Swift.(file)._StringObject.hasSharedStorage
let _this = this;
return Bool.infix_38_38(_this.hasStorage, () => Bool.prefix_33(_this.hasNativeStorage, {}), {})
----Swift.(file)._StringObject.largeFastIsTailAllocated
let _this = this;
return _this._countAndFlags.isTailAllocated
----Swift.(file)._StringObject.largeFastIsShared
let _this = this;
return Bool.prefix_33(_this.largeFastIsTailAllocated, {})
----Swift.(file)._StringObject.largeIsCocoa
let _this = this;
return UInt64.infix_33_61(UInt64.infix_38(_this.discriminatedObjectRawBits, 0x4000000000000000, {}), 0, {})
----Swift.(file)._StringObject.isPreferredRepresentation
let _this = this;
return _fastPath(Bool.infix_124_124(_this.isSmall, () => _this._countAndFlags.isTailAllocated, {}), {})
----Swift.(file)._StringObject.init(_:<<error type>>)
let _this = this;
const word1 = UInt64.prototype.littleEndian$get.call(small.rawBits["0"]);
const word2 = UInt64.prototype.littleEndian$get.call(small.rawBits["1"]);
_this.initRawValue_StringObjectRawBitPattern({0: word1, 1: word2}, {});
return
----Swift.(file)._StringObject.getSmallCount(fromRaw:UInt64)
let _this = this;
return _create(Int, 'initTruncatingIfNeeded', UInt64.infix_38_62_62(UInt64.infix_38(x, 0x0F00000000000000, {}), 56, {}), {})
----Swift.(file)._StringObject.smallCount
let _this = this;
return _StringObject.getSmallCountFromRaw(_this.discriminatedObjectRawBits, {})
----Swift.(file)._StringObject.getSmallIsASCII(fromRaw:UInt64)
let _this = this;
return UInt64.infix_33_61(UInt64.infix_38(x, 0x4000000000000000, {}), 0, {})
----Swift.(file)._StringObject.smallIsASCII
let _this = this;
return _StringObject.getSmallIsASCIIFromRaw(_this.discriminatedObjectRawBits, {})
----Swift.(file)._StringObject.CountAndFlags.countMask
let _this = this;
return 0x0000FFFFFFFFFFFF;
}
static get countMask() { return this.countMask$get()
----Swift.(file)._StringObject.CountAndFlags.flagsMask
let _this = this;
return UInt64.prefix_126(_this.countMask, {});
}
static get flagsMask() { return this.flagsMask$get()
----Swift.(file)._StringObject.CountAndFlags.isASCIIMask
let _this = this;
return 0x8000000000000000;
}
static get isASCIIMask() { return this.isASCIIMask$get()
----Swift.(file)._StringObject.CountAndFlags.isNFCMask
let _this = this;
return 0x4000000000000000;
}
static get isNFCMask() { return this.isNFCMask$get()
----Swift.(file)._StringObject.CountAndFlags.isNativelyStoredMask
let _this = this;
return 0x2000000000000000;
}
static get isNativelyStoredMask() { return this.isNativelyStoredMask$get()
----Swift.(file)._StringObject.CountAndFlags.isTailAllocatedMask
let _this = this;
return 0x1000000000000000;
}
static get isTailAllocatedMask() { return this.isTailAllocatedMask$get()
----Swift.(file)._StringObject.CountAndFlags.init(count:Int,isASCII:Bool,isNFC:Bool,isNativelyStored:Bool,isTailAllocated:Bool)
let _this = this;
let rawBits = _create(UInt64, 'initTruncatingIfNeeded', count, {});
if((isASCII)) {
UInt64.infix_124_61({get: () => rawBits, set: $val => rawBits = $val}, _StringObject.CountAndFlags.isASCIIMask, {});
};
if((isNFC)) {
UInt64.infix_124_61({get: () => rawBits, set: $val => rawBits = $val}, _StringObject.CountAndFlags.isNFCMask, {});
};
if((isNativelyStored)) {
UInt64.infix_124_61({get: () => rawBits, set: $val => rawBits = $val}, _StringObject.CountAndFlags.isNativelyStoredMask, {});
};
if((isTailAllocated)) {
UInt64.infix_124_61({get: () => rawBits, set: $val => rawBits = $val}, _StringObject.CountAndFlags.isTailAllocatedMask, {});
};
_this.initRaw_StringObjectCountAndFlagsRawBitPattern(rawBits, {});
return
----Swift.(file)._StringObject.CountAndFlags.init(count:Int,flags:UInt16)
let _this = this;
const rawBits = UInt64.infix_124(UInt64.infix_38_60_60(_create(UInt64, 'initTruncatingIfNeeded', flags, {}), 48, {}), _create(UInt64, 'initTruncatingIfNeeded', count, {}), {});
_this.initRaw_StringObjectCountAndFlagsRawBitPattern(rawBits, {});
return
----Swift.(file)._StringObject.CountAndFlags.init(immortalCount:Int,isASCII:Bool)
let _this = this;
_this.initCountIntIsASCIIBoolIsNFCBoolIsNativelyStoredBoolIsTailAllocatedBool(immortalCount, isASCII, isASCII, false, true, {});
return
----Swift.(file)._StringObject.CountAndFlags.init(mortalCount:Int,isASCII:Bool)
let _this = this;
_this.initCountIntIsASCIIBoolIsNFCBoolIsNativelyStoredBoolIsTailAllocatedBool(mortalCount, isASCII, isASCII, true, true, {});
return
----Swift.(file)._StringObject.CountAndFlags.init(sharedCount:Int,isASCII:Bool)
let _this = this;
_this.initCountIntIsASCIIBoolIsNFCBoolIsNativelyStoredBoolIsTailAllocatedBool(sharedCount, isASCII, isASCII, false, false, {});
return
----Swift.(file)._StringObject.CountAndFlags.count
let _this = this;
return _create(Int, 'initTruncatingIfNeeded', UInt64.infix_38(_this._storage, _StringObject.CountAndFlags.countMask, {}), {})
----Swift.(file)._StringObject.CountAndFlags.flags
let _this = this;
return _create(UInt16, 'initTruncatingIfNeeded', UInt64.infix_38_62_62(_this._storage, 48, {}), {})
----Swift.(file)._StringObject.CountAndFlags.isASCII
let _this = this;
return Int.infix_33_61(0, UInt64.infix_38(_this._storage, _StringObject.CountAndFlags.isASCIIMask, {}), {})
----Swift.(file)._StringObject.CountAndFlags.isNFC
let _this = this;
return Int.infix_33_61(0, UInt64.infix_38(_this._storage, _StringObject.CountAndFlags.isNFCMask, {}), {})
----Swift.(file)._StringObject.CountAndFlags.isNativelyStored
let _this = this;
return Int.infix_33_61(0, UInt64.infix_38(_this._storage, _StringObject.CountAndFlags.isNativelyStoredMask, {}), {})
----Swift.(file)._StringObject.CountAndFlags.isTailAllocated
let _this = this;
return Int.infix_33_61(0, UInt64.infix_38(_this._storage, _StringObject.CountAndFlags.isTailAllocatedMask, {}), {})
----Swift.(file)._StringObject.largeCount
let _this = this;
return _this._countAndFlags.count
----Swift.(file)._StringObject.largeAddressBits
let _this = this;
return _create(UInt, 'initTruncatingIfNeeded', UInt64.infix_38(_this.discriminatedObjectRawBits, _StringObject.Nibbles.largeAddressMask, {}), {})
----Swift.(file)._StringObject.nativeUTF8Start
let _this = this;
return _create(UnsafePointer, 'initBitPatternUInt', UInt.infix_38_43(_this.largeAddressBits, _StringObject.nativeBias, {}), {})._unsafelyUnwrappedUnchecked
----Swift.(file)._StringObject.nativeUTF8
let _this = this;
return _create(UnsafeBufferPointer, 'initStartOptionalCountInt', _injectIntoOptional(/*pointer_to_pointer*/_this.nativeUTF8Start), _this.largeCount, {})
----Swift.(file)._StringObject.getSharedUTF8Start()
let _this = this;
if((_this.largeIsCocoa)) {
return _cocoaUTF8Pointer(_this.cocoaObject, {})._unsafelyUnwrappedUnchecked;
};
return _this.sharedStorage.start
----Swift.(file)._StringObject.sharedUTF8
let _this = this;
const start = _cloneStruct(_this.getSharedUTF8Start( {}));
return _create(UnsafeBufferPointer, 'initStartOptionalCountInt', _injectIntoOptional(/*pointer_to_pointer*/start), _this.largeCount, {})
----Swift.(file)._StringObject.count
let _this = this;
return (_this.isSmall ? _this.smallCount : _this.largeCount)
----Swift.(file)._StringObject.isASCII
let _this = this;
if((_this.isSmall)) {
return _this.smallIsASCII;
};
return _this._countAndFlags.isASCII
----Swift.(file)._StringObject.isNFC
let _this = this;
if((_this.isSmall)) {
return _this.smallIsASCII;
};
return _this._countAndFlags.isNFC
----Swift.(file)._StringObject.fastUTF8
let _this = this;
if(!((_fastPath(_this.largeFastIsTailAllocated, {})))) {
return _this.sharedUTF8;
};
return _create(UnsafeBufferPointer, 'initStartOptionalCountInt', _injectIntoOptional(/*pointer_to_pointer*/_this.nativeUTF8Start), _this.largeCount, {})
----Swift.(file)._StringObject.hasObjCBridgeableObject
let _this = this;
return Bool.prefix_33(_this.isImmortal, {})
----Swift.(file)._StringObject.isFastZeroTerminated
let _this = this;
if((_slowPath(Bool.prefix_33(_this.providesFastUTF8, {}), {}))) {
return false;
};
if((_this.isSmall)) {
return true;
};
return _this.largeFastIsTailAllocated
----Swift.(file)._StringObject.init(immortal:UnsafeBufferPointer<UInt8>,isASCII:Bool)
let _this = this;
const countAndFlags = _create(_StringObject.CountAndFlags, 'initImmortalCountIntIsASCIIBool', bufPtr.count, isASCII, {});
const biasedAddress = UInt.infix_38_45(_create(UInt, 'initBitPatternOptional', _injectIntoOptional(bufPtr.baseAddress._unsafelyUnwrappedUnchecked), {}), _StringObject.nativeBias, {});
_this.initPointerBitsUInt64DiscriminatorUInt64CountAndFlags_StringObjectCountAndFlags(_create(UInt64, 'initTruncatingIfNeeded', biasedAddress, {}), _StringObject.Nibbles.largeImmortal( {}), countAndFlags, {});
return
----Swift.(file)._StringObject.init(_:<<error type>>)
let _this = this;
_this.initObjectAnyObjectDiscriminatorUInt64CountAndFlags_StringObjectCountAndFlags(storage, _StringObject.Nibbles.largeMortal( {}), storage._countAndFlags, {});
return
----Swift.(file)._StringObject.init(_:<<error type>>)
let _this = this;
_this.initObjectAnyObjectDiscriminatorUInt64CountAndFlags_StringObjectCountAndFlags(storage, _StringObject.Nibbles.largeMortal( {}), storage._countAndFlags, {});
return
----Swift.(file)._StringObject.init(cocoa:AnyObject,providesFastUTF8:Bool,isASCII:Bool,length:Int)
let _this = this;
const countAndFlags = _create(_StringObject.CountAndFlags, 'initSharedCountIntIsASCIIBool', _length, isASCII, {});
const discriminator = _StringObject.Nibbles.largeCocoaProvidesFastUTF8(providesFastUTF8, {});
_this.initObjectAnyObjectDiscriminatorUInt64CountAndFlags_StringObjectCountAndFlags(cocoa, discriminator, countAndFlags, {});
return
----Swift.(file).String.init(repeating:Character,count:Int)
let _this = this;
_this.initRepeatingStringCountInt(repeatedValue._str, count, {});
return
----Swift.(file).String.init(_:S)
let _this = this;
const $ifLet0, str_1
if((($ifLet0 = _injectIntoOptional(other))||true) && $ifLet0.rawValue == 'some' && ((str_1 = $ifLet0[0])||true)) {
return _cloneStruct(str_1);
return ;
};
return _cloneStruct(other.description);
return
----Swift.(file).String.init(_:S)
let _this = this;
const $ifLet0, str_1
if((($ifLet0 = _injectIntoOptional(characters))||true) && $ifLet0.rawValue == 'some' && ((str_1 = $ifLet0[0])||true)) {
return _cloneStruct(str_1);
return ;
};
const $ifLet2, subStr_3
if((($ifLet2 = _injectIntoOptional(characters))||true) && $ifLet2.rawValue == 'some' && ((subStr_3 = $ifLet2[0])||true)) {
_this.initSubstring(subStr_3, {});
return ;
};
return _cloneStruct("");
_this.appendContentsOf(characters, {$setThis: $val => return _cloneStruct($val)});
return
----Swift.(file).String.append(_:Character)
let _this = this;
_this.append(c._str, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
----Swift.(file).String.append(contentsOf:String)
let _this = this;
_this.append(newElements, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
----Swift.(file).String.append(contentsOf:S)
let _this = this;
const $ifLet0, str_1
if((($ifLet0 = _injectIntoOptional(newElements))||true) && $ifLet0.rawValue == 'some' && ((str_1 = $ifLet0[0])||true)) {
_this.append(str_1, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
return ;
};
const $ifLet2, substr_3
if((($ifLet2 = _injectIntoOptional(newElements))||true) && $ifLet2.rawValue == 'some' && ((substr_3 = $ifLet2[0])||true)) {
_this.appendContentsOf(substr_3, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
return ;
};
{
let $c$generator = newElements.makeIterator( {});
while(true) {
const $ifLet4, c_5;
if(!((($ifLet4 = $c$generator.next( {$setThis: $val => $c$generator = $val}))||true) && $ifLet4.rawValue == 'some' && ((c_5 = $ifLet4[0])||true))) break
_this.append(c_5._str, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))});
}
}
----Swift.(file).String.insert(_:Character,at:String.Index)
let _this = this;
_this.replaceSubrangeWith(String.Index.infix_46_46_60(i, i, {}), newElement._str, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
----Swift.(file).String.insert(contentsOf:S,at:String.Index)
let _this = this;
_this.replaceSubrangeWith(String.Index.infix_46_46_60(i, i, {}), newElements, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
----Swift.(file).String.max(_:T,_:T)
let _this = this;
return /*dot_syntax_base_ignored*/max(x, y, {})
----Swift.(file).String.min(_:T,_:T)
let _this = this;
return /*dot_syntax_base_ignored*/min(x, y, {})
----Swift.(file).Sequence.+infix(_:Self,_:String)
let _this = this;
fatalErrorFileLine(() => String()/*!default_value*/, '?3', '?3', {})
----Swift.(file).Sequence.+infix(_:String,_:Self)
let _this = this;
fatalErrorFileLine(() => String()/*!default_value*/, '?3', '?3', {})
----Swift.(file).__StringStorage.create(capacity:Int,countAndFlags:<<error type>>)
let _this = this;
const realCapacity = determineCodeUnitCapacity(capacity, {});
return __StringStorage.createRealCodeUnitCapacityCountAndFlags(realCapacity, countAndFlags, {})
----Swift.(file).__StringStorage.create(initializingFrom:UnsafeBufferPointer<UInt8>,capacity:Int,isASCII:Bool)
let _this = this;
const countAndFlags = _create(CountAndFlags, 'initMortalCountIntIsASCIIBool', bufPtr.count, isASCII, {});
const storage = __StringStorage.createCapacityCountAndFlags(capacity, countAndFlags, {});
const addr = _cloneStruct(bufPtr.baseAddress._unsafelyUnwrappedUnchecked);
storage.mutableStart.initializeFromCount(addr, bufPtr.count, {});
storage._invariantCheck( {});
return storage
----Swift.(file).__StringStorage.create(initializingFrom:UnsafeBufferPointer<UInt8>,isASCII:Bool)
let _this = this;
return __StringStorage.createInitializingFromCapacityIsASCII(bufPtr, bufPtr.count, isASCII, {})
----Swift.(file).__StringStorage.mutableEnd
let _this = this;
return UnsafeMutablePointer.infix_43(_this.mutableStart, _this.count, {})
----Swift.(file).__StringStorage.start
let _this = this;
return _create(UnsafePointer, 'init', /*pointer_to_pointer*/_this.mutableStart, {})
----Swift.(file).__StringStorage.end
let _this = this;
return _create(UnsafePointer, 'init', /*pointer_to_pointer*/_this.mutableEnd, {})
----Swift.(file).__StringStorage.terminator
let _this = this;
return _this.mutableEnd
----Swift.(file).__StringStorage.codeUnits
let _this = this;
return _create(UnsafeBufferPointer, 'initStartOptionalCountInt', _injectIntoOptional(/*pointer_to_pointer*/_this.start), _this.count, {})
----Swift.(file).__StringStorage.capacity
let _this = this;
return Int.infix_38_45(_this._realCapacity, 1, {})
----Swift.(file).__StringStorage.unusedStorage
let _this = this;
return _create(UnsafeMutableBufferPointer, 'initStartOptionalCountInt', _injectIntoOptional(/*pointer_to_pointer*/_this.mutableEnd), _this.unusedCapacity, {})
----Swift.(file).__StringStorage.unusedCapacity
let _this = this;
return Int.infix_38_45(Int.infix_38_45(_this._realCapacity, _this.count, {}), 1, {})
----Swift.(file).__StringStorage.appendInPlace(_:UnsafeBufferPointer<UInt8>,isASCII:Bool)
let _this = this;
const srcAddr = _cloneStruct(other.baseAddress._unsafelyUnwrappedUnchecked);
const srcCount = other.count;
_this.mutableEnd.initializeFromCount(srcAddr, srcCount, {});
_this._postAppendAdjustAppendedCountAppendedIsASCII(srcCount, isASCII, {})
----Swift.(file).__StringStorage.appendInPlace(_:Iter,isASCII:Bool)
let _this = this;
let other = other$inout.get()
const $result = (() => {
let srcCount = 0;
while(true){
const $ifLet0, cu_1
if(!((($ifLet0 = other.next( {$setThis: $val => other = $val}))||true) && $ifLet0.rawValue == 'some' && ((cu_1 = $ifLet0[0])||true))) break
_this.unusedStorage.subscript$set(cu_1, srcCount, {$setThis: $val => _this.unusedStorage = _cloneStruct($val)});
Int.infix_43_61({get: () => srcCount, set: $val => srcCount = $val}, 1, {});
};
_this._postAppendAdjustAppendedCountAppendedIsASCII(srcCount, isASCII, {});})()
other$inout.set(other)
return $result
----Swift.(file).__StringStorage.clear()
let _this = this;
_this._postRRCAdjustNewCountNewIsASCII(0, true, {})
----Swift.(file).__StringStorage.remove(from:Int,to:Int)
let _this = this;
const lowerPtr = _cloneStruct(UnsafeMutablePointer.infix_43(_this.mutableStart, lower, {}));
const upperPtr = _cloneStruct(UnsafeMutablePointer.infix_43(_this.mutableStart, upper, {}));
const tailCount = UnsafeMutablePointer.infix_45(_this.mutableEnd, upperPtr, {});
lowerPtr.moveInitializeFromCount(upperPtr, tailCount, {});
_this._postRRCAdjustNewCountNewIsASCII(Int.infix_38_45(_this.count, Int.infix_38_45(upper, lower, {}), {}), _this.isASCII, {})
----Swift.(file).__StringStorage.replace(from:Int,to:Int,with:UnsafeBufferPointer<UInt8>)
let _this = this;
const replCount = replacement.count;
const lowerPtr = _cloneStruct(UnsafeMutablePointer.infix_43(_this.mutableStart, lower, {}));
const tailCount = _this._slideTailSrcDst(UnsafeMutablePointer.infix_43(_this.mutableStart, upper, {}), UnsafeMutablePointer.infix_43(lowerPtr, replCount, {}), {});
lowerPtr.moveInitializeFromCount(_create(UnsafeMutablePointer, 'initMutatingUnsafePointer', replacement.baseAddress._unsafelyUnwrappedUnchecked, {}), replCount, {});
const isASCII = Bool.infix_38_38(_this.isASCII, () => _allASCII(replacement, {}), {});
_this._postRRCAdjustNewCountNewIsASCII(Int.infix_43(Int.infix_43(lower, replCount, {}), tailCount, {}), isASCII, {})
----Swift.(file).__StringStorage.replace(from:Int,to:Int,with:C,replacementCount:Int)
let _this = this;
const lowerPtr = _cloneStruct(UnsafeMutablePointer.infix_43(_this.mutableStart, lower, {}));
const tailCount = _this._slideTailSrcDst(UnsafeMutablePointer.infix_43(_this.mutableStart, upper, {}), UnsafeMutablePointer.infix_43(lowerPtr, replCount, {}), {});
let isASCII = _this.isASCII;
let srcCount = 0;
{
let $cu$generator = replacement.makeIterator( {});
while(true) {
const $ifLet0, cu_1;
if(!((($ifLet0 = $cu$generator.next( {$setThis: $val => $cu$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((cu_1 = $ifLet0[0])||true))) break
if((UInt8.infix_62_61(cu_1, 0x80, {}))) {
isASCII = false;
};
lowerPtr.subscript$set(cu_1, srcCount, {$setThis: $val => lowerPtr = _cloneStruct($val)});
Int.infix_43_61({get: () => srcCount, set: $val => srcCount = $val}, 1, {});
}
};
_this._postRRCAdjustNewCountNewIsASCII(Int.infix_43(Int.infix_43(lower, replCount, {}), tailCount, {}), isASCII, {})
----Swift.(file)..(error_type).debugDescription
let _this = this;
return (("StringUTF16(") + (_this.description.debugDescription) + (")"))
----Swift.(file)..(error_type).samePosition(in:String.UnicodeScalarView)
let _this = this;
return _create(String.UnicodeScalarIndex, 'initStringIndexWithinStringUnicodeScalarView', _this, unicodeScalars, {})
----Swift.(file)..(error_type).customMirror
let _this = this;
return _create(Mirror, 'initUnlabeledChildrenDisplayStyleOptionalAncestorRepresentationMirrorAncestorRepresentation', _this, _this, nil/*!default_value*/, .generated/*!default_value*/, {})
----Swift.(file)..(error_type).subscript(_:Range<String.UTF16View.Index>)
let _this = this;
return _create(Substring.UTF16View, 'initStringUTF16View_boundsRange', _this, r, {})
----Swift.(file).repairUTF8(_:UnsafeBufferPointer<UInt8>,firstKnownBrokenRange:Range<Int>)
let result = _create(_StringGuts, 'init', {});
const replacementCharacterCount = Unicode.Scalar._replacementCharacter.withUTF8CodeUnits((($0, $info?) => $0.count), {});
let brokenRange = _cloneStruct(firstKnownBrokenRange);
let remainingInput = _cloneStruct(input);
do {
const goodChunk = _cloneStruct(remainingInput.subscript$get(Int.prefix_46_46_60(brokenRange.startIndex, {}), {}));
result.appendInPlaceIsASCII(_create(UnsafeBufferPointer, 'initRebasingSlice', goodChunk, {}), false, {$setThis: $val => result = $val});
Unicode.Scalar._replacementCharacter.withUTF8CodeUnits((($0, $info?) => result.appendInPlaceIsASCII($0, false, {$setThis: $val => result = $val})), {});
remainingInput = _create(UnsafeBufferPointer, 'initRebasingSlice', remainingInput.subscript$get(Int.postfix_46_46_46(brokenRange.endIndex, {}), {}), {});
const $match = validateUTF8(remainingInput, {})
if((($match.rawValue == UTF8ValidationResult.success().rawValue))) {
result.appendInPlaceIsASCII(remainingInput, false, {$setThis: $val => result = $val});
return _create(String, 'init_StringGuts', result, {});
}
else if((($match.rawValue == UTF8ValidationResult.error().rawValue))) {
const newBrokenRange = $match[0]
brokenRange = _cloneStruct(newBrokenRange);
};
} while(Int.infix_62(remainingInput.count, 0, {}));
return _create(String, 'init_StringGuts', result, {})
----Swift.(file)..(error_type).debugDescription
let _this = this;
return (("UTF8View(") + (_this.description.debugDescription) + (")"))
----Swift.(file)..(error_type).customMirror
let _this = this;
return _create(Mirror, 'initUnlabeledChildrenDisplayStyleOptionalAncestorRepresentationMirrorAncestorRepresentation', _this, _this, nil/*!default_value*/, .generated/*!default_value*/, {})
----Swift.(file)..(error_type).subscript(_:Range<String.UTF8View.Index>)
let _this = this;
return _create(Substring.UTF8View, 'initStringUTF8View_boundsRange', _this, r, {})
----Swift.(file)..(error_type).debugDescription
let _this = this;
return (("StringUnicodeScalarView(") + (_this.description.debugDescription) + (")"))
----Swift.(file)..(error_type).init()
let _this = this;
_this.init_StringGuts(_create(_StringGuts, 'init', {}), {});
return
----Swift.(file)..(error_type).samePosition(in:String)
let _this = this;
return _create(String.Index, 'initStringIndexWithinString', _this, characters, {})
----Swift.(file)..(error_type).customMirror
let _this = this;
return _create(Mirror, 'initUnlabeledChildrenDisplayStyleOptionalAncestorRepresentationMirrorAncestorRepresentation', _this, _this, nil/*!default_value*/, .generated/*!default_value*/, {})
----Swift.(file)..(error_type).subscript(_:Range<String.UnicodeScalarView.Index>)
let _this = this;
return _create(String.UnicodeScalarView.SubSequence, 'initStringUnicodeScalarView_boundsRange', _this, r, {})
----Swift.(file).String.init(_:Substring)
let _this = this;
return _cloneStruct(String._fromSubstring(substring, {}));
return
----Swift.(file).Substring.init(_:Slice<String>)
let _this = this;
_this._slice = _cloneStruct(slice);
_this._invariantCheck( {});
return
----Swift.(file).Substring.init()
let _this = this;
_this.initSlice(_create(Slice, 'init', {}), {});
return
----Swift.(file).Substring.startIndex
let _this = this;
return _this._slice.startIndex
----Swift.(file).Substring.endIndex
let _this = this;
return _this._slice.endIndex
----Swift.(file).Substring.index(after:Substring.Index)
let _this = this;
preconditionFileLine(() => String.Index.infix_60(i, _this.endIndex, {}), () => "Cannot increment beyond endIndex", '?3', '?3', {});
preconditionFileLine(() => Substring.Index.infix_62_61(i, _this.startIndex, {}), () => "Cannot increment an invalid index", '?3', '?3', {});
return _this._slice.indexAfter(i, {})
----Swift.(file).Substring.index(before:Substring.Index)
let _this = this;
preconditionFileLine(() => Substring.Index.infix_60_61(i, _this.endIndex, {}), () => "Cannot decrement an invalid index", '?3', '?3', {});
preconditionFileLine(() => Substring.Index.infix_62(i, _this.startIndex, {}), () => "Cannot decrement beyond startIndex", '?3', '?3', {});
return _this._slice.indexBefore(i, {})
----Swift.(file).Substring.index(_:Substring.Index,offsetBy:Int)
let _this = this;
const result = _cloneStruct(_this._slice.indexOffsetBy(i, n, {}));
preconditionFileLine(() => String.Index.infix_46_46_46(_this._slice._startIndex, _this._slice.endIndex, {}).contains(result, {}), () => "Operation results in an invalid index", '?3', '?3', {});
return result
----Swift.(file).Substring.index(_:Substring.Index,offsetBy:Int,limitedBy:Substring.Index)
let _this = this;
const result = _this._slice.indexOffsetByLimitedBy(i, n, limit, {});
preconditionFileLine(() => infix_63_63(result.mapSwift((($0, $info?) => String.Index.infix_46_46_46(_this._slice._startIndex, _this._slice.endIndex, {}).contains($0, {})), {}), () => true, {}), () => "Operation results in an invalid index", '?3', '?3', {});
return result
----Swift.(file).Substring.distance(from:Substring.Index,to:Substring.Index)
let _this = this;
return _this._slice.distanceFromTo(start, end, {})
----Swift.(file).Substring.subscript(_:Substring.Index)
let _this = this;
return _this._slice.subscript$get(i, {})
----Swift.(file).Substring.replaceSubrange(_:Range<Substring.Index>,with:C)
let _this = this;
_this._slice.replaceSubrangeWith(bounds, newElements, {$setThis: $val => _this._slice = $val})
----Swift.(file).Substring.replaceSubrange(_:Range<Substring.Index>,with:Substring)
let _this = this;
_this.replaceSubrangeWith(bounds, newElements._slice, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
----Swift.(file).Substring.init(decoding:C,as:Encoding.Type)
let _this = this;
_this.initString(_create(String, 'initDecodingAs', codeUnits, sourceEncoding, {}), {});
return
----Swift.(file).Substring.init(cString:UnsafePointer<CChar>)
let _this = this;
_this.initString(_create(String, 'initCStringUnsafePointer', nullTerminatedUTF8, {}), {});
return
----Swift.(file).Substring.init(decodingCString:UnsafePointer<Encoding.CodeUnit>,as:Encoding.Type)
let _this = this;
_this.initString(_create(String, 'initDecodingCStringUnsafePointerAs', nullTerminatedCodeUnits, sourceEncoding, {}), {});
return
----Swift.(file).Substring.withCString(_:(UnsafePointer<CChar>) throws -> Result)
let _this = this;
return _create(String, 'initSubstring', _this, {}).withCString(body, {})
----Swift.(file).Substring.withCString(encodedAs:TargetEncoding.Type,_:(UnsafePointer<TargetEncoding.CodeUnit>) throws -> Result)
let _this = this;
return _create(String, 'initSubstring', _this, {}).withCStringEncodedAs(targetEncoding, body, {})
----Swift.(file).Substring.customMirror
let _this = this;
return _create(String, 'initSubstring', _this, {}).customMirror
----Swift.(file).Substring.description
let _this = this;
return _create(String, 'initSubstring', _this, {})
----Swift.(file).Substring.debugDescription
let _this = this;
return _create(String, 'initSubstring', _this, {}).debugDescription
----Swift.(file).Substring.init(_:String)
let _this = this;
$info.$setThis(_this = _cloneStruct(_cloneStruct(content.subscriptUnboundedRange$get(UnboundedRange_.postfix_46_46_46, {}))));
return
----Swift.(file).Substring.UTF8View.startIndex
let _this = this;
return _this._slice.startIndex
----Swift.(file).Substring.UTF8View.endIndex
let _this = this;
return _this._slice.endIndex
----Swift.(file).Substring.UTF8View.subscript(_:Substring.UTF8View.Index)
let _this = this;
return _this._slice.subscript$get(index, {})
----Swift.(file).Substring.UTF8View.indices
let _this = this;
return _this._slice.indices
----Swift.(file).Substring.UTF8View.index(after:Substring.UTF8View.Index)
let _this = this;
return _this._slice.indexAfter(i, {})
----Swift.(file).Substring.UTF8View.formIndex(after:Substring.UTF8View.Index)
let _this = this;
let i = i$inout.get()
const $result = (() => {
_this._slice.formIndexAfter({get: () => i, set: $val => i = $val}, {});})()
i$inout.set(i)
return $result
----Swift.(file).Substring.UTF8View.index(_:Substring.UTF8View.Index,offsetBy:Int)
let _this = this;
return _this._slice.indexOffsetBy(i, n, {})
----Swift.(file).Substring.UTF8View.index(_:Substring.UTF8View.Index,offsetBy:Int,limitedBy:Substring.UTF8View.Index)
let _this = this;
return _this._slice.indexOffsetByLimitedBy(i, n, limit, {})
----Swift.(file).Substring.UTF8View.distance(from:Substring.UTF8View.Index,to:Substring.UTF8View.Index)
let _this = this;
return _this._slice.distanceFromTo(start, end, {})
----Swift.(file).Substring.UTF8View.index(before:Substring.UTF8View.Index)
let _this = this;
return _this._slice.indexBefore(i, {})
----Swift.(file).Substring.UTF8View.formIndex(before:Substring.UTF8View.Index)
let _this = this;
let i = i$inout.get()
const $result = (() => {
_this._slice.formIndexBefore({get: () => i, set: $val => i = $val}, {});})()
i$inout.set(i)
return $result
----Swift.(file).Substring.UTF8View.subscript(_:Range<Substring.UTF8View.Index>)
let _this = this;
preconditionFileLine(() => Bool.infix_38_38(Substring.UTF8View.Index.infix_62_61(r.lowerBound, _this.startIndex, {}), () => Substring.UTF8View.Index.infix_60_61(r.upperBound, _this.endIndex, {}), {}), () => "UTF8View index range out of bounds", '?3', '?3', {});
return _create(Substring.UTF8View, 'initStringUTF8View_boundsRange', _this._slice.base, r, {})
----Swift.(file).Substring.utf8
let _this = this;
return _this._wholeString.utf8.subscriptRange$get(String.UTF8View.Index.infix_46_46_60(_this.startIndex, _this.endIndex, {}), {})
----Swift.(file).Substring.UTF16View.startIndex
let _this = this;
return _this._slice.startIndex
----Swift.(file).Substring.UTF16View.endIndex
let _this = this;
return _this._slice.endIndex
----Swift.(file).Substring.UTF16View.subscript(_:Substring.UTF16View.Index)
let _this = this;
return _this._slice.subscript$get(index, {})
----Swift.(file).Substring.UTF16View.indices
let _this = this;
return _this._slice.indices
----Swift.(file).Substring.UTF16View.index(after:Substring.UTF16View.Index)
let _this = this;
return _this._slice.indexAfter(i, {})
----Swift.(file).Substring.UTF16View.formIndex(after:Substring.UTF16View.Index)
let _this = this;
let i = i$inout.get()
const $result = (() => {
_this._slice.formIndexAfter({get: () => i, set: $val => i = $val}, {});})()
i$inout.set(i)
return $result
----Swift.(file).Substring.UTF16View.index(_:Substring.UTF16View.Index,offsetBy:Int)
let _this = this;
return _this._slice.indexOffsetBy(i, n, {})
----Swift.(file).Substring.UTF16View.index(_:Substring.UTF16View.Index,offsetBy:Int,limitedBy:Substring.UTF16View.Index)
let _this = this;
return _this._slice.indexOffsetByLimitedBy(i, n, limit, {})
----Swift.(file).Substring.UTF16View.distance(from:Substring.UTF16View.Index,to:Substring.UTF16View.Index)
let _this = this;
return _this._slice.distanceFromTo(start, end, {})
----Swift.(file).Substring.UTF16View.index(before:Substring.UTF16View.Index)
let _this = this;
return _this._slice.indexBefore(i, {})
----Swift.(file).Substring.UTF16View.formIndex(before:Substring.UTF16View.Index)
let _this = this;
let i = i$inout.get()
const $result = (() => {
_this._slice.formIndexBefore({get: () => i, set: $val => i = $val}, {});})()
i$inout.set(i)
return $result
----Swift.(file).Substring.UTF16View.subscript(_:Range<Substring.UTF16View.Index>)
let _this = this;
return _create(Substring.UTF16View, 'initStringUTF16View_boundsRange', _this._slice.base, r, {})
----Swift.(file).Substring.utf16
let _this = this;
return _this._wholeString.utf16.subscriptRange$get(String.UTF16View.Index.infix_46_46_60(_this.startIndex, _this.endIndex, {}), {})
----Swift.(file).Substring.UnicodeScalarView.startIndex
let _this = this;
return _this._slice.startIndex
----Swift.(file).Substring.UnicodeScalarView.endIndex
let _this = this;
return _this._slice.endIndex
----Swift.(file).Substring.UnicodeScalarView.subscript(_:Substring.UnicodeScalarView.Index)
let _this = this;
return _this._slice.subscript$get(index, {})
----Swift.(file).Substring.UnicodeScalarView.indices
let _this = this;
return _this._slice.indices
----Swift.(file).Substring.UnicodeScalarView.index(after:Substring.UnicodeScalarView.Index)
let _this = this;
return _this._slice.indexAfter(i, {})
----Swift.(file).Substring.UnicodeScalarView.formIndex(after:Substring.UnicodeScalarView.Index)
let _this = this;
let i = i$inout.get()
const $result = (() => {
_this._slice.formIndexAfter({get: () => i, set: $val => i = $val}, {});})()
i$inout.set(i)
return $result
----Swift.(file).Substring.UnicodeScalarView.index(_:Substring.UnicodeScalarView.Index,offsetBy:Int)
let _this = this;
return _this._slice.indexOffsetBy(i, n, {})
----Swift.(file).Substring.UnicodeScalarView.index(_:Substring.UnicodeScalarView.Index,offsetBy:Int,limitedBy:Substring.UnicodeScalarView.Index)
let _this = this;
return _this._slice.indexOffsetByLimitedBy(i, n, limit, {})
----Swift.(file).Substring.UnicodeScalarView.distance(from:Substring.UnicodeScalarView.Index,to:Substring.UnicodeScalarView.Index)
let _this = this;
return _this._slice.distanceFromTo(start, end, {})
----Swift.(file).Substring.UnicodeScalarView.index(before:Substring.UnicodeScalarView.Index)
let _this = this;
return _this._slice.indexBefore(i, {})
----Swift.(file).Substring.UnicodeScalarView.formIndex(before:Substring.UnicodeScalarView.Index)
let _this = this;
let i = i$inout.get()
const $result = (() => {
_this._slice.formIndexBefore({get: () => i, set: $val => i = $val}, {});})()
i$inout.set(i)
return $result
----Swift.(file).Substring.UnicodeScalarView.subscript(_:Range<Substring.UnicodeScalarView.Index>)
let _this = this;
return _create(Substring.UnicodeScalarView, 'initStringUnicodeScalarView_boundsRange', _this._slice.base, r, {})
----Swift.(file).Substring.unicodeScalars
let _this = this;
return _this._wholeString.unicodeScalars.subscriptRange$get(String.UnicodeScalarView.Index.infix_46_46_60(_this.startIndex, _this.endIndex, {}), {})
----Swift.(file).String.init(_:Substring.UnicodeScalarView)
let _this = this;
return _cloneStruct(_create(String, 'initSubstring', _create(Substring, 'initSubstringUnicodeScalarView', content, {}), {}));
return
----Swift.(file).Substring.UnicodeScalarView.init()
let _this = this;
_this._slice = _create(Slice, 'init', {});
return
----Swift.(file).Substring.UnicodeScalarView.replaceSubrange(_:Range<Substring.UnicodeScalarView.Index>,with:C)
let _this = this;
_this._slice.replaceSubrangeWith(target, replacement, {$setThis: $val => _this._slice = $val})
----Swift.(file).Substring.init(_:S)
let _this = this;
const $ifLet0, str_1
if((($ifLet0 = _injectIntoOptional(_elements))||true) && $ifLet0.rawValue == 'some' && ((str_1 = $ifLet0[0])||true)) {
$info.$setThis(_this = _cloneStruct(_cloneStruct(str_1.subscriptUnboundedRange$get(UnboundedRange_.postfix_46_46_46, {}))));
return ;
};
const $ifLet2, subStr_3
if((($ifLet2 = _injectIntoOptional(_elements))||true) && $ifLet2.rawValue == 'some' && ((subStr_3 = $ifLet2[0])||true)) {
$info.$setThis(_this = _cloneStruct(_cloneStruct(subStr_3)));
return ;
};
$info.$setThis(_this = _cloneStruct(_cloneStruct(_create(String, 'initBuffer', _elements, {}).subscriptUnboundedRange$get(UnboundedRange_.postfix_46_46_46, {}))));
return
----Swift.(file).Substring.append(contentsOf:S)
let _this = this;
let string = _create(String, 'initSubstring', _this, {});
$info.$setThis(_this = _cloneStruct(_create(Substring, 'init', {})));
string.appendContentsOf(_elements, {$setThis: $val => string = $val});
$info.$setThis(_this = _cloneStruct(_create(Substring, 'initString', string, {})))
----Swift.(file).Substring.lowercased()
let _this = this;
return _create(String, 'initSubstring', _this, {}).lowercased( {})
----Swift.(file).Substring.uppercased()
let _this = this;
return _create(String, 'initSubstring', _this, {}).uppercased( {})
----Swift.(file).Substring.filter(_:(Substring.Element) throws -> Bool)
let _this = this;
return _create(String, 'initBuffer', _this.lazy.filterSwift(isIncluded, {}), {})
----Swift.(file).Substring.write(_:String)
let _this = this;
_this.appendContentsOf(other, {$setThis: $val => $info.$setThis(_this = _cloneStruct($val))})
----Swift.(file).Substring.write(to:Target)
let _this = this;
let target = target$inout.get()
const $result = (() => {
target.write(_create(String, 'initSubstring', _this, {}), {$setThis: $val => target = $val});})()
target$inout.set(target)
return $result
----Swift.(file).Substring.init(unicodeScalarLiteral:String)
let _this = this;
_this.initString(value, {});
return
----Swift.(file).Substring.init(extendedGraphemeClusterLiteral:String)
let _this = this;
_this.initString(value, {});
return
----Swift.(file).Substring.init(stringLiteral:String)
let _this = this;
_this.initString(value, {});
return
----Swift.(file).String.subscript(_:Range<String.Index>)
let _this = this;
_this._boundsCheck(r, {});
return _create(Substring, 'initSlice', _create(Slice, 'initBaseBoundsRange', _this, r, {}), {})
----Swift.(file).Substring.subscript(_:Range<Substring.Index>)
let _this = this;
return _create(Substring, 'initSlice', _this._slice.subscriptRange$get(r, {}), {})
----Swift.(file).__SwiftNativeNSArrayWithContiguousStorage.objectAt(_:Int)
let _this = this;
return _this.withUnsafeBufferOfObjects(((objects, $info?) => { 
preconditionFileLine(() => _isValidArraySubscriptCount(index, objects.count, {}), () => "Array index out of range", '?3', '?3', {});
return objects.subscript$get(index, {}); }), {})
----Swift.(file).__SwiftNativeNSArrayWithContiguousStorage.copy(with:<<error type>>)
let _this = this;
return _this
----Swift.(file)._UIntBuffer.SubSequence

----Swift.(file)._UIntBuffer.Iterator.init(_:_UIntBuffer<Element>)
let _this = this;
_this._impl = _cloneStruct(x);
return
----Swift.(file)._UIntBuffer.Iterator.next()
let _this = this;
if((UInt8.infix_61_61(_this._impl._bitCount, 0, {}))) {
return Optional.none;
};
let $defer = () => {
_this._impl._storage = _UIntBuffer.Storage.infix_38_62_62(_this._impl._storage, ((function(){throw '!unclarifiedGeneric:Element'})()).bitWidth, {});
_this._impl._bitCount = UInt8.infix_38_45(_this._impl._bitCount, _this._impl._elementWidth, {});
}
const $result = (() => {
try {;
return _injectIntoOptional(_create(((function(){throw '!unclarifiedGeneric:Element'})()), 'initTruncatingIfNeeded', _this._impl._storage, {}));}catch($error){$defer( {});throw $error}})();$defer( {});return $result
----Swift.(file)._UIntBuffer.makeIterator()
let _this = this;
return _create(_UIntBuffer.Iterator, 'init_UIntBuffer', _this, {})
----Swift.(file)._UIntBuffer.Index.init(bitOffset:UInt8)
let _this = this;
_this.bitOffset = bitOffset;
return
----Swift.(file)._UIntBuffer.startIndex
let _this = this;
return _create(_UIntBuffer.Index, 'initBitOffsetUInt8', 0, {})
----Swift.(file)._UIntBuffer.endIndex
let _this = this;
return _create(_UIntBuffer.Index, 'initBitOffsetUInt8', _this._bitCount, {})
----Swift.(file)._UIntBuffer.index(after:_UIntBuffer<Element>.Index)
let _this = this;
return _create(_UIntBuffer.Index, 'initBitOffsetUInt8', UInt8.infix_38_43(i.bitOffset, _this._elementWidth, {}), {})
----Swift.(file)._UIntBuffer.subscript(_:_UIntBuffer<Element>.Index)
let _this = this;
return _create(((function(){throw '!unclarifiedGeneric:Element'})()), 'initTruncatingIfNeeded', _UIntBuffer.Storage.infix_38_62_62(_this._storage, i.bitOffset, {}), {})
----Swift.(file)._UIntBuffer.index(before:_UIntBuffer<Element>.Index)
let _this = this;
return _create(_UIntBuffer.Index, 'initBitOffsetUInt8', UInt8.infix_38_45(i.bitOffset, _this._elementWidth, {}), {})
----Swift.(file)._UIntBuffer.Indices

----Swift.(file)._UIntBuffer.index(_:_UIntBuffer<Element>.Index,offsetBy:Int)
let _this = this;
const x = Int.infix_38_43(_create(Int, 'initT', i.bitOffset, {}), Int.infix_38_42(n, ((function(){throw '!unclarifiedGeneric:Element'})()).bitWidth, {}), {});
return _create(_UIntBuffer.Index, 'initBitOffsetUInt8', _create(UInt8, 'initTruncatingIfNeeded', x, {}), {})
----Swift.(file)._UIntBuffer.distance(from:_UIntBuffer<Element>.Index,to:_UIntBuffer<Element>.Index)
let _this = this;
return Int.infix_47(Int.infix_38_45(_create(Int, 'initT', j.bitOffset, {}), _create(Int, 'initT', i.bitOffset, {}), {}), ((function(){throw '!unclarifiedGeneric:Element'})()).bitWidth, {})
----Swift.(file)._UIntBuffer.init()
let _this = this;
_this._storage = 0;
_this._bitCount = 0;
return
----Swift.(file)._UIntBuffer.capacity
let _this = this;
return Int.infix_47(_UIntBuffer.Storage.bitWidth, ((function(){throw '!unclarifiedGeneric:Element'})()).bitWidth, {})
----Swift.(file)._UIntBuffer.append(_:Element)
let _this = this;
preconditionFileLine(() => Int.infix_60_61(Int.infix_43(_this.count, 1, {}), _this.capacity, {}), () => String()/*!default_value*/, '?3', '?3', {});
UInt32.infix_38_61({get: () => _this._storage, set: $val => _this._storage = $val}, UInt32.prefix_126(_UIntBuffer.Storage.infix_38_60_60(_create(_UIntBuffer.Storage, 'initT', ((function(){throw '!unclarifiedGeneric:Element'})()).max, {}), _this._bitCount, {}), {}), {});
UInt32.infix_124_61({get: () => _this._storage, set: $val => _this._storage = $val}, UInt32.infix_38_60_60(_create(_UIntBuffer.Storage, 'initT', newElement, {}), _this._bitCount, {}), {});
_this._bitCount = UInt8.infix_38_43(_this._bitCount, _this._elementWidth, {})
----Swift.(file)._UIntBuffer.removeFirst()
let _this = this;
preconditionFileLine(() => Bool.prefix_33(_this.isEmpty, {}), () => String()/*!default_value*/, '?3', '?3', {});
const result = _create(((function(){throw '!unclarifiedGeneric:Element'})()), 'initTruncatingIfNeeded', _this._storage, {});
_this._bitCount = UInt8.infix_38_45(_this._bitCount, _this._elementWidth, {});
_this._storage = _UIntBuffer.Storage.prototype._fullShiftRight.call(_this._storage, _this._elementWidth, {});
return result
----Swift.(file)._UIntBuffer.replaceSubrange(_:Range<_UIntBuffer<Element>.Index>,with:C)
let _this = this;
preconditionFileLine(() => UInt8.infix_46_46_60(0, _this._bitCount, {})._contains_(UInt8.infix_46_46_60(target.lowerBound.bitOffset, target.upperBound.bitOffset, {}), {}), () => String()/*!default_value*/, '?3', '?3', {});
const replacement1 = _create(_UIntBuffer, 'initBuffer', replacement, {});
const targetCount = _this.distanceFromTo(target.lowerBound, target.upperBound, {});
const growth = Int.infix_38_45(replacement1.count, targetCount, {});
preconditionFileLine(() => Int.infix_60_61(Int.infix_43(_this.count, growth, {}), _this.capacity, {}), () => String()/*!default_value*/, '?3', '?3', {});
const headCount = _this.distanceFromTo(_this.startIndex, target.lowerBound, {});
const tailOffset = _this.distanceFromTo(_this.startIndex, target.upperBound, {});
const w = ((function(){throw '!unclarifiedGeneric:Element'})()).bitWidth;
const headBits = UInt32.infix_38(_this._storage, UInt32._lowBits(Int.infix_38_42(headCount, w, {}), {}), {});
const tailBits = _UIntBuffer.Storage.prototype._fullShiftRight.call(_this._storage, Int.infix_38_42(tailOffset, w, {}), {});
_this._storage = headBits;
UInt32.infix_124_61({get: () => _this._storage, set: $val => _this._storage = $val}, UInt32.infix_38_60_60(replacement1._storage, Int.infix_38_42(headCount, w, {}), {}), {});
UInt32.infix_124_61({get: () => _this._storage, set: $val => _this._storage = $val}, UInt32.infix_38_60_60(tailBits, Int.infix_38_42(Int.infix_38_43(tailOffset, growth, {}), w, {}), {}), {});
_this._bitCount = _create(UInt8, 'initTruncatingIfNeeded', Int.infix_38_43(_create(Int, 'initT', _this._bitCount, {}), Int.infix_38_42(growth, w, {}), {}), {})
----Swift.(file)..(error_type).EncodedScalar

----Swift.(file)..(error_type).encodedReplacementCharacter
let _this = this;
return _create(Unicode.UTF16.EncodedScalar, 'init_storage_UIntBufferStorage_bitCountUInt8', 0xFFFD, 16, {});
}
static get encodedReplacementCharacter() { return this.encodedReplacementCharacter$get()
----Swift.(file)..(error_type).decode(_:Unicode.UTF16.EncodedScalar)
let _this = this;
const bits = source._storage;
if((_fastPath(UInt8.infix_61_61(source._bitCount, 16, {}), {}))) {
return _create(Unicode.Scalar, 'init_uncheckedUInt32', UInt32.infix_38(bits, 0xffff, {}), {});
};
const lower = UInt32.infix_38(UInt32.infix_62_62(bits, 16, {}), 0x03ff, {});
const upper = UInt32.infix_60_60(UInt32.infix_38(bits, 0x03ff, {}), 10, {});
const value = UInt32.infix_43(0x10000, UInt32.infix_124(lower, upper, {}), {});
return _create(Unicode.Scalar, 'init_uncheckedUInt32', value, {})
----Swift.(file)..(error_type).encode(_:Unicode.Scalar)
let _this = this;
const x = source.value;
if((_fastPath(UInt32.infix_60(x, UInt32.infix_60_60(1, 16, {}), {}), {}))) {
return _injectIntoOptional(_create(Unicode.UTF16.EncodedScalar, 'init_storage_UIntBufferStorage_bitCountUInt8', x, 16, {}));
};
const x1 = UInt32.infix_45(x, UInt32.infix_60_60(1, 16, {}), {});
let r = UInt32.infix_43(0xdc00, UInt32.infix_38(x1, 0x3ff, {}), {});
UInt32.infix_38_60_60_61({get: () => r, set: $val => r = $val}, 16, {});
UInt32.infix_124_61({get: () => r, set: $val => r = $val}, UInt32.infix_43(0xd800, UInt32.infix_38(UInt32.infix_38_62_62(x1, 10, {}), 0x3ff, {}), {}), {});
return _injectIntoOptional(_create(Unicode.UTF16.EncodedScalar, 'init_storage_UIntBufferStorage_bitCountUInt8', r, 32, {}))
----Swift.(file)..(error_type).transcode(_:FromEncoding.EncodedScalar,from:FromEncoding.Type)
let _this = this;
if((_fastPath(infix_61_61(_injectIntoOptional(((function(){throw '!unclarifiedGeneric:FromEncoding'})())), _injectIntoOptional(UTF8), {}), {}))) {
const c = _cloneStruct(_identityCastTo(content, UTF8.EncodedScalar, {}));
let b = c.count;
b = Int.infix_38_45(b, 1, {});
if((_fastPath(Int.infix_61_61(b, 0, {}), {}))) {
return _injectIntoOptional(_create(Unicode.UTF16.EncodedScalar, 'init_storage_UIntBufferStorage_bitCountUInt8', UInt32.infix_38(UInt32.infix_38_45(c._biasedBits, 0x1, {}), 0b01111111, {}), 16, {}));
};
let s = UInt32.infix_38_45(c._biasedBits, 0x01010101, {});
let r = s;
UInt32.infix_38_60_60_61({get: () => r, set: $val => r = $val}, 6, {});
UInt32.infix_38_62_62_61({get: () => s, set: $val => s = $val}, 8, {});
UInt32.infix_124_61({get: () => r, set: $val => r = $val}, UInt32.infix_38(s, 0b0111111, {}), {});
b = Int.infix_38_45(b, 1, {});
if((_fastPath(Int.infix_61_61(b, 0, {}), {}))) {
return _injectIntoOptional(_create(Unicode.UTF16.EncodedScalar, 'init_storage_UIntBufferStorage_bitCountUInt8', UInt32.infix_38(r, 0b011111111111, {}), 16, {}));
};
UInt32.infix_38_60_60_61({get: () => r, set: $val => r = $val}, 6, {});
UInt32.infix_38_62_62_61({get: () => s, set: $val => s = $val}, 8, {});
UInt32.infix_124_61({get: () => r, set: $val => r = $val}, UInt32.infix_38(s, 0b0111111, {}), {});
b = Int.infix_38_45(b, 1, {});
if((_fastPath(Int.infix_61_61(b, 0, {}), {}))) {
return _injectIntoOptional(_create(Unicode.UTF16.EncodedScalar, 'init_storage_UIntBufferStorage_bitCountUInt8', UInt32.infix_38(r, 0xFFFF, {}), 16, {}));
};
UInt32.infix_38_60_60_61({get: () => r, set: $val => r = $val}, 6, {});
UInt32.infix_38_62_62_61({get: () => s, set: $val => s = $val}, 8, {});
UInt32.infix_124_61({get: () => r, set: $val => r = $val}, UInt32.infix_38(s, 0b0111111, {}), {});
UInt32.infix_38_61({get: () => r, set: $val => r = $val}, UInt32.infix_45(UInt32.infix_38_60_60(1, 21, {}), 1, {}), {});
return _this.encode(_create(Unicode.Scalar, 'init_uncheckedUInt32', r, {}), {});
}
else {
if((_fastPath(infix_61_61(_injectIntoOptional(((function(){throw '!unclarifiedGeneric:FromEncoding'})())), _injectIntoOptional(UTF16), {}), {}))) {
return _injectIntoOptional(unsafeBitCastTo(content, UTF16.EncodedScalar, {}));
}
};
return _this.encode(((function(){throw '!unclarifiedGeneric:FromEncoding'})()).decode(content, {}), {})
----Swift.(file)..(error_type).EncodedScalar

----Swift.(file)..(error_type).encodedReplacementCharacter
let _this = this;
return _create(Unicode.UTF32.EncodedScalar, 'init', _this._replacementCodeUnit, {});
}
static get encodedReplacementCharacter() { return this.encodedReplacementCharacter$get()
----Swift.(file)..(error_type).decode(_:Unicode.UTF32.EncodedScalar)
let _this = this;
return _create(Unicode.Scalar, 'init_uncheckedUInt32', source.first[0], {})
----Swift.(file)..(error_type).encode(_:Unicode.Scalar)
let _this = this;
return _injectIntoOptional(_create(Unicode.UTF32.EncodedScalar, 'init', source.value, {}))
----Swift.(file).UTF32.Parser.parseScalar(from:I)
let _this = this;
let input = input$inout.get()
const $result = (() => {
const n = input.next( {$setThis: $val => input = $val});
const $ifLet0, x_1
if((_fastPath(Optional.wrappedNotEqualsOptionalNilComparisonType(n, _create(_OptionalNilComparisonType, 'initNilLiteraltuple_type', {}), {}), {})) && (($ifLet0 = n)||true) && $ifLet0.rawValue == 'some' && ((x_1 = $ifLet0[0])||true)) {
if(!((_fastPath(Bool.infix_38_38(UInt32.infix_33_61(UInt32.infix_38_62_62(x_1, 11, {}), 0b11011, {}), () => UInt32.infix_60_61(x_1, 0x10ffff, {}), {}), {})))) {
return Unicode.ParseResult.error(1, {});
};
return Unicode.ParseResult.valid(_create(UTF32.EncodedScalar, 'init', x_1, {}), {});
};
return Unicode.ParseResult.emptyInput;})()
input$inout.set(input)
return $result
----Swift.(file)..(error_type).encodedReplacementCharacter
let _this = this;
return Unicode.UTF8.EncodedScalar.encodedReplacementCharacter;
}
static get encodedReplacementCharacter() { return this.encodedReplacementCharacter$get()
----Swift.(file)..(error_type).decode(_:Unicode.UTF8.EncodedScalar)
let _this = this;
const $match = source.count
if((((infix_126_61(1, $match, {}))))) {
return _create(Unicode.Scalar, 'init_uncheckedUInt32', UInt32.infix_38_45(source._biasedBits, 0x01, {}), {});
}
else if((((infix_126_61(2, $match, {}))))) {
const bits = UInt32.infix_38_45(source._biasedBits, 0x0101, {});
let value = UInt32.infix_38_62_62(UInt32.infix_38(bits, 0b011111100000000, {}), 8, {});
UInt32.infix_124_61({get: () => value, set: $val => value = $val}, UInt32.infix_38_60_60(UInt32.infix_38(bits, 0b000011111, {}), 6, {}), {});
return _create(Unicode.Scalar, 'init_uncheckedUInt32', value, {});
}
else if((((infix_126_61(3, $match, {}))))) {
const bits = UInt32.infix_38_45(source._biasedBits, 0x010101, {});
let value = UInt32.infix_38_62_62(UInt32.infix_38(bits, 0b01111110000000000000000, {}), 16, {});
UInt32.infix_124_61({get: () => value, set: $val => value = $val}, UInt32.infix_38_62_62(UInt32.infix_38(bits, 0b011111100000000, {}), 2, {}), {});
UInt32.infix_124_61({get: () => value, set: $val => value = $val}, UInt32.infix_38_60_60(UInt32.infix_38(bits, 0b000001111, {}), 12, {}), {});
return _create(Unicode.Scalar, 'init_uncheckedUInt32', value, {});
}
else if(((true))) {
const bits = UInt32.infix_38_45(source._biasedBits, 0x01010101, {});
let value = UInt32.infix_38_62_62(UInt32.infix_38(bits, 0b0111111000000000000000000000000, {}), 24, {});
UInt32.infix_124_61({get: () => value, set: $val => value = $val}, UInt32.infix_38_62_62(UInt32.infix_38(bits, 0b01111110000000000000000, {}), 10, {}), {});
UInt32.infix_124_61({get: () => value, set: $val => value = $val}, UInt32.infix_38_60_60(UInt32.infix_38(bits, 0b011111100000000, {}), 4, {}), {});
UInt32.infix_124_61({get: () => value, set: $val => value = $val}, UInt32.infix_38_60_60(UInt32.infix_38(bits, 0b000000111, {}), 18, {}), {});
return _create(Unicode.Scalar, 'init_uncheckedUInt32', value, {});
}
----Swift.(file)..(error_type).encode(_:Unicode.Scalar)
let _this = this;
let c = source.value;
if((_fastPath(UInt32.infix_60(c, Int.infix_38_60_60(1, 7, {}), {}), {}))) {
return _injectIntoOptional(_create(Unicode.UTF8.EncodedScalar, 'init_containing_ValidUTF8BufferElement', _create(UInt8, 'initT', c, {}), {}));
};
let o = UInt32.infix_38(c, 0b000111111, {});
UInt32.infix_38_62_62_61({get: () => c, set: $val => c = $val}, 6, {});
UInt32.infix_38_60_60_61({get: () => o, set: $val => o = $val}, 8, {});
if((_fastPath(UInt32.infix_60(c, Int.infix_38_60_60(1, 5, {}), {}), {}))) {
return _injectIntoOptional(_create(Unicode.UTF8.EncodedScalar, 'init_biasedBitsUInt32', UInt32.infix_38_43(UInt32.infix_124(o, c, {}), 0b01000000111000001, {}), {}));
};
UInt32.infix_124_61({get: () => o, set: $val => o = $val}, UInt32.infix_38(c, 0b000111111, {}), {});
UInt32.infix_38_62_62_61({get: () => c, set: $val => c = $val}, 6, {});
UInt32.infix_38_60_60_61({get: () => o, set: $val => o = $val}, 8, {});
if((_fastPath(UInt32.infix_60(c, Int.infix_38_60_60(1, 4, {}), {}), {}))) {
return _injectIntoOptional(_create(Unicode.UTF8.EncodedScalar, 'init_biasedBitsUInt32', UInt32.infix_38_43(UInt32.infix_124(o, c, {}), 0b0100000011000000111100001, {}), {}));
};
UInt32.infix_124_61({get: () => o, set: $val => o = $val}, UInt32.infix_38(c, 0b000111111, {}), {});
UInt32.infix_38_62_62_61({get: () => c, set: $val => c = $val}, 6, {});
UInt32.infix_38_60_60_61({get: () => o, set: $val => o = $val}, 8, {});
return _injectIntoOptional(_create(Unicode.UTF8.EncodedScalar, 'init_biasedBitsUInt32', UInt32.infix_38_43(UInt32.infix_124(o, c, {}), 0b010000001100000011000000111110001, {}), {}))
----Swift.(file)..(error_type).transcode(_:FromEncoding.EncodedScalar,from:FromEncoding.Type)
let _this = this;
if((_fastPath(infix_61_61(_injectIntoOptional(((function(){throw '!unclarifiedGeneric:FromEncoding'})())), _injectIntoOptional(UTF16), {}), {}))) {
const c = _cloneStruct(_identityCastTo(content, UTF16.EncodedScalar, {}));
let u0 = _create(UInt16, 'initTruncatingIfNeeded', c._storage, {});
if((_fastPath(UInt16.infix_60(u0, 0x80, {}), {}))) {
return _injectIntoOptional(_create(Unicode.UTF8.EncodedScalar, 'init_containing_ValidUTF8BufferElement', _create(UInt8, 'initTruncatingIfNeeded', u0, {}), {}));
};
let r = _create(UInt32, 'initT', UInt16.infix_38(u0, 0b0111111, {}), {});
UInt32.infix_38_60_60_61({get: () => r, set: $val => r = $val}, 8, {});
UInt16.infix_38_62_62_61({get: () => u0, set: $val => u0 = $val}, 6, {});
if((_fastPath(UInt16.infix_60(u0, Int.infix_38_60_60(1, 5, {}), {}), {}))) {
return _injectIntoOptional(_create(Unicode.UTF8.EncodedScalar, 'init_biasedBitsUInt32', UInt32.infix_38_43(UInt32.infix_124(_create(UInt32, 'initT', u0, {}), r, {}), 0b01000000111000001, {}), {}));
};
UInt32.infix_124_61({get: () => r, set: $val => r = $val}, _create(UInt32, 'initT', UInt16.infix_38(u0, 0b0111111, {}), {}), {});
UInt32.infix_38_60_60_61({get: () => r, set: $val => r = $val}, 8, {});
if((_fastPath(UInt16.infix_33_61(UInt16.infix_38(u0, UInt16.infix_38_62_62(0xF800, 6, {}), {}), Int.infix_38_62_62(0xD800, 6, {}), {}), {}))) {
UInt16.infix_38_62_62_61({get: () => u0, set: $val => u0 = $val}, 6, {});
return _injectIntoOptional(_create(Unicode.UTF8.EncodedScalar, 'init_biasedBitsUInt32', UInt32.infix_38_43(UInt32.infix_124(_create(UInt32, 'initT', u0, {}), r, {}), 0b0100000011000000111100001, {}), {}));
};
}
else {
if((_fastPath(infix_61_61(_injectIntoOptional(((function(){throw '!unclarifiedGeneric:FromEncoding'})())), _injectIntoOptional(UTF8), {}), {}))) {
return _injectIntoOptional(_identityCastTo(content, UTF8.EncodedScalar, {}));
}
};
return _this.encode(((function(){throw '!unclarifiedGeneric:FromEncoding'})()).decode(content, {}), {})
----Swift.(file).sequence(first:T,next:(T) -> T?)
return sequenceStateNext({0: _injectIntoOptional(first), 1: true}, ((state$inout, $info?) => { 
const $match = state
if(((true))) {
const value = $match[0]
state["1"] = false;
return value;
}
else if((($match[0].rawValue == 'some'))) {
const value = $match[0][0]
const nextValue = next(value, {});
state["0"] = nextValue;
return nextValue;
}
else if((($match[0].rawValue == Optional.none.rawValue))) {
return Optional.none;
}; }), {})
----Swift.(file).sequence(state:State,next:(inout State) -> T?)
return _create(UnfoldSequence, 'init_state_nextfunction_type', state, next, {})
----Swift.(file).UnfoldFirstSequence
const UnfoldFirstSequence = UnfoldSequenc
----Swift.(file).UnfoldSequence.next()
let _this = this;
if(!((Bool.prefix_33(_this._done, {})))) {
return Optional.none;
};
const $ifLet0, elt_1
if((($ifLet0 = _this._next({get: () => _this._state, set: $val => _this._state = $val}, {}))||true) && $ifLet0.rawValue == 'some' && ((elt_1 = $ifLet0[0])||true)) {
return _injectIntoOptional(elt_1);
}
else {
_this._done = true;
return Optional.none;
}
----Swift.(file)._UnicodeEncoding.transcode(_:<<error type>>,from:FromEncoding.Type)
let _this = this;
return _this.encode(((function(){throw '!unclarifiedGeneric:FromEncoding'})()).decode(content, {}), {})
----Swift.(file)._StringGuts.scalarAlign(_:<<error type>>)
let _this = this;
if((_slowPath(Bool.infix_124_124(Int.infix_33_61(idx.transcodedOffset, 0, {}), () => Int.infix_61_61(idx._encodedOffset, 0, {}), {}), {}))) {
return _create(String.Index, 'init_encodedOffsetInt', idx._encodedOffset, {});
};
if((_slowPath(_this.isForeign, {}))) {
return _this.foreignScalarAlign(idx, {});
};
return _this.withFastUTF8(((utf8, $info?) => { 
const i = _scalarAlign(utf8, idx._encodedOffset, {});
if((Int.infix_61_61(i, idx._encodedOffset, {}))) {
return idx;
};
return _create(_StringGuts.Index, 'init_encodedOffsetInt', i, {}); }), {})
----Swift.(file)._StringGuts.fastUTF8ScalarLength(startingAt:Int)
let _this = this;
const len = _utf8ScalarLength(_this.withFastUTF8((($0, $info?) => $0.subscript$get(i, {})), {}), {});
return len
----Swift.(file)._StringGuts.fastUTF8ScalarLength(endingAt:Int)
let _this = this;
return _this.withFastUTF8(((utf8, $info?) => { 
let len = 1;
while(true){
if(!((_isContinuation(utf8.subscript$get(Int.infix_38_45(i, len, {}), {}), {})))) break
Int.infix_43_61({get: () => len, set: $val => len = $val}, 1, {});
};
return len; }), {})
----Swift.(file)._StringGuts.fastUTF8Scalar(startingAt:Int)
let _this = this;
return _this.withFastUTF8((($0, $info?) => _decodeScalarStartingAt($0, i, {})["0"]), {})
----Swift.(file)._StringGuts.isOnUnicodeScalarBoundary(_:String.Index)
let _this = this;
if(!((Int.infix_61_61(i.transcodedOffset, 0, {})))) {
return false;
};
if((Bool.infix_124_124(String.Index.infix_61_61(i, _this.startIndex, {}), () => String.Index.infix_61_61(i, _this.endIndex, {}), {}))) {
return true;
};
if((_fastPath(_this.isFastUTF8, {}))) {
return _this.withFastUTF8((($0, $info?) => Bool.prefix_33(_isContinuation($0.subscript$get(i._encodedOffset, {}), {}), {})), {});
};
return String.Index.infix_61_61(i, _this.foreignScalarAlign(i, {}), {})
----Swift.(file)._StringGuts.foreignErrorCorrectedScalar(startingAt:String.Index)
let _this = this;
const start = idx._encodedOffset;
const leading = _this._getForeignCodeUnitAt(start, {});
if((_fastPath(Bool.prefix_33(_isSurrogate(leading, {}), {}), {}))) {
return {0: _create(Unicode.Scalar, 'init_uncheckedUInt32', _create(UInt32, 'initT', leading, {}), {}), 1: 1};
};
const nextOffset = Int.infix_38_43(start, 1, {});
if((_slowPath(Bool.infix_124_124(_isTrailingSurrogate(leading, {}), () => Int.infix_61_61(nextOffset, _this.count, {}), {}), {}))) {
return {0: Unicode.Scalar._replacementCharacter, 1: 1};
};
const trailing = _this._getForeignCodeUnitAt(nextOffset, {});
if((_slowPath(Bool.prefix_33(_isTrailingSurrogate(trailing, {}), {}), {}))) {
return {0: Unicode.Scalar._replacementCharacter, 1: 1};
};
return {0: _create(Unicode.Scalar, 'init_uncheckedUInt32', _decodeSurrogatePairLeadingTrailing(leading, trailing, {}), {}), 1: 2}
----Swift.(file)._StringGuts.foreignErrorCorrectedScalar(endingAt:String.Index)
let _this = this;
const end = idx._encodedOffset;
const trailing = _this._getForeignCodeUnitAt(Int.infix_38_45(end, 1, {}), {});
if((_fastPath(Bool.prefix_33(_isSurrogate(trailing, {}), {}), {}))) {
return {0: _create(Unicode.Scalar, 'init_uncheckedUInt32', _create(UInt32, 'initT', trailing, {}), {}), 1: 1};
};
const priorOffset = Int.infix_38_45(end, 2, {});
if((_slowPath(Bool.infix_124_124(_isLeadingSurrogate(trailing, {}), () => Int.infix_60(priorOffset, 0, {}), {}), {}))) {
return {0: Unicode.Scalar._replacementCharacter, 1: 1};
};
const leading = _this._getForeignCodeUnitAt(priorOffset, {});
if((_slowPath(Bool.prefix_33(_isLeadingSurrogate(leading, {}), {}), {}))) {
return {0: Unicode.Scalar._replacementCharacter, 1: 1};
};
return {0: _create(Unicode.Scalar, 'init_uncheckedUInt32', _decodeSurrogatePairLeadingTrailing(leading, trailing, {}), {}), 1: 2}
----Swift.(file)._StringGuts.foreignErrorCorrectedUTF16CodeUnit(at:String.Index)
let _this = this;
const start = idx._encodedOffset;
const cu = _this._getForeignCodeUnitAt(start, {});
if((_fastPath(Bool.prefix_33(_isSurrogate(cu, {}), {}), {}))) {
return cu;
};
if((_isLeadingSurrogate(cu, {}))) {
const nextOffset = Int.infix_38_43(start, 1, {});
if(!((Int.infix_60(nextOffset, _this.count, {})) && (_isTrailingSurrogate(_this._getForeignCodeUnitAt(nextOffset, {}), {})))) {
return UTF16._replacementCodeUnit;
};
}
else {
const priorOffset = Int.infix_38_45(start, 1, {});
if(!((Int.infix_62_61(priorOffset, 0, {})) && (_isLeadingSurrogate(_this._getForeignCodeUnitAt(priorOffset, {}), {})))) {
return UTF16._replacementCodeUnit;
};
};
return cu
----Swift.(file)._StringGuts.foreignErrorCorrectedGrapheme(startingAt:Int,endingAt:Int)
let _this = this;
const count = Int.infix_38_45(end, start, {});
if((Int.infix_61_61(Int.infix_38_45(start, end, {}), 1, {}))) {
return _create(Character, 'initString', _create(String, 'initUnicodeScalar', _this.foreignErrorCorrectedScalarStartingAt(_create(String.Index, 'init_encodedOffsetInt', start, {}), {})["0"], {}), {});
};
let cus = _create(Array, 'initRepeatingCountInt', 0, count, {});
cus.withUnsafeMutableBufferPointer((($0$inout, $info?) => _cocoaStringCopyCharactersFromRangeInto(_this._object.cocoaObject, Int.infix_46_46_60(start, end, {}), $0.baseAddress._unsafelyUnwrappedUnchecked, {})), {$setThis: $val => cus = $val});
return cus.withUnsafeBufferPointer((($0, $info?) => _create(Character, 'initString', String._uncheckedFromUTF16($0, {}), {})), {})
----Swift.(file)._StringGuts.errorCorrectedScalar(startingAt:Int)
let _this = this;
if((_fastPath(_this.isFastUTF8, {}))) {
return _this.withFastUTF8((($0, $info?) => _decodeScalarStartingAt($0, i, {})), {});
};
return _this.foreignErrorCorrectedScalarStartingAt(_create(String.Index, 'init_encodedOffsetInt', i, {}), {})
----Swift.(file)._StringGuts.errorCorrectedCharacter(startingAt:Int,endingAt:Int)
let _this = this;
if((_fastPath(_this.isFastUTF8, {}))) {
return _this.withFastUTF8Range(Int.infix_46_46_60(start, end, {}), ((utf8, $info?) => _create(Character, 'initUncheckedString', String._uncheckedFromUTF8(utf8, {}), {})), {});
};
return _this.foreignErrorCorrectedGraphemeStartingAtEndingAt(start, end, {})
----Swift.(file).Unicode.Scalar.init(_value:UInt32)
let _this = this;
_this._value = _value;
return
----Swift.(file)..(error_type).value
let _this = this;
return _this._value
----Swift.(file)..(error_type).init(unicodeScalarLiteral:<<error type>>)
let _this = this;
$info.$setThis(_this = _cloneStruct(_cloneStruct(value)));
return
----Swift.(file)..(error_type).init(_:UInt32)
let _this = this;
if((Bool.infix_38_38(Bool.infix_124_124(UInt32.infix_60(v, 0xD800, {}), () => UInt32.infix_62(v, 0xDFFF, {}), {}), () => UInt32.infix_60_61(v, 0x10FFFF, {}), {}))) {
_this._value = v;
return ;
};
return (this.$failed = true)
----Swift.(file)..(error_type).init(_:UInt16)
let _this = this;
_this.initUInt32(_create(UInt32, 'initT', v, {}), {});
return
----Swift.(file)..(error_type).init(_:UInt8)
let _this = this;
_this._value = _create(UInt32, 'initT', v, {});
return
----Swift.(file)..(error_type).init(_:<<error type>>)
let _this = this;
$info.$setThis(_this = _cloneStruct(_cloneStruct(v)));
return
----Swift.(file)..(error_type).escaped(asASCII:Bool)
let _this = this;
function lowNibbleAsHex(v, $info?){
const nibble = UInt32.infix_38(v, 15, {});
if((UInt32.infix_60(nibble, 10, {}))) {
return _create(String, 'initUnicodeScalar', _create(Unicode.Scalar, 'initUInt32', UInt32.infix_43(nibble, 48, {}), {})[0], {});
}
else {
return _create(String, 'initUnicodeScalar', _create(Unicode.Scalar, 'initUInt32', UInt32.infix_43(UInt32.infix_45(nibble, 10, {}), 65, {}), {})[0], {});
};
}
if((Unicode.Scalar.infix_61_61(_this, "\\", {}))) {
return "\\\\";
}
else {
if((Unicode.Scalar.infix_61_61(_this, "'", {}))) {
return "\\'";
}
else {
if((Unicode.Scalar.infix_61_61(_this, "\"", {}))) {
return "\\\"";
}
else {
if((_this._isPrintableASCII)) {
return _create(String, 'initUnicodeScalar', _this, {});
}
else {
if((Unicode.Scalar.infix_61_61(_this, "\0", {}))) {
return "\\0";
}
else {
if((Unicode.Scalar.infix_61_61(_this, "\n", {}))) {
return "\\n";
}
else {
if((Unicode.Scalar.infix_61_61(_this, "\r", {}))) {
return "\\r";
}
else {
if((Unicode.Scalar.infix_61_61(_this, "\t", {}))) {
return "\\t";
}
else {
if((UInt32.infix_60(_create(UInt32, 'initUnicodeScalar', _this, {}), 128, {}))) {
return String.infix_43(String.infix_43(String.infix_43("\\u{", lowNibbleAsHex(UInt32.infix_62_62(_create(UInt32, 'initUnicodeScalar', _this, {}), 4, {}), {}), {}), lowNibbleAsHex(_create(UInt32, 'initUnicodeScalar', _this, {}), {}), {}), "}", {});
}
else {
if((Bool.prefix_33(forceASCII, {}))) {
return _create(String, 'initUnicodeScalar', _this, {});
}
else {
if((UInt32.infix_60_61(_create(UInt32, 'initUnicodeScalar', _this, {}), 0xFFFF, {}))) {
let result = "\\u{";
String.infix_43_61({get: () => result, set: $val => result = $val}, lowNibbleAsHex(UInt32.infix_62_62(_create(UInt32, 'initUnicodeScalar', _this, {}), 12, {}), {}), {});
String.infix_43_61({get: () => result, set: $val => result = $val}, lowNibbleAsHex(UInt32.infix_62_62(_create(UInt32, 'initUnicodeScalar', _this, {}), 8, {}), {}), {});
String.infix_43_61({get: () => result, set: $val => result = $val}, lowNibbleAsHex(UInt32.infix_62_62(_create(UInt32, 'initUnicodeScalar', _this, {}), 4, {}), {}), {});
String.infix_43_61({get: () => result, set: $val => result = $val}, lowNibbleAsHex(_create(UInt32, 'initUnicodeScalar', _this, {}), {}), {});
String.infix_43_61({get: () => result, set: $val => result = $val}, "}", {});
return result;
}
else {
let result = "\\u{";
String.infix_43_61({get: () => result, set: $val => result = $val}, lowNibbleAsHex(UInt32.infix_62_62(_create(UInt32, 'initUnicodeScalar', _this, {}), 28, {}), {}), {});
String.infix_43_61({get: () => result, set: $val => result = $val}, lowNibbleAsHex(UInt32.infix_62_62(_create(UInt32, 'initUnicodeScalar', _this, {}), 24, {}), {}), {});
String.infix_43_61({get: () => result, set: $val => result = $val}, lowNibbleAsHex(UInt32.infix_62_62(_create(UInt32, 'initUnicodeScalar', _this, {}), 20, {}), {}), {});
String.infix_43_61({get: () => result, set: $val => result = $val}, lowNibbleAsHex(UInt32.infix_62_62(_create(UInt32, 'initUnicodeScalar', _this, {}), 16, {}), {}), {});
String.infix_43_61({get: () => result, set: $val => result = $val}, lowNibbleAsHex(UInt32.infix_62_62(_create(UInt32, 'initUnicodeScalar', _this, {}), 12, {}), {}), {});
String.infix_43_61({get: () => result, set: $val => result = $val}, lowNibbleAsHex(UInt32.infix_62_62(_create(UInt32, 'initUnicodeScalar', _this, {}), 8, {}), {}), {});
String.infix_43_61({get: () => result, set: $val => result = $val}, lowNibbleAsHex(UInt32.infix_62_62(_create(UInt32, 'initUnicodeScalar', _this, {}), 4, {}), {}), {});
String.infix_43_61({get: () => result, set: $val => result = $val}, lowNibbleAsHex(_create(UInt32, 'initUnicodeScalar', _this, {}), {}), {});
String.infix_43_61({get: () => result, set: $val => result = $val}, "}", {});
return result;
}
}
}
}
}
}
}
}
}
}
}
----Swift.(file)..(error_type).isASCII
let _this = this;
return UInt32.infix_60_61(_this.value, 127, {})
----Swift.(file)..(error_type).description
let _this = this;
return _create(String, 'initUnicodeScalar', _this, {})
----Swift.(file)..(error_type).debugDescription
let _this = this;
return (("\"") + (_this.escapedAsASCII(true, {})) + ("\""))
----Swift.(file)..(error_type).init(_:String)
let _this = this;
const scalars = _cloneStruct(description.unicodeScalars);
const $ifLet0, v_1
if(!((($ifLet0 = scalars.first)||true) && $ifLet0.rawValue == 'some' && ((v_1 = $ifLet0[0])||true) && (Int.infix_61_61(scalars.count, 1, {})))) {
return (this.$failed = true);
};
$info.$setThis(_this = _cloneStruct(_cloneStruct(v_1)));
return
----Swift.(file)..(error_type).hash(into:Hasher)
let _this = this;
let hasher = hasher$inout.get()
const $result = (() => {
hasher.combine(_this.value, {$setThis: $val => hasher = $val});})()
hasher$inout.set(hasher)
return $result
----Swift.(file)..(error_type).init(_:Int)
let _this = this;
const $ifLet0, us_1
if((($ifLet0 = _create(Unicode.Scalar, 'initUInt32', _create(UInt32, 'initT', v, {}), {}))||true) && $ifLet0.rawValue == 'some' && ((us_1 = $ifLet0[0])||true)) {
$info.$setThis(_this = _cloneStruct(_cloneStruct(us_1)));
}
else {
return (this.$failed = true);
};
return
----Swift.(file).UInt8.init(ascii:<<error type>>)
let _this = this;
preconditionFileLine(() => UInt32.infix_60(v.value, 128, {}), () => "Code point value does not fit into ASCII", '?3', '?3', {});
return _cloneStruct(_create(UInt8, 'initT', v.value, {}));
return
----Swift.(file).UInt32.init(_:<<error type>>)
let _this = this;
return _cloneStruct(v.value);
return
----Swift.(file).UInt64.init(_:<<error type>>)
let _this = this;
return _cloneStruct(_create(UInt64, 'initT', v.value, {}));
return
----Swift.(file)..(error_type).==infix(_:<<error type>>,_:<<error type>>)
let _this = this;
return UInt32.infix_61_61(lhs.value, rhs.value, {})
----Swift.(file)..(error_type).<infix(_:<<error type>>,_:<<error type>>)
let _this = this;
return UInt32.infix_60(lhs.value, rhs.value, {})
----Swift.(file)..(error_type).utf16
let _this = this;
return _create(Unicode.Scalar.UTF16View, 'initValueUnicodeScalar', _this, {})
----Swift.(file)..(error_type).Indices

----Swift.(file)..(error_type).startIndex
let _this = this;
return 0
----Swift.(file)..(error_type).endIndex
let _this = this;
return Int.infix_43(0, UTF16.width(_this.value, {}), {})
----Swift.(file)..(error_type).subscript(_:Int)
let _this = this;
return (Int.infix_61_61(position, 0, {}) ? (Int.infix_61_61(_this.endIndex, 1, {}) ? _create(UTF16.CodeUnit, 'initT', _this.value.value, {}) : UTF16.leadSurrogate(_this.value, {})) : UTF16.trailSurrogate(_this.value, {}))
----Swift.(file)..(error_type).withUTF16CodeUnits(_:(UnsafeBufferPointer<UInt16>) throws -> Result)
let _this = this;
let codeUnits = {0: _this.utf16.subscript$get(0, {}), 1: 0};
const utf16Count = _this.utf16.count;
if((Int.infix_62(utf16Count, 1, {}))) {
codeUnits["1"] = _this.utf16.subscript$get(1, {});
};
return /*dot_syntax_base_ignored*/withUnsafePointerTo({get: () => codeUnits, set: $val => codeUnits = $val}, (($0, $info?) => $0.withMemoryReboundToCapacity(UInt16, 2, (($0, $info?) => body(_create(UnsafeBufferPointer, 'initStartOptionalCountInt', _injectIntoOptional(/*pointer_to_pointer*/$0), utf16Count, {}), {})), {})), {})
----Swift.(file)..(error_type).withUTF8CodeUnits(_:(UnsafeBufferPointer<UInt8>) throws -> Result)
let _this = this;
const encodedScalar = _cloneStruct(UTF8.encode(_this, {})[0]);
let $tuple = encodedScalar._bytes/*destructure_tuple_expr (**NULL EXPRESSION**), (**NULL EXPRESSION**)*/, codeUnits = $tuple && $tuple[0], utf8Count = $tuple && $tuple[1];
codeUnits = UInt64.prototype.littleEndian$get.call(codeUnits);
return /*dot_syntax_base_ignored*/withUnsafePointerTo({get: () => codeUnits, set: $val => codeUnits = $val}, (($0, $info?) => $0.withMemoryReboundToCapacity(UInt8, 4, (($0, $info?) => body(_create(UnsafeBufferPointer, 'initStartOptionalCountInt', _injectIntoOptional(/*pointer_to_pointer*/$0), utf8Count, {}), {})), {})), {})
----Swift.(file).Unicode.Scalar.Properties.init(_:Unicode.Scalar)
let _this = this;
_this._scalar = _cloneStruct(scalar);
return
----Swift.(file).Unicode.Scalar.properties
let _this = this;
return _create(Unicode.Scalar.Properties, 'initUnicodeScalar', _this, {})
----Swift.(file).Unicode.Version

----Swift.(file).Unicode.CanonicalCombiningClass.hashValue
let _this = this;
return UInt8.prototype.hashValue$get.call(_this.rawValue)
----Swift.(file).Unicode.CanonicalCombiningClass.hash(into:Hasher)
let _this = this;
let hasher = hasher$inout.get()
const $result = (() => {
hasher.combine(_this.rawValue, {$setThis: $val => hasher = $val});})()
hasher$inout.set(hasher)
return $result
----Swift.(file).Unmanaged.init(_private:Instance)
let _this = this;
_this._value = _private;
return
----Swift.(file).Unmanaged.fromOpaque(_:UnsafeRawPointer)
let _this = this;
return _create(Unmanaged, 'init_private', unsafeBitCastTo(value, ((function(){throw '!unclarifiedGeneric:Instance'})()), {}), {})
----Swift.(file).Unmanaged.toOpaque()
let _this = this;
return unsafeBitCastTo(_this._value, UnsafeMutableRawPointer, {})
----Swift.(file).Unmanaged.passRetained(_:Instance)
let _this = this;
return _create(Unmanaged, 'init_private', value, {}).retain( {})
----Swift.(file).Unmanaged.passUnretained(_:Instance)
let _this = this;
return _create(Unmanaged, 'init_private', value, {})
----Swift.(file).Unmanaged.takeUnretainedValue()
let _this = this;
return _this._value
----Swift.(file).Unmanaged.takeRetainedValue()
let _this = this;
const result = _this._value;
_this.release( {});
return result
----Swift.(file).UnsafePointer.pointee
 return this.pointee$internal
----Swift.(file).UnsafePointer.subscript(_:Int)
let _this = this;
return UnsafePointer.infix_43(_this, i, {})
----Swift.(file).UnsafeMutablePointer.init(mutating:UnsafePointer<Pointee>?)
let _this = this;
const $ifLet0, unwrapped_1
if(!((($ifLet0 = other)||true) && $ifLet0.rawValue == 'some' && ((unwrapped_1 = $ifLet0[0])||true))) {
return (this.$failed = true);
};
_this.initMutatingUnsafePointer(unwrapped_1, {});
return
----Swift.(file).UnsafeMutablePointer.init(_:UnsafeMutablePointer<Pointee>?)
let _this = this;
const $ifLet0, unwrapped_1
if(!((($ifLet0 = other)||true) && $ifLet0.rawValue == 'some' && ((unwrapped_1 = $ifLet0[0])||true))) {
return (this.$failed = true);
};
_this.initUnsafeMutablePointer(unwrapped_1, {});
return
----Swift.(file).UnsafeMutablePointer.pointee
 return this.pointee$internal
----Swift.(file).UnsafeMutablePointer.assign(repeating:Pointee,count:Int)
let _this = this;
preconditionFileLine(() => Int.infix_62_61(count, 0, {}), () => "UnsafeMutablePointer.assign(repeating:count:) with negative count", '?3', '?3', {});
{
let $i$generator = _cloneStruct(Int.infix_46_46_60(0, count, {}).makeIterator( {}));
while(true) {
const $ifLet0, i_1;
if(!((($ifLet0 = $i$generator.next( {$setThis: $val => $i$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((i_1 = $ifLet0[0])||true))) break
_this.subscript$set(repeatedValue, i_1, {$setThis: $val => $info.$setThis(_this = _cloneStruct(_cloneStruct($val)))});
}
}
----Swift.(file).UnsafeMutablePointer.subscript(_:Int)
let _this = this;
return _create(UnsafePointer, 'init', /*pointer_to_pointer*/UnsafeMutablePointer.infix_43(_this, i, {}), {});
}subscript$unsafeMutableAddress(i, $info?){
let _this = this;
return UnsafeMutablePointer.infix_43(_this, i, {})
----Swift.(file).UnsafeRawPointer.assumingMemoryBound(to:T.Type)
let _this = this;
return _create(UnsafePointer, 'initRawPointer', _this._rawValue, {})
----Swift.(file).UnsafeMutableRawPointer.assumingMemoryBound(to:T.Type)
let _this = this;
return _create(UnsafeMutablePointer, 'initRawPointer', _this._rawValue, {})
----Swift.(file).UnsafeMutableRawPointer.copyMemory(from:UnsafeRawPointer,byteCount:Int)
let _this = this;
preconditionFileLine(() => Int.infix_62_61(byteCount, 0, {}), () => "UnsafeMutableRawPointer.copyMemory with negative count", '?3', '?3', {});
_memmoveDestSrcSize(_this, source, _create(UInt, 'initT', byteCount, {}), {})
----Swift.(file).OpaquePointer.init(_:UnsafeMutableRawPointer)
let _this = this;
_this._rawValue = from._rawValue;
return
----Swift.(file).OpaquePointer.init(_:UnsafeMutableRawPointer?)
let _this = this;
const $ifLet0, unwrapped_1
if(!((($ifLet0 = from)||true) && $ifLet0.rawValue == 'some' && ((unwrapped_1 = $ifLet0[0])||true))) {
return (this.$failed = true);
};
_this._rawValue = unwrapped_1._rawValue;
return
----Swift.(file).OpaquePointer.init(_:UnsafeRawPointer)
let _this = this;
_this._rawValue = from._rawValue;
return
----Swift.(file).OpaquePointer.init(_:UnsafeRawPointer?)
let _this = this;
const $ifLet0, unwrapped_1
if(!((($ifLet0 = from)||true) && $ifLet0.rawValue == 'some' && ((unwrapped_1 = $ifLet0[0])||true))) {
return (this.$failed = true);
};
_this._rawValue = unwrapped_1._rawValue;
return
----Swift.(file)._ValidUTF8Buffer.SubSequence

----Swift.(file)._ValidUTF8Buffer.Iterator.init(_:_ValidUTF8Buffer)
let _this = this;
_this._biasedBits = x._biasedBits;
return
----Swift.(file)._ValidUTF8Buffer.Iterator.next()
let _this = this;
if((UInt32.infix_61_61(_this._biasedBits, 0, {}))) {
return Optional.none;
};
let $defer = () => {
UInt32.infix_62_62_61({get: () => _this._biasedBits, set: $val => _this._biasedBits = $val}, 8, {});
}
const $result = (() => {
try {;
return _injectIntoOptional(_ValidUTF8Buffer.Iterator.Element.infix_38_45(_create(_ValidUTF8Buffer.Iterator.Element, 'initTruncatingIfNeeded', _this._biasedBits, {}), 1, {}));}catch($error){$defer( {});throw $error}})();$defer( {});return $result
----Swift.(file)._ValidUTF8Buffer.makeIterator()
let _this = this;
return _create(_ValidUTF8Buffer.Iterator, 'init_ValidUTF8Buffer', _this, {})
----Swift.(file)._ValidUTF8Buffer.Index.init(_biasedBits:UInt32)
let _this = this;
_this._biasedBits = _biasedBits;
return
----Swift.(file)._ValidUTF8Buffer.startIndex
let _this = this;
return _create(_ValidUTF8Buffer.Index, 'init_biasedBitsUInt32', _this._biasedBits, {})
----Swift.(file)._ValidUTF8Buffer.endIndex
let _this = this;
return _create(_ValidUTF8Buffer.Index, 'init_biasedBitsUInt32', 0, {})
----Swift.(file)._ValidUTF8Buffer.count
let _this = this;
return Int.infix_38_45(Int.infix_38_62_62(UInt32.bitWidth, 3, {}), Int.infix_38_62_62(UInt32.prototype.leadingZeroBitCount$get.call(_this._biasedBits), 3, {}), {})
----Swift.(file)._ValidUTF8Buffer.isEmpty
let _this = this;
return UInt32.infix_61_61(_this._biasedBits, 0, {})
----Swift.(file)._ValidUTF8Buffer.index(after:_ValidUTF8Buffer.Index)
let _this = this;
preconditionFileLine(() => UInt32.infix_33_61(i._biasedBits, 0, {}), () => String()/*!default_value*/, '?3', '?3', {});
return _create(_ValidUTF8Buffer.Index, 'init_biasedBitsUInt32', UInt32.infix_62_62(i._biasedBits, 8, {}), {})
----Swift.(file)._ValidUTF8Buffer.subscript(_:_ValidUTF8Buffer.Index)
let _this = this;
return _ValidUTF8Buffer.Element.infix_38_45(_create(_ValidUTF8Buffer.Element, 'initTruncatingIfNeeded', i._biasedBits, {}), 1, {})
----Swift.(file)._ValidUTF8Buffer.index(before:_ValidUTF8Buffer.Index)
let _this = this;
const offset = _create(_ValidUTF8Buffer, 'init_biasedBitsUInt32', i._biasedBits, {}).count;
preconditionFileLine(() => Int.infix_33_61(offset, 0, {}), () => String()/*!default_value*/, '?3', '?3', {});
return _create(_ValidUTF8Buffer.Index, 'init_biasedBitsUInt32', UInt32.infix_38_62_62(_this._biasedBits, Int.infix_45(Int.infix_38_60_60(offset, 3, {}), 8, {}), {}), {})
----Swift.(file)._ValidUTF8Buffer.Indices

----Swift.(file)._ValidUTF8Buffer.distance(from:_ValidUTF8Buffer.Index,to:_ValidUTF8Buffer.Index)
let _this = this;
preconditionFileLine(() => _this._isValid(i, {}), () => String()/*!default_value*/, '?3', '?3', {});
preconditionFileLine(() => _this._isValid(j, {}), () => String()/*!default_value*/, '?3', '?3', {});
return Int.infix_38_62_62(Int.infix_45(UInt32.prototype.leadingZeroBitCount$get.call(i._biasedBits), UInt32.prototype.leadingZeroBitCount$get.call(j._biasedBits), {}), 3, {})
----Swift.(file)._ValidUTF8Buffer.index(_:_ValidUTF8Buffer.Index,offsetBy:Int)
let _this = this;
const startOffset = _this.distanceFromTo(_this.startIndex, i, {});
const newOffset = Int.infix_43(startOffset, n, {});
preconditionFileLine(() => Int.infix_62_61(newOffset, 0, {}), () => String()/*!default_value*/, '?3', '?3', {});
preconditionFileLine(() => Int.infix_60_61(newOffset, _this.count, {}), () => String()/*!default_value*/, '?3', '?3', {});
return _create(_ValidUTF8Buffer.Index, 'init_biasedBitsUInt32', UInt32.prototype._fullShiftRight.call(_this._biasedBits, Int.infix_38_60_60(newOffset, 3, {}), {}), {})
----Swift.(file)._ValidUTF8Buffer.init()
let _this = this;
_this._biasedBits = 0;
return
----Swift.(file)._ValidUTF8Buffer.capacity
let _this = this;
return Int.infix_47(UInt32.bitWidth, _ValidUTF8Buffer.Element.bitWidth, {});
}
static get capacity() { return this.capacity$get()
----Swift.(file)._ValidUTF8Buffer.removeFirst()
let _this = this;
preconditionFileLine(() => Bool.prefix_33(_this.isEmpty, {}), () => String()/*!default_value*/, '?3', '?3', {});
const result = _ValidUTF8Buffer.Element.infix_38_45(_create(_ValidUTF8Buffer.Element, 'initTruncatingIfNeeded', _this._biasedBits, {}), 1, {});
_this._biasedBits = UInt32.prototype._fullShiftRight.call(_this._biasedBits, 8, {});
return result
----Swift.(file)._ValidUTF8Buffer.replaceSubrange(_:Range<_ValidUTF8Buffer.Index>,with:C)
let _this = this;
preconditionFileLine(() => _this._isValid(target.lowerBound, {}), () => String()/*!default_value*/, '?3', '?3', {});
preconditionFileLine(() => _this._isValid(target.upperBound, {}), () => String()/*!default_value*/, '?3', '?3', {});
let r = _create(_ValidUTF8Buffer, 'init', {});
{
let $x$generator = _cloneStruct(_this.subscript$get(_ValidUTF8Buffer.Index.prefix_46_46_60(target.lowerBound, {}), {}).makeIterator( {}));
while(true) {
const $ifLet0, x_1;
if(!((($ifLet0 = $x$generator.next( {$setThis: $val => $x$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((x_1 = $ifLet0[0])||true))) break
r.append(x_1, {$setThis: $val => r = $val});
}
};
{
let $x$generator = replacement.makeIterator( {});
while(true) {
const $ifLet2, x_3;
if(!((($ifLet2 = $x$generator.next( {$setThis: $val => $x$generator = $val}))||true) && $ifLet2.rawValue == 'some' && ((x_3 = $ifLet2[0])||true))) break
r.append(x_3, {$setThis: $val => r = $val});
}
};
{
let $x$generator = _cloneStruct(_this.subscript$get(_ValidUTF8Buffer.Index.postfix_46_46_46(target.upperBound, {}), {}).makeIterator( {}));
while(true) {
const $ifLet4, x_5;
if(!((($ifLet4 = $x$generator.next( {$setThis: $val => $x$generator = $val}))||true) && $ifLet4.rawValue == 'some' && ((x_5 = $ifLet4[0])||true))) break
r.append(x_5, {$setThis: $val => r = $val});
}
};
$info.$setThis(_this = _cloneStruct(_cloneStruct(r)))
----Swift.(file)._ValidUTF8Buffer.append(contentsOf:_ValidUTF8Buffer)
let _this = this;
preconditionFileLine(() => Int.infix_60_61(Int.infix_43(_this.count, other.count, {}), _this.capacity, {}), () => String()/*!default_value*/, '?3', '?3', {});
UInt32.infix_124_61({get: () => _this._biasedBits, set: $val => _this._biasedBits = $val}, UInt32.infix_38_60_60(_create(UInt32, 'initTruncatingIfNeeded', other._biasedBits, {}), Int.infix_38_60_60(_this.count, 3, {}), {}), {})
----Swift.(file)._ValidUTF8Buffer.encodedReplacementCharacter
let _this = this;
return _create(_ValidUTF8Buffer, 'init_biasedBitsUInt32', UInt32.infix_38_43(0xBDBFEF, 0x010101, {}), {});
}
static get encodedReplacementCharacter() { return this.encodedReplacementCharacter$get()
----Swift.(file).withVaList(_:[CVarArg],_:(CVaListPointer) -> R)
const builder = _create(__VaListBuilder, 'init', {});
{
let $a$generator = _cloneStruct(args.makeIterator( {}));
while(true) {
const $ifLet0, a_1;
if(!((($ifLet0 = $a$generator.next( {$setThis: $val => $a$generator = $val}))||true) && $ifLet0.rawValue == 'some' && ((a_1 = $ifLet0[0])||true))) break
builder.append(a_1, {});
}
};
return _withVaList(builder, body, {})
----Swift.(file).zip(_:Sequence1,_:Sequence2)
return _create(Zip2Sequence, 'init', sequence1, sequence2, {})
----Swift.(file).Zip2Sequence.Iterator.init(_:Sequence1.Iterator,_:Sequence2.Iterator)
let _this = this;
let $tuple = {0: iterator1, 1: iterator2}
_this._baseStream1 = $tuple[0]
_this._baseStream2 = $tuple[1];
return
----Swift.(file).Zip2Sequence.Iterator.Element

----Swift.(file).Zip2Sequence.Iterator.next()
let _this = this;
if((_this._reachedEnd)) {
return Optional.none;
};
const $ifLet0, element1_1
const $ifLet2, element2_3
if(!((($ifLet0 = _this._baseStream1.next( {$setThis: $val => _this._baseStream1 = $val}))||true) && $ifLet0.rawValue == 'some' && ((element1_1 = $ifLet0[0])||true) && (($ifLet2 = _this._baseStream2.next( {$setThis: $val => _this._baseStream2 = $val}))||true) && $ifLet2.rawValue == 'some' && ((element2_3 = $ifLet2[0])||true))) {
_this._reachedEnd = true;
return Optional.none;
};
return _injectIntoOptional({0: element1_1, 1: element2_3})
----Swift.(file).Zip2Sequence.Element

----Swift.(file).Zip2Sequence.makeIterator()
let _this = this;
return _create(Zip2Sequence.Iterator, 'init', _this._sequence1.makeIterator( {}), _this._sequence2.makeIterator( {}), {})
----Swift.(file).Zip2Sequence.underestimatedCount
let _this = this;
return /*dot_syntax_base_ignored*/min(_this._sequence1.underestimatedCount, _this._sequence2.underestimatedCount, {})
