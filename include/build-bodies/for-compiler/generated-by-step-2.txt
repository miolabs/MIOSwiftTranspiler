----Swift.(file)..(error_type).encodedReplacementCharacter
return _create(Unicode.ASCII.EncodedScalar, 'init', {}, 0x1a);
}
static get encodedReplacementCharacter() { return this.encodedReplacementCharacter$get()
----Swift.(file)..(error_type).decode(_:Unicode.ASCII.EncodedScalar)
return _create(Unicode.Scalar, 'init_uncheckedUInt32', {}, _create(UInt32, 'init', {}, source.first._unsafelyUnwrappedUnchecked))
----Swift.(file)..(error_type).encode(_:Unicode.Scalar)
{
if(!((UInt32.infix_60({}, source.value, Int.infix_38_60_60({}, 1, 7))))) {
return Optional.none;
}
};
return _injectIntoOptional(_create(Unicode.ASCII.EncodedScalar, 'init', {}, _create(UInt8, 'initTruncatingIfNeeded', {}, source.value)))
----Swift.(file)..(error_type).transcode(_:FromEncoding.EncodedScalar,from:FromEncoding.Type)
{
if((_fastPath({}, infix_61_61({}, _injectIntoOptional(((function(){throw '!unclarifiedGeneric:FromEncoding'})())), _injectIntoOptional(UTF16))))) {
const c = _cloneStruct(_identityCastTo({}, content, UTF16.EncodedScalar));
{
if(!((UInt32.infix_61_61({}, UInt32.infix_38({}, c._storage, 0xFF80), 0)))) {
return Optional.none;
}
};
return _injectIntoOptional(_create(Unicode.ASCII.EncodedScalar, 'init', {}, _create(Unicode.ASCII.CodeUnit, 'init', {}, UInt32.infix_38({}, c._storage, 0x7f))));
}
else {
{
if((_fastPath({}, infix_61_61({}, _injectIntoOptional(((function(){throw '!unclarifiedGeneric:FromEncoding'})())), _injectIntoOptional(UTF8))))) {
const c = _cloneStruct(_identityCastTo({}, content, UTF8.EncodedScalar));
const first = c.first.unsafelyUnwrapped;
{
if(!((UInt8.infix_60({}, first, 0x80)))) {
return Optional.none;
}
};
return _injectIntoOptional(_create(Unicode.ASCII.EncodedScalar, 'init', {}, _create(Unicode.ASCII.CodeUnit, 'init', {}, first)));
}
}
}
};
return this.encode({}, ((function(){throw '!unclarifiedGeneric:FromEncoding'})()).decode({}, content))
----Swift.(file)..(error_type).parseScalar(from:I)
let input = input$inout.get()
const $result = (() => {
const n = input.next({$setThis: $val => input = $val}, );
{const $ifLet0 = n
if((_fastPath({}, Optional.wrappedNotEqualsOptionalNilComparisonType({}, n, _create(_OptionalNilComparisonType, 'initNilLiteraltuple_type', {}, {})))) && $ifLet0.rawValue === 'some') {
let x = $ifLet0[0]
{
if(!((_fastPath({}, Int8.infix_62_61({}, _create(Int8, 'initTruncatingIfNeeded', {}, x), 0))))) {
return Unicode.ParseResult.error({}, 1);
}
};
return Unicode.ParseResult.valid({}, _create(Unicode.ASCII.EncodedScalar, 'init', {}, x));
}
};
return Unicode.ParseResult.emptyInput;})()
input$inout.set(input)
return $result
----Swift.(file).min(_:T,_:T)
return ((y).constructor.infix_60({}, y, x) ? y : x)
----Swift.(file).min(_:T,_:T,_:T,_:[T])
let minValue = min({}, min({}, x, y), z);
{
let $value$generator = _cloneStruct(rest.makeIterator({}, ));
while(true) {
const $ifLet0 = $value$generator.next({$setThis: $val => $value$generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
let value = $ifLet0[0]
if(!((value).constructor.infix_60({}, value, minValue))) break
minValue = value;
}
};
return minValue
----Swift.(file).max(_:T,_:T)
return ((y).constructor.infix_62_61({}, y, x) ? y : x)
----Swift.(file).max(_:T,_:T,_:T,_:[T])
let maxValue = max({}, max({}, x, y), z);
{
let $value$generator = _cloneStruct(rest.makeIterator({}, ));
while(true) {
const $ifLet0 = $value$generator.next({$setThis: $val => $value$generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
let value = $ifLet0[0]
if(!((value).constructor.infix_62_61({}, value, maxValue))) break
maxValue = value;
}
};
return maxValue
----Swift.(file).EnumeratedSequence.init(_base:Base)
this._base = _base;
return
----Swift.(file).EnumeratedSequence.Iterator.init(_base:Base.Iterator)
this._base = _base;
this._count = 0;
return
----Swift.(file).EnumeratedSequence.Iterator.next()
{const $ifLet0 = this._base.next({$setThis: $val => this._base = $val}, )
if(!($ifLet0.rawValue === 'some')) {
return Optional.none;
}let b = $ifLet0[0]
};
const result = {0: this._count, 1: b};
Int.infix_43_61({}, {get: () => this._count, set: $val => this._count = $val}, 1);
return _injectIntoOptional(result)
----Swift.(file).EnumeratedSequence.makeIterator()
return _create(EnumeratedSequence.Iterator, 'init_base', {}, this._base.makeIterator({}, ))
----Swift.(file).AnyHashable.init(_box:_AnyHashableBox)
this._box = _cloneStruct(box);
return
----Swift.(file).AnyHashable.init(_:H)
{const $ifLet0 = (((_.tmp0 = _injectIntoOptional(base)).rawValue === 'some') ? (_.tmp0[0]._toCustomAnyHashable({}, )) : null)
if($ifLet0.rawValue === 'some') {
let custom = $ifLet0[0]
$info.$setThis(_cloneStruct(_cloneStruct(custom)));
return ;
}
};
this.init_box_AnyHashableBox({}, _create(_ConcreteHashableBox, 'init', {}, false));
_makeAnyHashableUpcastingToHashableBaseTypeStoringResultInto({}, base, /**/{get: () => this, set: $val => $info.$setThis(_cloneStruct($val))});
return
----Swift.(file).AnyHashable.init(_usingDefaultRepresentationOf:H)
this._box = _cloneStruct(_create(_ConcreteHashableBox, 'init', {}, base));
return
----Swift.(file).AnyHashable.base
return this._box._base
----Swift.(file).AnyHashable.==infix(_:AnyHashable,_:AnyHashable)
return infix_63_63({}, lhs._box._canonicalBox._isEqualTo({}, rhs._box._canonicalBox), () => false)
----Swift.(file).AnyHashable.hashValue
return this._box._canonicalBox._hashValue
----Swift.(file).AnyHashable.hash(into:Hasher)
let hasher = hasher$inout.get()
const $result = (() => {
this._box._canonicalBox._hashInto({}, {get: () => hasher, set: $val => hasher = $val});})()
hasher$inout.set(hasher)
return $result
----Swift.(file).AnyHashable.description
return _create(String, 'initDescribing', {}, this.base)
----Swift.(file).AnyHashable.debugDescription
return String.infix_43({}, String.infix_43({}, "AnyHashable(", _create(String, 'initReflecting', {}, this.base)), ")")
----Swift.(file).AnyHashable.customMirror
return _create(Mirror, 'initChildrenKeyValuePairsDisplayStyleOptionalAncestorRepresentationMirrorAncestorRepresentation', {}, this, new Map([["value", this.base]]), nil/*!default_value*/, .generated/*!default_value*/)
----Swift.(file).Array.init(_buffer:<<error type>>)
this._buffer = _cloneStruct(_buffer);
return
----Swift.(file).Array.capacity
return this._getCapacity({}, )
----Swift.(file).Array.startIndex
return 0
----Swift.(file).Array.endIndex
return this._getCount({}, )
----Swift.(file).Array.index(after:Int)
return Int.infix_43({}, i, 1)
----Swift.(file).Array.formIndex(after:Int)
let i = i$inout.get()
const $result = (() => {
Int.infix_43_61({}, {get: () => i, set: $val => i = $val}, 1);})()
i$inout.set(i)
return $result
----Swift.(file).Array.index(before:Int)
return Int.infix_45({}, i, 1)
----Swift.(file).Array.formIndex(before:Int)
let i = i$inout.get()
const $result = (() => {
Int.infix_45_61({}, {get: () => i, set: $val => i = $val}, 1);})()
i$inout.set(i)
return $result
----Swift.(file).Array.index(_:Int,offsetBy:Int)
return Int.infix_43({}, i, distance)
----Swift.(file).Array.index(_:Int,offsetBy:Int,limitedBy:Int)
const l = Int.infix_45({}, limit, i);
{
if(((Int.infix_62({}, distance, 0) ? Bool.infix_38_38({}, Int.infix_62_61({}, l, 0), () => Int.infix_60({}, l, distance)) : Bool.infix_38_38({}, Int.infix_60_61({}, l, 0), () => Int.infix_60({}, distance, l))))) {
return Optional.none;
}
};
return _injectIntoOptional(Int.infix_43({}, i, distance))
----Swift.(file).Array.distance(from:Int,to:Int)
return Int.infix_45({}, end, start)
----Swift.(file).Array.subscript(_:Int)
const wasNativeTypeChecked = this._hoistableIsNativeTypeChecked({}, );
const token = _cloneStruct(this._checkSubscriptWasNativeTypeChecked({}, index, wasNativeTypeChecked));
return this._getElementWasNativeTypeCheckedMatchingSubscriptCheck({}, index, wasNativeTypeChecked, token);
}subscript$_modify($info, index){
this._makeMutableAndUnique({$setThis: $val => $info.$setThis(_cloneStruct($val))}, );
this._checkSubscript_native({}, index);
const address = _cloneStruct(UnsafeMutablePointer.infix_43({}, this._buffer.subscriptBaseAddress, index));
/*yield*/
----Swift.(file).Array.subscript(_:Range<Int>)#ASS

{
if((Bool.infix_124_124({}, UnsafeRawPointer.infix_33_61({}, this.subscript$get({}, bounds)._buffer.identity, rhs._buffer.identity), () => Range.infix_33_61({}, bounds, Int.infix_46_46_60({}, rhs.startIndex, rhs.endIndex))))) {
this.replaceSubrangeWith({$setThis: $val => $info.$setThis(_cloneStruct($val))}, bounds, rhs);
}
}
----Swift.(file).Array.subscript(_:Range<Int>)
return _create(ArraySlice, 'init_bufferArraySlice_Buffer', {}, this._buffer.subscript$get({}, bounds));

----Swift.(file).Array.count
return this._getCount({}, )
----Swift.(file).Array.init(arrayLiteral:[Element])
$info.$setThis(_cloneStruct(_cloneStruct(_elements)));
return
----Swift.(file).Array.init()
this._buffer = _create(Array._Buffer, 'init', {}, );
return
----Swift.(file).Array.init(_:S)
$info.$setThis(_cloneStruct(_create(Array, 'init_bufferArray_Buffer', {}, _create(Array._Buffer, 'init_buffer_ContiguousArrayBufferShiftedToStartIndexInt', {}, s._copyToContiguousArray({}, )._buffer, 0))));
return
----Swift.(file).Array.init(repeating:Element,count:Int)
let p;
let $tuple = Array._allocateUninitialized({}, count)
$info.$setThis(_cloneStruct($tuple[0]))
p = $tuple[1];
{
let $generator = _cloneStruct(Int.infix_46_46_60({}, 0, count).makeIterator({}, ));
while(true) {
const $ifLet0 = $generator.next({$setThis: $val => $generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
p.initializeTo({}, repeatedValue);
UnsafeMutablePointer.infix_43_61({}, {get: () => p, set: $val => p = $val}, 1);
}
};
return
----Swift.(file).Array.init(_uninitializedCount:Int)
preconditionFileLine({}, () => Int.infix_62_61({}, count, 0), () => "Can't construct Array with count < 0", '?3', '?3');
this._buffer = _create(Array._Buffer, 'init', {}, );
{
if((Int.infix_62({}, count, 0))) {
this._buffer = _cloneStruct(Array._allocateBufferUninitializedMinimumCapacity({}, count));
this._buffer.count = count;
}
};
return
----Swift.(file).Array.reserveCapacity(_:Int)
{
if((Optional.wrappedEqualsOptionalNilComparisonType({}, this._buffer.requestUniqueMutableBackingBufferMinimumCapacity({$setThis: $val => this._buffer = $val}, minimumCapacity), _create(_OptionalNilComparisonType, 'initNilLiteraltuple_type', {}, {})))) {
const newBuffer = _create(_ContiguousArrayBuffer, 'init_uninitializedCountIntMinimumCapacityInt', {}, this.count, minimumCapacity);
this._buffer._copyContentsSubRangeInitializing({}, this._buffer.indices, newBuffer.firstElementAddress);
this._buffer = _create(Array._Buffer, 'init_buffer_ContiguousArrayBufferShiftedToStartIndexInt', {}, newBuffer, this._buffer.startIndex);
}
}
----Swift.(file).Array.append(_:Element)
this._makeUniqueAndReserveCapacityIfNotUnique({$setThis: $val => $info.$setThis(_cloneStruct($val))}, );
const oldCount = this._getCount({}, );
this._reserveCapacityAssumingUniqueBufferOldCount({$setThis: $val => $info.$setThis(_cloneStruct($val))}, oldCount);
this._appendElementAssumeUniqueAndCapacityNewElement({$setThis: $val => $info.$setThis(_cloneStruct($val))}, oldCount, newElement)
----Swift.(file).Array.append(contentsOf:S)
const newElementsCount = newElements.underestimatedCount;
this.reserveCapacityForAppendNewElementsCount({$setThis: $val => $info.$setThis(_cloneStruct($val))}, newElementsCount);
const oldCount = this.count;
const startNewElements = _cloneStruct(UnsafeMutablePointer.infix_43({}, this._buffer.firstElementAddress, oldCount));
const buf = _create(UnsafeMutableBufferPointer, 'initStartOptionalCountInt', {}, _injectIntoOptional(/*pointer_to_pointer*/startNewElements), Int.infix_45({}, this.capacity, oldCount));
const $tuple = buf.initializeFrom({}, newElements), remainder = $tuple && $tuple[0], writtenUpTo = $tuple && $tuple[1];
const writtenCount = buf.distanceFromTo({}, buf.startIndex, writtenUpTo);
preconditionFileLine({}, () => Int.infix_60_61({}, newElementsCount, writtenCount), () => "newElements.underestimatedCount was an overestimate", '?3', '?3');
Int.infix_43_61({}, {get: () => this._buffer.count, set: $val => this._buffer.count = $val}, writtenCount);
{
if((Int.infix_61_61({}, writtenUpTo, buf.endIndex))) {
this._buffer._arrayAppendSequence({$setThis: $val => this._buffer = $val}, _create(IteratorSequence, 'init', {}, remainder));
}
}
----Swift.(file).Array.reserveCapacityForAppend(newElementsCount:Int)
const oldCount = this.count;
const oldCapacity = this.capacity;
const newCount = Int.infix_43({}, oldCount, newElementsCount);
this.reserveCapacity({$setThis: $val => $info.$setThis(_cloneStruct($val))}, (Int.infix_62({}, newCount, oldCapacity) ? /*dot_syntax_base_ignored*/max({}, newCount, _growArrayCapacity({}, oldCapacity)) : newCount))
----Swift.(file).Array.remove(at:Int)
preconditionFileLine({}, () => Int.infix_60({}, index, this.endIndex), () => "Index out of range", '?3', '?3');
preconditionFileLine({}, () => Int.infix_62_61({}, index, this.startIndex), () => "Index out of range", '?3', '?3');
this._makeUniqueAndReserveCapacityIfNotUnique({$setThis: $val => $info.$setThis(_cloneStruct($val))}, );
const newCount = Int.infix_45({}, this._getCount({}, ), 1);
const pointer = _cloneStruct(UnsafeMutablePointer.infix_43({}, this._buffer.firstElementAddress, index));
const result = pointer.move({}, );
pointer.moveInitializeFromCount({}, UnsafeMutablePointer.infix_43({}, pointer, 1), Int.infix_45({}, newCount, index));
this._buffer.count = newCount;
return result
----Swift.(file).Array.insert(_:Element,at:Int)
this.replaceSubrangeWith({$setThis: $val => $info.$setThis(_cloneStruct($val))}, Int.infix_46_46_60({}, i, i), _create(CollectionOfOne, 'init', {}, newElement))
----Swift.(file).Array.removeAll(keepingCapacity:Bool)
{
if((Bool.prefix_33({}, keepCapacity))) {
this._buffer = _create(Array._Buffer, 'init', {}, );
}
else {
this.replaceSubrangeWith({$setThis: $val => $info.$setThis(_cloneStruct($val))}, this.indices, _create(EmptyCollection, 'init', {}, ));
}
}
----Swift.(file).Array.withContiguousMutableStorageIfAvailable(_:(inout UnsafeMutableBufferPointer<Element>) throws -> R)
return _injectIntoOptional(this.withUnsafeMutableBufferPointer({$setThis: $val => $info.$setThis(_cloneStruct($val))}, (($info, bufferPointer$inout) => body({}, {get: () => bufferPointer, set: $val => bufferPointer = $val}))))
----Swift.(file).Array.withContiguousStorageIfAvailable(_:(UnsafeBufferPointer<Element>) throws -> R)
return _injectIntoOptional(this.withUnsafeBufferPointer({}, (($info, bufferPointer) => body({}, bufferPointer))))
----Swift.(file).Array.+infix(_:Array<Element>,_:Array<Element>)
let lhs_dupl = _cloneStruct(lhs);
lhs_dupl.appendContentsOf({$setThis: $val => lhs_dupl = $val}, rhs);
return lhs_dupl
----Swift.(file).Array.+=infix(_:Array<Element>,_:Array<Element>)
let lhs = lhs$inout.get()
const $result = (() => {
lhs.appendContentsOf({$setThis: $val => lhs = $val}, rhs);})()
lhs$inout.set(lhs)
return $result
----Swift.(file).Array.customMirror
return _create(Mirror, 'initUnlabeledChildrenDisplayStyleOptionalAncestorRepresentationMirrorAncestorRepresentation', {}, this, this, _injectIntoOptional(Mirror.DisplayStyle.collection), .generated/*!default_value*/)
----Swift.(file).Array.description
return this._makeCollectionDescriptionWithTypeName({}, nil/*!default_value*/)
----Swift.(file).Array.debugDescription
return this._makeCollectionDescriptionWithTypeName({}, nil/*!default_value*/)
----Swift.(file).Array.init(_unsafeUninitializedCapacity:Int,initializingWith:(inout UnsafeMutableBufferPointer<Element>, inout Int) throws -> Void)
let firstElementAddress;
let $tuple = Array._allocateUninitialized({}, _unsafeUninitializedCapacity)
$info.$setThis(_cloneStruct($tuple[0]))
firstElementAddress = $tuple[1];
let initializedCount = 0;
let $defer = () => {
preconditionFileLine({}, () => Int.infix_60_61({}, initializedCount, _unsafeUninitializedCapacity), () => "Initialized count set to greater than specified capacity.", '?3', '?3');
this._buffer.count = initializedCount;
}
try {;
let buffer = _create(UnsafeMutableBufferPointer, 'initStartOptionalCountInt', {}, _injectIntoOptional(firstElementAddress), _unsafeUninitializedCapacity);
initializer({}, {get: () => buffer, set: $val => buffer = $val}, {get: () => initializedCount, set: $val => initializedCount = $val});
return ;}catch($error){$defer({}, );throw $error}$defer({}, )
----Swift.(file).Array.withUnsafeBufferPointer(_:(UnsafeBufferPointer<Element>) throws -> R)
return this._buffer.withUnsafeBufferPointer({}, body)
----Swift.(file).Array.withUnsafeMutableBufferPointer(_:(inout UnsafeMutableBufferPointer<Element>) throws -> R)
const count = this.count;
this._buffer._outlinedMakeUniqueBufferBufferCount({$setThis: $val => this._buffer = $val}, count);
let work = _create(Array, 'init', {}, );
let $tuple = {0: this, 1: work}
work = $tuple[0]
$info.$setThis(_cloneStruct($tuple[1]));
const pointer = _cloneStruct(work._buffer.firstElementAddress);
let inoutBufferPointer = _create(UnsafeMutableBufferPointer, 'initStartOptionalCountInt', {}, _injectIntoOptional(/*pointer_to_pointer*/pointer), count);
let $defer = () => {
preconditionFileLine({}, () => Bool.infix_38_38({}, Optional.infix_61_61({}, inoutBufferPointer.baseAddress, _injectIntoOptional(pointer)), () => Int.infix_61_61({}, inoutBufferPointer.count, count)), () => "Array withUnsafeMutableBufferPointer: replacing the buffer is not allowed", '?3', '?3');
let $tuple = {0: this, 1: work}
work = $tuple[0]
$info.$setThis(_cloneStruct($tuple[1]));
}
try {;
return body({}, {get: () => inoutBufferPointer, set: $val => inoutBufferPointer = $val});}catch($error){$defer({}, );throw $error}$defer({}, )
----Swift.(file).Array.replaceSubrange(_:Range<Int>,with:C)
preconditionFileLine({}, () => Int.infix_62_61({}, subrange.lowerBound, this._buffer.startIndex), () => "Array replace: subrange start is negative", '?3', '?3');
preconditionFileLine({}, () => Int.infix_60_61({}, subrange.upperBound, this._buffer.endIndex), () => "Array replace: subrange extends past the end", '?3', '?3');
const oldCount = this._buffer.count;
const eraseCount = subrange.count;
const insertCount = newElements.count;
const growth = Int.infix_45({}, insertCount, eraseCount);
{
if((Optional.wrappedNotEqualsOptionalNilComparisonType({}, this._buffer.requestUniqueMutableBackingBufferMinimumCapacity({$setThis: $val => this._buffer = $val}, Int.infix_43({}, oldCount, growth)), _create(_OptionalNilComparisonType, 'initNilLiteraltuple_type', {}, {})))) {
this._buffer.replaceSubrangeWithElementsOf({$setThis: $val => this._buffer = $val}, subrange, insertCount, newElements);
}
else {
this._buffer._arrayOutOfPlaceReplaceWithCount({$setThis: $val => this._buffer = $val}, subrange, newElements, insertCount);
}
}
----Swift.(file).Array.==infix(_:Array<Element>,_:Array<Element>)
const lhsCount = lhs.count;
{
if((Int.infix_33_61({}, lhsCount, rhs.count))) {
return false;
}
};
{
if((Bool.infix_124_124({}, Int.infix_61_61({}, lhsCount, 0), () => UnsafeRawPointer.infix_61_61({}, lhs._buffer.identity, rhs._buffer.identity)))) {
return true;
}
};
{
let $idx$generator = _cloneStruct(Int.infix_46_46_60({}, 0, lhsCount).makeIterator({}, ));
while(true) {
const $ifLet0 = $idx$generator.next({$setThis: $val => $idx$generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
let idx = $ifLet0[0]
{
if(((lhs.subscript$get({}, idx)).constructor.infix_33_61({}, lhs.subscript$get({}, idx), rhs.subscript$get({}, idx)))) {
return false;
}
};
}
};
return true
----Swift.(file).Array.hash(into:Hasher)
let hasher = hasher$inout.get()
const $result = (() => {
hasher.combine({$setThis: $val => hasher = $val}, this.count);
{
let $element$generator = _cloneStruct(this.makeIterator({}, ));
while(true) {
const $ifLet0 = $element$generator.next({$setThis: $val => $element$generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
let _element = $ifLet0[0]
hasher.combine({$setThis: $val => hasher = $val}, _element);
}
};})()
hasher$inout.set(hasher)
return $result
----Swift.(file).Array.withUnsafeMutableBytes(_:(UnsafeMutableRawBufferPointer) throws -> R)
return this.withUnsafeMutableBufferPointer({$setThis: $val => $info.$setThis(_cloneStruct($val))}, (($info, $0$inout) => body({}, _create(UnsafeMutableRawBufferPointer, 'initUnsafeMutableBufferPointer', {}, $0))))
----Swift.(file).Array.withUnsafeBytes(_:(UnsafeRawBufferPointer) throws -> R)
return this.withUnsafeBufferPointer({}, (($info, $0) => body({}, _create(UnsafeRawBufferPointer, 'initUnsafeBufferPointer', {}, $0))))
----Swift.(file).Array.init(_immutableCocoaArray:AnyObject)
$info.$setThis(_cloneStruct(_cloneStruct(_bridgeCocoaArray({}, _immutableCocoaArray))));
return
----Swift.(file)._ArrayBuffer.init(_buffer:<<error type>>,shiftedToStartIndex:Int)
this._storage = _create(_ArrayBridgeStorage, 'initNative_BridgeStorageNative', {}, source._storage);
return
----Swift.(file)._ArrayBuffer.arrayPropertyIsNativeTypeChecked
return this._isNativeTypeChecked
----Swift.(file)._ArrayBuffer.isUniquelyReferenced()
{
if((Bool.prefix_33({}, _isClassOrObjCExistential({}, ((function(){throw '!unclarifiedGeneric:Element'})()))))) {
return this._storage.isUniquelyReferencedUnflaggedNative({$setThis: $val => this._storage = $val}, );
}
};
{
if((Bool.prefix_33({}, this._storage.isUniquelyReferencedNative({$setThis: $val => this._storage = $val}, )))) {
return false;
}
};
return this._isNative
----Swift.(file)._ArrayBuffer.requestUniqueMutableBackingBuffer(minimumCapacity:Int)
{
if((_fastPath({}, this.isUniquelyReferenced({$setThis: $val => $info.$setThis(_cloneStruct($val))}, )))) {
const b = _cloneStruct(this._native);
{
if((_fastPath({}, Int.infix_62_61({}, b.capacity, minimumCapacity)))) {
return _injectIntoOptional(b);
}
};
}
};
return Optional.none
----Swift.(file)._ArrayBuffer.isMutableAndUniquelyReferenced()
return this.isUniquelyReferenced({$setThis: $val => $info.$setThis(_cloneStruct($val))}, )
----Swift.(file)._ArrayBuffer.requestNativeBuffer()
{
if((Bool.prefix_33({}, _isClassOrObjCExistential({}, ((function(){throw '!unclarifiedGeneric:Element'})()))))) {
return _injectIntoOptional(this._native);
}
};
return (_fastPath({}, this._storage.isNative) ? _injectIntoOptional(this._native) : Optional.none)
----Swift.(file)._ArrayBuffer.subscript(_:Range<Int>)#ASS

fatalErrorFileLine({}, () => "not implemented", '?3', '?3')
----Swift.(file)._ArrayBuffer.subscript(_:Range<Int>)
this._typeCheck({}, bounds);
{
if((_fastPath({}, this._isNative))) {
return this._native.subscript$get({}, bounds);
}
};
return this._nonNative.subscriptRange$get({}, bounds).unsafeCastElementsTo({}, ((function(){throw '!unclarifiedGeneric:Element'})()));

----Swift.(file)._ArrayBuffer.firstElementAddress
return this._native.firstElementAddress
----Swift.(file)._ArrayBuffer.firstElementAddressIfContiguous
return (_fastPath({}, this._isNative) ? _injectIntoOptional(this.firstElementAddress) : Optional.none)
----Swift.(file)._ArrayBuffer.count
return (_fastPath({}, this._isNative) ? this._native.count : this._nonNative.count)
----Swift.(file)._ArrayBuffer.capacity
return (_fastPath({}, this._isNative) ? this._native.capacity : this._nonNative.count)
----Swift.(file)._ArrayBuffer.getElement(_:Int,wasNativeTypeChecked:Bool)
{
if((_fastPath({}, wasNativeTypeChecked))) {
return this._nativeTypeChecked.subscript$get({}, i);
}
};
return unsafeBitCastTo({}, this._getElementSlowPath({}, i), ((function(){throw '!unclarifiedGeneric:Element'})()))
----Swift.(file)._ArrayBuffer.subscript(_:Int)#ASS

{
if((_fastPath({}, this._isNative))) {
this._native.subscript$set({$setThis: $val => this._native = _cloneStruct($val)}, newValue, i);
}
else {
let refCopy = _cloneStruct(this);
refCopy.replaceSubrangeWithElementsOf({$setThis: $val => refCopy = $val}, Int.infix_46_46_60({}, i, Int.infix_43({}, i, 1)), 1, _create(CollectionOfOne, 'init', {}, newValue));
}
}
----Swift.(file)._ArrayBuffer.subscript(_:Int)
return this.getElementWasNativeTypeChecked({}, i, this._isNativeTypeChecked);

----Swift.(file)._ArrayBuffer.withUnsafeBufferPointer(_:(UnsafeBufferPointer<Element>) throws -> R)
{
if((_fastPath({}, this._isNative))) {
let $defer = () => {
_fixLifetime({}, this);
}
try {;
return body({}, _create(UnsafeBufferPointer, 'initStartOptionalCountInt', {}, _injectIntoOptional(/*pointer_to_pointer*/this.firstElementAddress), this.count));}catch($error){$defer({}, );throw $error}$defer({}, )
}
};
return _create(ContiguousArray, 'initBuffer', {}, this).withUnsafeBufferPointer({}, body)
----Swift.(file)._ArrayBuffer.owner
return (_fastPath({}, this._isNative) ? this._native._storage : this._nonNative.buffer)
----Swift.(file)._ArrayBuffer.nativeOwner
return this._native._storage
----Swift.(file)._ArrayBuffer.identity
{
if((this._isNative)) {
return this._native.identity;
}
else {
return _create(UnsafeRawPointer, 'initUnsafeMutableRawPointer', {}, Unmanaged.passUnretained({}, this._nonNative.buffer).toOpaque({}, ));
}
}
----Swift.(file)._ArrayBuffer.startIndex
return 0
----Swift.(file)._ArrayBuffer.endIndex
return this.count
----Swift.(file)._ArrayBufferProtocol.subscriptBaseAddress
return this.firstElementAddress
----Swift.(file)._ArrayBufferProtocol.init(copying:Self)
const newBuffer = _create(_ContiguousArrayBuffer, 'init_uninitializedCountIntMinimumCapacityInt', {}, buffer.count, buffer.count);
buffer._copyContentsSubRangeInitializing({}, buffer.indices, newBuffer.firstElementAddress);
$info.$setThis(_cloneStruct(_create(this.constructor, 'init_buffer_ContiguousArrayBufferShiftedToStartIndexInt', {}, newBuffer, buffer.startIndex)));
return
----Swift.(file)._ArrayBufferProtocol.replaceSubrange(_:Range<Int>,with:Int,elementsOf:C)
const oldCount = this.count;
const eraseCount = subrange.count;
const growth = Int.infix_45({}, newCount, eraseCount);
this.count = Int.infix_43({}, oldCount, growth);
const _elements = _cloneStruct(this.subscriptBaseAddress);
const oldTailIndex = subrange.upperBound;
const oldTailStart = _cloneStruct(UnsafeMutablePointer.infix_43({}, _elements, oldTailIndex));
const newTailIndex = Int.infix_43({}, oldTailIndex, growth);
const newTailStart = _cloneStruct(UnsafeMutablePointer.infix_43({}, oldTailStart, growth));
const tailCount = Int.infix_45({}, oldCount, subrange.upperBound);
{
if((Int.infix_62({}, growth, 0))) {
newTailStart.moveInitializeFromCount({}, oldTailStart, tailCount);
let i = newValues.startIndex;
{
let $j$generator = _cloneStruct(subrange.makeIterator({}, ));
while(true) {
const $ifLet0 = $j$generator.next({$setThis: $val => $j$generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
let j = $ifLet0[0]
_elements.subscript$set({$setThis: $val => _elements = _cloneStruct($val)}, newValues.subscript$get({}, i), j);
newValues.formIndexAfter({}, {get: () => i, set: $val => i = $val});
}
};
{
let $j$generator = _cloneStruct(Int.infix_46_46_60({}, oldTailIndex, newTailIndex).makeIterator({}, ));
while(true) {
const $ifLet0 = $j$generator.next({$setThis: $val => $j$generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
let j = $ifLet0[0]
UnsafeMutablePointer.infix_43({}, _elements, j).initializeTo({}, newValues.subscript$get({}, i));
newValues.formIndexAfter({}, {get: () => i, set: $val => i = $val});
}
};
}
else {
let i = subrange.lowerBound;
let j = newValues.startIndex;
{
let $generator = _cloneStruct(Int.infix_46_46_60({}, 0, newCount).makeIterator({}, ));
while(true) {
const $ifLet0 = $generator.next({$setThis: $val => $generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
_elements.subscript$set({$setThis: $val => _elements = _cloneStruct($val)}, newValues.subscript$get({}, j), i);
Int.infix_43_61({}, {get: () => i, set: $val => i = $val}, 1);
newValues.formIndexAfter({}, {get: () => j, set: $val => j = $val});
}
};
{
if((Int.infix_61_61({}, growth, 0))) {
return ;
}
};
const shrinkage = Int.prefix_45({}, growth);
{
if((Int.infix_62({}, tailCount, shrinkage))) {
newTailStart.moveAssignFromCount({}, oldTailStart, shrinkage);
oldTailStart.moveInitializeFromCount({}, UnsafeMutablePointer.infix_43({}, oldTailStart, shrinkage), Int.infix_45({}, tailCount, shrinkage));
}
else {
newTailStart.moveAssignFromCount({}, oldTailStart, tailCount);
UnsafeMutablePointer.infix_43({}, newTailStart, tailCount).deinitializeCount({}, Int.infix_45({}, shrinkage, tailCount));
}
};
}
}
----Swift.(file).ArraySlice.init(_buffer:<<error type>>)
this._buffer = _cloneStruct(_buffer);
return
----Swift.(file).ArraySlice.init(_buffer:<<error type>>)
this.init_bufferArraySlice_Buffer({}, _create(ArraySlice._Buffer, 'init_buffer_ContiguousArrayBufferShiftedToStartIndexInt', {}, buffer, 0));
return
----Swift.(file).ArraySlice.capacity
return this._getCapacity({}, )
----Swift.(file).ArraySlice.startIndex
return this._buffer.startIndex
----Swift.(file).ArraySlice.endIndex
return this._buffer.endIndex
----Swift.(file).ArraySlice.index(after:Int)
return Int.infix_43({}, i, 1)
----Swift.(file).ArraySlice.formIndex(after:Int)
let i = i$inout.get()
const $result = (() => {
Int.infix_43_61({}, {get: () => i, set: $val => i = $val}, 1);})()
i$inout.set(i)
return $result
----Swift.(file).ArraySlice.index(before:Int)
return Int.infix_45({}, i, 1)
----Swift.(file).ArraySlice.formIndex(before:Int)
let i = i$inout.get()
const $result = (() => {
Int.infix_45_61({}, {get: () => i, set: $val => i = $val}, 1);})()
i$inout.set(i)
return $result
----Swift.(file).ArraySlice.index(_:Int,offsetBy:Int)
return Int.infix_43({}, i, distance)
----Swift.(file).ArraySlice.index(_:Int,offsetBy:Int,limitedBy:Int)
const l = Int.infix_45({}, limit, i);
{
if(((Int.infix_62({}, distance, 0) ? Bool.infix_38_38({}, Int.infix_62_61({}, l, 0), () => Int.infix_60({}, l, distance)) : Bool.infix_38_38({}, Int.infix_60_61({}, l, 0), () => Int.infix_60({}, distance, l))))) {
return Optional.none;
}
};
return _injectIntoOptional(Int.infix_43({}, i, distance))
----Swift.(file).ArraySlice.distance(from:Int,to:Int)
return Int.infix_45({}, end, start)
----Swift.(file).ArraySlice.subscript(_:Int)
const wasNativeTypeChecked = this._hoistableIsNativeTypeChecked({}, );
const token = _cloneStruct(this._checkSubscriptWasNativeTypeChecked({}, index, wasNativeTypeChecked));
return this._getElementWasNativeTypeCheckedMatchingSubscriptCheck({}, index, wasNativeTypeChecked, token);
}subscript$_modify($info, index){
this._makeMutableAndUnique({$setThis: $val => $info.$setThis(_cloneStruct($val))}, );
this._checkSubscript_native({}, index);
const address = _cloneStruct(UnsafeMutablePointer.infix_43({}, this._buffer.subscriptBaseAddress, index));
/*yield*/
----Swift.(file).ArraySlice.subscript(_:Range<Int>)#ASS

{
if((Bool.infix_124_124({}, UnsafeRawPointer.infix_33_61({}, this.subscript$get({}, bounds)._buffer.identity, rhs._buffer.identity), () => Range.infix_33_61({}, bounds, Int.infix_46_46_60({}, rhs.startIndex, rhs.endIndex))))) {
this.replaceSubrangeWith({$setThis: $val => $info.$setThis(_cloneStruct($val))}, bounds, rhs);
}
}
----Swift.(file).ArraySlice.subscript(_:Range<Int>)
return _create(ArraySlice, 'init_bufferArraySlice_Buffer', {}, this._buffer.subscript$get({}, bounds));

----Swift.(file).ArraySlice.count
return this._getCount({}, )
----Swift.(file).ArraySlice.init(arrayLiteral:[Element])
this.init_buffer_ContiguousArrayBuffer({}, _create(ContiguousArray, 'initBuffer', {}, _elements)._buffer);
return
----Swift.(file).ArraySlice.init()
this._buffer = _create(ArraySlice._Buffer, 'init', {}, );
return
----Swift.(file).ArraySlice.init(_:S)
$info.$setThis(_cloneStruct(_create(ArraySlice, 'init_bufferArraySlice_Buffer', {}, _create(ArraySlice._Buffer, 'init_buffer_ContiguousArrayBufferShiftedToStartIndexInt', {}, s._copyToContiguousArray({}, )._buffer, 0))));
return
----Swift.(file).ArraySlice.init(repeating:Element,count:Int)
let p;
let $tuple = ArraySlice._allocateUninitialized({}, count)
$info.$setThis(_cloneStruct($tuple[0]))
p = $tuple[1];
{
let $generator = _cloneStruct(Int.infix_46_46_60({}, 0, count).makeIterator({}, ));
while(true) {
const $ifLet0 = $generator.next({$setThis: $val => $generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
p.initializeTo({}, repeatedValue);
UnsafeMutablePointer.infix_43_61({}, {get: () => p, set: $val => p = $val}, 1);
}
};
return
----Swift.(file).ArraySlice.init(_uninitializedCount:Int)
preconditionFileLine({}, () => Int.infix_62_61({}, count, 0), () => "Can't construct ArraySlice with count < 0", '?3', '?3');
this._buffer = _create(ArraySlice._Buffer, 'init', {}, );
{
if((Int.infix_62({}, count, 0))) {
this._buffer = _cloneStruct(ArraySlice._allocateBufferUninitializedMinimumCapacity({}, count));
this._buffer.count = count;
}
};
return
----Swift.(file).ArraySlice.reserveCapacity(_:Int)
{
if((Optional.wrappedEqualsOptionalNilComparisonType({}, this._buffer.requestUniqueMutableBackingBufferMinimumCapacity({$setThis: $val => this._buffer = $val}, minimumCapacity), _create(_OptionalNilComparisonType, 'initNilLiteraltuple_type', {}, {})))) {
const newBuffer = _create(_ContiguousArrayBuffer, 'init_uninitializedCountIntMinimumCapacityInt', {}, this.count, minimumCapacity);
this._buffer._copyContentsSubRangeInitializing({}, this._buffer.indices, newBuffer.firstElementAddress);
this._buffer = _create(ArraySlice._Buffer, 'init_buffer_ContiguousArrayBufferShiftedToStartIndexInt', {}, newBuffer, this._buffer.startIndex);
}
}
----Swift.(file).ArraySlice.append(_:Element)
this._makeUniqueAndReserveCapacityIfNotUnique({$setThis: $val => $info.$setThis(_cloneStruct($val))}, );
const oldCount = this._getCount({}, );
this._reserveCapacityAssumingUniqueBufferOldCount({$setThis: $val => $info.$setThis(_cloneStruct($val))}, oldCount);
this._appendElementAssumeUniqueAndCapacityNewElement({$setThis: $val => $info.$setThis(_cloneStruct($val))}, oldCount, newElement)
----Swift.(file).ArraySlice.append(contentsOf:S)
const newElementsCount = newElements.underestimatedCount;
this.reserveCapacityForAppendNewElementsCount({$setThis: $val => $info.$setThis(_cloneStruct($val))}, newElementsCount);
const oldCount = this.count;
const startNewElements = _cloneStruct(UnsafeMutablePointer.infix_43({}, this._buffer.firstElementAddress, oldCount));
const buf = _create(UnsafeMutableBufferPointer, 'initStartOptionalCountInt', {}, _injectIntoOptional(/*pointer_to_pointer*/startNewElements), Int.infix_45({}, this.capacity, oldCount));
const $tuple = buf.initializeFrom({}, newElements), remainder = $tuple && $tuple[0], writtenUpTo = $tuple && $tuple[1];
const writtenCount = buf.distanceFromTo({}, buf.startIndex, writtenUpTo);
preconditionFileLine({}, () => Int.infix_60_61({}, newElementsCount, writtenCount), () => "newElements.underestimatedCount was an overestimate", '?3', '?3');
Int.infix_43_61({}, {get: () => this._buffer.count, set: $val => this._buffer.count = $val}, writtenCount);
{
if((Int.infix_61_61({}, writtenUpTo, buf.endIndex))) {
this._buffer._arrayAppendSequence({$setThis: $val => this._buffer = $val}, _create(IteratorSequence, 'init', {}, remainder));
}
}
----Swift.(file).ArraySlice.reserveCapacityForAppend(newElementsCount:Int)
const oldCount = this.count;
const oldCapacity = this.capacity;
const newCount = Int.infix_43({}, oldCount, newElementsCount);
this.reserveCapacity({$setThis: $val => $info.$setThis(_cloneStruct($val))}, (Int.infix_62({}, newCount, oldCapacity) ? /*dot_syntax_base_ignored*/max({}, newCount, _growArrayCapacity({}, oldCapacity)) : newCount))
----Swift.(file).ArraySlice.remove(at:Int)
const result = this.subscript$get({}, index);
this.replaceSubrangeWith({$setThis: $val => $info.$setThis(_cloneStruct($val))}, Int.infix_46_46_60({}, index, Int.infix_43({}, index, 1)), _create(EmptyCollection, 'init', {}, ));
return result
----Swift.(file).ArraySlice.insert(_:Element,at:Int)
this.replaceSubrangeWith({$setThis: $val => $info.$setThis(_cloneStruct($val))}, Int.infix_46_46_60({}, i, i), _create(CollectionOfOne, 'init', {}, newElement))
----Swift.(file).ArraySlice.removeAll(keepingCapacity:Bool)
{
if((Bool.prefix_33({}, keepCapacity))) {
this._buffer = _create(ArraySlice._Buffer, 'init', {}, );
}
else {
this.replaceSubrangeWith({$setThis: $val => $info.$setThis(_cloneStruct($val))}, this.indices, _create(EmptyCollection, 'init', {}, ));
}
}
----Swift.(file).ArraySlice.withContiguousMutableStorageIfAvailable(_:(inout UnsafeMutableBufferPointer<Element>) throws -> R)
return _injectIntoOptional(this.withUnsafeMutableBufferPointer({$setThis: $val => $info.$setThis(_cloneStruct($val))}, (($info, bufferPointer$inout) => body({}, {get: () => bufferPointer, set: $val => bufferPointer = $val}))))
----Swift.(file).ArraySlice.withContiguousStorageIfAvailable(_:(UnsafeBufferPointer<Element>) throws -> R)
return _injectIntoOptional(this.withUnsafeBufferPointer({}, (($info, bufferPointer) => body({}, bufferPointer))))
----Swift.(file).ArraySlice.customMirror
return _create(Mirror, 'initUnlabeledChildrenDisplayStyleOptionalAncestorRepresentationMirrorAncestorRepresentation', {}, this, this, _injectIntoOptional(Mirror.DisplayStyle.collection), .generated/*!default_value*/)
----Swift.(file).ArraySlice.description
return this._makeCollectionDescriptionWithTypeName({}, nil/*!default_value*/)
----Swift.(file).ArraySlice.debugDescription
return this._makeCollectionDescriptionWithTypeName({}, _injectIntoOptional("ArraySlice"))
----Swift.(file).ArraySlice.withUnsafeBufferPointer(_:(UnsafeBufferPointer<Element>) throws -> R)
return this._buffer.withUnsafeBufferPointer({}, body)
----Swift.(file).ArraySlice.withUnsafeMutableBufferPointer(_:(inout UnsafeMutableBufferPointer<Element>) throws -> R)
const count = this.count;
this._buffer._outlinedMakeUniqueBufferBufferCount({$setThis: $val => this._buffer = $val}, count);
let work = _create(ArraySlice, 'init', {}, );
let $tuple = {0: this, 1: work}
work = $tuple[0]
$info.$setThis(_cloneStruct($tuple[1]));
const pointer = _cloneStruct(work._buffer.firstElementAddress);
let inoutBufferPointer = _create(UnsafeMutableBufferPointer, 'initStartOptionalCountInt', {}, _injectIntoOptional(/*pointer_to_pointer*/pointer), count);
let $defer = () => {
preconditionFileLine({}, () => Bool.infix_38_38({}, Optional.infix_61_61({}, inoutBufferPointer.baseAddress, _injectIntoOptional(pointer)), () => Int.infix_61_61({}, inoutBufferPointer.count, count)), () => "ArraySlice withUnsafeMutableBufferPointer: replacing the buffer is not allowed", '?3', '?3');
let $tuple = {0: this, 1: work}
work = $tuple[0]
$info.$setThis(_cloneStruct($tuple[1]));
}
try {;
return body({}, {get: () => inoutBufferPointer, set: $val => inoutBufferPointer = $val});}catch($error){$defer({}, );throw $error}$defer({}, )
----Swift.(file).ArraySlice.replaceSubrange(_:Range<Int>,with:C)
preconditionFileLine({}, () => Int.infix_62_61({}, subrange.lowerBound, this._buffer.startIndex), () => "ArraySlice replace: subrange start is before the startIndex", '?3', '?3');
preconditionFileLine({}, () => Int.infix_60_61({}, subrange.upperBound, this._buffer.endIndex), () => "ArraySlice replace: subrange extends past the end", '?3', '?3');
const oldCount = this._buffer.count;
const eraseCount = subrange.count;
const insertCount = newElements.count;
const growth = Int.infix_45({}, insertCount, eraseCount);
{
if((Optional.wrappedNotEqualsOptionalNilComparisonType({}, this._buffer.requestUniqueMutableBackingBufferMinimumCapacity({$setThis: $val => this._buffer = $val}, Int.infix_43({}, oldCount, growth)), _create(_OptionalNilComparisonType, 'initNilLiteraltuple_type', {}, {})))) {
this._buffer.replaceSubrangeWithElementsOf({$setThis: $val => this._buffer = $val}, subrange, insertCount, newElements);
}
else {
this._buffer._arrayOutOfPlaceReplaceWithCount({$setThis: $val => this._buffer = $val}, subrange, newElements, insertCount);
}
}
----Swift.(file).ArraySlice.==infix(_:ArraySlice<Element>,_:ArraySlice<Element>)
const lhsCount = lhs.count;
{
if((Int.infix_33_61({}, lhsCount, rhs.count))) {
return false;
}
};
{
if((Bool.infix_124_124({}, Int.infix_61_61({}, lhsCount, 0), () => UnsafeRawPointer.infix_61_61({}, lhs._buffer.identity, rhs._buffer.identity)))) {
return true;
}
};
let streamLHS = _cloneStruct(lhs.makeIterator({}, ));
let streamRHS = _cloneStruct(rhs.makeIterator({}, ));
let nextLHS = streamLHS.next({$setThis: $val => streamLHS = $val}, );
while(true){
if(!((Optional.wrappedNotEqualsOptionalNilComparisonType({}, nextLHS, _create(_OptionalNilComparisonType, 'initNilLiteraltuple_type', {}, {}))))) break
const nextRHS = streamRHS.next({$setThis: $val => streamRHS = $val}, );
{
if((Optional.infix_33_61({}, nextLHS, nextRHS))) {
return false;
}
};
nextLHS = streamLHS.next({$setThis: $val => streamLHS = $val}, );
};
return true
----Swift.(file).ArraySlice.hash(into:Hasher)
let hasher = hasher$inout.get()
const $result = (() => {
hasher.combine({$setThis: $val => hasher = $val}, this.count);
{
let $element$generator = _cloneStruct(this.makeIterator({}, ));
while(true) {
const $ifLet0 = $element$generator.next({$setThis: $val => $element$generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
let _element = $ifLet0[0]
hasher.combine({$setThis: $val => hasher = $val}, _element);
}
};})()
hasher$inout.set(hasher)
return $result
----Swift.(file).ArraySlice.withUnsafeMutableBytes(_:(UnsafeMutableRawBufferPointer) throws -> R)
return this.withUnsafeMutableBufferPointer({$setThis: $val => $info.$setThis(_cloneStruct($val))}, (($info, $0$inout) => body({}, _create(UnsafeMutableRawBufferPointer, 'initUnsafeMutableBufferPointer', {}, $0))))
----Swift.(file).ArraySlice.withUnsafeBytes(_:(UnsafeRawBufferPointer) throws -> R)
return this.withUnsafeBufferPointer({}, (($info, $0) => body({}, _create(UnsafeRawBufferPointer, 'initUnsafeBufferPointer', {}, $0))))
----Swift.(file).ArraySlice.init(_startIndex:Int)
this.init_bufferArraySlice_Buffer({}, _create(ArraySlice._Buffer, 'init_buffer_ContiguousArrayBufferShiftedToStartIndexInt', {}, _create(ContiguousArray, 'init', {}, )._buffer, _startIndex));
return
----Swift.(file)._ArrayProtocol.filter(_:(Self.Element) throws -> Bool)
return this._filter({}, isIncluded)
----Swift.(file).assert(_:() -> Bool,_:() -> String,file:StaticString,line:UInt)
{
if((_isDebugAssertConfiguration({}, ))) {
{
if((Bool.prefix_33({}, _branchHintExpected({}, condition({}, ), true)))) {
_assertionFailureFileLineFlags({}, "Assertion failed", message({}, ), file, line, _fatalErrorFlags({}, ));
}
};
}
}
----Swift.(file).assertionFailure(_:() -> String,file:StaticString,line:UInt)
{
if((_isDebugAssertConfiguration({}, ))) {
_assertionFailureFileLineFlags({}, "Fatal error", message({}, ), file, line, _fatalErrorFlags({}, ));
}
else {
{
if((_isFastAssertConfiguration({}, ))) {
_conditionallyUnreachable({}, );
}
}
}
}
----Swift.(file).fatalError(_:() -> String,file:StaticString,line:UInt)
_assertionFailureFileLineFlags({}, "Fatal error", message({}, ), file, line, _fatalErrorFlags({}, ))
----Swift.(file).BidirectionalCollection.formIndex(before:Self.Index)
let i = i$inout.get()
const $result = (() => {
i = this.indexBefore({}, i);})()
i$inout.set(i)
return $result
----Swift.(file).BidirectionalCollection.index(_:Self.Index,offsetBy:Int)
return this._indexOffsetBy({}, i, distance)
----Swift.(file).BidirectionalCollection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)
return this._indexOffsetByLimitedBy({}, i, distance, limit)
----Swift.(file).BidirectionalCollection.distance(from:Self.Index,to:Self.Index)
return this._distanceFromTo({}, start, end)
----Swift.(file).BidirectionalCollection.popLast()
{
if(!((Bool.prefix_33({}, this.isEmpty)))) {
return Optional.none;
}
};
const _element = this.last[0];
$info.$setThis(_cloneStruct(this.subscriptRange$get({}, (this.startIndex).constructor.infix_46_46_60({}, this.startIndex, this.indexBefore({}, this.endIndex)))));
return _injectIntoOptional(_element)
----Swift.(file).BidirectionalCollection.removeLast()
const _element = this.last[0];
$info.$setThis(_cloneStruct(this.subscriptRange$get({}, (this.startIndex).constructor.infix_46_46_60({}, this.startIndex, this.indexBefore({}, this.endIndex)))));
return _element
----Swift.(file).BidirectionalCollection.removeLast(_:Int)
{
if((Int.infix_61_61({}, k, 0))) {
return ;
}
};
preconditionFileLine({}, () => Int.infix_62_61({}, k, 0), () => "Number of elements to remove should be non-negative", '?3', '?3');
preconditionFileLine({}, () => Int.infix_62_61({}, this.count, k), () => "Can't remove more items from a collection than it contains", '?3', '?3');
$info.$setThis(_cloneStruct(this.subscriptRange$get({}, (this.startIndex).constructor.infix_46_46_60({}, this.startIndex, this.indexOffsetBy({}, this.endIndex, Int.prefix_45({}, k))))))
----Swift.(file).BidirectionalCollection.dropLast(_:Int)
preconditionFileLine({}, () => Int.infix_62_61({}, k, 0), () => "Can't drop a negative number of elements from a collection", '?3', '?3');
const end = infix_63_63({}, this.indexOffsetByLimitedBy({}, this.endIndex, Int.prefix_45({}, k), this.startIndex), () => this.startIndex);
return this.subscriptRange$get({}, (this.startIndex).constructor.infix_46_46_60({}, this.startIndex, end))
----Swift.(file).BidirectionalCollection.suffix(_:Int)
preconditionFileLine({}, () => Int.infix_62_61({}, maxLength, 0), () => "Can't take a suffix of negative length from a collection", '?3', '?3');
const start = infix_63_63({}, this.indexOffsetByLimitedBy({}, this.endIndex, Int.prefix_45({}, maxLength), this.startIndex), () => this.startIndex);
return this.subscriptRange$get({}, (start).constructor.infix_46_46_60({}, start, this.endIndex))
----Swift.(file)._UnsafeBitset.word(for:Int)
const _element = _create(UInt, 'initBitPatternInt', {}, _element);
const capacity = _create(UInt, 'initBitPatternInt', {}, _UnsafeBitset.Word.capacity);
return _create(Int, 'initBitPatternUInt', {}, UInt.infix_47({}, _element, capacity))
----Swift.(file)._UnsafeBitset.bit(for:Int)
const _element = _create(UInt, 'initBitPatternInt', {}, _element);
const capacity = _create(UInt, 'initBitPatternInt', {}, _UnsafeBitset.Word.capacity);
return _create(Int, 'initBitPatternUInt', {}, UInt.infix_37({}, _element, capacity))
----Swift.(file)._UnsafeBitset.split(_:Int)
return {0: this.wordFor({}, _element), 1: this.bitFor({}, _element)}
----Swift.(file)._UnsafeBitset.join(word:Int,bit:Int)
return Int.infix_38_43({}, Int.infix_38_42({}, word, _UnsafeBitset.Word.capacity), bit)
----Swift.(file)._UnsafeBitset.wordCount(forCapacity:Int)
return this.wordFor({}, Int.infix_38_45({}, Int.infix_38_43({}, capacity, _UnsafeBitset.Word.capacity), 1))
----Swift.(file)._UnsafeBitset.capacity
return Int.infix_38_42({}, this.wordCount, _UnsafeBitset.Word.capacity)
----Swift.(file)._UnsafeBitset.isValid(_:Int)
return Bool.infix_38_38({}, Int.infix_62_61({}, _element, 0), () => Int.infix_60_61({}, _element, this.capacity))
----Swift.(file)._UnsafeBitset.uncheckedContains(_:Int)
const $tuple = _UnsafeBitset.split({}, _element), word = $tuple && $tuple[0], bit = $tuple && $tuple[1];
return this.words.subscript$get({}, word).uncheckedContains({}, bit)
----Swift.(file)._UnsafeBitset.uncheckedInsert(_:Int)
const $tuple = _UnsafeBitset.split({}, _element), word = $tuple && $tuple[0], bit = $tuple && $tuple[1];
return this.words.subscript$get({}, word).uncheckedInsert({$setThis: $val => this.words.subscript$set({$setThis: $val => this.words = _cloneStruct($val)}, $val, word)}, bit)
----Swift.(file)._UnsafeBitset.uncheckedRemove(_:Int)
const $tuple = _UnsafeBitset.split({}, _element), word = $tuple && $tuple[0], bit = $tuple && $tuple[1];
return this.words.subscript$get({}, word).uncheckedRemove({$setThis: $val => this.words.subscript$set({$setThis: $val => this.words = _cloneStruct($val)}, $val, word)}, bit)
----Swift.(file)._UnsafeBitset.clear()
this.words.assignRepeatingCount({}, _UnsafeBitset.Word.empty, this.wordCount)
----Swift.(file)._UnsafeBitset.count
let count = 0;
{
let $w$generator = _cloneStruct(Int.infix_46_46_60({}, 0, this.wordCount).makeIterator({}, ));
while(true) {
const $ifLet0 = $w$generator.next({$setThis: $val => $w$generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
let w = $ifLet0[0]
Int.infix_43_61({}, {get: () => count, set: $val => count = $val}, this.words.subscript$get({}, w).count);
}
};
return count
----Swift.(file)._UnsafeBitset.underestimatedCount
return this.count
----Swift.(file)._UnsafeBitset.makeIterator()
return _create(_UnsafeBitset.Iterator, 'init_UnsafeBitset', {}, this)
----Swift.(file)._UnsafeBitset.Word.capacity
return UInt.bitWidth;
}
static get capacity() { return this.capacity$get()
----Swift.(file)._UnsafeBitset.Word.uncheckedContains(_:Int)
return UInt.infix_33_61({}, UInt.infix_38({}, this.value, UInt.infix_38_60_60({}, 1, bit)), 0)
----Swift.(file)._UnsafeBitset.Word.uncheckedInsert(_:Int)
const mask = UInt.infix_38_60_60({}, 1, bit);
const inserted = UInt.infix_61_61({}, UInt.infix_38({}, this.value, mask), 0);
UInt.infix_124_61({}, {get: () => this.value, set: $val => this.value = $val}, mask);
return inserted
----Swift.(file)._UnsafeBitset.Word.uncheckedRemove(_:Int)
const mask = UInt.infix_38_60_60({}, 1, bit);
const removed = UInt.infix_33_61({}, UInt.infix_38({}, this.value, mask), 0);
UInt.infix_38_61({}, {get: () => this.value, set: $val => this.value = $val}, UInt.prefix_126({}, mask));
return removed
----Swift.(file)._UnsafeBitset.Word.minimum
{
if(!((UInt.infix_33_61({}, this.value, 0)))) {
return Optional.none;
}
};
return _injectIntoOptional(this.value.trailingZeroBitCount)
----Swift.(file)._UnsafeBitset.Word.maximum
{
if(!((UInt.infix_33_61({}, this.value, 0)))) {
return Optional.none;
}
};
return _injectIntoOptional(Int.infix_38_45({}, Int.infix_38_45({}, _UnsafeBitset.Word.capacity, 1), this.value.leadingZeroBitCount))
----Swift.(file)._UnsafeBitset.Word.complement
return _create(_UnsafeBitset.Word, 'initUInt', {}, UInt.prefix_126({}, this.value))
----Swift.(file)._UnsafeBitset.Word.subtracting(elementsBelow:Int)
const mask = UInt.infix_38_60_60({}, UInt.max, bit);
return _create(_UnsafeBitset.Word, 'initUInt', {}, UInt.infix_38({}, this.value, mask))
----Swift.(file)._UnsafeBitset.Word.intersecting(elementsBelow:Int)
const mask = UInt.infix_38_45({}, UInt.infix_38_60_60({}, 1, bit), 1);
return _create(_UnsafeBitset.Word, 'initUInt', {}, UInt.infix_38({}, this.value, mask))
----Swift.(file)._UnsafeBitset.Word.intersecting(elementsAbove:Int)
const mask = UInt.infix_38_60_60({}, UInt.infix_38_60_60({}, UInt.max, bit), 1);
return _create(_UnsafeBitset.Word, 'initUInt', {}, UInt.infix_38({}, this.value, mask))
----Swift.(file)._UnsafeBitset.Word.empty
return _create(_UnsafeBitset.Word, 'initUInt', {}, 0);
}
static get empty() { return this.empty$get()
----Swift.(file)._UnsafeBitset.Word.allBits
return _create(_UnsafeBitset.Word, 'initUInt', {}, UInt.max);
}
static get allBits() { return this.allBits$get()
----Swift.(file)._UnsafeBitset.Word.count
return this.value.nonzeroBitCount
----Swift.(file)._UnsafeBitset.Word.underestimatedCount
return this.count
----Swift.(file)._UnsafeBitset.Word.isEmpty
return UInt.infix_61_61({}, this.value, 0)
----Swift.(file)._UnsafeBitset.Word.next()
{
if(!((UInt.infix_33_61({}, this.value, 0)))) {
return Optional.none;
}
};
const bit = this.value.trailingZeroBitCount;
UInt.infix_38_61({}, {get: () => this.value, set: $val => this.value = $val}, UInt.infix_38_45({}, this.value, 1));
return _injectIntoOptional(bit)
----Swift.(file).Bool.init(_:Bool)
$info.$setThis(_cloneStruct(value));
return
----Swift.(file).Bool.random(using:T)
let generator = generator$inout.get()
const $result = (() => {
return UInt64.infix_61_61({}, UInt64.infix_38({}, UInt64.infix_62_62({}, generator.next({$setThis: $val => generator = $val}, ), 17), 1), 0);})()
generator$inout.set(generator)
return $result
----Swift.(file).Bool.random()
let g = _create(SystemRandomNumberGenerator, 'init', {}, );
return Bool.randomUsing({}, {get: () => g, set: $val => g = $val})
----Swift.(file).Bool.init(booleanLiteral:Bool)
$info.$setThis(_cloneStruct(value));
return
----Swift.(file).Bool.description
return (this ? "true" : "false")
----Swift.(file).Bool.hash(into:Hasher)
let hasher = hasher$inout.get()
const $result = (() => {
hasher.combine({$setThis: $val => hasher = $val}, (this ? 1 : 0));})()
hasher$inout.set(hasher)
return $result
----Swift.(file).Bool.init(_:String)
{
if((String.infix_61_61({}, description, "true"))) {
$info.$setThis(_cloneStruct(true));
}
else {
{
if((String.infix_61_61({}, description, "false"))) {
$info.$setThis(_cloneStruct(false));
}
else {
return (this.$failed = true);
}
}
}
};
return
----Swift.(file).Bool.&&infix(_:Bool,_:() throws -> Bool)
return (lhs ? rhs({}, ) : false)
----Swift.(file).Bool.||infix(_:Bool,_:() throws -> Bool)
return (lhs ? true : rhs({}, ))
----Swift.(file).Bool.toggle()
$info.$setThis(_cloneStruct(Bool.prefix_33({}, this)))
----Swift.(file).AutoreleasingUnsafeMutablePointer.subscript(_:Int)
/*yield*/
----Swift.(file).AutoreleasingUnsafeMutablePointer.init(_:UnsafePointer<U>?)
{const $ifLet0 = from
if(!($ifLet0.rawValue === 'some')) {
return (this.$failed = true);
}let unwrapped = $ifLet0[0]
};
this.initUnsafePointer({}, unwrapped);
return
----Swift.(file).UnsafeMutableRawPointer.init(_:AutoreleasingUnsafeMutablePointer<T>?)
{const $ifLet0 = other
if(!($ifLet0.rawValue === 'some')) {
return (this.$failed = true);
}let unwrapped = $ifLet0[0]
};
this.initAutoreleasingUnsafeMutablePointer({}, unwrapped);
return
----Swift.(file).UnsafeRawPointer.init(_:AutoreleasingUnsafeMutablePointer<T>?)
{const $ifLet0 = other
if(!($ifLet0.rawValue === 'some')) {
return (this.$failed = true);
}let unwrapped = $ifLet0[0]
};
this.init({}, /*pointer_to_pointer*/unwrapped);
return
----Swift.(file).ManagedBufferPointer.init(_:Int)
this.init_uncheckedBufferClassAnyClassMinimumCapacityInt({}, _BridgingBufferStorage, count);
this.withUnsafeMutablePointerToHeader({}, (($info, $0) => $0.initializeTo({}, _create(_BridgingBufferHeader, 'initInt', {}, count))));
return
----Swift.(file).ManagedBufferPointer.count
return this.header.count
----Swift.(file).ManagedBufferPointer.subscript(_:Int)
return this.withUnsafeMutablePointerToElements({}, (($info, $0) => $0.subscript$get({}, i)))
----Swift.(file).ManagedBufferPointer.baseAddress
return this.withUnsafeMutablePointerToElements({}, (($info, $0) => $0))
----Swift.(file).ManagedBufferPointer.storage
return _injectIntoOptional(this.buffer)
----Swift.(file).!=infix(_:Any.Type?,_:Any.Type?)
return Bool.prefix_33({}, infix_61_61({}, t0, t1))
----Swift.(file).String.init(cString:UnsafePointer<CChar>)
const len = UTF8._nullCodeUnitOffsetIn({}, cString);
$info.$setThis(_cloneStruct(String._fromUTF8Repairing({}, _create(UnsafeBufferPointer, 'initStartOptionalCountInt', {}, _injectIntoOptional(/*pointer_to_pointer*/cString._asUInt8), len))["0"]));
return
----Swift.(file).String.init(cString:UnsafePointer<UInt8>)
const len = UTF8._nullCodeUnitOffsetIn({}, cString);
$info.$setThis(_cloneStruct(String._fromUTF8Repairing({}, _create(UnsafeBufferPointer, 'initStartOptionalCountInt', {}, _injectIntoOptional(/*pointer_to_pointer*/cString), len))["0"]));
return
----Swift.(file).String.init(validatingUTF8:UnsafePointer<CChar>)
const len = UTF8._nullCodeUnitOffsetIn({}, cString);
{const $ifLet0 = String._tryFromUTF8({}, _create(UnsafeBufferPointer, 'initStartOptionalCountInt', {}, _injectIntoOptional(/*pointer_to_pointer*/cString._asUInt8), len))
if(!($ifLet0.rawValue === 'some')) {
return (this.$failed = true);
}let str = $ifLet0[0]
};
$info.$setThis(_cloneStruct(str));
return
----Swift.(file).String.decodeCString(_:UnsafePointer<Encoding.CodeUnit>?,as:Encoding.Type,repairingInvalidCodeUnits:Bool)
{const $ifLet0 = cString
if(!($ifLet0.rawValue === 'some')) {
return Optional.none;
}let cPtr = $ifLet0[0]
};
{
if((_fastPath({}, infix_61_61({}, _injectIntoOptional(encoding), _injectIntoOptional(Unicode.UTF8))))) {
const ptr = _cloneStruct(_create(UnsafeRawPointer, 'init', {}, /*pointer_to_pointer*/cPtr).assumingMemoryBoundTo({}, UInt8));
const len = UTF8._nullCodeUnitOffsetIn({}, ptr);
const codeUnits = _create(UnsafeBufferPointer, 'initStartOptionalCountInt', {}, _injectIntoOptional(/*pointer_to_pointer*/ptr), len);
{
if((isRepairing)) {
return _injectIntoOptional(String._fromUTF8Repairing({}, codeUnits));
}
else {
{const $ifLet0 = String._tryFromUTF8({}, codeUnits)
if(!($ifLet0.rawValue === 'some')) {
return Optional.none;
}let str = $ifLet0[0]
};
return _injectIntoOptional({0: str, 1: false});
}
};
}
};
let end = _cloneStruct(cPtr);
while(true){
if(!(((end.pointee).constructor.infix_33_61({}, end.pointee, 0)))) break
UnsafePointer.infix_43_61({}, {get: () => end, set: $val => end = $val}, 1);
};
const len = UnsafePointer.infix_45({}, end, cPtr);
const codeUnits = _create(UnsafeBufferPointer, 'initStartOptionalCountInt', {}, _injectIntoOptional(/*pointer_to_pointer*/cPtr), len);
return _injectIntoOptional(((_.tmp0 = String._fromCodeUnitsEncodingRepair({}, codeUnits, encoding, isRepairing)).rawValue === 'some') ? (_.tmp0[0]) : null)
----Swift.(file).String.init(decodingCString:UnsafePointer<Encoding.CodeUnit>,as:Encoding.Type)
$info.$setThis(_cloneStruct(String.decodeCStringAsRepairingInvalidCodeUnits({}, _injectIntoOptional(/*pointer_to_pointer*/ptr), sourceEncoding, true/*!default_value*/)[0]["0"]));
return
----Swift.(file).OpaquePointer.init(_:UnsafePointer<T>)
this._rawValue = from._rawValue;
return
----Swift.(file).OpaquePointer.init(_:UnsafePointer<T>?)
{const $ifLet0 = from
if(!($ifLet0.rawValue === 'some')) {
return (this.$failed = true);
}let unwrapped = $ifLet0[0]
};
this.initUnsafeRawPointer({}, /*pointer_to_pointer*/unwrapped);
return
----Swift.(file).OpaquePointer.init(_:UnsafeMutablePointer<T>)
this._rawValue = from._rawValue;
return
----Swift.(file).OpaquePointer.init(_:UnsafeMutablePointer<T>?)
{const $ifLet0 = from
if(!($ifLet0.rawValue === 'some')) {
return (this.$failed = true);
}let unwrapped = $ifLet0[0]
};
this.initUnsafeMutablePointer({}, unwrapped);
return
----Swift.(file).OpaquePointer.debugDescription
return _rawPointerToString({}, this._rawValue)
----Swift.(file).Int.init(bitPattern:OpaquePointer?)
this.initBitPatternOptional({}, _create(UnsafeRawPointer, 'initOptional', {}, pointer));
return
----Swift.(file).UInt.init(bitPattern:OpaquePointer?)
this.initBitPatternOptional({}, _create(UnsafeRawPointer, 'initOptional', {}, pointer));
return
----Swift.(file).CVaListPointer.init(_fromUnsafeMutablePointer:UnsafeMutableRawPointer)
this._value = _cloneStruct(from);
return
----Swift.(file).CVaListPointer.debugDescription
return this._value.debugDescription
----Swift.(file).Character.init(unchecked:String)
this = str;
this._invariantCheck({}, );
return
----Swift.(file).Character.utf8
return this.utf8
----Swift.(file).Character.utf16
return this.utf16
----Swift.(file).Character.unicodeScalars
return this.unicodeScalars
----Swift.(file).Character.init(_:Unicode.Scalar)
this.initUncheckedString({}, _create(String, 'initUnicodeScalar', {}, content));
return
----Swift.(file).Character.init(extendedGraphemeClusterLiteral:Character)
this.initUncheckedString({}, value);
return
----Swift.(file).Character.init(_:String)
preconditionFileLine({}, () => Bool.prefix_33({}, s.isEmpty), () => "Can't form a Character from an empty String", '?3', '?3');
preconditionFileLine({}, () => String.Index.infix_61_61({}, s.indexAfter({}, s.startIndex), s.endIndex), () => "Can't form a Character from a String containing more than one extended grapheme cluster", '?3', '?3');
this.initUncheckedString({}, s);
return
----Swift.(file).Character.description
return this
----Swift.(file).Character.debugDescription
return this.debugDescription
----Swift.(file).Character.==infix(_:Character,_:Character)
return String.infix_61_61({}, lhs, rhs)
----Swift.(file).Character.<infix(_:Character,_:Character)
return String.infix_60({}, lhs, rhs)
----Swift.(file).Character.hash(into:Hasher)
let hasher = hasher$inout.get()
const $result = (() => {
this.hashInto({}, {get: () => hasher, set: $val => hasher = $val});})()
hasher$inout.set(hasher)
return $result
----Swift.(file).Character.isASCII
return Optional.wrappedNotEqualsOptionalNilComparisonType({}, this.asciiValue, _create(_OptionalNilComparisonType, 'initNilLiteraltuple_type', {}, {}))
----Swift.(file).Character.asciiValue
{
if((_slowPath({}, Character.infix_61_61({}, this, "\r\n")))) {
return _injectIntoOptional(0x000A);
}
};
{
if((_slowPath({}, Bool.infix_124_124({}, Bool.prefix_33({}, this._isSingleScalar), () => UInt32.infix_62_61({}, this._firstScalar.value, 0x80))))) {
return Optional.none;
}
};
return _injectIntoOptional(_create(UInt8, 'init', {}, this._firstScalar.value))
----Swift.(file).Character.isWhitespace
return this._firstScalar.properties.isWhitespace
----Swift.(file).Character.isNewline
const $match = this._firstScalar.value
if((((ClosedRange.infix_126_61({}, UInt32.infix_46_46_46({}, 0x000A, 0x000D), $match))))) {
return true;
}
else if((((infix_126_61({}, 0x0085, $match))))) {
return true;
}
else if((((infix_126_61({}, 0x2028, $match))))) {
return true;
}
else if((((infix_126_61({}, 0x2029, $match))))) {
return true;
}
else if(((true))) {
return false;
}
----Swift.(file).Character.isNumber
return Optional.wrappedNotEqualsOptionalNilComparisonType({}, this._firstScalar.properties.numericType, _create(_OptionalNilComparisonType, 'initNilLiteraltuple_type', {}, {}))
----Swift.(file).Character.isWholeNumber
return Optional.wrappedNotEqualsOptionalNilComparisonType({}, this.wholeNumberValue, _create(_OptionalNilComparisonType, 'initNilLiteraltuple_type', {}, {}))
----Swift.(file).Character.wholeNumberValue
{
if(!((this._isSingleScalar))) {
return Optional.none;
}
};
{const $ifLet0 = this._firstScalar.properties.numericValue
if(!($ifLet0.rawValue === 'some')) {
return Optional.none;
}let value = $ifLet0[0]
};
return _create(Int, 'initExactlyDouble', {}, value)
----Swift.(file).Character.isHexDigit
return Optional.wrappedNotEqualsOptionalNilComparisonType({}, this.hexDigitValue, _create(_OptionalNilComparisonType, 'initNilLiteraltuple_type', {}, {}))
----Swift.(file).Character.hexDigitValue
{
if(!((this._isSingleScalar))) {
return Optional.none;
}
};
const value = this._firstScalar.value;
const $match = value
if((((ClosedRange.infix_126_61({}, UInt32.infix_46_46_46({}, 0x0030, 0x0039), $match))))) {
return _injectIntoOptional(_create(Int, 'init', {}, UInt32.infix_38_45({}, value, 0x0030)));
}
else if((((ClosedRange.infix_126_61({}, UInt32.infix_46_46_46({}, 0x0041, 0x0046), $match))))) {
return _injectIntoOptional(_create(Int, 'init', {}, UInt32.infix_38_45({}, UInt32.infix_38_43({}, value, 10), 0x0041)));
}
else if((((ClosedRange.infix_126_61({}, UInt32.infix_46_46_46({}, 0x0061, 0x0066), $match))))) {
return _injectIntoOptional(_create(Int, 'init', {}, UInt32.infix_38_45({}, UInt32.infix_38_43({}, value, 10), 0x0061)));
}
else if((((ClosedRange.infix_126_61({}, UInt32.infix_46_46_46({}, 0xFF10, 0xFF19), $match))))) {
return _injectIntoOptional(_create(Int, 'init', {}, UInt32.infix_38_45({}, value, 0xFF10)));
}
else if((((ClosedRange.infix_126_61({}, UInt32.infix_46_46_46({}, 0xFF21, 0xFF26), $match))))) {
return _injectIntoOptional(_create(Int, 'init', {}, UInt32.infix_38_45({}, UInt32.infix_38_43({}, value, 10), 0xFF21)));
}
else if((((ClosedRange.infix_126_61({}, UInt32.infix_46_46_46({}, 0xFF41, 0xFF46), $match))))) {
return _injectIntoOptional(_create(Int, 'init', {}, UInt32.infix_38_45({}, UInt32.infix_38_43({}, value, 10), 0xFF41)));
}
else if(((true))) {
return Optional.none;
}
----Swift.(file).Character.isLetter
return this._firstScalar.properties.isAlphabetic
----Swift.(file).Character.uppercased()
return _create(String, 'initCharacter', {}, this).uppercased({}, )
----Swift.(file).Character.lowercased()
return _create(String, 'initCharacter', {}, this).lowercased({}, )
----Swift.(file).Character.isUppercase
{
if((_fastPath({}, Bool.infix_38_38({}, this._isSingleScalar, () => this._firstScalar.properties.isUppercase)))) {
return true;
}
};
return Bool.infix_38_38({}, this._isUppercased, () => this.isCased)
----Swift.(file).Character.isLowercase
{
if((_fastPath({}, Bool.infix_38_38({}, this._isSingleScalar, () => this._firstScalar.properties.isLowercase)))) {
return true;
}
};
return Bool.infix_38_38({}, this._isLowercased, () => this.isCased)
----Swift.(file).Character.isCased
{
if((_fastPath({}, Bool.infix_38_38({}, this._isSingleScalar, () => this._firstScalar.properties.isCased)))) {
return true;
}
};
return Bool.infix_124_124({}, Bool.prefix_33({}, this._isUppercased), () => Bool.prefix_33({}, this._isLowercased))
----Swift.(file).Character.isSymbol
return this._firstScalar.properties.generalCategory._isSymbol
----Swift.(file).Character.isMathSymbol
return this._firstScalar.properties.isMath
----Swift.(file).Character.isCurrencySymbol
return Unicode.GeneralCategory.infix_61_61({}, this._firstScalar.properties.generalCategory, Unicode.GeneralCategory.currencySymbol)
----Swift.(file).Character.isPunctuation
return this._firstScalar.properties.generalCategory._isPunctuation
----Swift.(file).ClosedRange.isEmpty
return false
----Swift.(file).ClosedRange.relative(to:C)
return _create(Range, 'initUncheckedBoundstuple_type', {}, {0: this.lowerBound, 1: collection.indexAfter({}, this.upperBound)})
----Swift.(file).ClosedRange.contains(_:Bound)
return Bool.infix_38_38({}, (_element).constructor.infix_62_61({}, _element, this.lowerBound), () => (_element).constructor.infix_60_61({}, _element, this.upperBound))
----Swift.(file).ClosedRange.Index.==infix(_:ClosedRange<Bound>.Index,_:ClosedRange<Bound>.Index)
const $match = {0: lhs, 1: rhs}
if((($match[0].rawValue == ClosedRange.Index.inRange().rawValue && $match[1].rawValue == ClosedRange.Index.inRange().rawValue))) {
const l = $match[0][0]
const r = $match[1][0]
return ((function(){throw '!unclarifiedGeneric:Bound'})()).infix_61_61({}, l, r);
}
else if((($match[0].rawValue == ClosedRange.Index.pastEnd.rawValue && $match[1].rawValue == ClosedRange.Index.pastEnd.rawValue))) {
return true;
}
else if(((true))) {
return false;
}
----Swift.(file).ClosedRange.Index.<infix(_:ClosedRange<Bound>.Index,_:ClosedRange<Bound>.Index)
const $match = {0: lhs, 1: rhs}
if((($match[0].rawValue == ClosedRange.Index.inRange().rawValue && $match[1].rawValue == ClosedRange.Index.inRange().rawValue))) {
const l = $match[0][0]
const r = $match[1][0]
return ((function(){throw '!unclarifiedGeneric:Bound'})()).infix_60({}, l, r);
}
else if((($match[0].rawValue == ClosedRange.Index.inRange().rawValue && $match[1].rawValue == ClosedRange.Index.pastEnd.rawValue))) {
return true;
}
else if(((true))) {
return false;
}
----Swift.(file).ClosedRange.Index.hash(into:Hasher)
let hasher = hasher$inout.get()
const $result = (() => {
const $match = this
if((($match.rawValue == ClosedRange.Index.inRange().rawValue))) {
const value = $match[0]
hasher.combine({$setThis: $val => hasher = $val}, 0);
hasher.combine({$setThis: $val => hasher = $val}, value);
}
else if((($match.rawValue == ClosedRange.Index.pastEnd.rawValue))) {
hasher.combine({$setThis: $val => hasher = $val}, 1);
};})()
hasher$inout.set(hasher)
return $result
----Swift.(file).ClosedRange.startIndex
return ClosedRange.Index.inRange({}, this.lowerBound)
----Swift.(file).ClosedRange.endIndex
return ClosedRange.Index.pastEnd
----Swift.(file).ClosedRange.index(after:ClosedRange<Bound>.Index)
const $match = i
if((($match.rawValue == ClosedRange.Index.inRange().rawValue))) {
const x = $match[0]
return ((this.upperBound).constructor.infix_61_61({}, x, this.upperBound) ? ClosedRange.Index.pastEnd : ClosedRange.Index.inRange({}, x.advancedBy({}, _create(Int, 'initIntegerLiteral', {}, 1))));
}
else if((($match.rawValue == ClosedRange.Index.pastEnd.rawValue))) {
preconditionFailureFileLine({}, () => "Incrementing past end index", '?3', '?3');
}
----Swift.(file).ClosedRange.index(before:ClosedRange<Bound>.Index)
const $match = i
if((($match.rawValue == ClosedRange.Index.inRange().rawValue))) {
const x = $match[0]
preconditionFileLine({}, () => (this.lowerBound).constructor.infix_62({}, x, this.lowerBound), () => "Incrementing past start index", '?3', '?3');
return ClosedRange.Index.inRange({}, x.advancedBy({}, _create(((function(){throw '!unclarifiedGeneric:Bound.Stride'})()), 'initIntegerLiteral', {}, -1)));
}
else if((($match.rawValue == ClosedRange.Index.pastEnd.rawValue))) {
preconditionFileLine({}, () => (this.upperBound).constructor.infix_62_61({}, this.upperBound, this.lowerBound), () => "Incrementing past start index", '?3', '?3');
return ClosedRange.Index.inRange({}, this.upperBound);
}
----Swift.(file).ClosedRange.index(_:ClosedRange<Bound>.Index,offsetBy:Int)
const $match = i
if((($match.rawValue == ClosedRange.Index.inRange().rawValue))) {
const x = $match[0]
const d = x.distanceTo({}, this.upperBound);
{
if((Int.infix_60_61({}, distance, d))) {
const newPosition = x.advancedBy({}, numericCast({}, distance));
preconditionFileLine({}, () => (this.lowerBound).constructor.infix_62_61({}, newPosition, this.lowerBound), () => "Advancing past start index", '?3', '?3');
return ClosedRange.Index.inRange({}, newPosition);
}
};
{
if((((d).constructor.infix_45({}, d, _create(((function(){throw '!unclarifiedGeneric:Bound.Stride'})()), 'initIntegerLiteral', {}, -1))).constructor.infix_61_61({}, (d).constructor.infix_45({}, d, _create(((function(){throw '!unclarifiedGeneric:Bound.Stride'})()), 'initIntegerLiteral', {}, -1)), distance))) {
return ClosedRange.Index.pastEnd;
}
};
preconditionFailureFileLine({}, () => "Advancing past end index", '?3', '?3');
}
else if((($match.rawValue == ClosedRange.Index.pastEnd.rawValue))) {
{
if((Int.infix_61_61({}, distance, 0))) {
return i;
}
};
{
if((Int.infix_60({}, distance, 0))) {
return this.indexOffsetBy({}, ClosedRange.Index.inRange({}, this.upperBound), numericCast({}, Int.infix_43({}, distance, 1)));
}
};
preconditionFailureFileLine({}, () => "Advancing past end index", '?3', '?3');
}
----Swift.(file).ClosedRange.distance(from:ClosedRange<Bound>.Index,to:ClosedRange<Bound>.Index)
const $match = {0: start, 1: end}
if((($match[0].rawValue == ClosedRange.Index.inRange().rawValue && $match[1].rawValue == ClosedRange.Index.inRange().rawValue))) {
const left = $match[0][0]
const right = $match[1][0]
return numericCast({}, left.distanceTo({}, right));
}
else if((($match[0].rawValue == ClosedRange.Index.inRange().rawValue && $match[1].rawValue == ClosedRange.Index.pastEnd.rawValue))) {
const left = $match[0][0]
return numericCast({}, (_create(((function(){throw '!unclarifiedGeneric:Bound.Stride'})()), 'initIntegerLiteral', {}, 1)).constructor.infix_43({}, _create(((function(){throw '!unclarifiedGeneric:Bound.Stride'})()), 'initIntegerLiteral', {}, 1), left.distanceTo({}, this.upperBound)));
}
else if((($match[0].rawValue == ClosedRange.Index.pastEnd.rawValue && $match[1].rawValue == ClosedRange.Index.inRange().rawValue))) {
const right = $match[1][0]
return numericCast({}, (this.upperBound.distanceTo({}, right)).constructor.infix_45({}, this.upperBound.distanceTo({}, right), _create(((function(){throw '!unclarifiedGeneric:Bound.Stride'})()), 'initIntegerLiteral', {}, 1)));
}
else if((($match[0].rawValue == ClosedRange.Index.pastEnd.rawValue && $match[1].rawValue == ClosedRange.Index.pastEnd.rawValue))) {
return 0;
}
----Swift.(file).ClosedRange.subscript(_:ClosedRange<Bound>.Index)
const $match = position
if((($match.rawValue == ClosedRange.Index.inRange().rawValue))) {
const x = $match[0]
return x;
}
else if((($match.rawValue == ClosedRange.Index.pastEnd.rawValue))) {
preconditionFailureFileLine({}, () => "Index out of range", '?3', '?3');
}
----Swift.(file).ClosedRange.subscript(_:Range<ClosedRange<Bound>.Index>)
return _create(Slice, 'initBaseBoundsRange', {}, this, bounds)
----Swift.(file).Comparable....infix(_:Self,_:Self)
preconditionFileLine({}, () => (minimum).constructor.infix_60_61({}, minimum, maximum), () => "Can't form Range with upperBound < lowerBound", '?3', '?3');
return _create(ClosedRange, 'initUncheckedBoundstuple_type', {}, {0: minimum, 1: maximum})
----Swift.(file).ClosedRange.==infix(_:ClosedRange<Bound>,_:ClosedRange<Bound>)
return Bool.infix_38_38({}, (lhs.lowerBound).constructor.infix_61_61({}, lhs.lowerBound, rhs.lowerBound), () => (lhs.upperBound).constructor.infix_61_61({}, lhs.upperBound, rhs.upperBound))
----Swift.(file).ClosedRange.hash(into:Hasher)
let hasher = hasher$inout.get()
const $result = (() => {
hasher.combine({$setThis: $val => hasher = $val}, this.lowerBound);
hasher.combine({$setThis: $val => hasher = $val}, this.upperBound);})()
hasher$inout.set(hasher)
return $result
----Swift.(file).ClosedRange.description
return (("") + (this.lowerBound) + ("...") + (this.upperBound) + (""))
----Swift.(file).ClosedRange.debugDescription
return String.infix_43({}, (("ClosedRange(") + (_create(String, 'initReflecting', {}, this.lowerBound)) + ("")), (("...") + (_create(String, 'initReflecting', {}, this.upperBound)) + (")")))
----Swift.(file).ClosedRange.customMirror
return _create(Mirror, 'initChildrenKeyValuePairsDisplayStyleOptionalAncestorRepresentationMirrorAncestorRepresentation', {}, this, new Map([["lowerBound", this.lowerBound], ["upperBound", this.upperBound]]), nil/*!default_value*/, .generated/*!default_value*/)
----Swift.(file).ClosedRange.clamped(to:ClosedRange<Bound>)
const lower = ((limits.lowerBound).constructor.infix_62({}, limits.lowerBound, this.lowerBound) ? limits.lowerBound : ((limits.upperBound).constructor.infix_60({}, limits.upperBound, this.lowerBound) ? limits.upperBound : this.lowerBound));
const upper = ((limits.upperBound).constructor.infix_60({}, limits.upperBound, this.upperBound) ? limits.upperBound : ((limits.lowerBound).constructor.infix_62({}, limits.lowerBound, this.upperBound) ? limits.lowerBound : this.upperBound));
return _create(ClosedRange, 'initUncheckedBoundstuple_type', {}, {0: lower, 1: upper})
----Swift.(file).ClosedRange.init(_:Range<Bound>)
preconditionFileLine({}, () => Bool.prefix_33({}, other.isEmpty), () => "Can't form an empty closed range", '?3', '?3');
const upperBound = other.upperBound.advancedBy({}, _create(((function(){throw '!unclarifiedGeneric:Bound.Stride'})()), 'initIntegerLiteral', {}, -1));
this.initUncheckedBoundstuple_type({}, {0: other.lowerBound, 1: upperBound});
return
----Swift.(file).ClosedRange.overlaps(_:ClosedRange<Bound>)
return Bool.infix_124_124({}, this.contains({}, other.lowerBound), () => other.contains({}, this.lowerBound))
----Swift.(file).ClosedRange.overlaps(_:Range<Bound>)
return other.overlaps({}, this)
----Swift.(file).IndexingIterator.next()
{
if(((this._position).constructor.infix_61_61({}, this._position, this._elements.endIndex))) {
return Optional.none;
}
};
const _element = this._elements.subscript$get({}, this._position);
this._elements.formIndexAfter({}, {get: () => this._position, set: $val => this._position = $val});
return _injectIntoOptional(_element)
----Swift.(file).Collection.formIndex(after:Self.Index)
let i = i$inout.get()
const $result = (() => {
i = this.indexAfter({}, i);})()
i$inout.set(i)
return $result
----Swift.(file).Collection.index(_:Self.Index,offsetBy:Int)
return this._advanceForwardBy({}, i, distance)
----Swift.(file).Collection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)
return this._advanceForwardByLimitedBy({}, i, distance, limit)
----Swift.(file).Collection.formIndex(_:Self.Index,offsetBy:Int)
let i = i$inout.get()
const $result = (() => {
i = this.indexOffsetBy({}, i, distance);})()
i$inout.set(i)
return $result
----Swift.(file).Collection.formIndex(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)
let i = i$inout.get()
const $result = (() => {
{const $ifLet0 = this.indexOffsetByLimitedBy({}, i, distance, limit)
if($ifLet0.rawValue === 'some') {
let advancedIndex = $ifLet0[0]
i = advancedIndex;
return true;
}
};
i = limit;
return false;})()
i$inout.set(i)
return $result
----Swift.(file).Collection.distance(from:Self.Index,to:Self.Index)
preconditionFileLine({}, () => (start).constructor.infix_60_61({}, start, end), () => "Only BidirectionalCollections can have end come before start", '?3', '?3');
let start_dupl = start;
let count = 0;
while(true){
if(!(((start_dupl).constructor.infix_33_61({}, start_dupl, end)))) break
count = Int.infix_43({}, count, 1);
this.formIndexAfter({}, {get: () => start_dupl, set: $val => start_dupl = $val});
};
return count
----Swift.(file).Collection.randomElement(using:T)
let generator = generator$inout.get()
const $result = (() => {
{
if(!((Bool.prefix_33({}, this.isEmpty)))) {
return Optional.none;
}
};
const random = Int.randomInUsing({}, Int.infix_46_46_60({}, 0, this.count), {get: () => generator, set: $val => generator = $val});
const idx = this.indexOffsetBy({}, this.startIndex, random);
return _injectIntoOptional(this.subscript$get({}, idx));})()
generator$inout.set(generator)
return $result
----Swift.(file).Collection.randomElement()
let g = _create(SystemRandomNumberGenerator, 'init', {}, );
return this.randomElementUsing({}, {get: () => g, set: $val => g = $val})
----Swift.(file).Collection.makeIterator()
return _create(IndexingIterator, 'init_elements', {}, this)
----Swift.(file).Collection.subscript(_:Range<Self.Index>)
return _create(Slice, 'initBaseBoundsRange', {}, this, bounds)
----Swift.(file).Collection.popFirst()
{
if(!((Bool.prefix_33({}, this.isEmpty)))) {
return Optional.none;
}
};
const _element = this.first[0];
$info.$setThis(_cloneStruct(this.subscriptRange$get({}, (this.indexAfter({}, this.startIndex)).constructor.infix_46_46_60({}, this.indexAfter({}, this.startIndex), this.endIndex))));
return _injectIntoOptional(_element)
----Swift.(file).Collection.isEmpty
return (this.startIndex).constructor.infix_61_61({}, this.startIndex, this.endIndex)
----Swift.(file).Collection.first
const start = this.startIndex;
{
if(((start).constructor.infix_33_61({}, start, this.endIndex))) {
return _injectIntoOptional(this.subscript$get({}, start));
}
else {
return Optional.none;
}
}
----Swift.(file).Collection.underestimatedCount
return this.count
----Swift.(file).Collection.count
return this.distanceFromTo({}, this.startIndex, this.endIndex)
----Swift.(file).Collection.map(_:(Self.Element) throws -> T)
const n = this.count;
{
if((Int.infix_61_61({}, n, 0))) {
return _create(Array, 'initBuffer', {}, []);
}
};
let result = _create(ContiguousArray, 'init', {}, );
result.reserveCapacity({$setThis: $val => result = $val}, n);
let i = this.startIndex;
{
let $generator = _cloneStruct(Int.infix_46_46_60({}, 0, n).makeIterator({}, ));
while(true) {
const $ifLet0 = $generator.next({$setThis: $val => $generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
result.append({$setThis: $val => result = $val}, transform({}, this.subscript$get({}, i)));
this.formIndexAfter({}, {get: () => i, set: $val => i = $val});
}
};
return _create(Array, 'initBuffer', {}, result)
----Swift.(file).Collection.dropFirst(_:Int)
preconditionFileLine({}, () => Int.infix_62_61({}, k, 0), () => "Can't drop a negative number of elements from a collection", '?3', '?3');
const start = infix_63_63({}, this.indexOffsetByLimitedBy({}, this.startIndex, k, this.endIndex), () => this.endIndex);
return this.subscriptRange$get({}, (start).constructor.infix_46_46_60({}, start, this.endIndex))
----Swift.(file).Collection.dropLast(_:Int)
preconditionFileLine({}, () => Int.infix_62_61({}, k, 0), () => "Can't drop a negative number of elements from a collection", '?3', '?3');
const amount = /*dot_syntax_base_ignored*/max({}, 0, Int.infix_45({}, this.count, k));
const end = infix_63_63({}, this.indexOffsetByLimitedBy({}, this.startIndex, amount, this.endIndex), () => this.endIndex);
return this.subscriptRange$get({}, (this.startIndex).constructor.infix_46_46_60({}, this.startIndex, end))
----Swift.(file).Collection.drop(while:(Self.Element) throws -> Bool)
let start = this.startIndex;
while(true){
if(!((Bool.infix_38_38({}, (start).constructor.infix_33_61({}, start, this.endIndex), () => predicate({}, this.subscript$get({}, start)))))) break
this.formIndexAfter({}, {get: () => start, set: $val => start = $val});
};
return this.subscriptRange$get({}, (start).constructor.infix_46_46_60({}, start, this.endIndex))
----Swift.(file).Collection.prefix(_:Int)
preconditionFileLine({}, () => Int.infix_62_61({}, maxLength, 0), () => "Can't take a prefix of negative length from a collection", '?3', '?3');
const end = infix_63_63({}, this.indexOffsetByLimitedBy({}, this.startIndex, maxLength, this.endIndex), () => this.endIndex);
return this.subscriptRange$get({}, (this.startIndex).constructor.infix_46_46_60({}, this.startIndex, end))
----Swift.(file).Collection.prefix(while:(Self.Element) throws -> Bool)
let end = this.startIndex;
while(true){
if(!((Bool.infix_38_38({}, (end).constructor.infix_33_61({}, end, this.endIndex), () => predicate({}, this.subscript$get({}, end)))))) break
this.formIndexAfter({}, {get: () => end, set: $val => end = $val});
};
return this.subscriptRange$get({}, (this.startIndex).constructor.infix_46_46_60({}, this.startIndex, end))
----Swift.(file).Collection.suffix(_:Int)
preconditionFileLine({}, () => Int.infix_62_61({}, maxLength, 0), () => "Can't take a suffix of negative length from a collection", '?3', '?3');
const amount = /*dot_syntax_base_ignored*/max({}, 0, Int.infix_45({}, this.count, maxLength));
const start = infix_63_63({}, this.indexOffsetByLimitedBy({}, this.startIndex, amount, this.endIndex), () => this.endIndex);
return this.subscriptRange$get({}, (start).constructor.infix_46_46_60({}, start, this.endIndex))
----Swift.(file).Collection.prefix(upTo:Self.Index)
return this.subscriptRange$get({}, (this.startIndex).constructor.infix_46_46_60({}, this.startIndex, end))
----Swift.(file).Collection.suffix(from:Self.Index)
return this.subscriptRange$get({}, (start).constructor.infix_46_46_60({}, start, this.endIndex))
----Swift.(file).Collection.prefix(through:Self.Index)
return this.prefixUpTo({}, this.indexAfter({}, position))
----Swift.(file).Collection.split(maxSplits:Int,omittingEmptySubsequences:Bool,whereSeparator:(Self.Element) throws -> Bool)
preconditionFileLine({}, () => Int.infix_62_61({}, maxSplits, 0), () => "Must take zero or more splits", '?3', '?3');
let result = _create(Array, 'initBuffer', {}, []);
let subSequenceStart = this.startIndex;
function appendSubsequenceEnd($info, end){
{
if((Bool.infix_38_38({}, (subSequenceStart).constructor.infix_61_61({}, subSequenceStart, end), () => omittingEmptySubsequences))) {
return false;
}
};
result.append({$setThis: $val => result = $val}, this.subscriptRange$get({}, (subSequenceStart).constructor.infix_46_46_60({}, subSequenceStart, end)));
return true;
}
{
if((Bool.infix_124_124({}, Int.infix_61_61({}, maxSplits, 0), () => this.isEmpty))) {
_.discardAssignment = appendSubsequenceEnd({}, this.endIndex);
return result;
}
};
let subSequenceEnd = subSequenceStart;
const cachedEndIndex = this.endIndex;
while(true){
if(!(((subSequenceEnd).constructor.infix_33_61({}, subSequenceEnd, cachedEndIndex)))) break
{
if((isSeparator({}, this.subscript$get({}, subSequenceEnd)))) {
const didAppend = appendSubsequenceEnd({}, subSequenceEnd);
this.formIndexAfter({}, {get: () => subSequenceEnd, set: $val => subSequenceEnd = $val});
subSequenceStart = subSequenceEnd;
{
if((Bool.infix_38_38({}, didAppend, () => Int.infix_61_61({}, result.count, maxSplits)))) {
break;
}
};
continue;
}
};
this.formIndexAfter({}, {get: () => subSequenceEnd, set: $val => subSequenceEnd = $val});
};
{
if((Bool.infix_124_124({}, (subSequenceStart).constructor.infix_33_61({}, subSequenceStart, cachedEndIndex), () => Bool.prefix_33({}, omittingEmptySubsequences)))) {
result.append({$setThis: $val => result = $val}, this.subscriptRange$get({}, (subSequenceStart).constructor.infix_46_46_60({}, subSequenceStart, cachedEndIndex)));
}
};
return result
----Swift.(file).Collection.split(separator:Self.Element,maxSplits:Int,omittingEmptySubsequences:Bool)
return this.splitMaxSplitsOmittingEmptySubsequencesWhereSeparator({}, maxSplits, omittingEmptySubsequences, (($info, $0) => ($0).constructor.infix_61_61({}, $0, separator)))
----Swift.(file).Collection.removeFirst()
preconditionFileLine({}, () => Bool.prefix_33({}, this.isEmpty), () => "Can't remove items from an empty collection", '?3', '?3');
const _element = this.first[0];
$info.$setThis(_cloneStruct(this.subscriptRange$get({}, (this.indexAfter({}, this.startIndex)).constructor.infix_46_46_60({}, this.indexAfter({}, this.startIndex), this.endIndex))));
return _element
----Swift.(file).Collection.removeFirst(_:Int)
{
if((Int.infix_61_61({}, k, 0))) {
return ;
}
};
preconditionFileLine({}, () => Int.infix_62_61({}, k, 0), () => "Number of elements to remove should be non-negative", '?3', '?3');
preconditionFileLine({}, () => Int.infix_62_61({}, this.count, k), () => "Can't remove more items from a collection than it contains", '?3', '?3');
$info.$setThis(_cloneStruct(this.subscriptRange$get({}, (this.indexOffsetBy({}, this.startIndex, k)).constructor.infix_46_46_60({}, this.indexOffsetBy({}, this.startIndex, k), this.endIndex))))
----Swift.(file).BidirectionalCollection.last
return (this.isEmpty ? Optional.none : _injectIntoOptional(this.subscript$get({}, this.indexBefore({}, this.endIndex))))
----Swift.(file).Collection.firstIndex(of:Self.Element)
{const $ifLet0 = this._customIndexOfEquatableElement({}, _element)
if($ifLet0.rawValue === 'some') {
let result = $ifLet0[0]
return result;
}
};
let i = this.startIndex;
while(true){
if(!(((i).constructor.infix_33_61({}, i, this.endIndex)))) break
{
if(((this.subscript$get({}, i)).constructor.infix_61_61({}, this.subscript$get({}, i), _element))) {
return _injectIntoOptional(i);
}
};
this.formIndexAfter({}, {get: () => i, set: $val => i = $val});
};
return Optional.none
----Swift.(file).Collection.firstIndex(where:(Self.Element) throws -> Bool)
let i = this.startIndex;
while(true){
if(!(((i).constructor.infix_33_61({}, i, this.endIndex)))) break
{
if((predicate({}, this.subscript$get({}, i)))) {
return _injectIntoOptional(i);
}
};
this.formIndexAfter({}, {get: () => i, set: $val => i = $val});
};
return Optional.none
----Swift.(file).BidirectionalCollection.last(where:(Self.Element) throws -> Bool)
return this.lastIndexWhere({}, predicate).mapSwift({}, (($info, $0) => this.subscript$get({}, $0)))
----Swift.(file).BidirectionalCollection.lastIndex(where:(Self.Element) throws -> Bool)
let i = this.endIndex;
while(true){
if(!(((i).constructor.infix_33_61({}, i, this.startIndex)))) break
this.formIndexBefore({}, {get: () => i, set: $val => i = $val});
{
if((predicate({}, this.subscript$get({}, i)))) {
return _injectIntoOptional(i);
}
};
};
return Optional.none
----Swift.(file).BidirectionalCollection.lastIndex(of:Self.Element)
{const $ifLet0 = this._customLastIndexOfEquatableElement({}, _element)
if($ifLet0.rawValue === 'some') {
let result = $ifLet0[0]
return result;
}
};
return this.lastIndexWhere({}, (($info, $0) => ($0).constructor.infix_61_61({}, $0, _element)))
----Swift.(file).MutableCollection.partition(by:(Self.Element) throws -> Bool)
return this._halfStablePartitionIsSuffixElement({$setThis: $val => $info.$setThis(_cloneStruct($val))}, belongsInSecondPartition)
----Swift.(file).MutableCollection.partition(by:(Self.Element) throws -> Bool)
const maybeOffset = this._withUnsafeMutableBufferPointerIfSupported({$setThis: $val => $info.$setThis(_cloneStruct($val))}, (($info, bufferPointer$inout) => { 
const unsafeBufferPivot = bufferPointer._partitionImplBy({$setThis: $val => bufferPointer = $val}, belongsInSecondPartition);
return Int.infix_45({}, unsafeBufferPivot, bufferPointer.startIndex); }));
{const $ifLet0 = maybeOffset
if($ifLet0.rawValue === 'some') {
let offset = $ifLet0[0]
return this.indexOffsetBy({}, this.startIndex, offset);
}
else {
return this._partitionImplBy({$setThis: $val => $info.$setThis(_cloneStruct($val))}, belongsInSecondPartition);
}
}
----Swift.(file).Sequence.shuffled(using:T)
let generator = generator$inout.get()
const $result = (() => {
let result = _create(ContiguousArray, 'initBuffer', {}, this);
result.shuffleUsing({$setThis: $val => result = $val}, {get: () => generator, set: $val => generator = $val});
return _create(Array, 'initBuffer', {}, result);})()
generator$inout.set(generator)
return $result
----Swift.(file).Sequence.shuffled()
let g = _create(SystemRandomNumberGenerator, 'init', {}, );
return this.shuffledUsing({}, {get: () => g, set: $val => g = $val})
----Swift.(file).MutableCollection.shuffle(using:T)
let generator = generator$inout.get()
const $result = (() => {
{
if(!((Int.infix_62({}, this.count, 1)))) {
return ;
}
};
let amount = this.count;
let currentIndex = this.startIndex;
while(true){
if(!((Int.infix_62({}, amount, 1)))) break
const random = Int.randomInUsing({}, Int.infix_46_46_60({}, 0, amount), {get: () => generator, set: $val => generator = $val});
Int.infix_45_61({}, {get: () => amount, set: $val => amount = $val}, 1);
this.swapAt({$setThis: $val => $info.$setThis(_cloneStruct($val))}, currentIndex, this.indexOffsetBy({}, currentIndex, random));
this.formIndexAfter({}, {get: () => currentIndex, set: $val => currentIndex = $val});
};})()
generator$inout.set(generator)
return $result
----Swift.(file).MutableCollection.shuffle()
let g = _create(SystemRandomNumberGenerator, 'init', {}, );
this.shuffleUsing({$setThis: $val => $info.$setThis(_cloneStruct($val))}, {get: () => g, set: $val => g = $val})
----Swift.(file).CollectionOfOne.init(_:Element)
this._element = _element;
return
----Swift.(file).CollectionOfOne.Iterator.init(_elements:Element?)
this._elements = _elements;
return
----Swift.(file).CollectionOfOne.Iterator.next()
const result = this._elements;
this._elements = Optional.none;
return result
----Swift.(file).CollectionOfOne.startIndex
return 0
----Swift.(file).CollectionOfOne.endIndex
return 1
----Swift.(file).CollectionOfOne.index(after:CollectionOfOne<Element>.Index)
preconditionFileLine({}, () => Int.infix_61_61({}, i, this.startIndex), () => String()/*!default_value*/, '?3', '?3');
return 1
----Swift.(file).CollectionOfOne.index(before:CollectionOfOne<Element>.Index)
preconditionFileLine({}, () => Int.infix_61_61({}, i, this.endIndex), () => String()/*!default_value*/, '?3', '?3');
return 0
----Swift.(file).CollectionOfOne.makeIterator()
return _create(CollectionOfOne.Iterator, 'init_elementsOptional', {}, _injectIntoOptional(this._element))
----Swift.(file).CollectionOfOne.subscript(_:Int)
preconditionFileLine({}, () => Int.infix_61_61({}, position, 0), () => "Index out of range", '?3', '?3');
return this._element;
}subscript$_modify($info, position){
preconditionFileLine({}, () => Int.infix_61_61({}, position, 0), () => "Index out of range", '?3', '?3');
/*yield*/
----Swift.(file).CollectionOfOne.subscript(_:Range<Int>)#ASS

const n = newValue.count;
preconditionFileLine({}, () => Int.infix_61_61({}, bounds.count, n), () => "CollectionOfOne can't be resized", '?3', '?3');
{
if((Int.infix_61_61({}, n, 1))) {
$info.$setThis(_cloneStruct(_cloneStruct(newValue.base)));
}
}
----Swift.(file).CollectionOfOne.subscript(_:Range<Int>)
return _create(Slice, 'initBaseBoundsRange', {}, this, bounds);

----Swift.(file).CollectionOfOne.count
return 1
----Swift.(file).CollectionOfOne.debugDescription
return (("CollectionOfOne(") + (_create(String, 'initReflecting', {}, this._element)) + (")"))
----Swift.(file).CollectionOfOne.customMirror
return _create(Mirror, 'initChildrenKeyValuePairsDisplayStyleOptionalAncestorRepresentationMirrorAncestorRepresentation', {}, this, new Map([["element", this._element]]), nil/*!default_value*/, .generated/*!default_value*/)
----Swift.(file).Comparable.>infix(_:Self,_:Self)
return (rhs).constructor.infix_60({}, rhs, lhs)
----Swift.(file).Comparable.<=infix(_:Self,_:Self)
return Bool.prefix_33({}, (rhs).constructor.infix_60({}, rhs, lhs))
----Swift.(file).Comparable.>=infix(_:Self,_:Self)
return Bool.prefix_33({}, (lhs).constructor.infix_60({}, lhs, rhs))
----Swift.(file).==infix(_:T,_:T)
return (lhs.rawValue).constructor.infix_61_61({}, lhs.rawValue, rhs.rawValue)
----Swift.(file).!=infix(_:T,_:T)
return (lhs.rawValue).constructor.infix_33_61({}, lhs.rawValue, rhs.rawValue)
----Swift.(file).!=infix(_:T,_:T)
return (lhs.rawValue).constructor.infix_33_61({}, lhs.rawValue, rhs.rawValue)
----Swift.(file).RawRepresentable.hashValue
return this.rawValue.hashValue
----Swift.(file).RawRepresentable.hash(into:Hasher)
let hasher = hasher$inout.get()
const $result = (() => {
hasher.combine({$setThis: $val => hasher = $val}, this.rawValue);})()
hasher$inout.set(hasher)
return $result
----Swift.(file).ExpressibleByExtendedGraphemeClusterLiteral.init(unicodeScalarLiteral:Self.ExtendedGraphemeClusterLiteralType)
this.initExtendedGraphemeClusterLiteral({}, value);
return
----Swift.(file).ExpressibleByStringLiteral.init(extendedGraphemeClusterLiteral:Self.StringLiteralType)
this.initStringLiteral({}, value);
return
----Swift.(file).ExpressibleByStringInterpolation.init(stringInterpolation:DefaultStringInterpolation)
this.initStringLiteral({}, stringInterpolation.make({}, ));
return
----Swift.(file).ContiguousArray.init(_buffer:<<error type>>)
this._buffer = _cloneStruct(_buffer);
return
----Swift.(file).ContiguousArray.capacity
return this._getCapacity({}, )
----Swift.(file).ContiguousArray.startIndex
return 0
----Swift.(file).ContiguousArray.endIndex
return this._getCount({}, )
----Swift.(file).ContiguousArray.index(after:Int)
return Int.infix_43({}, i, 1)
----Swift.(file).ContiguousArray.formIndex(after:Int)
let i = i$inout.get()
const $result = (() => {
Int.infix_43_61({}, {get: () => i, set: $val => i = $val}, 1);})()
i$inout.set(i)
return $result
----Swift.(file).ContiguousArray.index(before:Int)
return Int.infix_45({}, i, 1)
----Swift.(file).ContiguousArray.formIndex(before:Int)
let i = i$inout.get()
const $result = (() => {
Int.infix_45_61({}, {get: () => i, set: $val => i = $val}, 1);})()
i$inout.set(i)
return $result
----Swift.(file).ContiguousArray.index(_:Int,offsetBy:Int)
return Int.infix_43({}, i, distance)
----Swift.(file).ContiguousArray.index(_:Int,offsetBy:Int,limitedBy:Int)
const l = Int.infix_45({}, limit, i);
{
if(((Int.infix_62({}, distance, 0) ? Bool.infix_38_38({}, Int.infix_62_61({}, l, 0), () => Int.infix_60({}, l, distance)) : Bool.infix_38_38({}, Int.infix_60_61({}, l, 0), () => Int.infix_60({}, distance, l))))) {
return Optional.none;
}
};
return _injectIntoOptional(Int.infix_43({}, i, distance))
----Swift.(file).ContiguousArray.distance(from:Int,to:Int)
return Int.infix_45({}, end, start)
----Swift.(file).ContiguousArray.subscript(_:Int)
this._checkSubscript_native({}, index);
return this._buffer.getElement({}, index);
}subscript$_modify($info, index){
this._makeMutableAndUnique({$setThis: $val => $info.$setThis(_cloneStruct($val))}, );
this._checkSubscript_native({}, index);
const address = _cloneStruct(UnsafeMutablePointer.infix_43({}, this._buffer.subscriptBaseAddress, index));
/*yield*/
----Swift.(file).ContiguousArray.subscript(_:Range<Int>)#ASS

{
if((Bool.infix_124_124({}, UnsafeRawPointer.infix_33_61({}, this.subscript$get({}, bounds)._buffer.identity, rhs._buffer.identity), () => Range.infix_33_61({}, bounds, Int.infix_46_46_60({}, rhs.startIndex, rhs.endIndex))))) {
this.replaceSubrangeWith({$setThis: $val => $info.$setThis(_cloneStruct($val))}, bounds, rhs);
}
}
----Swift.(file).ContiguousArray.subscript(_:Range<Int>)
return _create(ArraySlice, 'init_bufferArraySlice_Buffer', {}, this._buffer.subscript$get({}, bounds));

----Swift.(file).ContiguousArray.count
return this._getCount({}, )
----Swift.(file).ContiguousArray.init(arrayLiteral:[Element])
this.init_bufferContiguousArray_Buffer({}, _create(ContiguousArray, 'initBuffer', {}, _elements)._buffer);
return
----Swift.(file).ContiguousArray.init()
this._buffer = _create(ContiguousArray._Buffer, 'init', {}, );
return
----Swift.(file).ContiguousArray.init(_:S)
$info.$setThis(_cloneStruct(_create(ContiguousArray, 'init_bufferContiguousArray_Buffer', {}, _create(ContiguousArray._Buffer, 'init_buffer_ContiguousArrayBufferShiftedToStartIndexInt', {}, s._copyToContiguousArray({}, )._buffer, 0))));
return
----Swift.(file).ContiguousArray.init(repeating:Element,count:Int)
let p;
let $tuple = ContiguousArray._allocateUninitialized({}, count)
$info.$setThis(_cloneStruct($tuple[0]))
p = $tuple[1];
{
let $generator = _cloneStruct(Int.infix_46_46_60({}, 0, count).makeIterator({}, ));
while(true) {
const $ifLet0 = $generator.next({$setThis: $val => $generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
p.initializeTo({}, repeatedValue);
UnsafeMutablePointer.infix_43_61({}, {get: () => p, set: $val => p = $val}, 1);
}
};
return
----Swift.(file).ContiguousArray.init(_uninitializedCount:Int)
preconditionFileLine({}, () => Int.infix_62_61({}, count, 0), () => "Can't construct ContiguousArray with count < 0", '?3', '?3');
this._buffer = _create(ContiguousArray._Buffer, 'init', {}, );
{
if((Int.infix_62({}, count, 0))) {
this._buffer = _cloneStruct(ContiguousArray._allocateBufferUninitializedMinimumCapacity({}, count));
this._buffer.count = count;
}
};
return
----Swift.(file).ContiguousArray.reserveCapacity(_:Int)
{
if((Optional.wrappedEqualsOptionalNilComparisonType({}, this._buffer.requestUniqueMutableBackingBufferMinimumCapacity({$setThis: $val => this._buffer = $val}, minimumCapacity), _create(_OptionalNilComparisonType, 'initNilLiteraltuple_type', {}, {})))) {
const newBuffer = _create(_ContiguousArrayBuffer, 'init_uninitializedCountIntMinimumCapacityInt', {}, this.count, minimumCapacity);
this._buffer._copyContentsSubRangeInitializing({}, this._buffer.indices, newBuffer.firstElementAddress);
this._buffer = _create(ContiguousArray._Buffer, 'init_buffer_ContiguousArrayBufferShiftedToStartIndexInt', {}, newBuffer, this._buffer.startIndex);
}
}
----Swift.(file).ContiguousArray.append(_:Element)
this._makeUniqueAndReserveCapacityIfNotUnique({$setThis: $val => $info.$setThis(_cloneStruct($val))}, );
const oldCount = this._getCount({}, );
this._reserveCapacityAssumingUniqueBufferOldCount({$setThis: $val => $info.$setThis(_cloneStruct($val))}, oldCount);
this._appendElementAssumeUniqueAndCapacityNewElement({$setThis: $val => $info.$setThis(_cloneStruct($val))}, oldCount, newElement)
----Swift.(file).ContiguousArray.append(contentsOf:S)
const newElementsCount = newElements.underestimatedCount;
this.reserveCapacityForAppendNewElementsCount({$setThis: $val => $info.$setThis(_cloneStruct($val))}, newElementsCount);
const oldCount = this.count;
const startNewElements = _cloneStruct(UnsafeMutablePointer.infix_43({}, this._buffer.firstElementAddress, oldCount));
const buf = _create(UnsafeMutableBufferPointer, 'initStartOptionalCountInt', {}, _injectIntoOptional(/*pointer_to_pointer*/startNewElements), Int.infix_45({}, this.capacity, oldCount));
const $tuple = buf.initializeFrom({}, newElements), remainder = $tuple && $tuple[0], writtenUpTo = $tuple && $tuple[1];
const writtenCount = buf.distanceFromTo({}, buf.startIndex, writtenUpTo);
preconditionFileLine({}, () => Int.infix_60_61({}, newElementsCount, writtenCount), () => "newElements.underestimatedCount was an overestimate", '?3', '?3');
Int.infix_43_61({}, {get: () => this._buffer.count, set: $val => this._buffer.count = $val}, writtenCount);
{
if((Int.infix_61_61({}, writtenUpTo, buf.endIndex))) {
this._buffer._arrayAppendSequence({$setThis: $val => this._buffer = $val}, _create(IteratorSequence, 'init', {}, remainder));
}
}
----Swift.(file).ContiguousArray.reserveCapacityForAppend(newElementsCount:Int)
const oldCount = this.count;
const oldCapacity = this.capacity;
const newCount = Int.infix_43({}, oldCount, newElementsCount);
this.reserveCapacity({$setThis: $val => $info.$setThis(_cloneStruct($val))}, (Int.infix_62({}, newCount, oldCapacity) ? /*dot_syntax_base_ignored*/max({}, newCount, _growArrayCapacity({}, oldCapacity)) : newCount))
----Swift.(file).ContiguousArray.remove(at:Int)
preconditionFileLine({}, () => Int.infix_60({}, index, this.endIndex), () => "Index out of range", '?3', '?3');
preconditionFileLine({}, () => Int.infix_62_61({}, index, this.startIndex), () => "Index out of range", '?3', '?3');
this._makeUniqueAndReserveCapacityIfNotUnique({$setThis: $val => $info.$setThis(_cloneStruct($val))}, );
const newCount = Int.infix_45({}, this._getCount({}, ), 1);
const pointer = _cloneStruct(UnsafeMutablePointer.infix_43({}, this._buffer.firstElementAddress, index));
const result = pointer.move({}, );
pointer.moveInitializeFromCount({}, UnsafeMutablePointer.infix_43({}, pointer, 1), Int.infix_45({}, newCount, index));
this._buffer.count = newCount;
return result
----Swift.(file).ContiguousArray.insert(_:Element,at:Int)
this.replaceSubrangeWith({$setThis: $val => $info.$setThis(_cloneStruct($val))}, Int.infix_46_46_60({}, i, i), _create(CollectionOfOne, 'init', {}, newElement))
----Swift.(file).ContiguousArray.removeAll(keepingCapacity:Bool)
{
if((Bool.prefix_33({}, keepCapacity))) {
this._buffer = _create(ContiguousArray._Buffer, 'init', {}, );
}
else {
this.replaceSubrangeWith({$setThis: $val => $info.$setThis(_cloneStruct($val))}, this.indices, _create(EmptyCollection, 'init', {}, ));
}
}
----Swift.(file).ContiguousArray.withContiguousMutableStorageIfAvailable(_:(inout UnsafeMutableBufferPointer<Element>) throws -> R)
return _injectIntoOptional(this.withUnsafeMutableBufferPointer({$setThis: $val => $info.$setThis(_cloneStruct($val))}, (($info, bufferPointer$inout) => body({}, {get: () => bufferPointer, set: $val => bufferPointer = $val}))))
----Swift.(file).ContiguousArray.withContiguousStorageIfAvailable(_:(UnsafeBufferPointer<Element>) throws -> R)
return _injectIntoOptional(this.withUnsafeBufferPointer({}, (($info, bufferPointer) => body({}, bufferPointer))))
----Swift.(file).ContiguousArray.customMirror
return _create(Mirror, 'initUnlabeledChildrenDisplayStyleOptionalAncestorRepresentationMirrorAncestorRepresentation', {}, this, this, _injectIntoOptional(Mirror.DisplayStyle.collection), .generated/*!default_value*/)
----Swift.(file).ContiguousArray.description
return this._makeCollectionDescriptionWithTypeName({}, nil/*!default_value*/)
----Swift.(file).ContiguousArray.debugDescription
return this._makeCollectionDescriptionWithTypeName({}, _injectIntoOptional("ContiguousArray"))
----Swift.(file).ContiguousArray.withUnsafeBufferPointer(_:(UnsafeBufferPointer<Element>) throws -> R)
return this._buffer.withUnsafeBufferPointer({}, body)
----Swift.(file).ContiguousArray.withUnsafeMutableBufferPointer(_:(inout UnsafeMutableBufferPointer<Element>) throws -> R)
const count = this.count;
this._buffer._outlinedMakeUniqueBufferBufferCount({$setThis: $val => this._buffer = $val}, count);
let work = _create(ContiguousArray, 'init', {}, );
let $tuple = {0: this, 1: work}
work = $tuple[0]
$info.$setThis(_cloneStruct($tuple[1]));
const pointer = _cloneStruct(work._buffer.firstElementAddress);
let inoutBufferPointer = _create(UnsafeMutableBufferPointer, 'initStartOptionalCountInt', {}, _injectIntoOptional(/*pointer_to_pointer*/pointer), count);
let $defer = () => {
preconditionFileLine({}, () => Bool.infix_38_38({}, Optional.infix_61_61({}, inoutBufferPointer.baseAddress, _injectIntoOptional(pointer)), () => Int.infix_61_61({}, inoutBufferPointer.count, count)), () => "ContiguousArray withUnsafeMutableBufferPointer: replacing the buffer is not allowed", '?3', '?3');
let $tuple = {0: this, 1: work}
work = $tuple[0]
$info.$setThis(_cloneStruct($tuple[1]));
}
try {;
return body({}, {get: () => inoutBufferPointer, set: $val => inoutBufferPointer = $val});}catch($error){$defer({}, );throw $error}$defer({}, )
----Swift.(file).ContiguousArray.replaceSubrange(_:Range<Int>,with:C)
preconditionFileLine({}, () => Int.infix_62_61({}, subrange.lowerBound, this._buffer.startIndex), () => "ContiguousArray replace: subrange start is negative", '?3', '?3');
preconditionFileLine({}, () => Int.infix_60_61({}, subrange.upperBound, this._buffer.endIndex), () => "ContiguousArray replace: subrange extends past the end", '?3', '?3');
const oldCount = this._buffer.count;
const eraseCount = subrange.count;
const insertCount = newElements.count;
const growth = Int.infix_45({}, insertCount, eraseCount);
{
if((Optional.wrappedNotEqualsOptionalNilComparisonType({}, this._buffer.requestUniqueMutableBackingBufferMinimumCapacity({$setThis: $val => this._buffer = $val}, Int.infix_43({}, oldCount, growth)), _create(_OptionalNilComparisonType, 'initNilLiteraltuple_type', {}, {})))) {
this._buffer.replaceSubrangeWithElementsOf({$setThis: $val => this._buffer = $val}, subrange, insertCount, newElements);
}
else {
this._buffer._arrayOutOfPlaceReplaceWithCount({$setThis: $val => this._buffer = $val}, subrange, newElements, insertCount);
}
}
----Swift.(file).ContiguousArray.==infix(_:ContiguousArray<Element>,_:ContiguousArray<Element>)
const lhsCount = lhs.count;
{
if((Int.infix_33_61({}, lhsCount, rhs.count))) {
return false;
}
};
{
if((Bool.infix_124_124({}, Int.infix_61_61({}, lhsCount, 0), () => UnsafeRawPointer.infix_61_61({}, lhs._buffer.identity, rhs._buffer.identity)))) {
return true;
}
};
{
let $idx$generator = _cloneStruct(Int.infix_46_46_60({}, 0, lhsCount).makeIterator({}, ));
while(true) {
const $ifLet0 = $idx$generator.next({$setThis: $val => $idx$generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
let idx = $ifLet0[0]
{
if(((lhs.subscript$get({}, idx)).constructor.infix_33_61({}, lhs.subscript$get({}, idx), rhs.subscript$get({}, idx)))) {
return false;
}
};
}
};
return true
----Swift.(file).ContiguousArray.hash(into:Hasher)
let hasher = hasher$inout.get()
const $result = (() => {
hasher.combine({$setThis: $val => hasher = $val}, this.count);
{
let $element$generator = _cloneStruct(this.makeIterator({}, ));
while(true) {
const $ifLet0 = $element$generator.next({$setThis: $val => $element$generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
let _element = $ifLet0[0]
hasher.combine({$setThis: $val => hasher = $val}, _element);
}
};})()
hasher$inout.set(hasher)
return $result
----Swift.(file).ContiguousArray.withUnsafeMutableBytes(_:(UnsafeMutableRawBufferPointer) throws -> R)
return this.withUnsafeMutableBufferPointer({$setThis: $val => $info.$setThis(_cloneStruct($val))}, (($info, $0$inout) => body({}, _create(UnsafeMutableRawBufferPointer, 'initUnsafeMutableBufferPointer', {}, $0))))
----Swift.(file).ContiguousArray.withUnsafeBytes(_:(UnsafeRawBufferPointer) throws -> R)
return this.withUnsafeBufferPointer({}, (($info, $0) => body({}, _create(UnsafeRawBufferPointer, 'initUnsafeBufferPointer', {}, $0))))
----Swift.(file).+=infix(_:_ContiguousArrayBuffer<Element>,_:C)
let lhs = lhs$inout.get()
const $result = (() => {
const oldCount = lhs.count;
const newCount = Int.infix_43({}, oldCount, numericCast({}, rhs.count));
const buf;
{
if((_fastPath({}, Int.infix_60_61({}, newCount, lhs.capacity)))) {
buf = _create(UnsafeMutableBufferPointer, 'initStartOptionalCountInt', {}, _injectIntoOptional(/*pointer_to_pointer*/UnsafeMutablePointer.infix_43({}, lhs.firstElementAddress, oldCount)), numericCast({}, rhs.count));
lhs.count = newCount;
}
else {
let newLHS = _create(_ContiguousArrayBuffer, 'init_uninitializedCountIntMinimumCapacityInt', {}, newCount, _growArrayCapacity({}, lhs.capacity));
newLHS.firstElementAddress.moveInitializeFromCount({}, lhs.firstElementAddress, oldCount);
lhs.count = 0;
let $tuple = {0: newLHS, 1: lhs}
lhs = $tuple[0]
newLHS = $tuple[1];
buf = _create(UnsafeMutableBufferPointer, 'initStartOptionalCountInt', {}, _injectIntoOptional(/*pointer_to_pointer*/UnsafeMutablePointer.infix_43({}, lhs.firstElementAddress, oldCount)), numericCast({}, rhs.count));
}
};
let $tuple = buf.initializeFrom({}, rhs), remainders = $tuple && $tuple[0], writtenUpTo = $tuple && $tuple[1];
preconditionFileLine({}, () => Optional.wrappedEqualsOptionalNilComparisonType({}, remainders.next({$setThis: $val => remainders = $val}, ), _create(_OptionalNilComparisonType, 'initNilLiteraltuple_type', {}, {})), () => "rhs underreported its count", '?3', '?3');
preconditionFileLine({}, () => Int.infix_61_61({}, writtenUpTo, buf.endIndex), () => "rhs overreported its count", '?3', '?3');})()
lhs$inout.set(lhs)
return $result
----Swift.(file)._ContiguousArrayBuffer.startIndex
return 0
----Swift.(file)._ContiguousArrayBuffer.endIndex
return this.count
----Swift.(file).UnsafeBufferPointer.withUnsafeBytes(_:(UnsafeRawBufferPointer) throws -> R)
const ptr = _create(UnsafeRawPointer, 'init', {}, /*pointer_to_pointer*/this.baseAddress._unsafelyUnwrappedUnchecked);
const len = Int.infix_38_42({}, this.count, MemoryLayout.stride);
return body({}, _create(UnsafeRawBufferPointer, 'initStartOptionalCountInt', {}, _injectIntoOptional(ptr), len))
----Swift.(file).UnsafeMutableBufferPointer.withUnsafeBytes(_:(UnsafeRawBufferPointer) throws -> R)
const ptr = _create(UnsafeRawPointer, 'initUnsafeMutablePointer', {}, this.baseAddress._unsafelyUnwrappedUnchecked);
const len = Int.infix_38_42({}, this.count, MemoryLayout.stride);
return body({}, _create(UnsafeRawBufferPointer, 'initStartOptionalCountInt', {}, _injectIntoOptional(ptr), len))
----Swift.(file).String.withUnsafeBytes(_:(UnsafeRawBufferPointer) throws -> R)
return this._withUTF8({}, (($info, $0) => body({}, _create(UnsafeRawBufferPointer, 'initUnsafeBufferPointer', {}, $0))))
----Swift.(file).Substring.withUnsafeBytes(_:(UnsafeRawBufferPointer) throws -> R)
return this._withUTF8({}, (($info, $0) => body({}, _create(UnsafeRawBufferPointer, 'initUnsafeBufferPointer', {}, $0))))
----Swift.(file)..(error_type).bridged()
const nsDictionary;
{
if((Bool.infix_124_124({}, infix_61_61_61({}, _injectIntoOptional(this._storage), _injectIntoOptional(_RawDictionaryStorage.empty)), () => Int.infix_61_61({}, this.count, 0)))) {
nsDictionary = _cloneStruct(_RawDictionaryStorage.empty);
}
else {
{
if((_isBridgedVerbatimToObjectiveC({}, ((function(){throw '!unclarifiedGeneric:Key'})()))) && (_isBridgedVerbatimToObjectiveC({}, ((function(){throw '!unclarifiedGeneric:Value'})())))) {
nsDictionary = _cloneStruct(unsafeDowncastTo({}, this._storage, _DictionaryStorage));
}
else {
nsDictionary = _cloneStruct(_create(_SwiftDeferredNSDictionary, 'init_NativeDictionary', {}, this));
}
}
}
};
return nsDictionary
----Swift.(file)._CocoaDictionary.isEqual(to:_CocoaDictionary)
return _stdlib_NSObject_isEqual({}, this.object, other.object)
----Swift.(file)._CocoaDictionary.startIndex
const allKeys = _cloneStruct(_stdlib_NSDictionary_allKeys({}, this.object));
return _create(_CocoaDictionary.Index, 'init_CocoaDictionaryIndexStorageOffsetInt', {}, _create(_CocoaDictionary.Index.Storage, 'init_CocoaDictionary_BridgingBuffer', {}, this, allKeys), 0)
----Swift.(file)._CocoaDictionary.endIndex
const allKeys = _cloneStruct(_stdlib_NSDictionary_allKeys({}, this.object));
return _create(_CocoaDictionary.Index, 'init_CocoaDictionaryIndexStorageOffsetInt', {}, _create(_CocoaDictionary.Index.Storage, 'init_CocoaDictionary_BridgingBuffer', {}, this, allKeys), allKeys.count)
----Swift.(file)._CocoaDictionary.index(after:_CocoaDictionary.Index)
this.validate({}, index);
let result = _cloneStruct(index);
Int.infix_43_61({}, {get: () => result._offset, set: $val => result._offset = $val}, 1);
return result
----Swift.(file)._CocoaDictionary.validate(_:_CocoaDictionary.Index)
preconditionFileLine({}, () => infix_61_61_61({}, _injectIntoOptional(index.storage.base.object), _injectIntoOptional(this.object)), () => "Invalid index", '?3', '?3');
preconditionFileLine({}, () => Int.infix_60({}, index._offset, index.storage.allKeys.count), () => "Attempt to access endIndex", '?3', '?3')
----Swift.(file)._CocoaDictionary.formIndex(after:_CocoaDictionary.Index,isUnique:Bool)
let index = index$inout.get()
const $result = (() => {
this.validate({}, index);
Int.infix_43_61({}, {get: () => index._offset, set: $val => index._offset = $val}, 1);})()
index$inout.set(index)
return $result
----Swift.(file)._CocoaDictionary.count
const nsd = _cloneStruct(unsafeBitCastTo({}, this.object, _NSDictionary));
return nsd.count
----Swift.(file)._CocoaDictionary.contains(_:_CocoaDictionary.Key)
const nsd = _cloneStruct(unsafeBitCastTo({}, this.object, _NSDictionary));
return Optional.wrappedNotEqualsOptionalNilComparisonType({}, nsd.objectForKey({}, key), _create(_OptionalNilComparisonType, 'initNilLiteraltuple_type', {}, {}))
----Swift.(file)._CocoaDictionary.lookup(_:_CocoaDictionary.Key)
const nsd = _cloneStruct(unsafeBitCastTo({}, this.object, _NSDictionary));
return nsd.objectForKey({}, key)
----Swift.(file)._CocoaDictionary.lookup(_:_CocoaDictionary.Index)
preconditionFileLine({}, () => infix_61_61_61({}, _injectIntoOptional(index.storage.base.object), _injectIntoOptional(this.object)), () => "Invalid index", '?3', '?3');
const key = _cloneStruct(index.storage.allKeys.subscript$get({}, index._offset));
const value = _cloneStruct(/*dynamic_member_ref_expr*/index.storage.base.object[0]({}, key)[0]);
return {0: key, 1: value}
----Swift.(file)._CocoaDictionary.key(at:_CocoaDictionary.Index)
preconditionFileLine({}, () => infix_61_61_61({}, _injectIntoOptional(index.storage.base.object), _injectIntoOptional(this.object)), () => "Invalid index", '?3', '?3');
return index.key
----Swift.(file)._CocoaDictionary.value(at:_CocoaDictionary.Index)
preconditionFileLine({}, () => infix_61_61_61({}, _injectIntoOptional(index.storage.base.object), _injectIntoOptional(this.object)), () => "Invalid index", '?3', '?3');
const key = _cloneStruct(index.storage.allKeys.subscript$get({}, index._offset));
return /*dynamic_member_ref_expr*/index.storage.base.object[0]({}, key)[0]
----Swift.(file)._CocoaDictionary.mapValues(_:(Value) throws -> T)
let result = _create(_NativeDictionary, 'initCapacityInt', {}, this.count);
{
let $generator = this.makeIterator({}, );
while(true) {
const $ifLet0 = _injectIntoOptional(((_.tmp0 = $generator.next({}, )).rawValue === 'some') ? (_.tmp0[0]) : null);
if(!($ifLet0.rawValue === 'some')) break
let cocoaKey = $ifLet0[0][0], cocoaValue = $ifLet0[0][1]
const key = _forceBridgeFromObjectiveC({}, cocoaKey, ((function(){throw '!unclarifiedGeneric:Key'})()));
const value = _forceBridgeFromObjectiveC({}, cocoaValue, ((function(){throw '!unclarifiedGeneric:Value'})()));
result.insertNewKeyValue({$setThis: $val => result = $val}, key, transform({}, value));
}
};
return result
----Swift.(file)._CocoaDictionary.Index.handleBitPattern
return unsafeBitCastTo({}, this.storage, UInt)
----Swift.(file)._CocoaDictionary.Index.dictionary
return this.storage.base
----Swift.(file)._CocoaDictionary.Index.key
preconditionFileLine({}, () => Int.infix_60({}, this._offset, this.storage.allKeys.count), () => "Attempting to access Dictionary elements using an invalid index", '?3', '?3');
return this.storage.allKeys.subscript$get({}, this._offset)
----Swift.(file)._CocoaDictionary.Index.age
return _HashTable.ageFor({}, this.storage.base.object)
----Swift.(file)._CocoaDictionary.Index.==infix(_:_CocoaDictionary.Index,_:_CocoaDictionary.Index)
preconditionFileLine({}, () => infix_61_61_61({}, _injectIntoOptional(lhs.storage.base.object), _injectIntoOptional(rhs.storage.base.object)), () => "Comparing indexes from different dictionaries", '?3', '?3');
return Int.infix_61_61({}, lhs._offset, rhs._offset)
----Swift.(file)._CocoaDictionary.Index.<infix(_:_CocoaDictionary.Index,_:_CocoaDictionary.Index)
preconditionFileLine({}, () => infix_61_61_61({}, _injectIntoOptional(lhs.storage.base.object), _injectIntoOptional(rhs.storage.base.object)), () => "Comparing indexes from different dictionaries", '?3', '?3');
return Int.infix_60({}, lhs._offset, rhs._offset)
----Swift.(file)._CocoaDictionary.makeIterator()
return _create(_CocoaDictionary.Iterator, 'init_CocoaDictionary', {}, this)
----Swift.(file)._CocoaDictionary.Iterator.nextKey()
{
if((Int.infix_60({}, this.itemIndex, 0))) {
return Optional.none;
}
};
const base = _cloneStruct(this.base);
{
if((Int.infix_61_61({}, this.itemIndex, this.itemCount))) {
const stackBufCount = this._fastEnumerationStackBuf.count;
this.itemCount = /*dynamic_member_ref_expr*/base.object[0]({}, this._fastEnumerationStatePtr, _create(UnsafeMutableRawPointer, 'initUnsafeMutablePointer', {}, this._fastEnumerationStackBufPtr).assumingMemoryBoundTo({}, AnyObject), stackBufCount);
{
if((Int.infix_61_61({}, this.itemCount, 0))) {
this.itemIndex = -1;
return Optional.none;
}
};
this.itemIndex = 0;
}
};
const itemsPtrUP = _cloneStruct(_create(UnsafeMutableRawPointer, 'initAutoreleasingUnsafeMutablePointer', {}, this._fastEnumerationState.itemsPtr[0]).assumingMemoryBoundTo({}, AnyObject));
const itemsPtr = _create(_UnmanagedAnyObjectArray, 'initUnsafeMutablePointer', {}, itemsPtrUP);
const key = _cloneStruct(itemsPtr.subscript$get({}, this.itemIndex));
Int.infix_43_61({}, {get: () => this.itemIndex, set: $val => this.itemIndex = $val}, 1);
return _injectIntoOptional(key)
----Swift.(file)._CocoaDictionary.Iterator.next()
{const $ifLet0 = this.nextKey({}, )
if(!($ifLet0.rawValue === 'some')) {
return Optional.none;
}let key = $ifLet0[0]
};
const value = _cloneStruct(/*dynamic_member_ref_expr*/this.base.object[0]({}, key)[0]);
return _injectIntoOptional({0: key, 1: value})
----Swift.(file).Dictionary.init(_unsafeUninitializedCapacity:Int,allowingDuplicates:Bool,initializingWith:(UnsafeMutableBufferPointer<Key>, UnsafeMutableBufferPointer<Value>, inout Int) -> Void)
this.init_native_NativeDictionary({}, _create(_NativeDictionary, 'init_unsafeUninitializedCapacityIntAllowingDuplicatesBoolInitializingWithfunction_type', {}, capacity, allowingDuplicates, initializer));
return
----Swift.(file)..(error_type).init(_unsafeUninitializedCapacity:Int,allowingDuplicates:Bool,initializingWith:<<error type>>)
this.initCapacityInt({}, capacity);
let initializedCount = 0;
initializer({}, _create(UnsafeMutableBufferPointer, 'initStartOptionalCountInt', {}, _injectIntoOptional(/*pointer_to_pointer*/this._keys), capacity), _create(UnsafeMutableBufferPointer, 'initStartOptionalCountInt', {}, _injectIntoOptional(/*pointer_to_pointer*/this._values), capacity), {get: () => initializedCount, set: $val => initializedCount = $val});
preconditionFileLine({}, () => Bool.infix_38_38({}, Int.infix_62_61({}, this.count, 0), () => Int.infix_60_61({}, this.count, capacity)), () => String()/*!default_value*/, '?3', '?3');
this._storage._count = initializedCount;
let bucket = _create(_HashTable.Bucket, 'initOffsetInt', {}, Int.infix_45({}, initializedCount, 1));
while(true){
if(!((Int.infix_62_61({}, bucket.offset, 0)))) break
{
if((this.hashTable._isOccupied({}, bucket))) {
Int.infix_45_61({}, {get: () => bucket.offset, set: $val => bucket.offset = $val}, 1);
continue;
}
};
const target;
{
if((Bool.infix_124_124({}, _isDebugAssertConfiguration({}, ), () => allowingDuplicates))) {
const $tuple = this.find({}, this._keys.subscript$get({}, bucket.offset)), b = $tuple && $tuple[0], found = $tuple && $tuple[1];
{
if((found)) {
preconditionFileLine({}, () => allowingDuplicates, () => "Duplicate keys found", '?3', '?3');
this.uncheckedDestroyAt({}, bucket);
Int.infix_45_61({}, {get: () => this._storage._count, set: $val => this._storage._count = $val}, 1);
Int.infix_45_61({}, {get: () => bucket.offset, set: $val => bucket.offset = $val}, 1);
continue;
}
};
this.hashTable.insert({}, b);
target = _cloneStruct(b);
}
else {
const hashValue = this.hashValueFor({}, this._keys.subscript$get({}, bucket.offset));
target = _cloneStruct(this.hashTable.insertNewHashValue({}, hashValue));
}
};
{
if((_NativeDictionary.Bucket.infix_62({}, target, bucket))) {
this.moveEntryFromTo({}, bucket, target);
Int.infix_45_61({}, {get: () => bucket.offset, set: $val => bucket.offset = $val}, 1);
}
else {
{
if((_HashTable.Bucket.infix_61_61({}, target, bucket))) {
Int.infix_45_61({}, {get: () => bucket.offset, set: $val => bucket.offset = $val}, 1);
}
else {
this.swapEntryWith({}, target, bucket);
}
}
}
};
};
return
----Swift.(file)._EmptyDictionarySingleton.copy(with:<<error type>>)
return this
----Swift.(file)._EmptyDictionarySingleton.count
return 0
----Swift.(file)._EmptyDictionarySingleton.object(forKey:AnyObject)
return Optional.none
----Swift.(file)._EmptyDictionarySingleton.keyEnumerator()
return _create(_SwiftEmptyNSEnumerator, 'init', {}, )
----Swift.(file)._EmptyDictionarySingleton.getObjects(_:UnsafeMutablePointer<AnyObject>?,andKeys:UnsafeMutablePointer<AnyObject>?,count:Int)

----Swift.(file)._DictionaryStorage.copy(original:_RawDictionaryStorage)
return this.allocateScaleAgeSeed({}, original._scale, _injectIntoOptional(original._age), _injectIntoOptional(original._seed))
----Swift.(file)._DictionaryStorage.resize(original:_RawDictionaryStorage,capacity:Int,move:Bool)
const scale = _HashTable.scaleForCapacity({}, capacity);
return this.allocateScaleAgeSeed({}, scale, Optional.none, Optional.none)
----Swift.(file)._DictionaryStorage.allocate(capacity:Int)
const scale = _HashTable.scaleForCapacity({}, capacity);
return this.allocateScaleAgeSeed({}, scale, Optional.none, Optional.none)
----Swift.(file)._DictionaryStorage.convert(_:<<error type>>,capacity:Int)
const scale = _HashTable.scaleForCapacity({}, capacity);
const age = _HashTable.ageFor({}, cocoa.object);
return this.allocateScaleAgeSeed({}, scale, _injectIntoOptional(age), Optional.none)
----Swift.(file).LazyDropWhileSequence.Iterator.next()
{
if((this._predicateHasFailed)) {
return this._base.next({$setThis: $val => this._base = $val}, );
}
};
while(true){
const $ifLet0 = this._base.next({$setThis: $val => this._base = $val}, )
if(!($ifLet0.rawValue === 'some')) break
let nextElement = $ifLet0[0]
{
if((Bool.prefix_33({}, this._predicate({}, nextElement)))) {
this._predicateHasFailed = true;
return _injectIntoOptional(nextElement);
}
};
};
return Optional.none
----Swift.(file).LazyDropWhileSequence.makeIterator()
return _create(LazyDropWhileSequence.Iterator, 'init_basePredicatefunction_type', {}, this._base.makeIterator({}, ), this._predicate)
----Swift.(file).LazySequenceProtocol.drop(while:(Self.Elements.Element) -> Bool)
return _create(LazyDropWhileSequence, 'init_basePredicatefunction_type', {}, this._elements, predicate)
----Swift.(file).LazyDropWhileCollection
const LazyDropWhileCollection = LazyDropWhileSequenc
----Swift.(file).LazyDropWhileCollection.startIndex
let index = this._base.startIndex;
while(true){
if(!((Bool.infix_38_38({}, (index).constructor.infix_33_61({}, index, this._base.endIndex), () => this._predicate({}, this._base.subscript$get({}, index)))))) break
this._base.formIndexAfter({}, {get: () => index, set: $val => index = $val});
};
return index
----Swift.(file).LazyDropWhileCollection.endIndex
return this._base.endIndex
----Swift.(file).LazyDropWhileCollection.index(after:LazyDropWhileSequence<Base>.Index)
preconditionFileLine({}, () => (i).constructor.infix_60({}, i, this._base.endIndex), () => "Can't advance past endIndex", '?3', '?3');
return this._base.indexAfter({}, i)
----Swift.(file).LazyDropWhileCollection.subscript(_:LazyDropWhileSequence<Base>.Index)
return this._base.subscript$get({}, position)
----Swift.(file).LazyDropWhileCollection.index(before:LazyDropWhileSequence<Base>.Index)
preconditionFileLine({}, () => (i).constructor.infix_62({}, i, this.startIndex), () => "Can't move before startIndex", '?3', '?3');
return this._base.indexBefore({}, i)
----Swift.(file).dump(_:T,to:TargetStream,name:String?,indent:Int,maxDepth:Int,maxItems:Int)
let target = target$inout.get()
const $result = (() => {
let maxItemCounter = maxItems;
let visitedItems = _create(Dictionary, 'init', {}, );
target._lock({$setThis: $val => target = $val}, );
let $defer = () => {
target._unlock({$setThis: $val => target = $val}, );
}
try {;
_dump_unlockedToNameIndentMaxDepthMaxItemCounterVisitedItems({}, value, {get: () => target, set: $val => target = $val}, _name, indent, maxDepth, {get: () => maxItemCounter, set: $val => maxItemCounter = $val}, {get: () => visitedItems, set: $val => visitedItems = $val});
return value;}catch($error){$defer({}, );throw $error}$defer({}, )})()
target$inout.set(target)
return $result
----Swift.(file).dump(_:T,name:String?,indent:Int,maxDepth:Int,maxItems:Int)
let stdoutStream = _create(_Stdout, 'init', {}, );
return dumpToNameIndentMaxDepthMaxItems({}, value, {get: () => stdoutStream, set: $val => stdoutStream = $val}, _name, indent, maxDepth, maxItems)
----Swift.(file).EmptyCollection.init()
return
----Swift.(file).EmptyCollection.Iterator.init()
return
----Swift.(file).EmptyCollection.Iterator.next()
return Optional.none
----Swift.(file).EmptyCollection.makeIterator()
return _create(EmptyCollection.Iterator, 'init', {}, )
----Swift.(file).EmptyCollection.startIndex
return 0
----Swift.(file).EmptyCollection.endIndex
return 0
----Swift.(file).EmptyCollection.index(after:EmptyCollection<Element>.Index)
preconditionFailureFileLine({}, () => "EmptyCollection can't advance indices", '?3', '?3')
----Swift.(file).EmptyCollection.index(before:EmptyCollection<Element>.Index)
preconditionFailureFileLine({}, () => "EmptyCollection can't advance indices", '?3', '?3')
----Swift.(file).EmptyCollection.subscript(_:EmptyCollection<Element>.Index)#ASS

preconditionFailureFileLine({}, () => "Index out of range", '?3', '?3')
----Swift.(file).EmptyCollection.subscript(_:EmptyCollection<Element>.Index)
preconditionFailureFileLine({}, () => "Index out of range", '?3', '?3');

----Swift.(file).EmptyCollection.subscript(_:Range<EmptyCollection<Element>.Index>)#ASS

preconditionFileLine({}, () => Bool.infix_38_38({}, Int.infix_61_61({}, bounds.lowerBound, 0), () => Int.infix_61_61({}, bounds.upperBound, 0)), () => "Index out of range", '?3', '?3')
----Swift.(file).EmptyCollection.subscript(_:Range<EmptyCollection<Element>.Index>)
preconditionFileLine({}, () => Bool.infix_38_38({}, Int.infix_61_61({}, bounds.lowerBound, 0), () => Int.infix_61_61({}, bounds.upperBound, 0)), () => "Index out of range", '?3', '?3');
return this;

----Swift.(file).EmptyCollection.count
return 0
----Swift.(file).EmptyCollection.index(_:EmptyCollection<Element>.Index,offsetBy:Int)
preconditionFileLine({}, () => Bool.infix_38_38({}, Int.infix_61_61({}, i, this.startIndex), () => Int.infix_61_61({}, n, 0)), () => "Index out of range", '?3', '?3');
return i
----Swift.(file).EmptyCollection.index(_:EmptyCollection<Element>.Index,offsetBy:Int,limitedBy:EmptyCollection<Element>.Index)
preconditionFileLine({}, () => Bool.infix_38_38({}, Int.infix_61_61({}, i, this.startIndex), () => Int.infix_61_61({}, limit, this.startIndex)), () => "Index out of range", '?3', '?3');
return (Int.infix_61_61({}, n, 0) ? _injectIntoOptional(i) : Optional.none)
----Swift.(file).EmptyCollection.distance(from:EmptyCollection<Element>.Index,to:EmptyCollection<Element>.Index)
preconditionFileLine({}, () => Int.infix_61_61({}, start, 0), () => "From must be startIndex (or endIndex)", '?3', '?3');
preconditionFileLine({}, () => Int.infix_61_61({}, end, 0), () => "To must be endIndex (or startIndex)", '?3', '?3');
return 0
----Swift.(file).EmptyCollection.==infix(_:EmptyCollection<Element>,_:EmptyCollection<Element>)
return true
----Swift.(file).Equatable.!=infix(_:Self,_:Self)
return Bool.prefix_33({}, (lhs).constructor.infix_61_61({}, lhs, rhs))
----Swift.(file).===infix(_:AnyObject?,_:AnyObject?)
const $match = {0: lhs, 1: rhs}
if((($match[0].rawValue == 'some' && $match[1].rawValue == 'some'))) {
const l = $match[0][0]
const r = $match[1][0]
return ObjectIdentifier.infix_61_61({}, _create(ObjectIdentifier, 'initAnyObject', {}, l), _create(ObjectIdentifier, 'initAnyObject', {}, r));
}
else if((($match[0].rawValue == Optional.none.rawValue && $match[1].rawValue == Optional.none.rawValue))) {
return true;
}
else if(((true))) {
return false;
}
----Swift.(file).!==infix(_:AnyObject?,_:AnyObject?)
return Bool.prefix_33({}, infix_61_61_61({}, lhs, rhs))
----Swift.(file).LazyFilterSequence.Iterator.base
return this._base
----Swift.(file).LazyFilterSequence.Iterator.next()
while(true){
const $ifLet0 = this._base.next({$setThis: $val => this._base = $val}, )
if(!($ifLet0.rawValue === 'some')) break
let n = $ifLet0[0]
{
if((this._predicate({}, n))) {
return _injectIntoOptional(n);
}
};
};
return Optional.none
----Swift.(file).LazyFilterSequence.makeIterator()
return _create(LazyFilterSequence.Iterator, 'init_basefunction_type', {}, this._base.makeIterator({}, ), this._predicate)
----Swift.(file).LazyFilterCollection
const LazyFilterCollection = LazyFilterSequenc
----Swift.(file).LazyFilterCollection.underestimatedCount
return 0
----Swift.(file).LazyFilterCollection.startIndex
let index = this._base.startIndex;
while(true){
if(!((Bool.infix_38_38({}, (index).constructor.infix_33_61({}, index, this._base.endIndex), () => Bool.prefix_33({}, this._predicate({}, this._base.subscript$get({}, index))))))) break
this._base.formIndexAfter({}, {get: () => index, set: $val => index = $val});
};
return index
----Swift.(file).LazyFilterCollection.endIndex
return this._base.endIndex
----Swift.(file).LazyFilterCollection.index(after:LazyFilterSequence<Base>.Index)
let i_dupl = i;
this.formIndexAfter({}, {get: () => i_dupl, set: $val => i_dupl = $val});
return i_dupl
----Swift.(file).LazyFilterCollection.formIndex(after:LazyFilterSequence<Base>.Index)
let i = i$inout.get()
const $result = (() => {
let index = i;
preconditionFileLine({}, () => (index).constructor.infix_33_61({}, index, this._base.endIndex), () => "Can't advance past endIndex", '?3', '?3');
do {
this._base.formIndexAfter({}, {get: () => index, set: $val => index = $val});
} while(Bool.infix_38_38({}, (index).constructor.infix_33_61({}, index, this._base.endIndex), () => Bool.prefix_33({}, this._predicate({}, this._base.subscript$get({}, index)))));
i = index;})()
i$inout.set(i)
return $result
----Swift.(file).LazyFilterCollection.distance(from:LazyFilterSequence<Base>.Index,to:LazyFilterSequence<Base>.Index)
_.discardAssignment = this._base.distanceFromTo({}, start, end);
let _start;
const _end;
const step;
{
if(((start).constructor.infix_62({}, start, end))) {
_start = end;
_end = start;
step = -1;
}
else {
_start = start;
_end = end;
step = 1;
}
};
let count = 0;
while(true){
if(!((LazyFilterSequence.Index.infix_33_61({}, _start, _end)))) break
Int.infix_43_61({}, {get: () => count, set: $val => count = $val}, step);
this.formIndexAfter({}, {get: () => _start, set: $val => _start = $val});
};
return count
----Swift.(file).LazyFilterCollection.index(_:LazyFilterSequence<Base>.Index,offsetBy:Int)
let i_dupl = i;
const step = n.signum({}, );
this._ensureBidirectionalStep({}, step);
{
let $generator = _cloneStruct(Int.infix_46_46_60({}, 0, abs({}, numericCast({}, n))).makeIterator({}, ));
while(true) {
const $ifLet0 = $generator.next({$setThis: $val => $generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
this._advanceIndexStep({}, {get: () => i_dupl, set: $val => i_dupl = $val}, step);
}
};
return i_dupl
----Swift.(file).LazyFilterCollection.formIndex(_:LazyFilterSequence<Base>.Index,offsetBy:Int)
let i = i$inout.get()
const $result = (() => {
i = this.indexOffsetBy({}, i, n);})()
i$inout.set(i)
return $result
----Swift.(file).LazyFilterCollection.index(_:LazyFilterSequence<Base>.Index,offsetBy:Int,limitedBy:LazyFilterSequence<Base>.Index)
let i_dupl = i;
const step = n.signum({}, );
this._ensureBidirectionalStep({}, step);
{
let $generator = _cloneStruct(Int.infix_46_46_60({}, 0, abs({}, numericCast({}, n))).makeIterator({}, ));
while(true) {
const $ifLet0 = $generator.next({$setThis: $val => $generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
{
if(((i_dupl).constructor.infix_61_61({}, i_dupl, limit))) {
return Optional.none;
}
};
this._advanceIndexStep({}, {get: () => i_dupl, set: $val => i_dupl = $val}, step);
}
};
return _injectIntoOptional(i_dupl)
----Swift.(file).LazyFilterCollection.formIndex(_:LazyFilterSequence<Base>.Index,offsetBy:Int,limitedBy:LazyFilterSequence<Base>.Index)
let i = i$inout.get()
const $result = (() => {
{const $ifLet0 = this.indexOffsetByLimitedBy({}, i, n, limit)
if($ifLet0.rawValue === 'some') {
let advancedIndex = $ifLet0[0]
i = advancedIndex;
return true;
}
};
i = limit;
return false;})()
i$inout.set(i)
return $result
----Swift.(file).LazyFilterCollection.subscript(_:LazyFilterSequence<Base>.Index)
return this._base.subscript$get({}, position)
----Swift.(file).LazyFilterCollection.subscript(_:Range<LazyFilterSequence<Base>.Index>)
return _create(LazyFilterSequence.SubSequence, 'init_basefunction_type', {}, this._base.subscriptRange$get({}, bounds), this._predicate)
----Swift.(file).LazyFilterCollection.index(before:LazyFilterSequence<Base>.Index)
let i_dupl = i;
this.formIndexBefore({}, {get: () => i_dupl, set: $val => i_dupl = $val});
return i_dupl
----Swift.(file).LazyFilterCollection.formIndex(before:LazyFilterSequence<Base>.Index)
let i = i$inout.get()
const $result = (() => {
let index = i;
preconditionFileLine({}, () => (index).constructor.infix_33_61({}, index, this._base.startIndex), () => "Can't retreat before startIndex", '?3', '?3');
do {
this._base.formIndexBefore({}, {get: () => index, set: $val => index = $val});
} while(Bool.prefix_33({}, this._predicate({}, this._base.subscript$get({}, index))));
i = index;})()
i$inout.set(i)
return $result
----Swift.(file).LazySequenceProtocol.filter(_:(Self.Elements.Element) -> Bool)
return _create(LazyFilterSequence, 'init_basefunction_type', {}, this._elements, isIncluded)
----Swift.(file).LazyFilterSequence.filter(_:(LazyFilterSequence<Base>.Element) -> Bool)
return _create(LazyFilterSequence, 'init_basefunction_type', {}, this._base, (($info, $0) => Bool.infix_38_38({}, isIncluded({}, $0), () => this._predicate({}, $0))))
----Swift.(file).LazySequenceProtocol.flatMap(_:(Self.Elements.Element) -> SegmentOfResult)
return this.mapSwift({}, transform).joined({}, )
----Swift.(file).LazySequenceProtocol.compactMap(_:(Self.Elements.Element) -> ElementOfResult?)
return this.mapSwift({}, transform).filterSwift({}, (($info, $0) => Optional.wrappedNotEqualsOptionalNilComparisonType({}, $0, _create(_OptionalNilComparisonType, 'initNilLiteraltuple_type', {}, {})))).mapSwift({}, (($info, $0) => $0[0]))
----Swift.(file).FlattenSequence.init(_base:Base)
this._base = _base;
return
----Swift.(file).FlattenSequence.Iterator.init(_base:Base.Iterator)
this._base = _base;
return
----Swift.(file).FlattenSequence.Iterator.next()
do {
{
if((_fastPath({}, Optional.wrappedNotEqualsOptionalNilComparisonType({}, this._inner, _create(_OptionalNilComparisonType, 'initNilLiteraltuple_type', {}, {}))))) {
const ret = this._inner[0].next({$setThis: $val => this._inner[0] = $val}, );
{
if((_fastPath({}, Optional.wrappedNotEqualsOptionalNilComparisonType({}, ret, _create(_OptionalNilComparisonType, 'initNilLiteraltuple_type', {}, {}))))) {
return ret;
}
};
}
};
const s = this._base.next({$setThis: $val => this._base = $val}, );
{
if((_slowPath({}, Optional.wrappedEqualsOptionalNilComparisonType({}, s, _create(_OptionalNilComparisonType, 'initNilLiteraltuple_type', {}, {}))))) {
return Optional.none;
}
};
this._inner = _injectIntoOptional(s[0].makeIterator({}, ));
} while(true)
----Swift.(file).FlattenSequence.makeIterator()
return _create(FlattenSequence.Iterator, 'init_base', {}, this._base.makeIterator({}, ))
----Swift.(file).Sequence.joined()
return _create(FlattenSequence, 'init_base', {}, this)
----Swift.(file).LazySequenceProtocol.joined()
return _create(FlattenSequence, 'init_base', {}, this._elements).lazy
----Swift.(file).FlattenSequence.Index.==infix(_:FlattenCollection<Base>.Index,_:FlattenCollection<Base>.Index)
return Bool.infix_38_38({}, (lhs._outer).constructor.infix_61_61({}, lhs._outer, rhs._outer), () => Optional.infix_61_61({}, lhs._inner, rhs._inner))
----Swift.(file).FlattenSequence.Index.<infix(_:FlattenCollection<Base>.Index,_:FlattenCollection<Base>.Index)
{
if(((lhs._outer).constructor.infix_33_61({}, lhs._outer, rhs._outer))) {
return (lhs._outer).constructor.infix_60({}, lhs._outer, rhs._outer);
}
};
{const $ifLet0 = lhs._inner
const $ifLet1 = rhs._inner
if($ifLet0.rawValue === 'some' && $ifLet1.rawValue === 'some') {
let lhsInner = $ifLet0[0]
let rhsInner = $ifLet1[0]
return (lhsInner).constructor.infix_60({}, lhsInner, rhsInner);
}
};
preconditionFileLine({}, () => Bool.infix_38_38({}, Optional.wrappedEqualsOptionalNilComparisonType({}, lhs._inner, _create(_OptionalNilComparisonType, 'initNilLiteraltuple_type', {}, {})), () => Optional.wrappedEqualsOptionalNilComparisonType({}, rhs._inner, _create(_OptionalNilComparisonType, 'initNilLiteraltuple_type', {}, {}))), () => String()/*!default_value*/, '?3', '?3');
return false
----Swift.(file).FlattenSequence.Index.hash(into:Hasher)
let hasher = hasher$inout.get()
const $result = (() => {
hasher.combine({$setThis: $val => hasher = $val}, this._outer);
hasher.combine({$setThis: $val => hasher = $val}, this._inner);})()
hasher$inout.set(hasher)
return $result
----Swift.(file).FlattenCollection.startIndex
const end = this._base.endIndex;
let outer = this._base.startIndex;
while(true){
if(!(((outer).constructor.infix_33_61({}, outer, end)))) break
const innerCollection = this._base.subscript$get({}, outer);
{
if((Bool.prefix_33({}, innerCollection.isEmpty))) {
return _create(FlattenSequence.Index, 'initOptional', {}, outer, _injectIntoOptional(innerCollection.startIndex));
}
};
this._base.formIndexAfter({}, {get: () => outer, set: $val => outer = $val});
};
return this.endIndex
----Swift.(file).FlattenCollection.endIndex
return _create(FlattenSequence.Index, 'initOptional', {}, this._base.endIndex, Optional.none)
----Swift.(file).FlattenCollection.index(after:FlattenSequence<Base>.Index)
return this._indexAfter({}, i)
----Swift.(file).FlattenCollection.formIndex(after:FlattenSequence<Base>.Index)
let i = i$inout.get()
const $result = (() => {
i = _cloneStruct(this.indexAfter({}, i));})()
i$inout.set(i)
return $result
----Swift.(file).FlattenCollection.distance(from:FlattenSequence<Base>.Index,to:FlattenSequence<Base>.Index)
{
if((FlattenSequence.Index.infix_60({}, end, start))) {
_.discardAssignment = this._base.distanceFromTo({}, this._base.endIndex, this._base.startIndex);
}
};
let _start;
const _end;
const step;
{
if((FlattenSequence.Index.infix_62({}, start, end))) {
_start = _cloneStruct(end);
_end = _cloneStruct(start);
step = -1;
}
else {
_start = _cloneStruct(start);
_end = _cloneStruct(end);
step = 1;
}
};
let count = 0;
while(true){
if(!((FlattenSequence.Index.infix_33_61({}, _start, _end)))) break
Int.infix_43_61({}, {get: () => count, set: $val => count = $val}, step);
this.formIndexAfter({}, {get: () => _start, set: $val => _start = $val});
};
return count
----Swift.(file).FlattenCollection.index(_:FlattenSequence<Base>.Index,offsetBy:Int)
let i_dupl = _cloneStruct(i);
const step = n.signum({}, );
this._ensureBidirectionalStep({}, step);
{
let $generator = _cloneStruct(Int.infix_46_46_60({}, 0, abs({}, n)).makeIterator({}, ));
while(true) {
const $ifLet0 = $generator.next({$setThis: $val => $generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
this._advanceIndexStep({}, {get: () => i_dupl, set: $val => i_dupl = $val}, step);
}
};
return i_dupl
----Swift.(file).FlattenCollection.formIndex(_:FlattenSequence<Base>.Index,offsetBy:Int)
let i = i$inout.get()
const $result = (() => {
i = _cloneStruct(this.indexOffsetBy({}, i, n));})()
i$inout.set(i)
return $result
----Swift.(file).FlattenCollection.index(_:FlattenSequence<Base>.Index,offsetBy:Int,limitedBy:FlattenSequence<Base>.Index)
let i_dupl = _cloneStruct(i);
const step = n.signum({}, );
this._ensureBidirectionalStep({}, step);
{
let $generator = _cloneStruct(Int.infix_46_46_60({}, 0, abs({}, n)).makeIterator({}, ));
while(true) {
const $ifLet0 = $generator.next({$setThis: $val => $generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
{
if((FlattenSequence.Index.infix_61_61({}, i_dupl, limit))) {
return Optional.none;
}
};
this._advanceIndexStep({}, {get: () => i_dupl, set: $val => i_dupl = $val}, step);
}
};
return _injectIntoOptional(i_dupl)
----Swift.(file).FlattenCollection.formIndex(_:FlattenSequence<Base>.Index,offsetBy:Int,limitedBy:FlattenSequence<Base>.Index)
let i = i$inout.get()
const $result = (() => {
{const $ifLet0 = this.indexOffsetByLimitedBy({}, i, n, limit)
if($ifLet0.rawValue === 'some') {
let advancedIndex = $ifLet0[0]
i = _cloneStruct(advancedIndex);
return true;
}
};
i = _cloneStruct(limit);
return false;})()
i$inout.set(i)
return $result
----Swift.(file).FlattenCollection.subscript(_:FlattenSequence<Base>.Index)
return this._base.subscript$get({}, position._outer).subscript$get({}, position._inner[0])
----Swift.(file).FlattenCollection.subscript(_:Range<FlattenSequence<Base>.Index>)
return _create(Slice, 'initBaseBoundsRange', {}, this, bounds)
----Swift.(file).FlattenCollection.index(before:FlattenSequence<Base>.Index)
return this._indexBefore({}, i)
----Swift.(file).FlattenCollection.formIndex(before:FlattenSequence<Base>.Index)
let i = i$inout.get()
const $result = (() => {
i = _cloneStruct(this.indexBefore({}, i));})()
i$inout.set(i)
return $result
----Swift.(file).FloatingPointSign.init(rawValue:Int)
const $match = rawValue
if((((infix_126_61({}, 0, $match))))) {
$info.$setThis(_cloneStruct(FloatingPointSign.plus));
}
else if((((infix_126_61({}, 1, $match))))) {
$info.$setThis(_cloneStruct(FloatingPointSign.minus));
}
else if(((true))) {
return (this.$failed = true);
};
return
----Swift.(file).FloatingPointSign.rawValue
const $match = this
if((($match.rawValue == FloatingPointSign.plus.rawValue))) {
return 0;
}
else if((($match.rawValue == FloatingPointSign.minus.rawValue))) {
return 1;
}
----Swift.(file).FloatingPointSign.==infix(_:FloatingPointSign,_:FloatingPointSign)
return Int.infix_61_61({}, a.rawValue, b.rawValue)
----Swift.(file).FloatingPointSign.hashValue
return this.rawValue.hashValue
----Swift.(file).FloatingPointSign.hash(into:Hasher)
let hasher = hasher$inout.get()
const $result = (() => {
hasher.combine({$setThis: $val => hasher = $val}, this.rawValue);})()
hasher$inout.set(hasher)
return $result
----Swift.(file).FloatingPoint.==infix(_:Self,_:Self)
return lhs.isEqualTo({}, rhs)
----Swift.(file).FloatingPoint.<infix(_:Self,_:Self)
return lhs.isLessThan({}, rhs)
----Swift.(file).FloatingPoint.<=infix(_:Self,_:Self)
return lhs.isLessThanOrEqualTo({}, rhs)
----Swift.(file).FloatingPoint.>infix(_:Self,_:Self)
return rhs.isLessThan({}, lhs)
----Swift.(file).FloatingPoint.>=infix(_:Self,_:Self)
return rhs.isLessThanOrEqualTo({}, lhs)
----Swift.(file).FloatingPoint.ulpOfOne
return _create(this.constructor, 'initIntegerLiteral', {}, 1).ulp;
}
static get ulpOfOne() { return this.ulpOfOne$get()
----Swift.(file).FloatingPoint.rounded(_:FloatingPointRoundingRule)
let lhs = this;
lhs.round({$setThis: $val => lhs = $val}, rule);
return lhs
----Swift.(file).FloatingPoint.rounded()
return this.rounded({}, FloatingPointRoundingRule.toNearestOrAwayFromZero)
----Swift.(file).FloatingPoint.round()
this.round({$setThis: $val => $info.$setThis(_cloneStruct($val))}, FloatingPointRoundingRule.toNearestOrAwayFromZero)
----Swift.(file).FloatingPoint.nextDown
return this.constructor.prefix_45({}, this.constructor.prefix_45({}, this).nextUp)
----Swift.(file).FloatingPoint.truncatingRemainder(dividingBy:Self)
let lhs = this;
lhs.formTruncatingRemainderDividingBy({$setThis: $val => lhs = $val}, other);
return lhs
----Swift.(file).FloatingPoint.remainder(dividingBy:Self)
let lhs = this;
lhs.formRemainderDividingBy({$setThis: $val => lhs = $val}, other);
return lhs
----Swift.(file).FloatingPoint.squareRoot()
let lhs = this;
lhs.formSquareRoot({$setThis: $val => lhs = $val}, );
return lhs
----Swift.(file).FloatingPoint.addingProduct(_:Self,_:Self)
let addend = this;
addend.addProduct({$setThis: $val => addend = $val}, lhs, rhs);
return addend
----Swift.(file).FloatingPoint.minimum(_:Self,_:Self)
{
if((Bool.infix_124_124({}, x.isSignalingNaN, () => y.isSignalingNaN))) {
return (x).constructor.infix_43({}, x, y);
}
};
{
if((Bool.infix_124_124({}, (x).constructor.infix_60_61({}, x, y), () => y._isNaN))) {
return x;
}
};
return y
----Swift.(file).FloatingPoint.maximum(_:Self,_:Self)
{
if((Bool.infix_124_124({}, x.isSignalingNaN, () => y.isSignalingNaN))) {
return (x).constructor.infix_43({}, x, y);
}
};
{
if((Bool.infix_124_124({}, (x).constructor.infix_62({}, x, y), () => y._isNaN))) {
return x;
}
};
return y
----Swift.(file).FloatingPoint.minimumMagnitude(_:Self,_:Self)
{
if((Bool.infix_124_124({}, x.isSignalingNaN, () => y.isSignalingNaN))) {
return (x).constructor.infix_43({}, x, y);
}
};
{
if((Bool.infix_124_124({}, (x.magnitude).constructor.infix_60_61({}, x.magnitude, y.magnitude), () => y._isNaN))) {
return x;
}
};
return y
----Swift.(file).FloatingPoint.maximumMagnitude(_:Self,_:Self)
{
if((Bool.infix_124_124({}, x.isSignalingNaN, () => y.isSignalingNaN))) {
return (x).constructor.infix_43({}, x, y);
}
};
{
if((Bool.infix_124_124({}, (x.magnitude).constructor.infix_62({}, x.magnitude, y.magnitude), () => y._isNaN))) {
return x;
}
};
return y
----Swift.(file).FloatingPoint.floatingPointClass
{
if((this.isSignalingNaN)) {
return FloatingPointClassification.signalingNaN;
}
};
{
if((this._isNaN)) {
return FloatingPointClassification.quietNaN;
}
};
{
if((this.isInfinite)) {
return (FloatingPointSign.infix_61_61({}, this.sign, FloatingPointSign.minus) ? FloatingPointClassification.negativeInfinity : FloatingPointClassification.positiveInfinity);
}
};
{
if((this.isNormal)) {
return (FloatingPointSign.infix_61_61({}, this.sign, FloatingPointSign.minus) ? FloatingPointClassification.negativeNormal : FloatingPointClassification.positiveNormal);
}
};
{
if((this.isSubnormal)) {
return (FloatingPointSign.infix_61_61({}, this.sign, FloatingPointSign.minus) ? FloatingPointClassification.negativeSubnormal : FloatingPointClassification.positiveSubnormal);
}
};
return (FloatingPointSign.infix_61_61({}, this.sign, FloatingPointSign.minus) ? FloatingPointClassification.negativeZero : FloatingPointClassification.positiveZero)
----Swift.(file).BinaryFloatingPoint.radix
return 2;
}
static get radix() { return this.radix$get()
----Swift.(file).BinaryFloatingPoint.init(signOf:Self,magnitudeOf:Self)
this.initSignFloatingPointSignExponentBitPatternSignificandBitPattern({}, signOf.sign, magnitudeOf.exponentBitPattern, magnitudeOf.significandBitPattern);
return
----Swift.(file).BinaryFloatingPoint.init(_:Source)
$info.$setThis(_cloneStruct(this.constructor._convertFrom({}, value)["0"]));
return
----Swift.(file).BinaryFloatingPoint.init(exactly:Source)
const $tuple = this.constructor._convertFrom({}, value), value_ = $tuple && $tuple[0], exact = $tuple && $tuple[1];
{
if(!((exact))) {
return (this.$failed = true);
}
};
$info.$setThis(_cloneStruct(value_));
return
----Swift.(file).BinaryFloatingPoint.isTotallyOrdered(belowOrEqualTo:Self)
{
if(((this).constructor.infix_60({}, this, other))) {
return true;
}
};
{
if(((other).constructor.infix_62({}, other, this))) {
return false;
}
};
{
if((FloatingPointSign.infix_33_61({}, this.sign, other.sign))) {
return FloatingPointSign.infix_61_61({}, this.sign, FloatingPointSign.minus);
}
};
{
if(((this.exponentBitPattern).constructor.infix_62({}, this.exponentBitPattern, other.exponentBitPattern))) {
return FloatingPointSign.infix_61_61({}, this.sign, FloatingPointSign.minus);
}
};
{
if(((this.exponentBitPattern).constructor.infix_60({}, this.exponentBitPattern, other.exponentBitPattern))) {
return FloatingPointSign.infix_61_61({}, this.sign, FloatingPointSign.plus);
}
};
{
if(((this.significandBitPattern).constructor.infix_62({}, this.significandBitPattern, other.significandBitPattern))) {
return FloatingPointSign.infix_61_61({}, this.sign, FloatingPointSign.minus);
}
};
{
if(((this.significandBitPattern).constructor.infix_60({}, this.significandBitPattern, other.significandBitPattern))) {
return FloatingPointSign.infix_61_61({}, this.sign, FloatingPointSign.plus);
}
};
return true
----Swift.(file).BinaryFloatingPoint.init(_:Source)
$info.$setThis(_cloneStruct(this.constructor._convertFrom({}, value)["0"]));
return
----Swift.(file).BinaryFloatingPoint.init(exactly:Source)
const $tuple = this.constructor._convertFrom({}, value), value_ = $tuple && $tuple[0], exact = $tuple && $tuple[1];
{
if(!((exact))) {
return (this.$failed = true);
}
};
$info.$setThis(_cloneStruct(value_));
return
----Swift.(file).BinaryFloatingPoint.random(in:Range<Self>,using:T)
let generator = generator$inout.get()
const $result = (() => {
preconditionFileLine({}, () => Bool.prefix_33({}, range.isEmpty), () => "Can't get random value with an empty range", '?3', '?3');
const delta = (range.upperBound).constructor.infix_45({}, range.upperBound, range.lowerBound);
preconditionFileLine({}, () => delta._isFinite, () => "There is no uniform distribution on an infinite range", '?3', '?3');
const rand;
{
if((Int.infix_61_61({}, ((function(){throw '!unclarifiedGeneric:Self.RawSignificand'})()).bitWidth, Int.infix_43({}, this.constructor.significandBitCount, 1)))) {
rand = generator.next({$setThis: $val => generator = $val}, );
}
else {
const significandCount = Int.infix_43({}, this.constructor.significandBitCount, 1);
const maxSignificand = (_create(((function(){throw '!unclarifiedGeneric:Self.RawSignificand'})()), 'initIntegerLiteral', {}, 1)).constructor.infix_60_60({}, _create(((function(){throw '!unclarifiedGeneric:Self.RawSignificand'})()), 'initIntegerLiteral', {}, 1), significandCount);
rand = (generator.next({$setThis: $val => generator = $val}, )).constructor.infix_38({}, generator.next({$setThis: $val => generator = $val}, ), (maxSignificand).constructor.infix_45({}, maxSignificand, _create(((function(){throw '!unclarifiedGeneric:Self.RawSignificand'})()), 'initIntegerLiteral', {}, 1)));
}
};
const unitRandom = (_create(this.constructor, 'init', {}, rand)).constructor.infix_42({}, _create(this.constructor, 'init', {}, rand), (this.constructor.ulpOfOne).constructor.infix_47({}, this.constructor.ulpOfOne, _create(this.constructor, 'initIntegerLiteral', {}, 2)));
const randFloat = ((delta).constructor.infix_42({}, delta, unitRandom)).constructor.infix_43({}, (delta).constructor.infix_42({}, delta, unitRandom), range.lowerBound);
{
if(((randFloat).constructor.infix_61_61({}, randFloat, range.upperBound))) {
return this.constructor.randomInUsing({}, range, {get: () => generator, set: $val => generator = $val});
}
};
return randFloat;})()
generator$inout.set(generator)
return $result
----Swift.(file).BinaryFloatingPoint.random(in:Range<Self>)
let g = _create(SystemRandomNumberGenerator, 'init', {}, );
return this.constructor.randomInUsing({}, range, {get: () => g, set: $val => g = $val})
----Swift.(file).BinaryFloatingPoint.random(in:ClosedRange<Self>,using:T)
let generator = generator$inout.get()
const $result = (() => {
preconditionFileLine({}, () => Bool.prefix_33({}, range.isEmpty), () => "Can't get random value with an empty range", '?3', '?3');
const delta = (range.upperBound).constructor.infix_45({}, range.upperBound, range.lowerBound);
preconditionFileLine({}, () => delta._isFinite, () => "There is no uniform distribution on an infinite range", '?3', '?3');
const rand;
{
if((Int.infix_61_61({}, ((function(){throw '!unclarifiedGeneric:Self.RawSignificand'})()).bitWidth, Int.infix_43({}, this.constructor.significandBitCount, 1)))) {
rand = generator.next({$setThis: $val => generator = $val}, );
const tmp = UInt8.infix_38({}, generator.next({$setThis: $val => generator = $val}, ), 1);
{
if((Bool.infix_38_38({}, (rand).constructor.infix_61_61({}, rand, ((function(){throw '!unclarifiedGeneric:Self.RawSignificand'})()).max), () => UInt8.infix_61_61({}, tmp, 1)))) {
return range.upperBound;
}
};
}
else {
const significandCount = Int.infix_43({}, this.constructor.significandBitCount, 1);
const maxSignificand = (_create(((function(){throw '!unclarifiedGeneric:Self.RawSignificand'})()), 'initIntegerLiteral', {}, 1)).constructor.infix_60_60({}, _create(((function(){throw '!unclarifiedGeneric:Self.RawSignificand'})()), 'initIntegerLiteral', {}, 1), significandCount);
rand = generator.nextUpperBound({$setThis: $val => generator = $val}, (maxSignificand).constructor.infix_43({}, maxSignificand, _create(((function(){throw '!unclarifiedGeneric:Self.RawSignificand'})()), 'initIntegerLiteral', {}, 1)));
{
if(((rand).constructor.infix_61_61({}, rand, maxSignificand))) {
return range.upperBound;
}
};
}
};
const unitRandom = (_create(this.constructor, 'init', {}, rand)).constructor.infix_42({}, _create(this.constructor, 'init', {}, rand), (this.constructor.ulpOfOne).constructor.infix_47({}, this.constructor.ulpOfOne, _create(this.constructor, 'initIntegerLiteral', {}, 2)));
const randFloat = ((delta).constructor.infix_42({}, delta, unitRandom)).constructor.infix_43({}, (delta).constructor.infix_42({}, delta, unitRandom), range.lowerBound);
return randFloat;})()
generator$inout.set(generator)
return $result
----Swift.(file).BinaryFloatingPoint.random(in:ClosedRange<Self>)
let g = _create(SystemRandomNumberGenerator, 'init', {}, );
return this.constructor.randomInUsing({}, range, {get: () => g, set: $val => g = $val})
----Swift.(file)._HashTable.maxLoadFactor
return Double.infix_47({}, 3, 4);
}
static get maxLoadFactor() { return this.maxLoadFactor$get()
----Swift.(file)._HashTable.capacity(forScale:Int8)
const bucketCount = Int.infix_38_60_60({}, 1, scale);
return _create(Int, 'initDouble', {}, Double.infix_42({}, _create(Double, 'initInt', {}, bucketCount), this.maxLoadFactor))
----Swift.(file)._HashTable.scale(forCapacity:Int)
const capacity = /*dot_syntax_base_ignored*/max({}, capacity, 1);
const minimumEntries = /*dot_syntax_base_ignored*/max({}, _create(Int, 'initDouble', {}, Double.infix_47({}, _create(Double, 'initInt', {}, capacity), this.maxLoadFactor).rounded({}, FloatingPointRoundingRule.up)), Int.infix_43({}, capacity, 1));
const exponent = Int.infix_43({}, Int.infix_45({}, /*dot_syntax_base_ignored*/max({}, minimumEntries, 2), 1)._binaryLogarithm({}, ), 1);
const scale = _create(Int8, 'initTruncatingIfNeeded', {}, exponent);
return scale
----Swift.(file)._HashTable.age(for:AnyObject)
const hash = _create(ObjectIdentifier, 'initAnyObject', {}, cocoa).hashValue;
return _create(Int32, 'initTruncatingIfNeeded', {}, hash)
----Swift.(file)._HashTable.hashSeed(for:AnyObject,scale:Int8)
{
if((Hasher._isDeterministic)) {
return _create(Int, 'init', {}, scale);
}
};
return unsafeBitCastTo({}, object, Int)
----Swift.(file)._HashTable.Bucket.==infix(_:_HashTable.Bucket,_:_HashTable.Bucket)
return Int.infix_61_61({}, lhs.offset, rhs.offset)
----Swift.(file)._HashTable.Bucket.<infix(_:_HashTable.Bucket,_:_HashTable.Bucket)
return Int.infix_60({}, lhs.offset, rhs.offset)
----Swift.(file)._HashTable.Index.==infix(_:_HashTable.Index,_:_HashTable.Index)
preconditionFileLine({}, () => Int32.infix_61_61({}, lhs.age, rhs.age), () => "Can't compare indices belonging to different collections", '?3', '?3');
return _HashTable.Bucket.infix_61_61({}, lhs.bucket, rhs.bucket)
----Swift.(file)._HashTable.Index.<infix(_:_HashTable.Index,_:_HashTable.Index)
preconditionFileLine({}, () => Int32.infix_61_61({}, lhs.age, rhs.age), () => "Can't compare indices belonging to different collections", '?3', '?3');
return _HashTable.Bucket.infix_60({}, lhs.bucket, rhs.bucket)
----Swift.(file)._HashTable.makeIterator()
return _create(_HashTable.Iterator, 'init_HashTable', {}, this)
----Swift.(file)._HashTable.isValid(_:_HashTable.Bucket)
return Bool.infix_38_38({}, Int.infix_62_61({}, bucket.offset, 0), () => Int.infix_60({}, bucket.offset, this.bucketCount))
----Swift.(file)._HashTable.isOccupied(_:_HashTable.Bucket)
return Bool.infix_38_38({}, this.isValid({}, bucket), () => this._isOccupied({}, bucket))
----Swift.(file)._HashTable.checkOccupied(_:_HashTable.Bucket)
preconditionFileLine({}, () => this.isOccupied({}, bucket), () => "Attempting to access Collection elements using an invalid Index", '?3', '?3')
----Swift.(file)._HashTable.occupiedBucket(after:_HashTable.Bucket)
const word = bucket.word;
{const $ifLet0 = this.words.subscript$get({}, word).intersectingElementsAbove({}, bucket.bit).minimum
if($ifLet0.rawValue === 'some') {
let bit = $ifLet0[0]
return _create(_HashTable.Bucket, 'initWordIntBitInt', {}, word, bit);
}
};
return this._firstOccupiedBucketFromWord({}, Int.infix_43({}, word, 1))
----Swift.(file)._HashTable.startBucket
return this._firstOccupiedBucketFromWord({}, 0)
----Swift.(file)._HashTable.endBucket
return _create(_HashTable.Bucket, 'initOffsetInt', {}, this.bucketCount)
----Swift.(file)._HashTable.idealBucket(forHashValue:Int)
return _create(_HashTable.Bucket, 'initOffsetInt', {}, Int.infix_38({}, hashValue, this.bucketMask))
----Swift.(file)._HashTable.bucket(wrappedAfter:_HashTable.Bucket)
return _create(_HashTable.Bucket, 'initOffsetInt', {}, Int.infix_38({}, Int.infix_38_43({}, bucket.offset, 1), this.bucketMask))
----Swift.(file)._HashTable.previousHole(before:_HashTable.Bucket)
let word = bucket.word;
{const $ifLet0 = this.words.subscript$get({}, word).complement.intersectingElementsBelow({}, bucket.bit).maximum
if($ifLet0.rawValue === 'some') {
let bit = $ifLet0[0]
return _create(_HashTable.Bucket, 'initWordIntBitInt', {}, word, bit);
}
};
let wrap = false;
while(true){
if(!((true))) break
Int.infix_45_61({}, {get: () => word, set: $val => word = $val}, 1);
{
if((Int.infix_60({}, word, 0))) {
preconditionFileLine({}, () => Bool.prefix_33({}, wrap), () => "Hash table has no holes", '?3', '?3');
wrap = true;
word = Int.infix_45({}, this.wordCount, 1);
}
};
{const $ifLet0 = this.words.subscript$get({}, word).complement.maximum
if($ifLet0.rawValue === 'some') {
let bit = $ifLet0[0]
return _create(_HashTable.Bucket, 'initWordIntBitInt', {}, word, bit);
}
};
}
----Swift.(file)._HashTable.nextHole(atOrAfter:_HashTable.Bucket)
let word = bucket.word;
{const $ifLet0 = this.words.subscript$get({}, word).complement.subtractingElementsBelow({}, bucket.bit).minimum
if($ifLet0.rawValue === 'some') {
let bit = $ifLet0[0]
return _create(_HashTable.Bucket, 'initWordIntBitInt', {}, word, bit);
}
};
let wrap = false;
while(true){
if(!((true))) break
Int.infix_38_43_61({}, {get: () => word, set: $val => word = $val}, 1);
{
if((Int.infix_61_61({}, word, this.wordCount))) {
preconditionFileLine({}, () => Bool.prefix_33({}, wrap), () => "Hash table has no holes", '?3', '?3');
wrap = true;
word = 0;
}
};
{const $ifLet0 = this.words.subscript$get({}, word).complement.minimum
if($ifLet0.rawValue === 'some') {
let bit = $ifLet0[0]
return _create(_HashTable.Bucket, 'initWordIntBitInt', {}, word, bit);
}
};
}
----Swift.(file)._HashTable.copyContents(of:_HashTable)
this.words.assignFromCount({}, /*pointer_to_pointer*/other.words, this.wordCount)
----Swift.(file)._HashTable.insertNew(hashValue:Int)
const hole = _cloneStruct(this.nextHoleAtOrAfter({}, this.idealBucketForHashValue({}, hashValue)));
this.insert({}, hole);
return hole
----Swift.(file)._HashTable.insert(_:_HashTable.Bucket)
this.words.subscript$get({}, bucket.word).uncheckedInsert({$setThis: $val => this.words.subscript$set({$setThis: $val => this.words = _cloneStruct($val)}, $val, bucket.word)}, bucket.bit)
----Swift.(file)._HashTable.clear()
{
if((Int.infix_60({}, this.bucketCount, _HashTable.Word.capacity))) {
this.words.subscript$set({$setThis: $val => this.words = _cloneStruct($val)}, _cloneStruct(_HashTable.Word.allBits.subtractingElementsBelow({}, this.bucketCount)), 0);
}
else {
this.words.assignRepeatingCount({}, _HashTable.Word.empty, this.wordCount);
}
}
----Swift.(file)._HashTable.delete(at:_HashTable.Bucket,with:D)
let hole = _cloneStruct(bucket);
let candidate = _cloneStruct(this.bucketWrappedAfter({}, hole));
{
if(!((this._isOccupied({}, candidate)))) {
this.words.subscript$get({}, hole.word).uncheckedRemove({$setThis: $val => this.words.subscript$set({$setThis: $val => this.words = _cloneStruct($val)}, $val, hole.word)}, hole.bit);
return ;
}
};
const start = _cloneStruct(this.bucketWrappedAfter({}, this.previousHoleBefore({}, bucket)));
while(true){
if(!((this._isOccupied({}, candidate)))) break
const candidateHash = delegate.hashValueAt({}, candidate);
const ideal = _cloneStruct(this.idealBucketForHashValue({}, candidateHash));
const c0 = _HashTable.Bucket.infix_62_61({}, ideal, start);
const c1 = _HashTable.Bucket.infix_60_61({}, ideal, hole);
{
if(((_HashTable.Bucket.infix_60_61({}, start, hole) ? Bool.infix_38_38({}, c0, () => c1) : Bool.infix_124_124({}, c0, () => c1)))) {
delegate.moveEntryFromTo({}, candidate, hole);
hole = _cloneStruct(candidate);
}
};
candidate = _cloneStruct(this.bucketWrappedAfter({}, candidate));
};
this.words.subscript$get({}, hole.word).uncheckedRemove({$setThis: $val => this.words.subscript$set({$setThis: $val => this.words = _cloneStruct($val)}, $val, hole.word)}, hole.bit)
----Swift.(file).Hashable_isEqual_indirect(_:UnsafePointer<T>,_:UnsafePointer<T>)
return (lhs.pointee).constructor.infix_61_61({}, lhs.pointee, rhs.pointee)
----Swift.(file).Hashable_hashValue_indirect(_:UnsafePointer<T>)
return value.pointee.hashValue
----Swift.(file).Hasher.init()
this._core = _create(Hasher._Core, 'init', {}, );
return
----Swift.(file).Hasher.init(_seed:Int)
this._core = _create(Hasher._Core, 'initSeedInt', {}, _seed);
return
----Swift.(file).Hasher.init(_rawSeed:(UInt64, UInt64))
this._core = _create(Hasher._Core, 'initStateHasher_State', {}, _create(Hasher._State, 'initRawSeedtuple_type', {}, _rawSeed));
return
----Swift.(file).Hasher.combine(_:H)
value.hashInto({}, {get: () => this, set: $val => $info.$setThis(_cloneStruct($val))})
----Swift.(file).Hasher.combine(bytes:UnsafeRawBufferPointer)
this._core.combineBytes({$setThis: $val => this._core = $val}, bytes)
----Swift.(file).Hasher.finalize()
let core = _cloneStruct(this._core);
return _create(Int, 'initTruncatingIfNeeded', {}, core.finalize({$setThis: $val => core = $val}, ))
----Swift.(file).DefaultIndices.init(_elements:Elements,startIndex:Elements.Index,endIndex:Elements.Index)
this._elements = _elements;
this._startIndex = startIndex;
this._endIndex = endIndex;
return
----Swift.(file).DefaultIndices.startIndex
return this._startIndex
----Swift.(file).DefaultIndices.endIndex
return this._endIndex
----Swift.(file).DefaultIndices.subscript(_:DefaultIndices<Elements>.Index)
return i
----Swift.(file).DefaultIndices.subscript(_:Range<DefaultIndices<Elements>.Index>)
return _create(DefaultIndices, 'init_elementsStartIndexEndIndex', {}, this._elements, bounds.lowerBound, bounds.upperBound)
----Swift.(file).DefaultIndices.index(after:DefaultIndices<Elements>.Index)
return this._elements.indexAfter({}, i)
----Swift.(file).DefaultIndices.formIndex(after:DefaultIndices<Elements>.Index)
let i = i$inout.get()
const $result = (() => {
this._elements.formIndexAfter({}, {get: () => i, set: $val => i = $val});})()
i$inout.set(i)
return $result
----Swift.(file).DefaultIndices.indices
return this
----Swift.(file).DefaultIndices.index(before:DefaultIndices<Elements>.Index)
return this._elements.indexBefore({}, i)
----Swift.(file).DefaultIndices.formIndex(before:DefaultIndices<Elements>.Index)
let i = i$inout.get()
const $result = (() => {
this._elements.formIndexBefore({}, {get: () => i, set: $val => i = $val});})()
i$inout.set(i)
return $result
----Swift.(file).Collection.indices
return _create(DefaultIndices, 'init_elementsStartIndexEndIndex', {}, this, this.startIndex, this.endIndex)
----Swift.(file).FixedWidthInteger.init(_:String)
this.initRadixInt({}, description, 10);
return
----Swift.(file).ExpressibleByIntegerLiteral.init(integerLiteral:Self)
$info.$setThis(_cloneStruct(value));
return
----Swift.(file).AdditiveArithmetic.zero
return _create(this.constructor, 'initIntegerLiteral', {}, 0);
}
static get zero() { return this.zero$get()
----Swift.(file).SignedNumeric.-prefix(_:Self)
let result = operand;
result.negate({$setThis: $val => result = $val}, );
return result
----Swift.(file).SignedNumeric.negate()
$info.$setThis(_cloneStruct((_create(this.constructor, 'initIntegerLiteral', {}, 0)).constructor.infix_45({}, _create(this.constructor, 'initIntegerLiteral', {}, 0), this)))
----Swift.(file).abs(_:T)
{
if((infix_61_61({}, _injectIntoOptional(((function(){throw '!unclarifiedGeneric:T'})())), _injectIntoOptional(((function(){throw '!unclarifiedGeneric:T.Magnitude'})()))))) {
return unsafeBitCastTo({}, x.magnitude, ((function(){throw '!unclarifiedGeneric:T'})()));
}
};
return ((x).constructor.infix_60({}, x, _create(((function(){throw '!unclarifiedGeneric:T'})()), 'initIntegerLiteral', {}, 0)) ? ((function(){throw '!unclarifiedGeneric:T'})()).prefix_45({}, x) : x)
----Swift.(file).AdditiveArithmetic.+prefix(_:Self)
return x
----Swift.(file).BinaryInteger.init()
$info.$setThis(_cloneStruct(_create(this.constructor, 'initIntegerLiteral', {}, 0)));
return
----Swift.(file).BinaryInteger.signum()
return this.constructor.infix_45({}, ((this).constructor.infix_62({}, this, _create(this.constructor, 'initIntegerLiteral', {}, 0)) ? _create(this.constructor, 'initIntegerLiteral', {}, 1) : _create(this.constructor, 'initIntegerLiteral', {}, 0)), ((this).constructor.infix_60({}, this, _create(this.constructor, 'initIntegerLiteral', {}, 0)) ? _create(this.constructor, 'initIntegerLiteral', {}, 1) : _create(this.constructor, 'initIntegerLiteral', {}, 0)))
----Swift.(file).BinaryInteger.quotientAndRemainder(dividingBy:Self)
return {0: (this).constructor.infix_47({}, this, rhs), 1: (this).constructor.infix_37({}, this, rhs)}
----Swift.(file).BinaryInteger.isMultiple(of:Self)
{
if(((other).constructor.infix_61_61({}, other, 0))) {
return (this).constructor.infix_61_61({}, this, 0);
}
};
return ((this.magnitude).constructor.infix_37({}, this.magnitude, other.magnitude)).constructor.infix_61_61({}, (this.magnitude).constructor.infix_37({}, this.magnitude, other.magnitude), 0)
----Swift.(file).BinaryInteger.&infix(_:Self,_:Self)
let lhs_dupl = lhs;
(rhs).constructor.infix_38_61({}, {get: () => lhs_dupl, set: $val => lhs_dupl = $val}, rhs);
return lhs_dupl
----Swift.(file).BinaryInteger.|infix(_:Self,_:Self)
let lhs_dupl = lhs;
(rhs).constructor.infix_124_61({}, {get: () => lhs_dupl, set: $val => lhs_dupl = $val}, rhs);
return lhs_dupl
----Swift.(file).BinaryInteger.^infix(_:Self,_:Self)
let lhs_dupl = lhs;
(rhs).constructor.infix_94_61({}, {get: () => lhs_dupl, set: $val => lhs_dupl = $val}, rhs);
return lhs_dupl
----Swift.(file).BinaryInteger.>>infix(_:Self,_:RHS)
let r = lhs;
this.constructor.infix_62_62_61({}, {get: () => r, set: $val => r = $val}, rhs);
return r
----Swift.(file).BinaryInteger.<<infix(_:Self,_:RHS)
let r = lhs;
this.constructor.infix_60_60_61({}, {get: () => r, set: $val => r = $val}, rhs);
return r
----Swift.(file).BinaryInteger.description
return this._descriptionRadixUppercase({}, 10, false)
----Swift.(file).BinaryInteger.distance(to:Self)
{
if((Bool.prefix_33({}, this.constructor.isSigned))) {
{
if(((this).constructor.infix_62({}, this, other))) {
{const $ifLet0 = _create(Int, 'initExactly', {}, (this).constructor.infix_45({}, this, other))
if($ifLet0.rawValue === 'some') {
let result = $ifLet0[0]
return Int.prefix_45({}, result);
}
};
}
else {
{const $ifLet0 = _create(Int, 'initExactly', {}, (other).constructor.infix_45({}, other, this))
if($ifLet0.rawValue === 'some') {
let result = $ifLet0[0]
return result;
}
};
}
};
}
else {
const isNegative = (this).constructor.infix_60({}, this, _create(this.constructor, 'initIntegerLiteral', {}, 0));
{
if((Bool.infix_61_61({}, isNegative, (other).constructor.infix_60({}, other, _create(this.constructor, 'initIntegerLiteral', {}, 0))))) {
{const $ifLet0 = _create(Int, 'initExactly', {}, (other).constructor.infix_45({}, other, this))
if($ifLet0.rawValue === 'some') {
let result = $ifLet0[0]
return result;
}
};
}
else {
{const $ifLet0 = _create(Int, 'initExactly', {}, (this.magnitude).constructor.infix_43({}, this.magnitude, other.magnitude))
if($ifLet0.rawValue === 'some') {
let result = $ifLet0[0]
return (isNegative ? result : Int.prefix_45({}, result));
}
};
}
};
}
};
preconditionFailureFileLine({}, () => "Distance is not representable in Int", '?3', '?3')
----Swift.(file).BinaryInteger.advanced(by:Int)
{
if((Bool.prefix_33({}, this.constructor.isSigned))) {
return (Int.infix_60({}, n, 0) ? (this).constructor.infix_45({}, this, _create(this.constructor, 'init', {}, Int.prefix_45({}, n))) : (this).constructor.infix_43({}, this, _create(this.constructor, 'init', {}, n)));
}
};
{
if((Bool.infix_61_61({}, (this).constructor.infix_60({}, this, _create(this.constructor, 'initIntegerLiteral', {}, 0)), Int.infix_60({}, n, _create(this.constructor, 'initIntegerLiteral', {}, 0))))) {
return (this).constructor.infix_43({}, this, _create(this.constructor, 'init', {}, n));
}
};
return ((this.magnitude).constructor.infix_60({}, this.magnitude, n.magnitude) ? _create(this.constructor, 'init', {}, Int.infix_43({}, _create(Int, 'init', {}, this), n)) : (this).constructor.infix_43({}, this, _create(this.constructor, 'init', {}, n)))
----Swift.(file).BinaryInteger.==infix(_:Self,_:Other)
const lhsNegative = Bool.infix_38_38({}, this.constructor.isSigned, () => (lhs).constructor.infix_60({}, lhs, _create(this.constructor, 'initIntegerLiteral', {}, 0)));
const rhsNegative = Bool.infix_38_38({}, ((function(){throw '!unclarifiedGeneric:Other'})()).isSigned, () => (rhs).constructor.infix_60({}, rhs, _create(((function(){throw '!unclarifiedGeneric:Other'})()), 'initIntegerLiteral', {}, 0)));
{
if((Bool.infix_33_61({}, lhsNegative, rhsNegative))) {
return false;
}
};
{
if((Int.infix_60({}, lhs.bitWidth, rhs.bitWidth))) {
return (_create(((function(){throw '!unclarifiedGeneric:Other'})()), 'initTruncatingIfNeeded', {}, lhs)).constructor.infix_61_61({}, _create(((function(){throw '!unclarifiedGeneric:Other'})()), 'initTruncatingIfNeeded', {}, lhs), rhs);
}
};
{
if((Int.infix_62({}, lhs.bitWidth, rhs.bitWidth))) {
return (lhs).constructor.infix_61_61({}, lhs, _create(this.constructor, 'initTruncatingIfNeeded', {}, rhs));
}
};
{
if((this.constructor.isSigned)) {
return (_create(((function(){throw '!unclarifiedGeneric:Other'})()), 'initTruncatingIfNeeded', {}, lhs)).constructor.infix_61_61({}, _create(((function(){throw '!unclarifiedGeneric:Other'})()), 'initTruncatingIfNeeded', {}, lhs), rhs);
}
};
return (lhs).constructor.infix_61_61({}, lhs, _create(this.constructor, 'initTruncatingIfNeeded', {}, rhs))
----Swift.(file).BinaryInteger.!=infix(_:Self,_:Other)
return Bool.prefix_33({}, (lhs).constructor.infix_61_61({}, lhs, rhs))
----Swift.(file).BinaryInteger.<infix(_:Self,_:Other)
const lhsNegative = Bool.infix_38_38({}, this.constructor.isSigned, () => (lhs).constructor.infix_60({}, lhs, _create(this.constructor, 'initIntegerLiteral', {}, 0)));
const rhsNegative = Bool.infix_38_38({}, ((function(){throw '!unclarifiedGeneric:Other'})()).isSigned, () => (rhs).constructor.infix_60({}, rhs, _create(((function(){throw '!unclarifiedGeneric:Other'})()), 'initIntegerLiteral', {}, 0)));
{
if((Bool.infix_33_61({}, lhsNegative, rhsNegative))) {
return lhsNegative;
}
};
{
if((Bool.infix_38_38({}, (lhs).constructor.infix_61_61({}, lhs, _create(this.constructor, 'initIntegerLiteral', {}, 0)), () => (rhs).constructor.infix_61_61({}, rhs, _create(((function(){throw '!unclarifiedGeneric:Other'})()), 'initIntegerLiteral', {}, 0))))) {
return false;
}
};
const rhsAsSelf = _create(this.constructor, 'initTruncatingIfNeeded', {}, rhs);
const rhsAsSelfNegative = (rhsAsSelf).constructor.infix_60({}, rhsAsSelf, _create(this.constructor, 'initIntegerLiteral', {}, 0));
{
if((Bool.infix_38_38({}, (_create(((function(){throw '!unclarifiedGeneric:Other'})()), 'initTruncatingIfNeeded', {}, rhsAsSelf)).constructor.infix_61_61({}, _create(((function(){throw '!unclarifiedGeneric:Other'})()), 'initTruncatingIfNeeded', {}, rhsAsSelf), rhs), () => Bool.infix_61_61({}, rhsNegative, rhsAsSelfNegative)))) {
return (lhs).constructor.infix_60({}, lhs, rhsAsSelf);
}
};
return (_create(((function(){throw '!unclarifiedGeneric:Other'})()), 'initTruncatingIfNeeded', {}, lhs)).constructor.infix_60({}, _create(((function(){throw '!unclarifiedGeneric:Other'})()), 'initTruncatingIfNeeded', {}, lhs), rhs)
----Swift.(file).BinaryInteger.<=infix(_:Self,_:Other)
return Bool.prefix_33({}, (rhs).constructor.infix_60({}, rhs, lhs))
----Swift.(file).BinaryInteger.>=infix(_:Self,_:Other)
return Bool.prefix_33({}, (lhs).constructor.infix_60({}, lhs, rhs))
----Swift.(file).BinaryInteger.>infix(_:Self,_:Other)
return (rhs).constructor.infix_60({}, rhs, lhs)
----Swift.(file).BinaryInteger.!=infix(_:Self,_:Self)
return Bool.prefix_33({}, (lhs).constructor.infix_61_61({}, lhs, rhs))
----Swift.(file).BinaryInteger.<=infix(_:Self,_:Self)
return Bool.prefix_33({}, (rhs).constructor.infix_60({}, rhs, lhs))
----Swift.(file).BinaryInteger.>=infix(_:Self,_:Self)
return Bool.prefix_33({}, (lhs).constructor.infix_60({}, lhs, rhs))
----Swift.(file).BinaryInteger.>infix(_:Self,_:Self)
return (rhs).constructor.infix_60({}, rhs, lhs)
----Swift.(file).FixedWidthInteger.bitWidth
return this.constructor.bitWidth
----Swift.(file).FixedWidthInteger.init(littleEndian:Self)
$info.$setThis(_cloneStruct(value));
return
----Swift.(file).FixedWidthInteger.init(bigEndian:Self)
$info.$setThis(_cloneStruct(value.byteSwapped));
return
----Swift.(file).FixedWidthInteger.littleEndian
return this
----Swift.(file).FixedWidthInteger.bigEndian
return this.byteSwapped
----Swift.(file).FixedWidthInteger.&>>infix(_:Self,_:Self)
let lhs_dupl = lhs;
(rhs).constructor.infix_38_62_62_61({}, {get: () => lhs_dupl, set: $val => lhs_dupl = $val}, rhs);
return lhs_dupl
----Swift.(file).FixedWidthInteger.&>>infix(_:Self,_:Other)
return (lhs).constructor.infix_38_62_62({}, lhs, _create(this.constructor, 'initTruncatingIfNeeded', {}, rhs))
----Swift.(file).FixedWidthInteger.&>>=infix(_:Self,_:Other)
let lhs = lhs$inout.get()
const $result = (() => {
lhs = (lhs).constructor.infix_38_62_62({}, lhs, rhs);})()
lhs$inout.set(lhs)
return $result
----Swift.(file).FixedWidthInteger.&<<infix(_:Self,_:Self)
let lhs_dupl = lhs;
(rhs).constructor.infix_38_60_60_61({}, {get: () => lhs_dupl, set: $val => lhs_dupl = $val}, rhs);
return lhs_dupl
----Swift.(file).FixedWidthInteger.&<<infix(_:Self,_:Other)
return (lhs).constructor.infix_38_60_60({}, lhs, _create(this.constructor, 'initTruncatingIfNeeded', {}, rhs))
----Swift.(file).FixedWidthInteger.&<<=infix(_:Self,_:Other)
let lhs = lhs$inout.get()
const $result = (() => {
lhs = (lhs).constructor.infix_38_60_60({}, lhs, rhs);})()
lhs$inout.set(lhs)
return $result
----Swift.(file).FixedWidthInteger.random(in:Range<Self>,using:T)
let generator = generator$inout.get()
const $result = (() => {
preconditionFileLine({}, () => Bool.prefix_33({}, range.isEmpty), () => "Can't get random value with an empty range", '?3', '?3');
const delta = _create(((function(){throw '!unclarifiedGeneric:Self.Magnitude'})()), 'initTruncatingIfNeeded', {}, (range.upperBound).constructor.infix_38_45({}, range.upperBound, range.lowerBound));
return _create(this.constructor, 'initTruncatingIfNeeded', {}, (_create(((function(){throw '!unclarifiedGeneric:Self.Magnitude'})()), 'initTruncatingIfNeeded', {}, range.lowerBound)).constructor.infix_38_43({}, _create(((function(){throw '!unclarifiedGeneric:Self.Magnitude'})()), 'initTruncatingIfNeeded', {}, range.lowerBound), generator.nextUpperBound({$setThis: $val => generator = $val}, delta)));})()
generator$inout.set(generator)
return $result
----Swift.(file).FixedWidthInteger.random(in:Range<Self>)
let g = _create(SystemRandomNumberGenerator, 'init', {}, );
return this.constructor.randomInUsing({}, range, {get: () => g, set: $val => g = $val})
----Swift.(file).FixedWidthInteger.random(in:ClosedRange<Self>,using:T)
let generator = generator$inout.get()
const $result = (() => {
preconditionFileLine({}, () => Bool.prefix_33({}, range.isEmpty), () => "Can't get random value with an empty range", '?3', '?3');
let delta = _create(((function(){throw '!unclarifiedGeneric:Self.Magnitude'})()), 'initTruncatingIfNeeded', {}, (range.upperBound).constructor.infix_38_45({}, range.upperBound, range.lowerBound));
{
if(((delta).constructor.infix_61_61({}, delta, ((function(){throw '!unclarifiedGeneric:Self.Magnitude'})()).max))) {
return _create(this.constructor, 'initTruncatingIfNeeded', {}, generator.next({$setThis: $val => generator = $val}, ));
}
};
(_create(((function(){throw '!unclarifiedGeneric:Self.Magnitude'})()), 'initIntegerLiteral', {}, 1)).constructor.infix_43_61({}, {get: () => delta, set: $val => delta = $val}, _create(((function(){throw '!unclarifiedGeneric:Self.Magnitude'})()), 'initIntegerLiteral', {}, 1));
return _create(this.constructor, 'initTruncatingIfNeeded', {}, (_create(((function(){throw '!unclarifiedGeneric:Self.Magnitude'})()), 'initTruncatingIfNeeded', {}, range.lowerBound)).constructor.infix_38_43({}, _create(((function(){throw '!unclarifiedGeneric:Self.Magnitude'})()), 'initTruncatingIfNeeded', {}, range.lowerBound), generator.nextUpperBound({$setThis: $val => generator = $val}, delta)));})()
generator$inout.set(generator)
return $result
----Swift.(file).FixedWidthInteger.random(in:ClosedRange<Self>)
let g = _create(SystemRandomNumberGenerator, 'init', {}, );
return this.constructor.randomInUsing({}, range, {get: () => g, set: $val => g = $val})
----Swift.(file).FixedWidthInteger.~prefix(_:Self)
return ((_create(this.constructor, 'initIntegerLiteral', {}, 0)).constructor.infix_38_45({}, _create(this.constructor, 'initIntegerLiteral', {}, 0), x)).constructor.infix_38_45({}, (_create(this.constructor, 'initIntegerLiteral', {}, 0)).constructor.infix_38_45({}, _create(this.constructor, 'initIntegerLiteral', {}, 0), x), _create(this.constructor, 'initIntegerLiteral', {}, 1))
----Swift.(file).FixedWidthInteger.>>infix(_:Self,_:Other)
let lhs_dupl = lhs;
this._nonMaskingRightShiftGeneric({}, {get: () => lhs_dupl, set: $val => lhs_dupl = $val}, rhs);
return lhs_dupl
----Swift.(file).FixedWidthInteger.>>=infix(_:Self,_:Other)
let lhs = lhs$inout.get()
const $result = (() => {
this._nonMaskingRightShiftGeneric({}, {get: () => lhs, set: $val => lhs = $val}, rhs);})()
lhs$inout.set(lhs)
return $result
----Swift.(file).FixedWidthInteger.<<infix(_:Self,_:Other)
let lhs_dupl = lhs;
this._nonMaskingLeftShiftGeneric({}, {get: () => lhs_dupl, set: $val => lhs_dupl = $val}, rhs);
return lhs_dupl
----Swift.(file).FixedWidthInteger.<<=infix(_:Self,_:Other)
let lhs = lhs$inout.get()
const $result = (() => {
this._nonMaskingLeftShiftGeneric({}, {get: () => lhs, set: $val => lhs = $val}, rhs);})()
lhs$inout.set(lhs)
return $result
----Swift.(file).FixedWidthInteger.init(_:T)
{const $ifLet0 = this.constructor._convertFrom({}, source)["0"]
if(!($ifLet0.rawValue === 'some')) {
fatalErrorFileLine({}, () => (("") + (((function(){throw '!unclarifiedGeneric:T'})())) + (" value cannot be converted to ") + (this.constructor) + (" because it is outside the representable range")), '?3', '?3');
}let value = $ifLet0[0]
};
$info.$setThis(_cloneStruct(value));
return
----Swift.(file).FixedWidthInteger.init(exactly:T)
const $tuple = this.constructor._convertFrom({}, source), temporary = $tuple && $tuple[0], exact = $tuple && $tuple[1];
{const $ifLet0 = temporary
if(!((exact) && $ifLet0.rawValue === 'some')) {
return (this.$failed = true);
}let value = $ifLet0[0]
};
$info.$setThis(_cloneStruct(value));
return
----Swift.(file).FixedWidthInteger.init(clamping:Other)
{
if((_slowPath({}, (source).constructor.infix_60({}, source, this.constructor.min)))) {
$info.$setThis(_cloneStruct(this.constructor.min));
}
else {
{
if((_slowPath({}, (source).constructor.infix_62({}, source, this.constructor.max)))) {
$info.$setThis(_cloneStruct(this.constructor.max));
}
else {
$info.$setThis(_cloneStruct(_create(this.constructor, 'initTruncatingIfNeeded', {}, source)));
}
}
}
};
return
----Swift.(file).FixedWidthInteger.init(truncatingIfNeeded:T)
{
if((Int.infix_60_61({}, this.constructor.bitWidth, Int.bitWidth))) {
$info.$setThis(_cloneStruct(_create(this.constructor, 'init_truncatingBitsUInt', {}, source._lowWord)));
}
else {
const neg = (source).constructor.infix_60({}, source, _create(((function(){throw '!unclarifiedGeneric:T'})()), 'initIntegerLiteral', {}, 0));
let result = (neg ? this.constructor.prefix_126({}, _create(this.constructor, 'initIntegerLiteral', {}, 0)) : _create(this.constructor, 'initIntegerLiteral', {}, 0));
let shift = _create(this.constructor, 'initIntegerLiteral', {}, 0);
const width = _create(this.constructor, 'init_truncatingBitsUInt', {}, this.constructor.bitWidth._lowWord);
{
let $word$generator = source.words.makeIterator({}, );
while(true) {
const $ifLet0 = $word$generator.next({$setThis: $val => $word$generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
let word = $ifLet0[0]
{
if(!(((shift).constructor.infix_60({}, shift, width)))) {
break;
}
};
((_create(this.constructor, 'init_truncatingBitsUInt', {}, (neg ? UInt.prefix_126({}, word) : word))).constructor.infix_38_60_60({}, _create(this.constructor, 'init_truncatingBitsUInt', {}, (neg ? UInt.prefix_126({}, word) : word)), shift)).constructor.infix_94_61({}, {get: () => result, set: $val => result = $val}, (_create(this.constructor, 'init_truncatingBitsUInt', {}, (neg ? UInt.prefix_126({}, word) : word))).constructor.infix_38_60_60({}, _create(this.constructor, 'init_truncatingBitsUInt', {}, (neg ? UInt.prefix_126({}, word) : word)), shift));
(_create(this.constructor, 'init_truncatingBitsUInt', {}, Int.bitWidth._lowWord)).constructor.infix_43_61({}, {get: () => shift, set: $val => shift = $val}, _create(this.constructor, 'init_truncatingBitsUInt', {}, Int.bitWidth._lowWord));
}
};
$info.$setThis(_cloneStruct(result));
}
};
return
----Swift.(file).FixedWidthInteger.&+infix(_:Self,_:Self)
return lhs.addingReportingOverflow({}, rhs)["0"]
----Swift.(file).FixedWidthInteger.&+=infix(_:Self,_:Self)
let lhs = lhs$inout.get()
const $result = (() => {
lhs = (lhs).constructor.infix_38_43({}, lhs, rhs);})()
lhs$inout.set(lhs)
return $result
----Swift.(file).FixedWidthInteger.&-infix(_:Self,_:Self)
return lhs.subtractingReportingOverflow({}, rhs)["0"]
----Swift.(file).FixedWidthInteger.&-=infix(_:Self,_:Self)
let lhs = lhs$inout.get()
const $result = (() => {
lhs = (lhs).constructor.infix_38_45({}, lhs, rhs);})()
lhs$inout.set(lhs)
return $result
----Swift.(file).FixedWidthInteger.&*infix(_:Self,_:Self)
return lhs.multipliedReportingOverflowBy({}, rhs)["0"]
----Swift.(file).FixedWidthInteger.&*=infix(_:Self,_:Self)
let lhs = lhs$inout.get()
const $result = (() => {
lhs = (lhs).constructor.infix_38_42({}, lhs, rhs);})()
lhs$inout.set(lhs)
return $result
----Swift.(file).UnsignedInteger.magnitude
return this
----Swift.(file).UnsignedInteger.isSigned
return false;
}
static get isSigned() { return this.isSigned$get()
----Swift.(file).UnsignedInteger.init(_:T)
{
if((((function(){throw '!unclarifiedGeneric:T'})()).isSigned)) {
preconditionFileLine({}, () => (source).constructor.infix_62_61({}, source, _create(((function(){throw '!unclarifiedGeneric:T'})()), 'initIntegerLiteral', {}, 0)), () => "Negative value is not representable", '?3', '?3');
}
};
{
if((Int.infix_62_61({}, source.bitWidth, this.constructor.bitWidth))) {
preconditionFileLine({}, () => (source).constructor.infix_60_61({}, source, this.constructor.max), () => "Not enough bits to represent the passed value", '?3', '?3');
}
};
this.initTruncatingIfNeeded({}, source);
return
----Swift.(file).UnsignedInteger.init(exactly:T)
{
if((Bool.infix_38_38({}, ((function(){throw '!unclarifiedGeneric:T'})()).isSigned, () => (source).constructor.infix_60({}, source, _create(((function(){throw '!unclarifiedGeneric:T'})()), 'initIntegerLiteral', {}, 0))))) {
return (this.$failed = true);
}
};
{
if((Bool.infix_38_38({}, Int.infix_62_61({}, source.bitWidth, this.constructor.bitWidth), () => (source).constructor.infix_62({}, source, this.constructor.max)))) {
return (this.$failed = true);
}
};
this.initTruncatingIfNeeded({}, source);
return
----Swift.(file).UnsignedInteger.max
return this.constructor.prefix_126({}, _create(this.constructor, 'initIntegerLiteral', {}, 0));
}
static get max() { return this.max$get()
----Swift.(file).UnsignedInteger.min
return _create(this.constructor, 'initIntegerLiteral', {}, 0);
}
static get min() { return this.min$get()
----Swift.(file).SignedInteger.isSigned
return true;
}
static get isSigned() { return this.isSigned$get()
----Swift.(file).SignedInteger.init(_:T)
{
if((Bool.infix_38_38({}, ((function(){throw '!unclarifiedGeneric:T'})()).isSigned, () => Int.infix_62({}, source.bitWidth, this.constructor.bitWidth)))) {
preconditionFileLine({}, () => (source).constructor.infix_62_61({}, source, this.constructor.min), () => "Not enough bits to represent a signed value", '?3', '?3');
}
};
{
if((Bool.infix_124_124({}, Int.infix_62({}, source.bitWidth, this.constructor.bitWidth), () => Bool.infix_38_38({}, Int.infix_61_61({}, source.bitWidth, this.constructor.bitWidth), () => Bool.prefix_33({}, ((function(){throw '!unclarifiedGeneric:T'})()).isSigned))))) {
preconditionFileLine({}, () => (source).constructor.infix_60_61({}, source, this.constructor.max), () => "Not enough bits to represent the passed value", '?3', '?3');
}
};
this.initTruncatingIfNeeded({}, source);
return
----Swift.(file).SignedInteger.init(exactly:T)
{
if((Bool.infix_38_38({}, Bool.infix_38_38({}, ((function(){throw '!unclarifiedGeneric:T'})()).isSigned, () => Int.infix_62({}, source.bitWidth, this.constructor.bitWidth)), () => (source).constructor.infix_60({}, source, this.constructor.min)))) {
return (this.$failed = true);
}
};
{
if((Bool.infix_38_38({}, Bool.infix_124_124({}, Int.infix_62({}, source.bitWidth, this.constructor.bitWidth), () => Bool.infix_38_38({}, Int.infix_61_61({}, source.bitWidth, this.constructor.bitWidth), () => Bool.prefix_33({}, ((function(){throw '!unclarifiedGeneric:T'})()).isSigned))), () => (source).constructor.infix_62({}, source, this.constructor.max)))) {
return (this.$failed = true);
}
};
this.initTruncatingIfNeeded({}, source);
return
----Swift.(file).SignedInteger.max
return this.constructor.prefix_126({}, this.min);
}
static get max() { return this.max$get()
----Swift.(file).SignedInteger.min
return (this.constructor._highBitIndex).constructor.infix_38_60_60({}, _create(this.constructor, 'initIntegerLiteral', {}, -1), this.constructor._highBitIndex);
}
static get min() { return this.min$get()
----Swift.(file).SignedInteger.isMultiple(of:Self)
{
if(((other).constructor.infix_61_61({}, other, 0))) {
return (this).constructor.infix_61_61({}, this, 0);
}
};
{
if(((other).constructor.infix_61_61({}, other, -1))) {
return true;
}
};
return ((this).constructor.infix_37({}, this, other)).constructor.infix_61_61({}, (this).constructor.infix_37({}, this, other), 0)
----Swift.(file).numericCast(_:T)
return _create(((function(){throw '!unclarifiedGeneric:U'})()), 'init', {}, x)
----Swift.(file).FixedWidthInteger.>>infix(_:Self,_:Self)
let lhs_dupl = lhs;
this._nonMaskingRightShiftGeneric({}, {get: () => lhs_dupl, set: $val => lhs_dupl = $val}, rhs);
return lhs_dupl
----Swift.(file).FixedWidthInteger.>>=infix(_:Self,_:Self)
let lhs = lhs$inout.get()
const $result = (() => {
this._nonMaskingRightShiftGeneric({}, {get: () => lhs, set: $val => lhs = $val}, rhs);})()
lhs$inout.set(lhs)
return $result
----Swift.(file).FixedWidthInteger.<<infix(_:Self,_:Self)
let lhs_dupl = lhs;
this._nonMaskingLeftShiftGeneric({}, {get: () => lhs_dupl, set: $val => lhs_dupl = $val}, rhs);
return lhs_dupl
----Swift.(file).FixedWidthInteger.<<=infix(_:Self,_:Self)
let lhs = lhs$inout.get()
const $result = (() => {
this._nonMaskingLeftShiftGeneric({}, {get: () => lhs, set: $val => lhs = $val}, rhs);})()
lhs$inout.set(lhs)
return $result
----Swift.(file).FixedWidthInteger.addWithOverflow(_:Self,_:Self)
const $tuple = lhs.addingReportingOverflow({}, rhs), partialValue = $tuple && $tuple[0], overflow = $tuple && $tuple[1];
return {0: partialValue, 1: overflow}
----Swift.(file).FixedWidthInteger.subtractWithOverflow(_:Self,_:Self)
const $tuple = lhs.subtractingReportingOverflow({}, rhs), partialValue = $tuple && $tuple[0], overflow = $tuple && $tuple[1];
return {0: partialValue, 1: overflow}
----Swift.(file).FixedWidthInteger.multiplyWithOverflow(_:Self,_:Self)
const $tuple = lhs.multipliedReportingOverflowBy({}, rhs), partialValue = $tuple && $tuple[0], overflow = $tuple && $tuple[1];
return {0: partialValue, 1: overflow}
----Swift.(file).FixedWidthInteger.divideWithOverflow(_:Self,_:Self)
const $tuple = lhs.dividedReportingOverflowBy({}, rhs), partialValue = $tuple && $tuple[0], overflow = $tuple && $tuple[1];
return {0: partialValue, 1: overflow}
----Swift.(file).FixedWidthInteger.remainderWithOverflow(_:Self,_:Self)
const $tuple = lhs.remainderReportingOverflowDividingBy({}, rhs), partialValue = $tuple && $tuple[0], overflow = $tuple && $tuple[1];
return {0: partialValue, 1: overflow}
----Swift.(file).BinaryInteger.addWithOverflow(_:Self,_:Self)
fatalErrorFileLine({}, () => "Unavailable", '?3', '?3')
----Swift.(file).BinaryInteger.subtractWithOverflow(_:Self,_:Self)
fatalErrorFileLine({}, () => "Unavailable", '?3', '?3')
----Swift.(file).BinaryInteger.multiplyWithOverflow(_:Self,_:Self)
fatalErrorFileLine({}, () => "Unavailable", '?3', '?3')
----Swift.(file).BinaryInteger.divideWithOverflow(_:Self,_:Self)
fatalErrorFileLine({}, () => "Unavailable", '?3', '?3')
----Swift.(file).BinaryInteger.remainderWithOverflow(_:Self,_:Self)
fatalErrorFileLine({}, () => "Unavailable", '?3', '?3')
----Swift.(file).SignedInteger.&+infix(_:Self,_:Self)
return this._maskingAdd({}, lhs, rhs)
----Swift.(file).SignedInteger.&-infix(_:Self,_:Self)
return this._maskingSubtract({}, lhs, rhs)
----Swift.(file).SignedInteger.&+infix(_:Self,_:Self)
return this._maskingAdd({}, lhs, rhs)
----Swift.(file).SignedInteger.&-infix(_:Self,_:Self)
return this._maskingSubtract({}, lhs, rhs)
----Swift.(file).JoinedSequence.init(base:Base,separator:Separator)
this._base = base;
this._separator = _create(ContiguousArray, 'initBuffer', {}, separator);
return
----Swift.(file).JoinedSequence.Iterator.init(base:Base.Iterator,separator:Separator)
this._base = base;
this._separatorData = _create(ContiguousArray, 'initBuffer', {}, separator);
return
----Swift.(file).JoinedSequence.Iterator.next()
while(true){
if(!((true))) break
const $match = this._state
if((($match.rawValue == JoinedSequence.Iterator._JoinIteratorState.start.rawValue))) {
{const $ifLet0 = this._base.next({$setThis: $val => this._base = $val}, )
if($ifLet0.rawValue === 'some') {
let nextSubSequence = $ifLet0[0]
this._inner = _injectIntoOptional(nextSubSequence.makeIterator({}, ));
this._state = JoinedSequence.Iterator._JoinIteratorState.generatingElements;
}
else {
this._state = JoinedSequence.Iterator._JoinIteratorState.end;
return Optional.none;
}
};
}
else if((($match.rawValue == JoinedSequence.Iterator._JoinIteratorState.generatingElements.rawValue))) {
const result = this._inner[0].next({$setThis: $val => this._inner[0] = $val}, );
{
if((_fastPath({}, Optional.wrappedNotEqualsOptionalNilComparisonType({}, result, _create(_OptionalNilComparisonType, 'initNilLiteraltuple_type', {}, {}))))) {
return result;
}
};
this._inner = _injectIntoOptional(((_.tmp0 = this._base.next({$setThis: $val => this._base = $val}, )).rawValue === 'some') ? (_.tmp0[0].makeIterator({}, )) : null);
{
if((Optional.wrappedEqualsOptionalNilComparisonType({}, this._inner, _create(_OptionalNilComparisonType, 'initNilLiteraltuple_type', {}, {})))) {
this._state = JoinedSequence.Iterator._JoinIteratorState.end;
return Optional.none;
}
};
{
if((Bool.prefix_33({}, this._separatorData.isEmpty))) {
this._separator = _injectIntoOptional(this._separatorData.makeIterator({}, ));
this._state = JoinedSequence.Iterator._JoinIteratorState.generatingSeparator;
}
};
}
else if((($match.rawValue == JoinedSequence.Iterator._JoinIteratorState.generatingSeparator.rawValue))) {
const result = this._separator[0].next({$setThis: $val => this._separator[0] = $val}, );
{
if((_fastPath({}, Optional.wrappedNotEqualsOptionalNilComparisonType({}, result, _create(_OptionalNilComparisonType, 'initNilLiteraltuple_type', {}, {}))))) {
return result;
}
};
this._state = JoinedSequence.Iterator._JoinIteratorState.generatingElements;
}
else if((($match.rawValue == JoinedSequence.Iterator._JoinIteratorState.end.rawValue))) {
return Optional.none;
};
}
----Swift.(file).JoinedSequence.makeIterator()
return _create(JoinedSequence.Iterator, 'initBaseSeparator', {}, this._base.makeIterator({}, ), this._separator)
----Swift.(file).Sequence.joined(separator:Separator)
return _create(JoinedSequence, 'initBaseSeparator', {}, this, separator)
----Swift.(file).AnyKeyPath.rootType
return this._rootAndValueType["0"];
}
static get rootType() { return this.rootType$get()
----Swift.(file).AnyKeyPath.valueType
return this._rootAndValueType["1"];
}
static get valueType() { return this.valueType$get()
----Swift.(file).AnyKeyPath.hashValue
return _hashValueFor({}, this)
----Swift.(file).AnyKeyPath.hash(into:Hasher)
let hasher = hasher$inout.get()
const $result = (() => {
_create(ObjectIdentifier, 'initprotocol_composition_type', {}, AnyKeyPath).hashInto({}, {get: () => hasher, set: $val => hasher = $val});
return this.withBuffer({}, (($info, $0) => { 
let buffer = _cloneStruct($0);
{
if((buffer.data.isEmpty)) {
return ;
}
};
while(true){
if(!((true))) break
const $tuple = buffer.next({$setThis: $val => buffer = $val}, ), component = $tuple && $tuple[0], type = $tuple && $tuple[1];
hasher.combine({$setThis: $val => hasher = $val}, component.value);
{const $ifLet0 = type
if($ifLet0.rawValue === 'some') {
let type = $ifLet0[0]
hasher.combine({$setThis: $val => hasher = $val}, unsafeBitCastTo({}, type, Int));
}
else {
break;
}
};
}; }));})()
hasher$inout.set(hasher)
return $result
----Swift.(file).AnyKeyPath.==infix(_:AnyKeyPath,_:AnyKeyPath)
{
if((infix_61_61_61({}, _injectIntoOptional(a), _injectIntoOptional(b)))) {
return true;
}
};
{
if((infix_33_61({}, _injectIntoOptional(AnyKeyPath), _injectIntoOptional(AnyKeyPath)))) {
return false;
}
};
return a.withBuffer({}, (($info, $0) => { 
let aBuffer = _cloneStruct($0);
return b.withBuffer({}, (($info, $0) => { 
let bBuffer = _cloneStruct($0);
{
if((Bool.infix_33_61({}, aBuffer.hasReferencePrefix, bBuffer.hasReferencePrefix))) {
return false;
}
};
{
if((aBuffer.data.isEmpty)) {
return bBuffer.data.isEmpty;
}
};
while(true){
if(!((true))) break
const $tuple = aBuffer.next({$setThis: $val => aBuffer = $val}, ), aComponent = $tuple && $tuple[0], aType = $tuple && $tuple[1];
const $tuple = bBuffer.next({$setThis: $val => bBuffer = $val}, ), bComponent = $tuple && $tuple[0], bType = $tuple && $tuple[1];
{
if((Bool.infix_124_124({}, Bool.infix_124_124({}, Bool.infix_33_61({}, aComponent.header.endOfReferencePrefix, bComponent.header.endOfReferencePrefix), () => KeyPathComponent.infix_33_61({}, aComponent.value, bComponent.value)), () => infix_33_61({}, aType, bType)))) {
return false;
}
};
{
if((infix_61_61({}, aType, Optional.none))) {
return true;
}
};
}; })); }))
----Swift.(file).KeyPath.kind
return KeyPath.Kind.readOnly;
}
static get kind() { return this.kind$get()
----Swift.(file).KeyPath.appendedType(with:KeyPath<Value, AppendedValue>.Type)
const resultKind;
const $match = {0: this.kind, 1: t.kind}
if((($match[1].rawValue == KeyPath.Kind.reference.rawValue))) {
resultKind = KeyPath.Kind.reference;
}
else if((($match[1].rawValue == KeyPath.Kind.value.rawValue))) {
const x = $match[0]
resultKind = x;
}
else if(((true))) {
resultKind = KeyPath.Kind.readOnly;
};
const $match = resultKind
if((($match.rawValue == KeyPath.Kind.readOnly.rawValue))) {
return KeyPath;
}
else if((($match.rawValue == KeyPath.Kind.value.rawValue))) {
return WritableKeyPath;
}
else if((($match.rawValue == KeyPath.Kind.reference.rawValue))) {
return ReferenceWritableKeyPath;
}
----Swift.(file).KeyPathComputedArgumentLayoutFn
const KeyPathComputedArgumentLayoutFn = '?function_type
----Swift.(file).KeyPathComputedArgumentInitializerFn
const KeyPathComputedArgumentInitializerFn = '?function_type
----Swift.(file)._AppendKeyPath.appending(path:AnyKeyPath)
return _tryToAppendKeyPathsRootLeaf({}, this, path)
----Swift.(file)._AppendKeyPath.appending(path:AnyKeyPath)
return _tryToAppendKeyPathsRootLeaf({}, /*derived_to_base_expr*/this, path)
----Swift.(file)._AppendKeyPath.appending(path:KeyPath<AppendedRoot, AppendedValue>)
return _tryToAppendKeyPathsRootLeaf({}, /*derived_to_base_expr*/this, /*derived_to_base_expr*/path)
----Swift.(file)._AppendKeyPath.appending(path:ReferenceWritableKeyPath<AppendedRoot, AppendedValue>)
return _tryToAppendKeyPathsRootLeaf({}, /*derived_to_base_expr*/this, /*derived_to_base_expr*/path)
----Swift.(file)._AppendKeyPath.appending(path:KeyPath<Value, AppendedValue>)
return _appendingKeyPathsRootLeaf({}, /*archetype_to_super_expr*/this, path)
----Swift.(file)._AppendKeyPath.appending(path:ReferenceWritableKeyPath<Value, AppendedValue>)
return _appendingKeyPathsRootLeaf({}, this, /*derived_to_base_expr*/path)
----Swift.(file)._AppendKeyPath.appending(path:WritableKeyPath<Value, AppendedValue>)
return _appendingKeyPathsRootLeaf({}, /*derived_to_base_expr*/this, /*derived_to_base_expr*/path)
----Swift.(file)._AppendKeyPath.appending(path:ReferenceWritableKeyPath<Value, AppendedValue>)
return _appendingKeyPathsRootLeaf({}, /*derived_to_base_expr*/this, /*derived_to_base_expr*/path)
----Swift.(file)._AppendKeyPath.appending(path:WritableKeyPath<Value, AppendedValue>)
return _appendingKeyPathsRootLeaf({}, /*derived_to_base_expr*/this, /*derived_to_base_expr*/path)
----Swift.(file).keyPathPatternHeaderSize
let keyPathPatternHeaderSize
----Swift.(file).KeyValuePairs.startIndex
return 0
----Swift.(file).KeyValuePairs.endIndex
return this._elements.endIndex
----Swift.(file).KeyValuePairs.subscript(_:KeyValuePairs<Key, Value>.Index)
return this._elements.subscript$get({}, position)
----Swift.(file).KeyValuePairs.description
return this._makeKeyValuePairDescriptionWithTypeName({}, nil/*!default_value*/)
----Swift.(file).KeyValuePairs.debugDescription
return this._makeKeyValuePairDescriptionWithTypeName({}, nil/*!default_value*/)
----Swift.(file).LazyCollectionProtocol.lazy
return this._elements.lazy
----Swift.(file).LazyCollectionProtocol.lazy
return this._elements
----Swift.(file).LazyCollection
const LazyCollection = LazySequenc
----Swift.(file).LazyCollection.startIndex
return this._base.startIndex
----Swift.(file).LazyCollection.endIndex
return this._base.endIndex
----Swift.(file).LazyCollection.indices
return this._base.indices
----Swift.(file).LazyCollection.index(after:LazySequence<Base>.Index)
return this._base.indexAfter({}, i)
----Swift.(file).LazyCollection.subscript(_:LazySequence<Base>.Index)
return this._base.subscript$get({}, position)
----Swift.(file).LazyCollection.isEmpty
return this._base.isEmpty
----Swift.(file).LazyCollection.count
return this._base.count
----Swift.(file).LazyCollection.index(_:LazySequence<Base>.Index,offsetBy:Int)
return this._base.indexOffsetBy({}, i, n)
----Swift.(file).LazyCollection.index(_:LazySequence<Base>.Index,offsetBy:Int,limitedBy:LazySequence<Base>.Index)
return this._base.indexOffsetByLimitedBy({}, i, n, limit)
----Swift.(file).LazyCollection.distance(from:LazySequence<Base>.Index,to:LazySequence<Base>.Index)
return this._base.distanceFromTo({}, start, end)
----Swift.(file).LazyCollection.index(before:LazySequence<Base>.Index)
return this._base.indexBefore({}, i)
----Swift.(file).LazySequenceProtocol.lazy
return this._elements.lazy
----Swift.(file).LazySequenceProtocol.lazy
return this._elements
----Swift.(file).LazySequence.init(_base:Base)
this._base = _base;
return
----Swift.(file).LazySequence.makeIterator()
return this._base.makeIterator({}, )
----Swift.(file).LazySequence.underestimatedCount
return this._base.underestimatedCount
----Swift.(file).Sequence.lazy
return _create(LazySequence, 'init_base', {}, this)
----Swift.(file).withExtendedLifetime(_:T,_:() throws -> Result)
let $defer = () => {
_fixLifetime({}, x);
}
try {;
return body({}, );}catch($error){$defer({}, );throw $error}$defer({}, )
----Swift.(file).withExtendedLifetime(_:T,_:(T) throws -> Result)
let $defer = () => {
_fixLifetime({}, x);
}
try {;
return body({}, x);}catch($error){$defer({}, );throw $error}$defer({}, )
----Swift.(file).ManagedBuffer.withUnsafeMutablePointerToHeader(_:(UnsafeMutablePointer<Header>) throws -> R)
return this.withUnsafeMutablePointers({}, (($info, v, _) => body({}, v)))
----Swift.(file).ManagedBuffer.withUnsafeMutablePointerToElements(_:(UnsafeMutablePointer<Element>) throws -> R)
return this.withUnsafeMutablePointers({}, (($info, $0, $1) => body({}, $1)))
----Swift.(file).ManagedBuffer.withUnsafeMutablePointers(_:(UnsafeMutablePointer<Header>, UnsafeMutablePointer<Element>) throws -> R)
let $defer = () => {
_fixLifetime({}, this);
}
try {;
return body({}, this.headerAddress, this.firstElementAddress);}catch($error){$defer({}, );throw $error}$defer({}, )
----Swift.(file).tryReallocateUniquelyReferenced(buffer:Buffer,newMinimumCapacity:Int)
let buffer = buffer$inout.get()
const $result = (() => {
preconditionFileLine({}, () => _isBitwiseTakable({}, ((function(){throw '!unclarifiedGeneric:Header'})())), () => String()/*!default_value*/, '?3', '?3');
preconditionFileLine({}, () => _isBitwiseTakable({}, ((function(){throw '!unclarifiedGeneric:Element'})())), () => String()/*!default_value*/, '?3', '?3');
preconditionFileLine({}, () => isKnownUniquelyReferenced({}, {get: () => buffer, set: $val => buffer = $val}), () => String()/*!default_value*/, '?3', '?3');
const newSizeInBytes = Int.infix_43({}, MemoryLayout.stride, Int.infix_42({}, newMinimumCapacity, MemoryLayout.stride));
return withUnsafeMutablePointerTo({}, {get: () => buffer, set: $val => buffer = $val}, (($info, $0) => $0.withMemoryReboundToCapacity({}, UnsafeMutableRawPointer, 1, (($info, $0) => { 
{const $ifLet0 = _reallocObject({}, $0.pointee, newSizeInBytes)
if($ifLet0.rawValue === 'some') {
let reallocdObject = $ifLet0[0]
$0.pointee = _cloneStruct(reallocdObject);
return true;
}
else {
return false;
}
}; }))));})()
buffer$inout.set(buffer)
return $result
----Swift.(file).ManagedBufferPointer.init(bufferClass:AnyClass,minimumCapacity:Int,makingHeaderWith:(AnyObject, (AnyObject) -> Int) throws -> Header)
$info.$setThis(_cloneStruct(_create(ManagedBufferPointer, 'initBufferClassAnyClassMinimumCapacityInt', {}, bufferClass, minimumCapacity)));
this.withUnsafeMutablePointerToHeader({}, (($info, $0) => $0.initializeTo({}, factory({}, this.buffer, (($info, $0) => _create(ManagedBufferPointer, 'initUnsafeBufferObjectAnyObject', {}, $0).capacity)))));
_.discardAssignment = this.header;
return
----Swift.(file).ManagedBufferPointer.init(bufferClass:AnyClass,minimumCapacity:Int)
ManagedBufferPointer._checkValidBufferClassCreating({}, bufferClass, true);
preconditionFileLine({}, () => Int.infix_62_61({}, minimumCapacity, 0), () => "ManagedBufferPointer must have non-negative capacity", '?3', '?3');
this.init_uncheckedBufferClassAnyClassMinimumCapacityInt({}, bufferClass, minimumCapacity);
return
----Swift.(file).ManagedBufferPointer.header
 return this.header$internal
----Swift.(file).ManagedBufferPointer.capacity
return Int.infix_47({}, Int.infix_38_45({}, this._capacityInBytes, ManagedBufferPointer._elementOffset), MemoryLayout.stride)
----Swift.(file).ManagedBufferPointer.withUnsafeMutablePointerToHeader(_:(UnsafeMutablePointer<Header>) throws -> R)
return this.withUnsafeMutablePointers({}, (($info, v, _) => body({}, v)))
----Swift.(file).ManagedBufferPointer.withUnsafeMutablePointerToElements(_:(UnsafeMutablePointer<Element>) throws -> R)
return this.withUnsafeMutablePointers({}, (($info, $0, $1) => body({}, $1)))
----Swift.(file).ManagedBufferPointer.withUnsafeMutablePointers(_:(UnsafeMutablePointer<Header>, UnsafeMutablePointer<Element>) throws -> R)
let $defer = () => {
_fixLifetime({}, this._nativeBuffer);
}
try {;
return body({}, this._headerPointer, this._elementPointer);}catch($error){$defer({}, );throw $error}$defer({}, )
----Swift.(file).ManagedBufferPointer.isUniqueReference()
return _isUnique({}, {get: () => this._nativeBuffer, set: $val => this._nativeBuffer = $val})
----Swift.(file).ManagedBufferPointer.==infix(_:ManagedBufferPointer<Header, Element>,_:ManagedBufferPointer<Header, Element>)
return UnsafeMutableRawPointer.infix_61_61({}, lhs._address, rhs._address)
----Swift.(file).isKnownUniquelyReferenced(_:T)
let object = object$inout.get()
const $result = (() => {
return _isUnique({}, {get: () => object, set: $val => object = $val});})()
object$inout.set(object)
return $result
----Swift.(file).isKnownUniquelyReferenced(_:T?)
let object = object$inout.get()
const $result = (() => {
return _isUnique({}, {get: () => object, set: $val => object = $val});})()
object$inout.set(object)
return $result
----Swift.(file).LazyMapSequence.Iterator.base
return this._base
----Swift.(file).LazyMapSequence.Iterator.next()
return this._base.next({$setThis: $val => this._base = $val}, ).mapSwift({}, this._transform)
----Swift.(file).LazyMapSequence.makeIterator()
return _create(LazyMapSequence.Iterator, 'init_base_transformfunction_type', {}, this._base.makeIterator({}, ), this._transform)
----Swift.(file).LazyMapSequence.underestimatedCount
return this._base.underestimatedCount
----Swift.(file).LazyMapCollection
const LazyMapCollection = LazyMapSequenc
----Swift.(file).LazyMapCollection.startIndex
return this._base.startIndex
----Swift.(file).LazyMapCollection.endIndex
return this._base.endIndex
----Swift.(file).LazyMapCollection.index(after:LazyMapSequence<Base, Element>.Index)
return this._base.indexAfter({}, i)
----Swift.(file).LazyMapCollection.formIndex(after:LazyMapSequence<Base, Element>.Index)
let i = i$inout.get()
const $result = (() => {
this._base.formIndexAfter({}, {get: () => i, set: $val => i = $val});})()
i$inout.set(i)
return $result
----Swift.(file).LazyMapCollection.subscript(_:Base.Index)
return this._transform({}, this._base.subscript$get({}, position))
----Swift.(file).LazyMapCollection.subscript(_:Range<Base.Index>)
return _create(LazyMapSequence.SubSequence, 'init_baseTransformfunction_type', {}, this._base.subscriptRange$get({}, bounds), this._transform)
----Swift.(file).LazyMapCollection.indices
return this._base.indices
----Swift.(file).LazyMapCollection.isEmpty
return this._base.isEmpty
----Swift.(file).LazyMapCollection.count
return this._base.count
----Swift.(file).LazyMapCollection.index(_:LazyMapSequence<Base, Element>.Index,offsetBy:Int)
return this._base.indexOffsetBy({}, i, n)
----Swift.(file).LazyMapCollection.index(_:LazyMapSequence<Base, Element>.Index,offsetBy:Int,limitedBy:LazyMapSequence<Base, Element>.Index)
return this._base.indexOffsetByLimitedBy({}, i, n, limit)
----Swift.(file).LazyMapCollection.distance(from:LazyMapSequence<Base, Element>.Index,to:LazyMapSequence<Base, Element>.Index)
return this._base.distanceFromTo({}, start, end)
----Swift.(file).LazyMapCollection.index(before:LazyMapSequence<Base, Element>.Index)
return this._base.indexBefore({}, i)
----Swift.(file).LazyMapCollection.formIndex(before:LazyMapSequence<Base, Element>.Index)
let i = i$inout.get()
const $result = (() => {
this._base.formIndexBefore({}, {get: () => i, set: $val => i = $val});})()
i$inout.set(i)
return $result
----Swift.(file).LazySequenceProtocol.map(_:(Self.Element) -> U)
return _create(LazyMapSequence, 'init_baseTransformfunction_type', {}, this._elements, transform)
----Swift.(file).LazyMapSequence.map(_:(Element) -> ElementOfResult)
return _create(LazyMapSequence, 'init_baseTransformfunction_type', {}, this._base, (($info, $0) => transform({}, this._transform({}, $0))))
----Swift.(file).LazyMapCollection.map(_:(Element) -> ElementOfResult)
return _create(LazyMapCollection, 'init_baseTransformfunction_type', {}, this._base, (($info, $0) => transform({}, this._transform({}, $0))))
----Swift.(file).MemoryLayout.size(ofValue:T)
return MemoryLayout.size
----Swift.(file).MemoryLayout.stride(ofValue:T)
return MemoryLayout.stride
----Swift.(file).MemoryLayout.alignment(ofValue:T)
return MemoryLayout.alignment
----Swift.(file).MemoryLayout.offset(of:PartialKeyPath<T>)
return /*derived_to_base_expr*/key._storedInlineOffset
----Swift.(file).ReversedRandomAccessCollection
const ReversedRandomAccessCollection = ReversedCollectio
----Swift.(file).ReversedIndex
const ReversedIndex = ReversedCollectio
----Swift.(file).ImplicitlyUnwrappedOptional
const ImplicitlyUnwrappedOptional = Optiona
----Swift.(file).Range.init(_:Range<Bound>)
$info.$setThis(_cloneStruct(_cloneStruct(other)));
return
----Swift.(file).ClosedRange.init(_:ClosedRange<Bound>)
$info.$setThis(_cloneStruct(_cloneStruct(other)));
return
----Swift.(file).DictionaryLiteral
const DictionaryLiteral = KeyValuePair
----Swift.(file).LazySequenceProtocol.flatMap(_:(Self.Elements.Element) -> ElementOfResult?)
return this.compactMap({}, transform)
----Swift.(file).String.characters
return this
----Swift.(file).String.withMutableCharacters(_:(inout String) -> R)
return body({}, {get: () => this, set: $val => $info.$setThis(_cloneStruct($val))})
----Swift.(file).String.UnicodeScalarView.customPlaygroundQuickLook
return _PlaygroundQuickLook._text({}, this.description)
----Swift.(file).String.UTF16View.customPlaygroundQuickLook
return _PlaygroundQuickLook._text({}, this.description)
----Swift.(file).String.UTF8View.customPlaygroundQuickLook
return _PlaygroundQuickLook._text({}, this.description)
----Swift.(file).Substring.characters
return this
----Swift.(file).Substring.withMutableCharacters(_:(inout Substring) -> R)
return body({}, {get: () => this, set: $val => $info.$setThis(_cloneStruct($val))})
----Swift.(file).Substring.customPlaygroundQuickLook
return _create(String, 'initSubstring', {}, this).customPlaygroundQuickLook
----Swift.(file).Collection.index(_:Self.Index,offsetBy:T)
return this.indexOffsetBy({}, i, _create(Int, 'init', {}, n))
----Swift.(file).Collection.formIndex(_:Self.Index,offsetBy:T)
let i = i$inout.get()
const $result = (() => {
return this.formIndexOffsetBy({}, {get: () => i, set: $val => i = $val}, _create(Int, 'init', {}, n));})()
i$inout.set(i)
return $result
----Swift.(file).Collection.index(_:Self.Index,offsetBy:T,limitedBy:Self.Index)
return this.indexOffsetByLimitedBy({}, i, _create(Int, 'init', {}, n), limit)
----Swift.(file).Collection.formIndex(_:Self.Index,offsetBy:T,limitedBy:Self.Index)
let i = i$inout.get()
const $result = (() => {
return this.formIndexOffsetByLimitedBy({}, {get: () => i, set: $val => i = $val}, _create(Int, 'init', {}, n), limit);})()
i$inout.set(i)
return $result
----Swift.(file).Collection.distance(from:Self.Index,to:Self.Index)
return numericCast({}, this.distanceFromTo({}, start, end))
----Swift.(file).UnsafeMutablePointer.initialize(to:Pointee,count:Int)
this.initializeRepeatingCount({}, newValue, count)
----Swift.(file).UnsafeMutablePointer.deinitialize()
return this.deinitializeCount({}, 1)
----Swift.(file).UnsafeMutablePointer.deallocate(capacity:Int)
this.deallocate({}, )
----Swift.(file).UnsafeMutablePointer.initialize(from:C)
const buf = _create(UnsafeMutableBufferPointer, 'initStartOptionalCountInt', {}, _injectIntoOptional(/*pointer_to_pointer*/this), numericCast({}, source.count));
let $tuple = source._copyContentsInitializing({}, buf), remainders = $tuple && $tuple[0], writtenUpTo = $tuple && $tuple[1];
preconditionFileLine({}, () => Optional.wrappedEqualsOptionalNilComparisonType({}, remainders.next({$setThis: $val => remainders = $val}, ), _create(_OptionalNilComparisonType, 'initNilLiteraltuple_type', {}, {})), () => "rhs underreported its count", '?3', '?3');
preconditionFileLine({}, () => Int.infix_61_61({}, writtenUpTo, buf.endIndex), () => "rhs overreported its count", '?3', '?3')
----Swift.(file).UnsafeRawPointer.customPlaygroundQuickLook
return _PlaygroundQuickLook._text({}, this.summary)
----Swift.(file).UnsafeMutableRawPointer.customPlaygroundQuickLook
return _PlaygroundQuickLook._text({}, this.summary)
----Swift.(file).UnsafePointer.customPlaygroundQuickLook
return PlaygroundQuickLook._text({}, this.summary)
----Swift.(file).UnsafeMutablePointer.customPlaygroundQuickLook
return PlaygroundQuickLook._text({}, this.summary)
----Swift.(file).UnsafeMutableRawPointer.allocate(bytes:Int,alignedTo:Int)
return UnsafeMutableRawPointer.allocateByteCountAlignment({}, size, alignment)
----Swift.(file).UnsafeMutableRawPointer.deallocate(bytes:Int,alignedTo:Int)
this.deallocate({}, )
----Swift.(file).UnsafeMutableRawPointer.copyBytes(from:UnsafeRawPointer,count:Int)
this.copyMemoryFromByteCount({}, source, count)
----Swift.(file).UnsafeMutableRawPointer.initializeMemory(as:T.Type,at:Int,count:Int,to:T)
return UnsafeMutableRawPointer.infix_43({}, this, Int.infix_42({}, offset, MemoryLayout.stride)).initializeMemoryAsRepeatingCount({}, type, repeatedValue, count)
----Swift.(file).UnsafeMutableRawPointer.initializeMemory(as:C.Element.Type,from:C)
let ptr = _cloneStruct(this);
{
let $element$generator = source.makeIterator({}, );
while(true) {
const $ifLet0 = $element$generator.next({$setThis: $val => $element$generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
let _element = $ifLet0[0]
ptr.initializeMemoryAsRepeatingCount({}, ((function(){throw '!unclarifiedGeneric:C.Element'})()), _element, 1);
UnsafeMutableRawPointer.infix_43_61({}, {get: () => ptr, set: $val => ptr = $val}, MemoryLayout.stride);
}
};
return _create(UnsafeMutablePointer, 'initRawPointer', {}, this._rawValue)
----Swift.(file).UnsafeMutableRawBufferPointer.allocate(count:Int)
return UnsafeMutableRawBufferPointer.allocateByteCountAlignment({}, count, MemoryLayout.alignment)
----Swift.(file).UnsafeMutableRawBufferPointer.copyBytes(from:UnsafeRawBufferPointer)
this.copyMemoryFrom({}, source)
----Swift.(file).Sequence.flatMap(_:(Self.Element) throws -> ElementOfResult?)
return this._compactMap({}, transform)
----Swift.(file).Sequence.flatMap(_:(Self.Element) throws -> String)
return this.mapSwift({}, transform)
----Swift.(file).Collection.flatMap(_:(Self.Element) throws -> String?)
return this._compactMap({}, transform)
----Swift.(file).Collection.index(where:(Self.Element) throws -> Bool)
return this.firstIndexWhere({}, _predicate)
----Swift.(file).Collection.index(of:Self.Element)
return this.firstIndexOf({}, _element)
----Swift.(file)._PlaygroundQuickLook.init(reflecting:Any)
{const $ifLet0 = _injectIntoOptional(subject)
if($ifLet0.rawValue === 'some') {
let customized = $ifLet0[0]
$info.$setThis(_cloneStruct(customized.customPlaygroundQuickLook));
}
else {
{const $ifLet0 = _injectIntoOptional(subject)
if($ifLet0.rawValue === 'some') {
let customized = $ifLet0[0]
$info.$setThis(_cloneStruct(customized._defaultCustomPlaygroundQuickLook));
}
else {
{const $ifLet0 = Mirror.quickLookObject({}, subject)
if($ifLet0.rawValue === 'some') {
let q = $ifLet0[0]
$info.$setThis(_cloneStruct(q));
}
else {
$info.$setThis(_cloneStruct(_PlaygroundQuickLook._text({}, _create(String, 'initReflecting', {}, subject))));
}
};
}
}
}
};
return
----Swift.(file).MutableCollection.withContiguousMutableStorageIfAvailable(_:(inout UnsafeMutableBufferPointer<Self.Element>) throws -> R)
return Optional.none
----Swift.(file).MutableCollection.subscript(_:Range<Self.Index>)#ASS

_writeBackMutableSliceBoundsSlice({}, {get: () => this, set: $val => $info.$setThis(_cloneStruct($val))}, bounds, newValue)
----Swift.(file).MutableCollection.subscript(_:Range<Self.Index>)
return _create(Slice, 'initBaseBoundsRange', {}, this, bounds);

----Swift.(file).MutableCollection.swapAt(_:Self.Index,_:Self.Index)
{
if(!(((i).constructor.infix_33_61({}, i, j)))) {
return ;
}
};
const tmp = this.subscript$get({}, i);
this.subscript$set({$setThis: $val => $info.$setThis(_cloneStruct($val))}, this.subscript$get({}, j), i);
this.subscript$set({$setThis: $val => $info.$setThis(_cloneStruct($val))}, tmp, j)
----Swift.(file)._NativeDictionary.capacity
return _assumeNonNegative({}, this._storage._capacity)
----Swift.(file)._NativeDictionary.hashTable
return this._storage._hashTable
----Swift.(file)._NativeDictionary.age
return this._storage._age
----Swift.(file)._NativeDictionary.invalidateIndices()
Int32.infix_38_43_61({}, {get: () => this._storage._age, set: $val => this._storage._age = $val}, 1)
----Swift.(file)._NativeDictionary.uncheckedKey(at:<<error type>>)
let $defer = () => {
_fixLifetime({}, this);
}
try {;
return this._keys.subscript$get({}, bucket.offset);}catch($error){$defer({}, );throw $error}$defer({}, )
----Swift.(file)._NativeDictionary.uncheckedValue(at:<<error type>>)
let $defer = () => {
_fixLifetime({}, this);
}
try {;
return this._values.subscript$get({}, bucket.offset);}catch($error){$defer({}, );throw $error}$defer({}, )
----Swift.(file)._NativeDictionary.uncheckedInitialize(at:<<error type>>,toKey:Key,value:Value)
let $defer = () => {
_fixLifetime({}, this);
}
try {;
UnsafeMutablePointer.infix_43({}, this._keys, bucket.offset).initializeTo({}, key);
UnsafeMutablePointer.infix_43({}, this._values, bucket.offset).initializeTo({}, value);}catch($error){$defer({}, );throw $error}$defer({}, )
----Swift.(file)._NativeDictionary.uncheckedDestroy(at:<<error type>>)
let $defer = () => {
_fixLifetime({}, this);
}
try {;
UnsafeMutablePointer.infix_43({}, this._keys, bucket.offset).deinitializeCount({}, 1);
UnsafeMutablePointer.infix_43({}, this._values, bucket.offset).deinitializeCount({}, 1);}catch($error){$defer({}, );throw $error}$defer({}, )
----Swift.(file)._NativeDictionary.hashValue(for:Key)
return key._rawHashValueSeed({}, this._storage._seed)
----Swift.(file)._NativeDictionary.find(_:Key)
return this.findHashValue({}, key, this.hashValueFor({}, key))
----Swift.(file)._NativeDictionary.find(_:Key,hashValue:Int)
const hashTable = _cloneStruct(this.hashTable);
let bucket = _cloneStruct(hashTable.idealBucketForHashValue({}, hashValue));
while(true){
if(!((hashTable._isOccupied({}, bucket)))) break
{
if(((this.uncheckedKeyAt({}, bucket)).constructor.infix_61_61({}, this.uncheckedKeyAt({}, bucket), key))) {
return {0: bucket, 1: true};
}
};
bucket = _cloneStruct(hashTable.bucketWrappedAfter({}, bucket));
};
return {0: bucket, 1: false}
----Swift.(file)._NativeDictionary.resize(capacity:Int)
const capacity = /*dot_syntax_base_ignored*/max({}, capacity, this.capacity);
const newStorage = _DictionaryStorage.resizeOriginalCapacityMove({}, this._storage, capacity, true);
const result = _create(_NativeDictionary, 'init_RawDictionaryStorage', {}, /*derived_to_base_expr*/newStorage);
{
if((Int.infix_62({}, this.count, 0))) {
{
let $bucket$generator = _cloneStruct(this.hashTable.makeIterator({}, ));
while(true) {
const $ifLet0 = $bucket$generator.next({$setThis: $val => $bucket$generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
let bucket = $ifLet0[0]
const key = UnsafeMutablePointer.infix_43({}, this._keys, bucket.offset).move({}, );
const value = UnsafeMutablePointer.infix_43({}, this._values, bucket.offset).move({}, );
result._unsafeInsertNewKeyValue({}, key, value);
}
};
this._storage._hashTable.clear({}, );
this._storage._count = 0;
}
};
this._storage = result._storage
----Swift.(file)._NativeDictionary.copyAndResize(capacity:Int)
const capacity = /*dot_syntax_base_ignored*/max({}, capacity, this.capacity);
const newStorage = _DictionaryStorage.resizeOriginalCapacityMove({}, this._storage, capacity, false);
const result = _create(_NativeDictionary, 'init_RawDictionaryStorage', {}, /*derived_to_base_expr*/newStorage);
{
if((Int.infix_62({}, this.count, 0))) {
{
let $bucket$generator = _cloneStruct(this.hashTable.makeIterator({}, ));
while(true) {
const $ifLet0 = $bucket$generator.next({$setThis: $val => $bucket$generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
let bucket = $ifLet0[0]
result._unsafeInsertNewKeyValue({}, this.uncheckedKeyAt({}, bucket), this.uncheckedValueAt({}, bucket));
}
};
}
};
this._storage = result._storage
----Swift.(file)._NativeDictionary.copy()
const newStorage = _DictionaryStorage.copyOriginal({}, this._storage);
const result = _create(_NativeDictionary, 'init_RawDictionaryStorage', {}, /*derived_to_base_expr*/newStorage);
{
if((Int.infix_62({}, this.count, 0))) {
result.hashTable.copyContentsOf({}, this.hashTable);
result._storage._count = this.count;
{
let $bucket$generator = _cloneStruct(this.hashTable.makeIterator({}, ));
while(true) {
const $ifLet0 = $bucket$generator.next({$setThis: $val => $bucket$generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
let bucket = $ifLet0[0]
const key = this.uncheckedKeyAt({}, bucket);
const value = this.uncheckedValueAt({}, bucket);
result.uncheckedInitializeAtToKeyValue({}, bucket, key, value);
}
};
}
};
this._storage = result._storage
----Swift.(file)._NativeDictionary.ensureUnique(isUnique:Bool,capacity:Int)
{
if((_fastPath({}, Bool.infix_38_38({}, Int.infix_60_61({}, capacity, this.capacity), () => isUnique)))) {
return false;
}
};
{
if((isUnique)) {
this.resizeCapacity({$setThis: $val => $info.$setThis(_cloneStruct($val))}, capacity);
return true;
}
};
{
if((Int.infix_60_61({}, capacity, this.capacity))) {
this.copy({$setThis: $val => $info.$setThis(_cloneStruct($val))}, );
return false;
}
};
this.copyAndResizeCapacity({$setThis: $val => $info.$setThis(_cloneStruct($val))}, capacity);
return true
----Swift.(file)._NativeDictionary.reserveCapacity(_:Int,isUnique:Bool)
_.discardAssignment = this.ensureUniqueIsUniqueCapacity({$setThis: $val => $info.$setThis(_cloneStruct($val))}, isUnique, capacity)
----Swift.(file)._NativeDictionary.validatedBucket(for:<<error type>>)
preconditionFileLine({}, () => Bool.infix_38_38({}, this.hashTable.isOccupied({}, index.bucket), () => Int32.infix_61_61({}, index.age, this.age)), () => "Attempting to access Dictionary elements using an invalid index", '?3', '?3');
return index.bucket
----Swift.(file)._NativeDictionary.validatedBucket(for:Dictionary<Key, Value>.Index)
{
if(!((index._isNative))) {
index._cocoaPath({}, );
const cocoa = _cloneStruct(index._asCocoa);
{
if((Int32.infix_61_61({}, cocoa.age, this.age))) {
const key = _forceBridgeFromObjectiveC({}, cocoa.key, ((function(){throw '!unclarifiedGeneric:Key'})()));
const $tuple = this.find({}, key), bucket = $tuple && $tuple[0], found = $tuple && $tuple[1];
{
if((found)) {
return bucket;
}
};
}
};
preconditionFailureFileLine({}, () => "Attempting to access Dictionary elements using an invalid index", '?3', '?3');
}
};
return this.validatedBucketFor({}, index._asNative)
----Swift.(file)._NativeDictionary.startIndex
const bucket = _cloneStruct(this.hashTable.startBucket);
return _create(_NativeDictionary.Index, 'init_native_HashTableIndex', {}, _create(_HashTable.Index, 'initBucket_HashTableBucketAgeInt32', {}, bucket, this.age))
----Swift.(file)._NativeDictionary.endIndex
const bucket = _cloneStruct(this.hashTable.endBucket);
return _create(_NativeDictionary.Index, 'init_native_HashTableIndex', {}, _create(_HashTable.Index, 'initBucket_HashTableBucketAgeInt32', {}, bucket, this.age))
----Swift.(file)._NativeDictionary.index(after:_NativeDictionary<Key, Value>.Index)
{
if(!((_fastPath({}, index._isNative)))) {
 const _ = _cloneStruct(this.validatedBucketFor({}, index));
const i = _cloneStruct(index._asCocoa);
return _create(_NativeDictionary.Index, 'init_cocoa_CocoaDictionaryIndex', {}, i.dictionary.indexAfter({}, i));
}
};
const bucket = _cloneStruct(this.validatedBucketFor({}, index._asNative));
const next = _cloneStruct(this.hashTable.occupiedBucketAfter({}, bucket));
return _create(_NativeDictionary.Index, 'init_native_HashTableIndex', {}, _create(_HashTable.Index, 'initBucket_HashTableBucketAgeInt32', {}, next, this.age))
----Swift.(file)._NativeDictionary.index(forKey:Key)
{
if((Int.infix_61_61({}, this.count, 0))) {
return Optional.none;
}
};
const $tuple = this.find({}, key), bucket = $tuple && $tuple[0], found = $tuple && $tuple[1];
{
if(!((found))) {
return Optional.none;
}
};
return _injectIntoOptional(_create(_NativeDictionary.Index, 'init_native_HashTableIndex', {}, _create(_HashTable.Index, 'initBucket_HashTableBucketAgeInt32', {}, bucket, this.age)))
----Swift.(file)._NativeDictionary.count
return _assumeNonNegative({}, this._storage._count)
----Swift.(file)._NativeDictionary.contains(_:Key)
return this.find({}, key)["1"]
----Swift.(file)._NativeDictionary.lookup(_:Key)
{
if((Int.infix_61_61({}, this.count, 0))) {
return Optional.none;
}
};
const $tuple = this.find({}, key), bucket = $tuple && $tuple[0], found = $tuple && $tuple[1];
{
if(!((found))) {
return Optional.none;
}
};
return _injectIntoOptional(this.uncheckedValueAt({}, bucket))
----Swift.(file)._NativeDictionary.lookup(_:_NativeDictionary<Key, Value>.Index)
const bucket = _cloneStruct(this.validatedBucketFor({}, index));
const key = this.uncheckedKeyAt({}, bucket);
const value = this.uncheckedValueAt({}, bucket);
return {0: key, 1: value}
----Swift.(file)._NativeDictionary.key(at:_NativeDictionary<Key, Value>.Index)
const bucket = _cloneStruct(this.validatedBucketFor({}, index));
return this.uncheckedKeyAt({}, bucket)
----Swift.(file)._NativeDictionary.value(at:_NativeDictionary<Key, Value>.Index)
const bucket = _cloneStruct(this.validatedBucketFor({}, index));
return this.uncheckedValueAt({}, bucket)
----Swift.(file)._NativeDictionary.subscript(_:Key,isUnique:Bool)
return this.lookup({}, key);
}subscriptIsUnique$_modify($info, key, isUnique){
const $tuple = this.mutatingFindIsUnique({$setThis: $val => $info.$setThis(_cloneStruct($val))}, key, isUnique), bucket = $tuple && $tuple[0], found = $tuple && $tuple[1];
{
if((found)) {
let value = _injectIntoOptional(UnsafeMutablePointer.infix_43({}, this._values, bucket.offset).move({}, ));
let $defer = () => {
{const $ifLet0 = value
if($ifLet0.rawValue === 'some') {
let value = $ifLet0[0]
UnsafeMutablePointer.infix_43({}, this._values, bucket.offset).initializeTo({}, value);
}
else {
UnsafeMutablePointer.infix_43({}, this._keys, bucket.offset).deinitializeCount({}, 1);
this._deleteAt({}, bucket);
}
};
}
try {;
/*yield*/;}catch($error){$defer({}, );throw $error}$defer({}, )
}
else {
let value = Optional.none;
let $defer = () => {
{const $ifLet0 = value
if($ifLet0.rawValue === 'some') {
let value = $ifLet0[0]
this._insertAtKeyValue({}, bucket, key, value);
}
};
}
try {;
/*yield*/;}catch($error){$defer({}, );throw $error}$defer({}, )
}
}
----Swift.(file).KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:Any.Type)
_assertionFailureFlags({}, "Fatal error", (("Duplicate keys of type '") + (keyType) + ("' were found in a Dictionary.\nThis usually means either that the type violates Hashable's requirements, or\nthat members of such a dictionary were mutated after insertion.")), _fatalErrorFlags({}, ))
----Swift.(file)._NativeDictionary.insertNew(key:Key,value:Value)
_.discardAssignment = this.ensureUniqueIsUniqueCapacity({$setThis: $val => $info.$setThis(_cloneStruct($val))}, true, Int.infix_43({}, this.count, 1));
this._unsafeInsertNewKeyValue({}, key, value)
----Swift.(file)._NativeDictionary.mutatingFind(_:Key,isUnique:Bool)
const $tuple = this.find({}, key), bucket = $tuple && $tuple[0], found = $tuple && $tuple[1];
const rehashed = this.ensureUniqueIsUniqueCapacity({$setThis: $val => $info.$setThis(_cloneStruct($val))}, isUnique, Int.infix_43({}, this.count, (found ? 0 : 1)));
{
if(!((rehashed))) {
return {0: bucket, 1: found};
}
};
const $tuple = this.find({}, key), b = $tuple && $tuple[0], f = $tuple && $tuple[1];
{
if((Bool.infix_33_61({}, f, found))) {
KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS({}, ((function(){throw '!unclarifiedGeneric:Key'})()));
}
};
return {0: b, 1: found}
----Swift.(file)._NativeDictionary.updateValue(_:Value,forKey:Key,isUnique:Bool)
const $tuple = this.mutatingFindIsUnique({$setThis: $val => $info.$setThis(_cloneStruct($val))}, key, isUnique), bucket = $tuple && $tuple[0], found = $tuple && $tuple[1];
{
if((found)) {
const oldValue = UnsafeMutablePointer.infix_43({}, this._values, bucket.offset).move({}, );
UnsafeMutablePointer.infix_43({}, this._values, bucket.offset).initializeTo({}, value);
return _injectIntoOptional(oldValue);
}
};
this._insertAtKeyValue({}, bucket, key, value);
return Optional.none
----Swift.(file)._NativeDictionary.setValue(_:Value,forKey:Key,isUnique:Bool)
const $tuple = this.mutatingFindIsUnique({$setThis: $val => $info.$setThis(_cloneStruct($val))}, key, isUnique), bucket = $tuple && $tuple[0], found = $tuple && $tuple[1];
{
if((found)) {
UnsafeMutablePointer.infix_43({}, this._values, bucket.offset).pointee = value;
}
else {
this._insertAtKeyValue({}, bucket, key, value);
}
}
----Swift.(file)._NativeDictionary.swapValuesAt(_:<<error type>>,_:<<error type>>,isUnique:Bool)
const rehashed = this.ensureUniqueIsUniqueCapacity({$setThis: $val => $info.$setThis(_cloneStruct($val))}, isUnique, this.capacity);
const value = UnsafeMutablePointer.infix_43({}, this._values, a.offset).move({}, );
UnsafeMutablePointer.infix_43({}, this._values, a.offset).moveInitializeFromCount({}, UnsafeMutablePointer.infix_43({}, this._values, b.offset), 1);
UnsafeMutablePointer.infix_43({}, this._values, b.offset).initializeTo({}, value)
----Swift.(file)._NativeDictionary.isEqual(to:_NativeDictionary<Key, Value>)
{
if((infix_61_61_61({}, _injectIntoOptional(this._storage), _injectIntoOptional(other._storage)))) {
return true;
}
};
{
if((Int.infix_33_61({}, this.count, other.count))) {
return false;
}
};
{
let $generator = _cloneStruct(this.makeIterator({}, ));
while(true) {
const $ifLet0 = _injectIntoOptional(((_.tmp0 = $generator.next({$setThis: $val => $generator = $val}, )).rawValue === 'some') ? (_.tmp0[0]) : null);
if(!($ifLet0.rawValue === 'some')) break
let key = $ifLet0[0][0], value = $ifLet0[0][1]
const $tuple = other.find({}, key), bucket = $tuple && $tuple[0], found = $tuple && $tuple[1];
{
if(!((found) && ((other.uncheckedValueAt({}, bucket)).constructor.infix_61_61({}, other.uncheckedValueAt({}, bucket), value)))) {
return false;
}
};
}
};
return true
----Swift.(file)._NativeDictionary.isEqual(to:<<error type>>)
{
if((Int.infix_33_61({}, this.count, other.count))) {
return false;
}
};
let $defer = () => {
_fixLifetime({}, this);
}
try {;
{
let $bucket$generator = _cloneStruct(this.hashTable.makeIterator({}, ));
while(true) {
const $ifLet0 = $bucket$generator.next({$setThis: $val => $bucket$generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
let bucket = $ifLet0[0]
const key = this.uncheckedKeyAt({}, bucket);
const value = this.uncheckedValueAt({}, bucket);
{const $ifLet0 = other.lookup({}, _bridgeAnythingToObjectiveC({}, key))
if(!($ifLet0.rawValue === 'some' && ((value).constructor.infix_61_61({}, value, _forceBridgeFromObjectiveC({}, cocoaValue, ((function(){throw '!unclarifiedGeneric:Value'})())))))) {
return false;
}let cocoaValue = $ifLet0[0]
};
}
};
return true;}catch($error){$defer({}, );throw $error}$defer({}, )
----Swift.(file)._NativeDictionary.hashValue(at:<<error type>>)
return this.hashValueFor({}, this.uncheckedKeyAt({}, bucket))
----Swift.(file)._NativeDictionary.moveEntry(from:<<error type>>,to:<<error type>>)
UnsafeMutablePointer.infix_43({}, this._keys, target.offset).moveInitializeFromCount({}, UnsafeMutablePointer.infix_43({}, this._keys, source.offset), 1);
UnsafeMutablePointer.infix_43({}, this._values, target.offset).moveInitializeFromCount({}, UnsafeMutablePointer.infix_43({}, this._values, source.offset), 1)
----Swift.(file)._NativeDictionary.swapEntry(_:<<error type>>,with:<<error type>>)
swap({}, {get: () => this._keys.subscript$get({}, left.offset), set: $val => this._keys.subscript$set({$setThis: $val => this._keys = _cloneStruct($val)}, $val, left.offset)}, {get: () => this._keys.subscript$get({}, right.offset), set: $val => this._keys.subscript$set({$setThis: $val => this._keys = _cloneStruct($val)}, $val, right.offset)});
swap({}, {get: () => this._values.subscript$get({}, left.offset), set: $val => this._values.subscript$set({$setThis: $val => this._values = _cloneStruct($val)}, $val, left.offset)}, {get: () => this._values.subscript$get({}, right.offset), set: $val => this._values.subscript$set({$setThis: $val => this._values = _cloneStruct($val)}, $val, right.offset)})
----Swift.(file)._NativeDictionary.uncheckedRemove(at:<<error type>>,isUnique:Bool)
const rehashed = this.ensureUniqueIsUniqueCapacity({$setThis: $val => $info.$setThis(_cloneStruct($val))}, isUnique, this.capacity);
const oldKey = UnsafeMutablePointer.infix_43({}, this._keys, bucket.offset).move({}, );
const oldValue = UnsafeMutablePointer.infix_43({}, this._values, bucket.offset).move({}, );
this._deleteAt({}, bucket);
return {0: oldKey, 1: oldValue}
----Swift.(file)._NativeDictionary.removeAll(isUnique:Bool)
{
if(!((isUnique))) {
const scale = this._storage._scale;
this._storage = /*derived_to_base_expr*/_DictionaryStorage.allocateScaleAgeSeed({}, scale, Optional.none, Optional.none);
return ;
}
};
{
let $bucket$generator = _cloneStruct(this.hashTable.makeIterator({}, ));
while(true) {
const $ifLet0 = $bucket$generator.next({$setThis: $val => $bucket$generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
let bucket = $ifLet0[0]
UnsafeMutablePointer.infix_43({}, this._keys, bucket.offset).deinitializeCount({}, 1);
UnsafeMutablePointer.infix_43({}, this._values, bucket.offset).deinitializeCount({}, 1);
}
};
this.hashTable.clear({}, );
this._storage._count = 0;
this.invalidateIndices({}, )
----Swift.(file)._NativeDictionary.mapValues(_:(Value) throws -> T)
const resultStorage = _DictionaryStorage.copyOriginal({}, this._storage);
const result = _create(_NativeDictionary, 'init_RawDictionaryStorage', {}, /*derived_to_base_expr*/resultStorage);
{
let $bucket$generator = _cloneStruct(this.hashTable.makeIterator({}, ));
while(true) {
const $ifLet0 = $bucket$generator.next({$setThis: $val => $bucket$generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
let bucket = $ifLet0[0]
const key = this.uncheckedKeyAt({}, bucket);
const value = this.uncheckedValueAt({}, bucket);
result._insertAtKeyValue({}, bucket, key, transform({}, value));
}
};
return result
----Swift.(file)._NativeDictionary.merge(_:S,isUnique:Bool,uniquingKeysWith:(Value, Value) throws -> Value)
let isUnique_dupl = isUnique;
{
let $generator = keysAndValues.makeIterator({}, );
while(true) {
const $ifLet0 = $generator.next({$setThis: $val => $generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
let key = $ifLet0[0][0], value = $ifLet0[0][1]
const $tuple = this.mutatingFindIsUnique({$setThis: $val => $info.$setThis(_cloneStruct($val))}, key, isUnique_dupl), bucket = $tuple && $tuple[0], found = $tuple && $tuple[1];
isUnique_dupl = true;
{
if((found)) {
try {
const newValue = combine({}, this.uncheckedValueAt({}, bucket), value);
this._values.subscript$set({$setThis: $val => this._values = _cloneStruct($val)}, newValue, bucket.offset);
} catch(error) {
if((error instanceof _MergeError && error.rawValue == _MergeError.keyCollision.rawValue)) {
fatalErrorFileLine({}, () => (("Duplicate values for key: '") + (key) + ("'")), '?3', '?3');
}
else throw error
};
}
else {
this._insertAtKeyValue({}, bucket, key, value);
}
};
}
}
----Swift.(file)._NativeDictionary.init(grouping:S,by:(S.Element) throws -> Key)
this.init({}, );
{
let $value$generator = values.makeIterator({}, );
while(true) {
const $ifLet0 = $value$generator.next({$setThis: $val => $value$generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
let value = $ifLet0[0]
const key = keyForValue({}, value);
const $tuple = this.mutatingFindIsUnique({$setThis: $val => $info.$setThis(_cloneStruct($val))}, key, true), bucket = $tuple && $tuple[0], found = $tuple && $tuple[1];
{
if((found)) {
this._values.subscript$get({}, bucket.offset).append({$setThis: $val => this._values.subscript$set({$setThis: $val => this._values = _cloneStruct($val)}, $val, bucket.offset)}, value);
}
else {
this._insertAtKeyValue({}, bucket, key, _create(Array, 'initBuffer', {}, [value]));
}
};
}
};
return
----Swift.(file)._NativeDictionary.makeIterator()
return _create(_NativeDictionary.Iterator, 'init_NativeDictionary', {}, this)
----Swift.(file)._NativeDictionary.Iterator.nextKey()
{const $ifLet0 = this.iterator.next({$setThis: $val => this.iterator = $val}, )
if(!($ifLet0.rawValue === 'some')) {
return Optional.none;
}let index = $ifLet0[0]
};
return _injectIntoOptional(this.base.uncheckedKeyAt({}, index))
----Swift.(file)._NativeDictionary.Iterator.nextValue()
{const $ifLet0 = this.iterator.next({$setThis: $val => this.iterator = $val}, )
if(!($ifLet0.rawValue === 'some')) {
return Optional.none;
}let index = $ifLet0[0]
};
return _injectIntoOptional(this.base.uncheckedValueAt({}, index))
----Swift.(file)._NativeDictionary.Iterator.next()
{const $ifLet0 = this.iterator.next({$setThis: $val => this.iterator = $val}, )
if(!($ifLet0.rawValue === 'some')) {
return Optional.none;
}let index = $ifLet0[0]
};
const key = this.base.uncheckedKeyAt({}, index);
const value = this.base.uncheckedValueAt({}, index);
return _injectIntoOptional({0: key, 1: value})
----Swift.(file)._NativeSet.capacity
return _assumeNonNegative({}, this._storage._capacity)
----Swift.(file)._NativeSet.hashTable
return this._storage._hashTable
----Swift.(file)._NativeSet.age
return this._storage._age
----Swift.(file)._NativeSet.invalidateIndices()
Int32.infix_38_43_61({}, {get: () => this._storage._age, set: $val => this._storage._age = $val}, 1)
----Swift.(file)._NativeSet.uncheckedElement(at:<<error type>>)
let $defer = () => {
_fixLifetime({}, this);
}
try {;
return this._elements.subscript$get({}, bucket.offset);}catch($error){$defer({}, );throw $error}$defer({}, )
----Swift.(file)._NativeSet.uncheckedInitialize(at:<<error type>>,to:Element)
UnsafeMutablePointer.infix_43({}, this._elements, bucket.offset).initializeTo({}, _element)
----Swift.(file)._NativeSet.hashValue(for:Element)
return _element._rawHashValueSeed({}, this._storage._seed)
----Swift.(file)._NativeSet.find(_:Element)
return this.findHashValue({}, _element, this.hashValueFor({}, _element))
----Swift.(file)._NativeSet.find(_:Element,hashValue:Int)
const hashTable = _cloneStruct(this.hashTable);
let bucket = _cloneStruct(hashTable.idealBucketForHashValue({}, hashValue));
while(true){
if(!((hashTable._isOccupied({}, bucket)))) break
{
if(((this.uncheckedElementAt({}, bucket)).constructor.infix_61_61({}, this.uncheckedElementAt({}, bucket), _element))) {
return {0: bucket, 1: true};
}
};
bucket = _cloneStruct(hashTable.bucketWrappedAfter({}, bucket));
};
return {0: bucket, 1: false}
----Swift.(file)._NativeSet.resize(capacity:Int)
const capacity = /*dot_syntax_base_ignored*/max({}, capacity, this.capacity);
const result = _create(_NativeSet, 'init_RawSetStorage', {}, /*derived_to_base_expr*/_SetStorage.resizeOriginalCapacityMove({}, this._storage, capacity, true));
{
if((Int.infix_62({}, this.count, 0))) {
{
let $bucket$generator = _cloneStruct(this.hashTable.makeIterator({}, ));
while(true) {
const $ifLet0 = $bucket$generator.next({$setThis: $val => $bucket$generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
let bucket = $ifLet0[0]
const _element = UnsafeMutablePointer.infix_43({}, this._elements, bucket.offset).move({}, );
result._unsafeInsertNew({}, _element);
}
};
this._storage._hashTable.clear({}, );
this._storage._count = 0;
}
};
this._storage = result._storage
----Swift.(file)._NativeSet.copyAndResize(capacity:Int)
const capacity = /*dot_syntax_base_ignored*/max({}, capacity, this.capacity);
const result = _create(_NativeSet, 'init_RawSetStorage', {}, /*derived_to_base_expr*/_SetStorage.resizeOriginalCapacityMove({}, this._storage, capacity, false));
{
if((Int.infix_62({}, this.count, 0))) {
{
let $bucket$generator = _cloneStruct(this.hashTable.makeIterator({}, ));
while(true) {
const $ifLet0 = $bucket$generator.next({$setThis: $val => $bucket$generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
let bucket = $ifLet0[0]
result._unsafeInsertNew({}, this.uncheckedElementAt({}, bucket));
}
};
}
};
this._storage = result._storage
----Swift.(file)._NativeSet.copy()
const newStorage = _SetStorage.copyOriginal({}, this._storage);
const result = _create(_NativeSet, 'init_RawSetStorage', {}, /*derived_to_base_expr*/newStorage);
{
if((Int.infix_62({}, this.count, 0))) {
result.hashTable.copyContentsOf({}, this.hashTable);
result._storage._count = this.count;
{
let $bucket$generator = _cloneStruct(this.hashTable.makeIterator({}, ));
while(true) {
const $ifLet0 = $bucket$generator.next({$setThis: $val => $bucket$generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
let bucket = $ifLet0[0]
const _element = this.uncheckedElementAt({}, bucket);
result.uncheckedInitializeAtTo({}, bucket, _element);
}
};
}
};
this._storage = result._storage
----Swift.(file)._NativeSet.ensureUnique(isUnique:Bool,capacity:Int)
{
if((_fastPath({}, Bool.infix_38_38({}, Int.infix_60_61({}, capacity, this.capacity), () => isUnique)))) {
return false;
}
};
{
if((isUnique)) {
this.resizeCapacity({$setThis: $val => $info.$setThis(_cloneStruct($val))}, capacity);
return true;
}
};
{
if((Int.infix_60_61({}, capacity, this.capacity))) {
this.copy({$setThis: $val => $info.$setThis(_cloneStruct($val))}, );
return false;
}
};
this.copyAndResizeCapacity({$setThis: $val => $info.$setThis(_cloneStruct($val))}, capacity);
return true
----Swift.(file)._NativeSet.reserveCapacity(_:Int,isUnique:Bool)
_.discardAssignment = this.ensureUniqueIsUniqueCapacity({$setThis: $val => $info.$setThis(_cloneStruct($val))}, isUnique, capacity)
----Swift.(file)._NativeSet.validatedBucket(for:<<error type>>)
preconditionFileLine({}, () => Bool.infix_38_38({}, this.hashTable.isOccupied({}, index.bucket), () => Int32.infix_61_61({}, index.age, this.age)), () => "Attempting to access Set elements using an invalid index", '?3', '?3');
return index.bucket
----Swift.(file)._NativeSet.validatedBucket(for:Set<Element>.Index)
{
if(!((index._isNative))) {
index._cocoaPath({}, );
const cocoa = _cloneStruct(index._asCocoa);
{
if((Int32.infix_61_61({}, cocoa.age, this.age))) {
const _element = _forceBridgeFromObjectiveC({}, cocoa._element, ((function(){throw '!unclarifiedGeneric:Element'})()));
const $tuple = this.find({}, _element), bucket = $tuple && $tuple[0], found = $tuple && $tuple[1];
{
if((found)) {
return bucket;
}
};
}
};
preconditionFailureFileLine({}, () => "Attempting to access Set elements using an invalid index", '?3', '?3');
}
};
return this.validatedBucketFor({}, index._asNative)
----Swift.(file)._NativeSet.startIndex
const bucket = _cloneStruct(this.hashTable.startBucket);
return _create(_NativeSet.Index, 'init_native_HashTableIndex', {}, _create(_HashTable.Index, 'initBucket_HashTableBucketAgeInt32', {}, bucket, this.age))
----Swift.(file)._NativeSet.endIndex
const bucket = _cloneStruct(this.hashTable.endBucket);
return _create(_NativeSet.Index, 'init_native_HashTableIndex', {}, _create(_HashTable.Index, 'initBucket_HashTableBucketAgeInt32', {}, bucket, this.age))
----Swift.(file)._NativeSet.index(after:_NativeSet<Element>.Index)
const bucket = _cloneStruct(this.validatedBucketFor({}, index._asNative));
const next = _cloneStruct(this.hashTable.occupiedBucketAfter({}, bucket));
return _create(_NativeSet.Index, 'init_native_HashTableIndex', {}, _create(_HashTable.Index, 'initBucket_HashTableBucketAgeInt32', {}, next, this.age))
----Swift.(file)._NativeSet.index(for:Element)
{
if((Int.infix_61_61({}, this.count, 0))) {
return Optional.none;
}
};
const $tuple = this.find({}, _element), bucket = $tuple && $tuple[0], found = $tuple && $tuple[1];
{
if(!((found))) {
return Optional.none;
}
};
return _injectIntoOptional(_create(_NativeSet.Index, 'init_native_HashTableIndex', {}, _create(_HashTable.Index, 'initBucket_HashTableBucketAgeInt32', {}, bucket, this.age)))
----Swift.(file)._NativeSet.count
return _assumeNonNegative({}, this._storage._count)
----Swift.(file)._NativeSet.contains(_:Element)
{
if((Int.infix_61_61({}, this.count, 0))) {
return false;
}
};
return this.find({}, member)["1"]
----Swift.(file)._NativeSet.element(at:_NativeSet<Element>.Index)
const bucket = _cloneStruct(this.validatedBucketFor({}, index));
return this.uncheckedElementAt({}, bucket)
----Swift.(file).ELEMENT_TYPE_OF_SET_VIOLATES_HASHABLE_REQUIREMENTS(_:Any.Type)
_assertionFailureFlags({}, "Fatal error", (("Duplicate elements of type '") + (elementType) + ("' were found in a Set.\nThis usually means either that the type violates Hashable's requirements, or\nthat members of such a set were mutated after insertion.")), _fatalErrorFlags({}, ))
----Swift.(file)._NativeSet.insertNew(_:Element,isUnique:Bool)
_.discardAssignment = this.ensureUniqueIsUniqueCapacity({$setThis: $val => $info.$setThis(_cloneStruct($val))}, isUnique, Int.infix_43({}, this.count, 1));
this._unsafeInsertNew({}, _element)
----Swift.(file)._NativeSet.insertNew(_:Element,at:<<error type>>,isUnique:Bool)
let bucket_dupl = _cloneStruct(bucket);
const rehashed = this.ensureUniqueIsUniqueCapacity({$setThis: $val => $info.$setThis(_cloneStruct($val))}, isUnique, Int.infix_43({}, this.count, 1));
{
if((rehashed)) {
const $tuple = this.find({}, _element), b = $tuple && $tuple[0], f = $tuple && $tuple[1];
{
if((f)) {
ELEMENT_TYPE_OF_SET_VIOLATES_HASHABLE_REQUIREMENTS({}, ((function(){throw '!unclarifiedGeneric:Element'})()));
}
};
bucket_dupl = _cloneStruct(b);
}
};
this._unsafeInsertNewAt({}, _element, bucket_dupl)
----Swift.(file)._NativeSet.update(with:Element,isUnique:Bool)
let $tuple = this.find({}, _element), bucket = $tuple && $tuple[0], found = $tuple && $tuple[1];
const rehashed = this.ensureUniqueIsUniqueCapacity({$setThis: $val => $info.$setThis(_cloneStruct($val))}, isUnique, Int.infix_43({}, this.count, (found ? 0 : 1)));
{
if((rehashed)) {
const $tuple = this.find({}, _element), b = $tuple && $tuple[0], f = $tuple && $tuple[1];
{
if((Bool.infix_33_61({}, f, found))) {
ELEMENT_TYPE_OF_SET_VIOLATES_HASHABLE_REQUIREMENTS({}, ((function(){throw '!unclarifiedGeneric:Element'})()));
}
};
bucket = _cloneStruct(b);
}
};
{
if((found)) {
const old = UnsafeMutablePointer.infix_43({}, this._elements, bucket.offset).move({}, );
this.uncheckedInitializeAtTo({}, bucket, _element);
return _injectIntoOptional(old);
}
};
this._unsafeInsertNewAt({}, _element, bucket);
return Optional.none
----Swift.(file)._NativeSet.isEqual(to:_NativeSet<Element>)
{
if((infix_61_61_61({}, _injectIntoOptional(this._storage), _injectIntoOptional(other._storage)))) {
return true;
}
};
{
if((Int.infix_33_61({}, this.count, other.count))) {
return false;
}
};
{
let $member$generator = _cloneStruct(this.makeIterator({}, ));
while(true) {
const $ifLet0 = $member$generator.next({$setThis: $val => $member$generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
let member = $ifLet0[0]
{
if(!((other.find({}, member)["1"]))) {
return false;
}
};
}
};
return true
----Swift.(file)._NativeSet.isEqual(to:<<error type>>)
{
if((Int.infix_33_61({}, this.count, other.count))) {
return false;
}
};
let $defer = () => {
_fixLifetime({}, this);
}
try {;
{
let $bucket$generator = _cloneStruct(this.hashTable.makeIterator({}, ));
while(true) {
const $ifLet0 = $bucket$generator.next({$setThis: $val => $bucket$generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
let bucket = $ifLet0[0]
const key = this.uncheckedElementAt({}, bucket);
const bridgedKey = _cloneStruct(_bridgeAnythingToObjectiveC({}, key));
{
if(!((other.contains({}, bridgedKey)))) {
return false;
}
};
}
};
return true;}catch($error){$defer({}, );throw $error}$defer({}, )
----Swift.(file)._NativeSet.hashValue(at:<<error type>>)
return this.hashValueFor({}, this.uncheckedElementAt({}, bucket))
----Swift.(file)._NativeSet.moveEntry(from:<<error type>>,to:<<error type>>)
UnsafeMutablePointer.infix_43({}, this._elements, target.offset).moveInitializeFromCount({}, UnsafeMutablePointer.infix_43({}, this._elements, source.offset), 1)
----Swift.(file)._NativeSet.uncheckedRemove(at:<<error type>>,isUnique:Bool)
const rehashed = this.ensureUniqueIsUniqueCapacity({$setThis: $val => $info.$setThis(_cloneStruct($val))}, isUnique, this.capacity);
const old = UnsafeMutablePointer.infix_43({}, this._elements, bucket.offset).move({}, );
this._deleteAt({$setThis: $val => $info.$setThis(_cloneStruct($val))}, bucket);
return old
----Swift.(file)._NativeSet.removeAll(isUnique:Bool)
{
if(!((isUnique))) {
const scale = this._storage._scale;
this._storage = /*derived_to_base_expr*/_SetStorage.allocateScaleAgeSeed({}, scale, Optional.none, Optional.none);
return ;
}
};
{
let $bucket$generator = _cloneStruct(this.hashTable.makeIterator({}, ));
while(true) {
const $ifLet0 = $bucket$generator.next({$setThis: $val => $bucket$generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
let bucket = $ifLet0[0]
UnsafeMutablePointer.infix_43({}, this._elements, bucket.offset).deinitializeCount({}, 1);
}
};
this.hashTable.clear({}, );
this._storage._count = 0;
this.invalidateIndices({}, )
----Swift.(file)._NativeSet.makeIterator()
return _create(_NativeSet.Iterator, 'init_NativeSet', {}, this)
----Swift.(file)._NativeSet.Iterator.next()
{const $ifLet0 = this.iterator.next({$setThis: $val => this.iterator = $val}, )
if(!($ifLet0.rawValue === 'some')) {
return Optional.none;
}let index = $ifLet0[0]
};
return _injectIntoOptional(this.base.uncheckedElementAt({}, index))
----Swift.(file)._SwiftNewtypeWrapper.hashValue
return this.rawValue.hashValue
----Swift.(file)._SwiftNewtypeWrapper.hash(into:Hasher)
let hasher = hasher$inout.get()
const $result = (() => {
hasher.combine({$setThis: $val => hasher = $val}, this.rawValue);})()
hasher$inout.set(hasher)
return $result
----Swift.(file)._StringGuts.foreignHasNormalizationBoundary(before:String.Index)
const offset = index.encodedOffset;
{
if((Bool.infix_124_124({}, Int.infix_61_61({}, offset, 0), () => Int.infix_61_61({}, offset, this.count)))) {
return true;
}
};
const scalar = _cloneStruct(this.foreignErrorCorrectedScalarStartingAt({}, index)["0"]);
return scalar._hasNormalizationBoundaryBefore
----Swift.(file).UnsafeBufferPointer.hasNormalizationBoundary(before:Int)
{
if((Bool.infix_124_124({}, Int.infix_61_61({}, index, 0), () => Int.infix_61_61({}, index, this.count)))) {
return true;
}
};
assertFileLine({}, () => Bool.prefix_33({}, _isContinuation({}, this.subscript_unchecked$get({}, index))), () => String()/*!default_value*/, '?3', '?3');
{
if((UInt8.infix_60({}, this.subscript_unchecked$get({}, index), 0xCC))) {
return true;
}
};
const cu = _cloneStruct(_decodeScalarStartingAt({}, this, index)["0"]);
return cu._hasNormalizationBoundaryBefore
----Swift.(file)._SegmentSource.tryFill(into:<<error type>>)
return this.tryFillInto({$setThis: $val => $info.$setThis(_cloneStruct($val))}, _castOutputBufferEndingAt({}, output, _Normalization._SegmentOutputBuffer.capacity/*!default_value*/))
----Swift.(file)._NormalizedUTF8CodeUnitIterator_2.outputBufferThreshold
return Int.infix_45({}, this.outputBuffer.capacity, 4)
----Swift.(file)._NormalizedUTF8CodeUnitIterator_2.outputBufferEmpty
return Int.infix_61_61({}, this.outputPosition, this.outputBufferCount)
----Swift.(file)._NormalizedUTF8CodeUnitIterator_2.outputBufferFull
return Int.infix_62_61({}, this.outputBufferCount, this.outputBufferThreshold)
----Swift.(file)._NormalizedUTF8CodeUnitIterator_2.inputBufferEmpty
return this.gutsSlice.range.isEmpty
----Swift.(file)._NormalizedUTF8CodeUnitIterator_2.fill()
const priorInputCount = this.gutsSlice._offsetRange.count;
this.outputPosition = 0;
const $tuple = this.fastPathFill({$setThis: $val => $info.$setThis(_cloneStruct($val))}, ), inputCount = $tuple && $tuple[0], outputCount = $tuple && $tuple[1];
this.outputBufferCount = outputCount;
{
if((Int.infix_62({}, inputCount, 0))) {
this.gutsSlice._offsetRange = _create(Range, 'initUncheckedBoundstuple_type', {}, {0: Int.infix_43({}, this.gutsSlice._offsetRange.lowerBound, inputCount), 1: this.gutsSlice._offsetRange.upperBound});
return ;
}
};
const remaining = this.gutsSlice.withNFCCodeUnitsIterator({}, (($info, $0) => { 
let nfc = _cloneStruct($0);
while(true){
const $ifLet0 = nfc.next({$setThis: $val => nfc = $val}, )
if(!((Bool.prefix_33({}, this.outputBufferFull)) && $ifLet0.rawValue === 'some')) break
let cu = $ifLet0[0]
this.outputBuffer.subscript$set({$setThis: $val => this.outputBuffer = $val}, cu, this.outputBufferCount);
Int.infix_38_43_61({}, {get: () => this.outputBufferCount, set: $val => this.outputBufferCount = $val}, 1);
};
return nfc.utf16Iterator.source.remaining; }));
{
if((Bool.prefix_33({}, Bool.infix_124_124({}, Int.infix_61_61({}, this.outputBufferCount, 0), () => Int.infix_60({}, remaining, priorInputCount))))) {
}
};
this.gutsSlice._offsetRange = _create(Range, 'initUncheckedBoundstuple_type', {}, {0: Int.infix_43({}, this.gutsSlice._offsetRange.lowerBound, Int.infix_45({}, priorInputCount, remaining)), 1: this.gutsSlice._offsetRange.upperBound})
----Swift.(file)._NormalizedUTF8CodeUnitIterator_2.compare(with:_NormalizedUTF8CodeUnitIterator_2,expecting:<<error type>>)
let mutableOther = _cloneStruct(other);
{
let $cu$generator = _cloneStruct(this.makeIterator({}, ));
while(true) {
const $ifLet0 = $cu$generator.next({$setThis: $val => $cu$generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
let cu = $ifLet0[0]
{const $ifLet0 = mutableOther.next({$setThis: $val => mutableOther = $val}, )
if(!($ifLet0.rawValue === 'some')) {
return false;
}let otherCU = $ifLet0[0]
};
{
if((UInt8.infix_61_61({}, cu, otherCU))) {
continue;
}
};
return (_StringComparisonResult.infix_61_61({}, expecting, _StringComparisonResult.less) ? UInt8.infix_60({}, cu, otherCU) : false);
}
};
return (Optional.wrappedEqualsOptionalNilComparisonType({}, mutableOther.next({$setThis: $val => mutableOther = $val}, ), _create(_OptionalNilComparisonType, 'initNilLiteraltuple_type', {}, {})) ? _StringComparisonResult.infix_61_61({}, expecting, _StringComparisonResult.equal) : _StringComparisonResult.infix_61_61({}, expecting, _StringComparisonResult.less))
----Swift.(file).ObjectIdentifier.debugDescription
return (("ObjectIdentifier(") + (_rawPointerToString({}, this._value)) + (")"))
----Swift.(file).ObjectIdentifier.<infix(_:ObjectIdentifier,_:ObjectIdentifier)
return UInt.infix_60({}, _create(UInt, 'initBitPatternObjectIdentifier', {}, lhs), _create(UInt, 'initBitPatternObjectIdentifier', {}, rhs))
----Swift.(file).Int.init(bitPattern:ObjectIdentifier)
this.initBitPatternUInt({}, _create(UInt, 'initBitPatternObjectIdentifier', {}, objectID));
return
----Swift.(file).OptionSet.union(_:Self)
let r = _create(this.constructor, 'initRawValue', {}, this.rawValue);
r.formUnion({$setThis: $val => r = $val}, other);
return r
----Swift.(file).OptionSet.intersection(_:Self)
let r = _create(this.constructor, 'initRawValue', {}, this.rawValue);
r.formIntersection({$setThis: $val => r = $val}, other);
return r
----Swift.(file).OptionSet.symmetricDifference(_:Self)
let r = _create(this.constructor, 'initRawValue', {}, this.rawValue);
r.formSymmetricDifference({$setThis: $val => r = $val}, other);
return r
----Swift.(file).OptionSet.contains(_:Self)
return this.isSupersetOf({}, member)
----Swift.(file).OptionSet.insert(_:Self.Element)
const oldMember = this.intersection({}, newMember);
const shouldInsert = (oldMember).constructor.infix_33_61({}, oldMember, newMember);
const result = {0: shouldInsert, 1: (shouldInsert ? newMember : oldMember)};
{
if((shouldInsert)) {
this.formUnion({$setThis: $val => $info.$setThis(_cloneStruct($val))}, newMember);
}
};
return result
----Swift.(file).OptionSet.remove(_:Self.Element)
const r = (this.isSupersetOf({}, member) ? _create(Optional, 'init', {}, member) : Optional.none);
this.subtract({$setThis: $val => $info.$setThis(_cloneStruct($val))}, member);
return r
----Swift.(file).OptionSet.update(with:Self.Element)
const r = this.intersection({}, newMember);
this.formUnion({$setThis: $val => $info.$setThis(_cloneStruct($val))}, newMember);
return (r.isEmpty ? Optional.none : _injectIntoOptional(r))
----Swift.(file).OptionSet.init()
this.initRawValue({}, _create(((function(){throw '!unclarifiedGeneric:Self.RawValue'})()), 'initIntegerLiteral', {}, 0));
return
----Swift.(file).OptionSet.formUnion(_:Self)
$info.$setThis(_cloneStruct(_create(this.constructor, 'initRawValue', {}, (this.rawValue).constructor.infix_124({}, this.rawValue, other.rawValue))))
----Swift.(file).OptionSet.formIntersection(_:Self)
$info.$setThis(_cloneStruct(_create(this.constructor, 'initRawValue', {}, (this.rawValue).constructor.infix_38({}, this.rawValue, other.rawValue))))
----Swift.(file).OptionSet.formSymmetricDifference(_:Self)
$info.$setThis(_cloneStruct(_create(this.constructor, 'initRawValue', {}, (this.rawValue).constructor.infix_94({}, this.rawValue, other.rawValue))))
----Swift.(file).Optional.init(_:Wrapped)
$info.$setThis(_cloneStruct(Optional.some({}, some)));
return
----Swift.(file).Optional.map(_:(Wrapped) throws -> U)
const $match = this
if((($match.rawValue == Optional.some().rawValue))) {
const y = $match[0]
return Optional.some({}, transform({}, y));
}
else if((($match.rawValue == Optional.none.rawValue))) {
return Optional.none;
}
----Swift.(file).Optional.flatMap(_:(Wrapped) throws -> U?)
const $match = this
if((($match.rawValue == Optional.some().rawValue))) {
const y = $match[0]
return transform({}, y);
}
else if((($match.rawValue == Optional.none.rawValue))) {
return Optional.none;
}
----Swift.(file).Optional.init(nilLiteral:())
$info.$setThis(_cloneStruct(Optional.none));
return
----Swift.(file).Optional.unsafelyUnwrapped
{const $ifLet0 = this
if($ifLet0.rawValue === 'some') {
let x = $ifLet0[0]
return x;
}
};
preconditionFailureFileLine({}, () => "unsafelyUnwrapped of nil optional", '?3', '?3')
----Swift.(file).Optional.debugDescription
const $match = this
if((($match.rawValue == Optional.some().rawValue))) {
const value = $match[0]
let result = "Optional(";
debugPrintSeparatorTerminatorTo({}, _create(Array, 'initBuffer', {}, [value]), " "/*!default_value*/, "", {get: () => result, set: $val => result = $val});
String.infix_43_61({}, {get: () => result, set: $val => result = $val}, ")");
return result;
}
else if((($match.rawValue == Optional.none.rawValue))) {
return "nil";
}
----Swift.(file).Optional.customMirror
const $match = this
if((($match.rawValue == Optional.some().rawValue))) {
const value = $match[0]
return _create(Mirror, 'initChildrenKeyValuePairsDisplayStyleOptionalAncestorRepresentationMirrorAncestorRepresentation', {}, this, new Map([["some", value]]), _injectIntoOptional(Mirror.DisplayStyle.optional), .generated/*!default_value*/);
}
else if((($match.rawValue == Optional.none.rawValue))) {
return _create(Mirror, 'initChildrenKeyValuePairsDisplayStyleOptionalAncestorRepresentationMirrorAncestorRepresentation', {}, this, new Map([]), _injectIntoOptional(Mirror.DisplayStyle.optional), .generated/*!default_value*/);
}
----Swift.(file).Optional.==infix(_:Wrapped?,_:Wrapped?)
const $match = {0: lhs, 1: rhs}
if((($match[0].rawValue == 'some' && $match[1].rawValue == 'some'))) {
const l = $match[0][0]
const r = $match[1][0]
return (l).constructor.infix_61_61({}, l, r);
}
else if((($match[0].rawValue == Optional.none.rawValue && $match[1].rawValue == Optional.none.rawValue))) {
return true;
}
else if(((true))) {
return false;
}
----Swift.(file).Optional.hash(into:Hasher)
let hasher = hasher$inout.get()
const $result = (() => {
const $match = this
if((($match.rawValue == Optional.none.rawValue))) {
hasher.combine({$setThis: $val => hasher = $val}, 0);
}
else if((($match.rawValue == Optional.some().rawValue))) {
const wrapped = $match[0]
hasher.combine({$setThis: $val => hasher = $val}, 1);
hasher.combine({$setThis: $val => hasher = $val}, wrapped);
};})()
hasher$inout.set(hasher)
return $result
----Swift.(file).Optional.~=infix(_:_OptionalNilComparisonType,_:Wrapped?)
const $match = rhs
if((($match.rawValue == Optional.some().rawValue))) {
return false;
}
else if((($match.rawValue == Optional.none.rawValue))) {
return true;
}
----Swift.(file).Optional.==infix(_:Wrapped?,_:_OptionalNilComparisonType)
const $match = lhs
if((($match.rawValue == Optional.some().rawValue))) {
return false;
}
else if((($match.rawValue == Optional.none.rawValue))) {
return true;
}
----Swift.(file).Optional.!=infix(_:Wrapped?,_:_OptionalNilComparisonType)
const $match = lhs
if((($match.rawValue == Optional.some().rawValue))) {
return true;
}
else if((($match.rawValue == Optional.none.rawValue))) {
return false;
}
----Swift.(file).Optional.==infix(_:_OptionalNilComparisonType,_:Wrapped?)
const $match = rhs
if((($match.rawValue == Optional.some().rawValue))) {
return false;
}
else if((($match.rawValue == Optional.none.rawValue))) {
return true;
}
----Swift.(file).Optional.!=infix(_:_OptionalNilComparisonType,_:Wrapped?)
const $match = rhs
if((($match.rawValue == Optional.some().rawValue))) {
return true;
}
else if((($match.rawValue == Optional.none.rawValue))) {
return false;
}
----Swift.(file).??infix(_:T?,_:() throws -> T)
const $match = optional
if((($match.rawValue == Optional.some().rawValue))) {
const value = $match[0]
return value;
}
else if((($match.rawValue == Optional.none.rawValue))) {
return defaultValue({}, );
}
----Swift.(file).??infix(_:T?,_:() throws -> T?)
const $match = optional
if((($match.rawValue == Optional.some().rawValue))) {
const value = $match[0]
return _injectIntoOptional(value);
}
else if((($match.rawValue == Optional.none.rawValue))) {
return defaultValue({}, );
}
----Swift.(file).String.write(_:String)
String.infix_43_61({}, {get: () => this, set: $val => $info.$setThis(_cloneStruct($val))}, other)
----Swift.(file).String.write(to:Target)
let target = target$inout.get()
const $result = (() => {
target.write({$setThis: $val => target = $val}, this);})()
target$inout.set(target)
return $result
----Swift.(file).Character.write(to:Target)
let target = target$inout.get()
const $result = (() => {
target.write({$setThis: $val => target = $val}, _create(String, 'initCharacter', {}, this));})()
target$inout.set(target)
return $result
----Swift.(file).Unicode.Scalar.write(to:Target)
let target = target$inout.get()
const $result = (() => {
target.write({$setThis: $val => target = $val}, _create(String, 'initCharacter', {}, _create(Character, 'initUnicodeScalar', {}, this)));})()
target$inout.set(target)
return $result
----Swift.(file)._Pointer.init(_:OpaquePointer)
this.initRawPointer({}, from._rawValue);
return
----Swift.(file)._Pointer.init(_:OpaquePointer?)
{const $ifLet0 = from
if(!($ifLet0.rawValue === 'some')) {
return (this.$failed = true);
}let unwrapped = $ifLet0[0]
};
this.initOpaquePointer({}, unwrapped);
return
----Swift.(file)._Pointer.init(_:Self)
this.initRawPointer({}, other._rawValue);
return
----Swift.(file)._Pointer.init(_:Self?)
{const $ifLet0 = other
if(!($ifLet0.rawValue === 'some')) {
return (this.$failed = true);
}let unwrapped = $ifLet0[0]
};
this.initRawPointer({}, unwrapped._rawValue);
return
----Swift.(file)._Pointer.init(_:UnsafeMutablePointer<T>)
this.initRawPointer({}, other._rawValue);
return
----Swift.(file)._Pointer.init(_:UnsafeMutablePointer<T>?)
{const $ifLet0 = other
if(!($ifLet0.rawValue === 'some')) {
return (this.$failed = true);
}let unwrapped = $ifLet0[0]
};
this.initUnsafeMutablePointer({}, unwrapped);
return
----Swift.(file)._Pointer.successor()
return this.advancedBy({}, 1)
----Swift.(file)._Pointer.predecessor()
return this.advancedBy({}, -1)
----Swift.(file)._Pointer.hash(into:Hasher)
let hasher = hasher$inout.get()
const $result = (() => {
hasher.combine({$setThis: $val => hasher = $val}, _create(UInt, 'initBitPatternOptional', {}, _injectIntoOptional(this)));})()
hasher$inout.set(hasher)
return $result
----Swift.(file)._Pointer.debugDescription
return _rawPointerToString({}, this._rawValue)
----Swift.(file).Strideable.+infix(_:Self,_:Self.Stride)
return lhs.advancedBy({}, rhs)
----Swift.(file).Strideable.+infix(_:Self.Stride,_:Self)
return rhs.advancedBy({}, lhs)
----Swift.(file).Strideable.-infix(_:Self,_:Self.Stride)
return lhs.advancedBy({}, ((function(){throw '!unclarifiedGeneric:Self.Stride'})()).prefix_45({}, rhs))
----Swift.(file).Strideable.-infix(_:Self,_:Self)
return rhs.distanceTo({}, lhs)
----Swift.(file).Strideable.+=infix(_:Self,_:Self.Stride)
let lhs = lhs$inout.get()
const $result = (() => {
lhs = lhs.advancedBy({}, rhs);})()
lhs$inout.set(lhs)
return $result
----Swift.(file).Strideable.-=infix(_:Self,_:Self.Stride)
let lhs = lhs$inout.get()
const $result = (() => {
lhs = lhs.advancedBy({}, ((function(){throw '!unclarifiedGeneric:Self.Stride'})()).prefix_45({}, rhs));})()
lhs$inout.set(lhs)
return $result
----Swift.(file).Never.<infix(_:Never,_:Never)

----Swift.(file).Void
const Void = '?tuple_type
----Swift.(file).~=infix(_:T,_:T)
return (a).constructor.infix_61_61({}, a, b)
----Swift.(file).LazyPrefixWhileSequence.Iterator.next()
{const $ifLet0 = this._base.next({$setThis: $val => this._base = $val}, )
if((Bool.prefix_33({}, this._predicateHasFailed)) && $ifLet0.rawValue === 'some') {
let nextElement = $ifLet0[0]
{
if((this._predicate({}, nextElement))) {
return _injectIntoOptional(nextElement);
}
else {
this._predicateHasFailed = true;
}
};
}
};
return Optional.none
----Swift.(file).LazyPrefixWhileSequence.makeIterator()
return _create(LazyPrefixWhileSequence.Iterator, 'init_basePredicatefunction_type', {}, this._base.makeIterator({}, ), this._predicate)
----Swift.(file).LazySequenceProtocol.prefix(while:(Self.Elements.Element) -> Bool)
return _create(LazyPrefixWhileSequence, 'init_basePredicatefunction_type', {}, this._elements, predicate)
----Swift.(file).LazyPrefixWhileCollection
const LazyPrefixWhileCollection = LazyPrefixWhileSequenc
----Swift.(file).LazyPrefixWhileSequence.Index.==infix(_:LazyPrefixWhileCollection<Base>.Index,_:LazyPrefixWhileCollection<Base>.Index)
const $match = {0: lhs._value, 1: rhs._value}
if((($match[0].rawValue == LazyPrefixWhileSequence._IndexRepresentation.index().rawValue && $match[1].rawValue == LazyPrefixWhileSequence._IndexRepresentation.index().rawValue))) {
const l = $match[0][0]
const r = $match[1][0]
return ((function(){throw '!unclarifiedGeneric:Base.Index'})()).infix_61_61({}, l, r);
}
else if((($match[0].rawValue == LazyPrefixWhileSequence._IndexRepresentation.pastEnd.rawValue && $match[1].rawValue == LazyPrefixWhileSequence._IndexRepresentation.pastEnd.rawValue))) {
return true;
}
else if((($match[0].rawValue == LazyPrefixWhileSequence._IndexRepresentation.pastEnd.rawValue && $match[1].rawValue == LazyPrefixWhileSequence._IndexRepresentation.index().rawValue) || ($match[0].rawValue == LazyPrefixWhileSequence._IndexRepresentation.index().rawValue && $match[1].rawValue == LazyPrefixWhileSequence._IndexRepresentation.pastEnd.rawValue))) {
return false;
}
----Swift.(file).LazyPrefixWhileSequence.Index.<infix(_:LazyPrefixWhileCollection<Base>.Index,_:LazyPrefixWhileCollection<Base>.Index)
const $match = {0: lhs._value, 1: rhs._value}
if((($match[0].rawValue == LazyPrefixWhileSequence._IndexRepresentation.index().rawValue && $match[1].rawValue == LazyPrefixWhileSequence._IndexRepresentation.index().rawValue))) {
const l = $match[0][0]
const r = $match[1][0]
return ((function(){throw '!unclarifiedGeneric:Base.Index'})()).infix_60({}, l, r);
}
else if((($match[0].rawValue == LazyPrefixWhileSequence._IndexRepresentation.index().rawValue && $match[1].rawValue == LazyPrefixWhileSequence._IndexRepresentation.pastEnd.rawValue))) {
return true;
}
else if((($match[0].rawValue == LazyPrefixWhileSequence._IndexRepresentation.pastEnd.rawValue))) {
return false;
}
----Swift.(file).LazyPrefixWhileSequence.Index.hash(into:Hasher)
let hasher = hasher$inout.get()
const $result = (() => {
const $match = this._value
if((($match.rawValue == LazyPrefixWhileSequence._IndexRepresentation.index().rawValue))) {
const value = $match[0]
hasher.combine({$setThis: $val => hasher = $val}, value);
}
else if((($match.rawValue == LazyPrefixWhileSequence._IndexRepresentation.pastEnd.rawValue))) {
hasher.combine({$setThis: $val => hasher = $val}, Int.max);
};})()
hasher$inout.set(hasher)
return $result
----Swift.(file).LazyPrefixWhileCollection.startIndex
return _create(LazyPrefixWhileSequence.Index, 'init', {}, this._base.startIndex)
----Swift.(file).LazyPrefixWhileCollection.endIndex
{const $ifLet0 = this._base.first
if($ifLet0.rawValue === 'some' && (this._predicate({}, first))) {
let first = $ifLet0[0]
return _create(LazyPrefixWhileSequence.Index, 'initEndOf', {}, this._base);
}
};
return this.startIndex
----Swift.(file).LazyPrefixWhileCollection.index(after:LazyPrefixWhileSequence<Base>.Index)
preconditionFileLine({}, () => LazyPrefixWhileSequence.Index.infix_33_61({}, i, this.endIndex), () => "Can't advance past endIndex", '?3', '?3');
{const $ifLet0 = i._value
if(!($ifLet0.rawValue === 'some')) {
preconditionFailureFileLine({}, () => "Invalid index passed to index(after:)", '?3', '?3');
}let i = $ifLet0[0]
};
const nextIndex = this._base.indexAfter({}, i);
{
if(!((Bool.infix_38_38({}, (nextIndex).constructor.infix_33_61({}, nextIndex, this._base.endIndex), () => this._predicate({}, this._base.subscript$get({}, nextIndex)))))) {
return _create(LazyPrefixWhileSequence.Index, 'initEndOf', {}, this._base);
}
};
return _create(LazyPrefixWhileSequence.Index, 'init', {}, nextIndex)
----Swift.(file).LazyPrefixWhileCollection.subscript(_:LazyPrefixWhileSequence<Base>.Index)
const $match = position._value
if((($match.rawValue == LazyPrefixWhileSequence._IndexRepresentation.index().rawValue))) {
const i = $match[0]
return this._base.subscript$get({}, i);
}
else if((($match.rawValue == LazyPrefixWhileSequence._IndexRepresentation.pastEnd.rawValue))) {
preconditionFailureFileLine({}, () => "Index out of range", '?3', '?3');
}
----Swift.(file).LazyPrefixWhileCollection.index(before:LazyPrefixWhileSequence<Base>.Index)
const $match = i._value
if((($match.rawValue == LazyPrefixWhileSequence._IndexRepresentation.index().rawValue))) {
const i = $match[0]
preconditionFileLine({}, () => (this._base.startIndex).constructor.infix_33_61({}, i, this._base.startIndex), () => "Can't move before startIndex", '?3', '?3');
return _create(LazyPrefixWhileSequence.Index, 'init', {}, this._base.indexBefore({}, i));
}
else if((($match.rawValue == LazyPrefixWhileSequence._IndexRepresentation.pastEnd.rawValue))) {
let result = this._base.startIndex;
while(true){
if(!((true))) break
const next = this._base.indexAfter({}, result);
{
if((Bool.infix_124_124({}, (next).constructor.infix_61_61({}, next, this._base.endIndex), () => Bool.prefix_33({}, this._predicate({}, this._base.subscript$get({}, next)))))) {
break;
}
};
result = next;
};
return _create(LazyPrefixWhileSequence.Index, 'init', {}, result);
}
----Swift.(file).print(_:[Any],separator:String,terminator:String)
{const $ifLet0 = _playgroundPrintHook
if($ifLet0.rawValue === 'some') {
let hook = $ifLet0[0]
let output = _create(_TeeStream, 'initLeftRight', {}, "", _create(_Stdout, 'init', {}, ));
_printSeparatorTerminatorTo({}, items, separator, terminator, {get: () => output, set: $val => output = $val});
hook({}, output.left);
}
else {
let output = _create(_Stdout, 'init', {}, );
_printSeparatorTerminatorTo({}, items, separator, terminator, {get: () => output, set: $val => output = $val});
}
}
----Swift.(file).debugPrint(_:[Any],separator:String,terminator:String)
{const $ifLet0 = _playgroundPrintHook
if($ifLet0.rawValue === 'some') {
let hook = $ifLet0[0]
let output = _create(_TeeStream, 'initLeftRight', {}, "", _create(_Stdout, 'init', {}, ));
_debugPrintSeparatorTerminatorTo({}, items, separator, terminator, {get: () => output, set: $val => output = $val});
hook({}, output.left);
}
else {
let output = _create(_Stdout, 'init', {}, );
_debugPrintSeparatorTerminatorTo({}, items, separator, terminator, {get: () => output, set: $val => output = $val});
}
}
----Swift.(file).print(_:[Any],separator:String,terminator:String,to:Target)
let output = output$inout.get()
const $result = (() => {
_printSeparatorTerminatorTo({}, items, separator, terminator, {get: () => output, set: $val => output = $val});})()
output$inout.set(output)
return $result
----Swift.(file).debugPrint(_:[Any],separator:String,terminator:String,to:Target)
let output = output$inout.get()
const $result = (() => {
_debugPrintSeparatorTerminatorTo({}, items, separator, terminator, {get: () => output, set: $val => output = $val});})()
output$inout.set(output)
return $result
----Swift.(file).RandomNumberGenerator.next()
return ((function(){throw '!unclarifiedGeneric:T'})())._randomUsing({}, {get: () => this, set: $val => $info.$setThis(_cloneStruct($val))})
----Swift.(file).RandomNumberGenerator.next(upperBound:T)
preconditionFileLine({}, () => (upperBound).constructor.infix_33_61({}, upperBound, 0), () => "upperBound cannot be zero.", '?3', '?3');
const tmp = (_create(((function(){throw '!unclarifiedGeneric:T'})()), 'initIntegerLiteral', {}, 1)).constructor.infix_43({}, (((function(){throw '!unclarifiedGeneric:T'})()).max).constructor.infix_37({}, ((function(){throw '!unclarifiedGeneric:T'})()).max, upperBound), _create(((function(){throw '!unclarifiedGeneric:T'})()), 'initIntegerLiteral', {}, 1));
const range = ((tmp).constructor.infix_61_61({}, tmp, upperBound) ? _create(((function(){throw '!unclarifiedGeneric:T'})()), 'initIntegerLiteral', {}, 0) : tmp);
let random = _create(((function(){throw '!unclarifiedGeneric:T'})()), 'initIntegerLiteral', {}, 0);
do {
random = this.next({$setThis: $val => $info.$setThis(_cloneStruct($val))}, );
} while((random).constructor.infix_60({}, random, range));
return (random).constructor.infix_37({}, random, upperBound)
----Swift.(file).SystemRandomNumberGenerator.init()
return
----Swift.(file).RandomAccessCollection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)
const l = this.distanceFromTo({}, i, limit);
{
if(((Int.infix_62({}, distance, 0) ? Bool.infix_38_38({}, Int.infix_62_61({}, l, 0), () => Int.infix_60({}, l, distance)) : Bool.infix_38_38({}, Int.infix_60_61({}, l, 0), () => Int.infix_60({}, distance, l))))) {
return Optional.none;
}
};
return _injectIntoOptional(this.indexOffsetBy({}, i, distance))
----Swift.(file).RandomAccessCollection.indices
return (this.startIndex).constructor.infix_46_46_60({}, this.startIndex, this.endIndex)
----Swift.(file).RangeExpression.~=infix(_:Self,_:Self.Bound)
return pattern.contains({}, value)
----Swift.(file).Range.contains(_:Bound)
return Bool.infix_38_38({}, (this.lowerBound).constructor.infix_60_61({}, this.lowerBound, _element), () => (_element).constructor.infix_60({}, _element, this.upperBound))
----Swift.(file).Range.isEmpty
return (this.lowerBound).constructor.infix_61_61({}, this.lowerBound, this.upperBound)
----Swift.(file).Range.startIndex
return this.lowerBound
----Swift.(file).Range.endIndex
return this.upperBound
----Swift.(file).Range.index(after:Range<Bound>.Index)
return i.advancedBy({}, _create(Int, 'initIntegerLiteral', {}, 1))
----Swift.(file).Range.index(before:Range<Bound>.Index)
preconditionFileLine({}, () => (i).constructor.infix_62({}, i, this.lowerBound), () => String()/*!default_value*/, '?3', '?3');
preconditionFileLine({}, () => (i).constructor.infix_60_61({}, i, this.upperBound), () => String()/*!default_value*/, '?3', '?3');
return i.advancedBy({}, _create(((function(){throw '!unclarifiedGeneric:Bound.Stride'})()), 'initIntegerLiteral', {}, -1))
----Swift.(file).Range.index(_:Range<Bound>.Index,offsetBy:Int)
const r = i.advancedBy({}, numericCast({}, n));
preconditionFileLine({}, () => (r).constructor.infix_62_61({}, r, this.lowerBound), () => String()/*!default_value*/, '?3', '?3');
preconditionFileLine({}, () => (r).constructor.infix_60_61({}, r, this.upperBound), () => String()/*!default_value*/, '?3', '?3');
return r
----Swift.(file).Range.distance(from:Range<Bound>.Index,to:Range<Bound>.Index)
return numericCast({}, start.distanceTo({}, end))
----Swift.(file).Range.subscript(_:Range<Range<Bound>.Index>)
return bounds
----Swift.(file).Range.indices
return this
----Swift.(file).Range.subscript(_:Range<Bound>.Index)
preconditionFileLine({}, () => this.contains({}, position), () => "Index out of range", '?3', '?3');
return position
----Swift.(file).Range.init(_:ClosedRange<Bound>)
const upperBound = other.upperBound.advancedBy({}, _create(((function(){throw '!unclarifiedGeneric:Bound.Stride'})()), 'initIntegerLiteral', {}, 1));
this.initUncheckedBoundstuple_type({}, {0: other.lowerBound, 1: upperBound});
return
----Swift.(file).Range.relative(to:C)
return _create(Range, 'initUncheckedBoundstuple_type', {}, {0: this.lowerBound, 1: this.upperBound})
----Swift.(file).Range.clamped(to:Range<Bound>)
const lower = ((limits.lowerBound).constructor.infix_62({}, limits.lowerBound, this.lowerBound) ? limits.lowerBound : ((limits.upperBound).constructor.infix_60({}, limits.upperBound, this.lowerBound) ? limits.upperBound : this.lowerBound));
const upper = ((limits.upperBound).constructor.infix_60({}, limits.upperBound, this.upperBound) ? limits.upperBound : ((limits.lowerBound).constructor.infix_62({}, limits.lowerBound, this.upperBound) ? limits.lowerBound : this.upperBound));
return _create(Range, 'initUncheckedBoundstuple_type', {}, {0: lower, 1: upper})
----Swift.(file).Range.description
return (("") + (this.lowerBound) + ("..<") + (this.upperBound) + (""))
----Swift.(file).Range.debugDescription
return String.infix_43({}, (("Range(") + (_create(String, 'initReflecting', {}, this.lowerBound)) + ("")), (("..<") + (_create(String, 'initReflecting', {}, this.upperBound)) + (")")))
----Swift.(file).Range.customMirror
return _create(Mirror, 'initChildrenKeyValuePairsDisplayStyleOptionalAncestorRepresentationMirrorAncestorRepresentation', {}, this, new Map([["lowerBound", this.lowerBound], ["upperBound", this.upperBound]]), nil/*!default_value*/, .generated/*!default_value*/)
----Swift.(file).Range.==infix(_:Range<Bound>,_:Range<Bound>)
return Bool.infix_38_38({}, (lhs.lowerBound).constructor.infix_61_61({}, lhs.lowerBound, rhs.lowerBound), () => (lhs.upperBound).constructor.infix_61_61({}, lhs.upperBound, rhs.upperBound))
----Swift.(file).Range.hash(into:Hasher)
let hasher = hasher$inout.get()
const $result = (() => {
hasher.combine({$setThis: $val => hasher = $val}, this.lowerBound);
hasher.combine({$setThis: $val => hasher = $val}, this.upperBound);})()
hasher$inout.set(hasher)
return $result
----Swift.(file).PartialRangeUpTo.relative(to:C)
return (collection.startIndex).constructor.infix_46_46_60({}, collection.startIndex, this.upperBound)
----Swift.(file).PartialRangeUpTo.contains(_:Bound)
return (_element).constructor.infix_60({}, _element, this.upperBound)
----Swift.(file).PartialRangeThrough.relative(to:C)
return (collection.startIndex).constructor.infix_46_46_60({}, collection.startIndex, collection.indexAfter({}, this.upperBound))
----Swift.(file).PartialRangeThrough.contains(_:Bound)
return (_element).constructor.infix_60_61({}, _element, this.upperBound)
----Swift.(file).PartialRangeFrom.relative(to:C)
return (this.lowerBound).constructor.infix_46_46_60({}, this.lowerBound, collection.endIndex)
----Swift.(file).PartialRangeFrom.contains(_:Bound)
return (this.lowerBound).constructor.infix_60_61({}, this.lowerBound, _element)
----Swift.(file).PartialRangeFrom.Iterator.init(_current:Bound)
this._current = _current;
return
----Swift.(file).PartialRangeFrom.Iterator.next()
let $defer = () => {
this._current = this._current.advancedBy({}, _create(((function(){throw '!unclarifiedGeneric:Bound.Stride'})()), 'initIntegerLiteral', {}, 1));
}
try {;
return _injectIntoOptional(this._current);}catch($error){$defer({}, );throw $error}$defer({}, )
----Swift.(file).PartialRangeFrom.makeIterator()
return _create(PartialRangeFrom.Iterator, 'init_current', {}, this.lowerBound)
----Swift.(file).Comparable...<infix(_:Self,_:Self)
preconditionFileLine({}, () => (minimum).constructor.infix_60_61({}, minimum, maximum), () => "Can't form Range with upperBound < lowerBound", '?3', '?3');
return _create(Range, 'initUncheckedBoundstuple_type', {}, {0: minimum, 1: maximum})
----Swift.(file).Comparable...<prefix(_:Self)
return _create(PartialRangeUpTo, 'init', {}, maximum)
----Swift.(file).Comparable....prefix(_:Self)
return _create(PartialRangeThrough, 'init', {}, maximum)
----Swift.(file).Comparable....postfix(_:Self)
return _create(PartialRangeFrom, 'init', {}, minimum)
----Swift.(file).UnboundedRange
const UnboundedRange = '?function_type
----Swift.(file).Collection.subscript(_:R)
return this.subscriptRange$get({}, r.relativeTo({}, this))
----Swift.(file).Collection.subscript(_:(UnboundedRange_) -> ())
return this.subscript$get({}, ((function(){throw '!unclarifiedGeneric:Self.Index'})()).postfix_46_46_46({}, this.startIndex))
----Swift.(file).MutableCollection.subscript(_:R)#ASS

this.subscriptRange$set({$setThis: $val => $info.$setThis(_cloneStruct($val))}, newValue, r.relativeTo({}, this))
----Swift.(file).MutableCollection.subscript(_:R)
return this.subscriptRange$get({}, r.relativeTo({}, this));

----Swift.(file).MutableCollection.subscript(_:(UnboundedRange_) -> ())#ASS

this.subscriptRange$set({$setThis: $val => $info.$setThis(_cloneStruct($val))}, newValue, ((function(){throw '!unclarifiedGeneric:Self.Index'})()).postfix_46_46_46({}, this.startIndex))
----Swift.(file).MutableCollection.subscript(_:(UnboundedRange_) -> ())
return this.subscriptRange$get({}, ((function(){throw '!unclarifiedGeneric:Self.Index'})()).postfix_46_46_46({}, this.startIndex));

----Swift.(file).Range.overlaps(_:Range<Bound>)
return Bool.infix_124_124({}, Bool.infix_38_38({}, Bool.prefix_33({}, other.isEmpty), () => this.contains({}, other.lowerBound)), () => Bool.infix_38_38({}, Bool.prefix_33({}, this.isEmpty), () => other.contains({}, this.lowerBound)))
----Swift.(file).Range.overlaps(_:ClosedRange<Bound>)
return Bool.infix_124_124({}, this.contains({}, other.lowerBound), () => Bool.infix_38_38({}, Bool.prefix_33({}, this.isEmpty), () => other.contains({}, this.lowerBound)))
----Swift.(file).RangeReplaceableCollection.init(repeating:Self.Element,count:Int)
this.init({}, );
{
if((Int.infix_33_61({}, count, 0))) {
const _elements = _create(Repeated, 'init_repeatingCountInt', {}, repeatedValue, count);
this.appendContentsOf({$setThis: $val => $info.$setThis(_cloneStruct($val))}, _elements);
}
};
return
----Swift.(file).RangeReplaceableCollection.init(_:S)
this.init({}, );
this.appendContentsOf({$setThis: $val => $info.$setThis(_cloneStruct($val))}, _elements);
return
----Swift.(file).RangeReplaceableCollection.append(_:Self.Element)
this.insertAt({$setThis: $val => $info.$setThis(_cloneStruct($val))}, newElement, this.endIndex)
----Swift.(file).RangeReplaceableCollection.append(contentsOf:S)
const approximateCapacity = Int.infix_43({}, this.count, numericCast({}, newElements.underestimatedCount));
this.reserveCapacity({$setThis: $val => $info.$setThis(_cloneStruct($val))}, approximateCapacity);
{
let $element$generator = newElements.makeIterator({}, );
while(true) {
const $ifLet0 = $element$generator.next({$setThis: $val => $element$generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
let _element = $ifLet0[0]
this.append({$setThis: $val => $info.$setThis(_cloneStruct($val))}, _element);
}
}
----Swift.(file).RangeReplaceableCollection.insert(_:Self.Element,at:Self.Index)
this.replaceSubrangeWith({$setThis: $val => $info.$setThis(_cloneStruct($val))}, (i).constructor.infix_46_46_60({}, i, i), _create(CollectionOfOne, 'init', {}, newElement))
----Swift.(file).RangeReplaceableCollection.insert(contentsOf:C,at:Self.Index)
this.replaceSubrangeWith({$setThis: $val => $info.$setThis(_cloneStruct($val))}, (i).constructor.infix_46_46_60({}, i, i), newElements)
----Swift.(file).RangeReplaceableCollection.remove(at:Self.Index)
preconditionFileLine({}, () => Bool.prefix_33({}, this.isEmpty), () => "Can't remove from an empty collection", '?3', '?3');
const result = this.subscript$get({}, position);
this.replaceSubrangeWith({$setThis: $val => $info.$setThis(_cloneStruct($val))}, (position).constructor.infix_46_46_60({}, position, this.indexAfter({}, position)), _create(EmptyCollection, 'init', {}, ));
return result
----Swift.(file).RangeReplaceableCollection.removeSubrange(_:Range<Self.Index>)
this.replaceSubrangeWith({$setThis: $val => $info.$setThis(_cloneStruct($val))}, bounds, _create(EmptyCollection, 'init', {}, ))
----Swift.(file).RangeReplaceableCollection.removeFirst(_:Int)
{
if((Int.infix_61_61({}, k, 0))) {
return ;
}
};
preconditionFileLine({}, () => Int.infix_62_61({}, k, 0), () => "Number of elements to remove should be non-negative", '?3', '?3');
preconditionFileLine({}, () => Int.infix_62_61({}, this.count, k), () => "Can't remove more items from a collection than it has", '?3', '?3');
const end = this.indexOffsetBy({}, this.startIndex, k);
this.removeSubrangeRange({$setThis: $val => $info.$setThis(_cloneStruct($val))}, (this.startIndex).constructor.infix_46_46_60({}, this.startIndex, end))
----Swift.(file).RangeReplaceableCollection.removeFirst()
preconditionFileLine({}, () => Bool.prefix_33({}, this.isEmpty), () => "Can't remove first element from an empty collection", '?3', '?3');
const firstElement = this.first[0];
this.removeFirstMultiple({$setThis: $val => $info.$setThis(_cloneStruct($val))}, 1);
return firstElement
----Swift.(file).RangeReplaceableCollection.removeAll(keepingCapacity:Bool)
{
if((Bool.prefix_33({}, keepCapacity))) {
$info.$setThis(_cloneStruct(_create(this.constructor, 'init', {}, )));
}
else {
this.replaceSubrangeWith({$setThis: $val => $info.$setThis(_cloneStruct($val))}, (this.startIndex).constructor.infix_46_46_60({}, this.startIndex, this.endIndex), _create(EmptyCollection, 'init', {}, ));
}
}
----Swift.(file).RangeReplaceableCollection.reserveCapacity(_:Int)

----Swift.(file).RangeReplaceableCollection.removeFirst()
preconditionFileLine({}, () => Bool.prefix_33({}, this.isEmpty), () => "Can't remove items from an empty collection", '?3', '?3');
const _element = this.first[0];
$info.$setThis(_cloneStruct(this.subscriptRange$get({}, (this.indexAfter({}, this.startIndex)).constructor.infix_46_46_60({}, this.indexAfter({}, this.startIndex), this.endIndex))));
return _element
----Swift.(file).RangeReplaceableCollection.removeFirst(_:Int)
{
if((Int.infix_61_61({}, k, 0))) {
return ;
}
};
preconditionFileLine({}, () => Int.infix_62_61({}, k, 0), () => "Number of elements to remove should be non-negative", '?3', '?3');
preconditionFileLine({}, () => Int.infix_62_61({}, this.count, k), () => "Can't remove more items from a collection than it contains", '?3', '?3');
$info.$setThis(_cloneStruct(this.subscriptRange$get({}, (this.indexOffsetBy({}, this.startIndex, k)).constructor.infix_46_46_60({}, this.indexOffsetBy({}, this.startIndex, k), this.endIndex))))
----Swift.(file).RangeReplaceableCollection.replaceSubrange(_:R,with:C)
this.replaceSubrangeWith({$setThis: $val => $info.$setThis(_cloneStruct($val))}, subrange.relativeTo({}, this), newElements)
----Swift.(file).RangeReplaceableCollection.removeSubrange(_:R)
this.removeSubrangeRange({$setThis: $val => $info.$setThis(_cloneStruct($val))}, bounds.relativeTo({}, this))
----Swift.(file).RangeReplaceableCollection.popLast()
{
if((this.isEmpty)) {
return Optional.none;
}
};
return _injectIntoOptional(this.removeAt({$setThis: $val => $info.$setThis(_cloneStruct($val))}, this.indexBefore({}, this.endIndex)))
----Swift.(file).RangeReplaceableCollection.removeLast()
preconditionFileLine({}, () => Bool.prefix_33({}, this.isEmpty), () => "Can't remove last element from an empty collection", '?3', '?3');
return this.removeAt({$setThis: $val => $info.$setThis(_cloneStruct($val))}, this.indexBefore({}, this.endIndex))
----Swift.(file).RangeReplaceableCollection.popLast()
{
if((this.isEmpty)) {
return Optional.none;
}
};
return _injectIntoOptional(this.removeAt({$setThis: $val => $info.$setThis(_cloneStruct($val))}, this.indexBefore({}, this.endIndex)))
----Swift.(file).RangeReplaceableCollection.removeLast()
preconditionFileLine({}, () => Bool.prefix_33({}, this.isEmpty), () => "Can't remove last element from an empty collection", '?3', '?3');
return this.removeAt({$setThis: $val => $info.$setThis(_cloneStruct($val))}, this.indexBefore({}, this.endIndex))
----Swift.(file).RangeReplaceableCollection.+infix(_:Self,_:Other)
let lhs_dupl = lhs;
lhs_dupl.appendContentsOf({$setThis: $val => lhs_dupl = $val}, rhs);
return lhs_dupl
----Swift.(file).RangeReplaceableCollection.+infix(_:Other,_:Self)
let result = _create(this.constructor, 'init', {}, );
result.reserveCapacity({$setThis: $val => result = $val}, Int.infix_43({}, rhs.count, numericCast({}, lhs.underestimatedCount)));
result.appendContentsOf({$setThis: $val => result = $val}, lhs);
result.appendContentsOf({$setThis: $val => result = $val}, rhs);
return result
----Swift.(file).RangeReplaceableCollection.+=infix(_:Self,_:Other)
let lhs = lhs$inout.get()
const $result = (() => {
lhs.appendContentsOf({$setThis: $val => lhs = $val}, rhs);})()
lhs$inout.set(lhs)
return $result
----Swift.(file).RangeReplaceableCollection.+infix(_:Self,_:Other)
let lhs_dupl = lhs;
lhs_dupl.appendContentsOf({$setThis: $val => lhs_dupl = $val}, rhs);
return lhs_dupl
----Swift.(file).RangeReplaceableCollection.filter(_:(Self.Element) throws -> Bool)
return _create(this.constructor, 'initBuffer', {}, this.lazy.filterSwift({}, isIncluded))
----Swift.(file).RangeReplaceableCollection.removeAll(where:(Self.Element) throws -> Bool)
const suffixStart = this._halfStablePartitionIsSuffixElement({$setThis: $val => $info.$setThis(_cloneStruct($val))}, shouldBeRemoved);
this.removeSubrange({$setThis: $val => $info.$setThis(_cloneStruct($val))}, ((function(){throw '!unclarifiedGeneric:Self.Index'})()).postfix_46_46_46({}, suffixStart))
----Swift.(file).RangeReplaceableCollection.removeAll(where:(Self.Element) throws -> Bool)
$info.$setThis(_cloneStruct(_create(this.constructor, 'initBuffer', {}, this.lazy.filterSwift({}, (($info, $0) => Bool.prefix_33({}, shouldBeRemoved({}, $0)))))))
----Swift.(file).getChild(of:T,type:Any.Type,index:Int)
let nameC = Optional.none;
let freeFunc = Optional.none;
const value = _cloneStruct(_getChildOfTypeIndexOutNameOutFreeFunc({}, value, type, index, /**/{get: () => nameC, set: $val => nameC = $val}, /**/{get: () => freeFunc, set: $val => freeFunc = $val}));
const _name = nameC.flatMap({}, (($info, $0) => _create(String, 'initValidatingUTF8UnsafePointer', {}, $0)));
_injectIntoOptional(((_.tmp0 = freeFunc).rawValue === 'some') ? (_.tmp0[0]({}, nameC)) : null);
return {0: _name, 1: value}
----Swift.(file).Mirror.quickLookObject(_:Any)
const object = _getQuickLookObject({}, subject);
return object.flatMap({}, _getClassPlaygroundQuickLook)
----Swift.(file).Repeated.startIndex
return 0
----Swift.(file).Repeated.endIndex
return this.count
----Swift.(file).Repeated.subscript(_:Int)
preconditionFileLine({}, () => Bool.infix_38_38({}, Int.infix_62_61({}, position, 0), () => Int.infix_60({}, position, this.count)), () => "Index out of range", '?3', '?3');
return this.repeatedValue
----Swift.(file).repeatElement(_:T,count:Int)
return _create(Repeated, 'init_repeatingCountInt', {}, _element, n)
----Swift.(file).Result.map(_:(Success) -> NewSuccess)
const $match = this
if((($match.rawValue == Result.success().rawValue))) {
const success = $match[0]
return Result.success({}, transform({}, success));
}
else if((($match.rawValue == Result.failure().rawValue))) {
const failure = $match[0]
return Result.failure({}, failure);
}
----Swift.(file).Result.mapError(_:(Failure) -> NewFailure)
const $match = this
if((($match.rawValue == Result.success().rawValue))) {
const success = $match[0]
return Result.success({}, success);
}
else if((($match.rawValue == Result.failure().rawValue))) {
const failure = $match[0]
return Result.failure({}, transform({}, failure));
}
----Swift.(file).Result.flatMap(_:(Success) -> Result<NewSuccess, Failure>)
const $match = this
if((($match.rawValue == Result.success().rawValue))) {
const success = $match[0]
return transform({}, success);
}
else if((($match.rawValue == Result.failure().rawValue))) {
const failure = $match[0]
return Result.failure({}, failure);
}
----Swift.(file).Result.flatMapError(_:(Failure) -> Result<Success, NewFailure>)
const $match = this
if((($match.rawValue == Result.success().rawValue))) {
const success = $match[0]
return Result.success({}, success);
}
else if((($match.rawValue == Result.failure().rawValue))) {
const failure = $match[0]
return transform({}, failure);
}
----Swift.(file).Result.get()
const $match = this
if((($match.rawValue == Result.success().rawValue))) {
const success = $match[0]
return success;
}
else if((($match.rawValue == Result.failure().rawValue))) {
const failure = $match[0]
throw failure;
}
----Swift.(file).Result.init(catching:() throws -> Success)
try {
$info.$setThis(_cloneStruct(Result.success({}, body({}, ))));
} catch(error) {
if((true)) {
$info.$setThis(_cloneStruct(Result.failure({}, error)));
}
else throw error
};
return
----Swift.(file).MutableCollection.reverse()
{
if((this.isEmpty)) {
return ;
}
};
let f = this.startIndex;
let l = this.indexBefore({}, this.endIndex);
while(true){
if(!(((f).constructor.infix_60({}, f, l)))) break
this.swapAt({$setThis: $val => $info.$setThis(_cloneStruct($val))}, f, l);
this.formIndexAfter({}, {get: () => f, set: $val => f = $val});
this.formIndexBefore({}, {get: () => l, set: $val => l = $val});
}
----Swift.(file).ReversedCollection.Iterator.next()
{
if(!((_fastPath({}, (this._position).constructor.infix_33_61({}, this._position, this._base.startIndex))))) {
return Optional.none;
}
};
this._base.formIndexBefore({}, {get: () => this._position, set: $val => this._position = $val});
return _injectIntoOptional(this._base.subscript$get({}, this._position))
----Swift.(file).ReversedCollection.makeIterator()
return _create(ReversedCollection.Iterator, 'init_base', {}, this._base)
----Swift.(file).ReversedCollection.Index.==infix(_:ReversedCollection<Base>.Index,_:ReversedCollection<Base>.Index)
return (lhs.base).constructor.infix_61_61({}, lhs.base, rhs.base)
----Swift.(file).ReversedCollection.Index.<infix(_:ReversedCollection<Base>.Index,_:ReversedCollection<Base>.Index)
return (lhs.base).constructor.infix_62({}, lhs.base, rhs.base)
----Swift.(file).ReversedCollection.Index.hash(into:Hasher)
let hasher = hasher$inout.get()
const $result = (() => {
hasher.combine({$setThis: $val => hasher = $val}, this.base);})()
hasher$inout.set(hasher)
return $result
----Swift.(file).ReversedCollection.startIndex
return _create(ReversedCollection.Index, 'init', {}, this._base.endIndex)
----Swift.(file).ReversedCollection.endIndex
return _create(ReversedCollection.Index, 'init', {}, this._base.startIndex)
----Swift.(file).ReversedCollection.index(after:ReversedCollection<Base>.Index)
return _create(ReversedCollection.Index, 'init', {}, this._base.indexBefore({}, i.base))
----Swift.(file).ReversedCollection.index(before:ReversedCollection<Base>.Index)
return _create(ReversedCollection.Index, 'init', {}, this._base.indexAfter({}, i.base))
----Swift.(file).ReversedCollection.index(_:ReversedCollection<Base>.Index,offsetBy:Int)
return _create(ReversedCollection.Index, 'init', {}, this._base.indexOffsetBy({}, i.base, Int.prefix_45({}, n)))
----Swift.(file).ReversedCollection.index(_:ReversedCollection<Base>.Index,offsetBy:Int,limitedBy:ReversedCollection<Base>.Index)
return this._base.indexOffsetByLimitedBy({}, i.base, Int.prefix_45({}, n), limit.base).mapSwift({}, init({}, ReversedCollection.Index))
----Swift.(file).ReversedCollection.distance(from:ReversedCollection<Base>.Index,to:ReversedCollection<Base>.Index)
return this._base.distanceFromTo({}, end.base, start.base)
----Swift.(file).ReversedCollection.subscript(_:ReversedCollection<Base>.Index)
return this._base.subscript$get({}, this._base.indexBefore({}, position.base))
----Swift.(file).ReversedCollection.reversed()
return this._base
----Swift.(file).BidirectionalCollection.reversed()
return _create(ReversedCollection, 'init_base', {}, this)
----Swift.(file).Sequence.makeIterator()
return this
----Swift.(file).DropFirstSequence.makeIterator()
let it = this._base.makeIterator({}, );
let dropped = 0;
while(true){
if(!((Int.infix_60({}, dropped, this._limit)) && (Optional.wrappedNotEqualsOptionalNilComparisonType({}, it.next({$setThis: $val => it = $val}, ), _create(_OptionalNilComparisonType, 'initNilLiteraltuple_type', {}, {}))))) break
Int.infix_38_43_61({}, {get: () => dropped, set: $val => dropped = $val}, 1);
};
return it
----Swift.(file).DropFirstSequence.dropFirst(_:Int)
return _create(DropFirstSequence, 'initDroppingInt', {}, this._base, Int.infix_43({}, this._limit, k))
----Swift.(file).PrefixSequence.Iterator.init(_:Base.Iterator,maxLength:Int)
this._base = base;
this._remaining = maxLength;
return
----Swift.(file).PrefixSequence.Iterator.next()
{
if((Int.infix_33_61({}, this._remaining, 0))) {
Int.infix_38_45_61({}, {get: () => this._remaining, set: $val => this._remaining = $val}, 1);
return this._base.next({$setThis: $val => this._base = $val}, );
}
else {
return Optional.none;
}
}
----Swift.(file).PrefixSequence.makeIterator()
return _create(PrefixSequence.Iterator, 'initMaxLengthInt', {}, this._base.makeIterator({}, ), this._maxLength)
----Swift.(file).PrefixSequence.prefix(_:Int)
const _length = /*dot_syntax_base_ignored*/min({}, maxLength, this._maxLength);
return _create(PrefixSequence, 'initMaxLengthInt', {}, this._base, _length)
----Swift.(file).DropWhileSequence.init(iterator:Base.Iterator,predicate:(Base.Element) throws -> Bool)
this._iterator = iterator;
this._nextElement = this._iterator.next({$setThis: $val => this._iterator = $val}, );
while(true){
const $ifLet0 = this._nextElement
if(!($ifLet0.rawValue === 'some' && (predicate({}, x)))) break
let x = $ifLet0[0]
this._nextElement = this._iterator.next({$setThis: $val => this._iterator = $val}, );
};
return
----Swift.(file).DropWhileSequence.init(_:Base,predicate:(Base.Element) throws -> Bool)
$info.$setThis(_cloneStruct(_cloneStruct(_create(DropWhileSequence, 'initIteratorPredicatefunction_type', {}, base.makeIterator({}, ), predicate))));
return
----Swift.(file).DropWhileSequence.Iterator.init(_:Base.Iterator,nextElement:DropWhileSequence<Base>.Iterator.Element?)
this._iterator = iterator;
this._nextElement = nextElement;
return
----Swift.(file).DropWhileSequence.Iterator.next()
{const $ifLet0 = this._nextElement
if(!($ifLet0.rawValue === 'some')) {
return Optional.none;
}let next = $ifLet0[0]
};
this._nextElement = this._iterator.next({$setThis: $val => this._iterator = $val}, );
return _injectIntoOptional(next)
----Swift.(file).DropWhileSequence.makeIterator()
return _create(DropWhileSequence.Iterator, 'initNextElementOptional', {}, this._iterator, this._nextElement)
----Swift.(file).DropWhileSequence.drop(while:(Base.Element) throws -> Bool)
{const $ifLet0 = this._nextElement
if(!($ifLet0.rawValue === 'some' && (predicate({}, x)))) {
return this;
}let x = $ifLet0[0]
};
return _create(DropWhileSequence, 'initIteratorPredicatefunction_type', {}, this._iterator, predicate)
----Swift.(file).Sequence.map(_:(Self.Element) throws -> T)
const initialCapacity = this.underestimatedCount;
let result = _create(ContiguousArray, 'init', {}, );
result.reserveCapacity({$setThis: $val => result = $val}, initialCapacity);
let iterator = this.makeIterator({}, );
{
let $generator = _cloneStruct(Int.infix_46_46_60({}, 0, initialCapacity).makeIterator({}, ));
while(true) {
const $ifLet0 = $generator.next({$setThis: $val => $generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
result.append({$setThis: $val => result = $val}, transform({}, iterator.next({$setThis: $val => iterator = $val}, )[0]));
}
};
while(true){
const $ifLet0 = iterator.next({$setThis: $val => iterator = $val}, )
if(!($ifLet0.rawValue === 'some')) break
let _element = $ifLet0[0]
result.append({$setThis: $val => result = $val}, transform({}, _element));
};
return _create(Array, 'initBuffer', {}, result)
----Swift.(file).Sequence.filter(_:(Self.Element) throws -> Bool)
return this._filter({}, isIncluded)
----Swift.(file).Sequence.underestimatedCount
return 0
----Swift.(file).Sequence.forEach(_:(Self.Element) throws -> Void)
{
let $element$generator = this.makeIterator({}, );
while(true) {
const $ifLet0 = $element$generator.next({$setThis: $val => $element$generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
let _element = $ifLet0[0]
body({}, _element);
}
}
----Swift.(file).Sequence.first(where:(Self.Element) throws -> Bool)
{
let $element$generator = this.makeIterator({}, );
while(true) {
const $ifLet0 = $element$generator.next({$setThis: $val => $element$generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
let _element = $ifLet0[0]
{
if((predicate({}, _element))) {
return _injectIntoOptional(_element);
}
};
}
};
return Optional.none
----Swift.(file).Sequence.split(separator:Self.Element,maxSplits:Int,omittingEmptySubsequences:Bool)
return this.splitMaxSplitsOmittingEmptySubsequencesWhereSeparator({}, maxSplits, omittingEmptySubsequences, (($info, $0) => ($0).constructor.infix_61_61({}, $0, separator)))
----Swift.(file).Sequence.split(maxSplits:Int,omittingEmptySubsequences:Bool,whereSeparator:(Self.Element) throws -> Bool)
preconditionFileLine({}, () => Int.infix_62_61({}, maxSplits, 0), () => "Must take zero or more splits", '?3', '?3');
const whole = _create(Array, 'initBuffer', {}, this);
return whole.splitMaxSplitsOmittingEmptySubsequencesWhereSeparator({}, maxSplits, omittingEmptySubsequences, isSeparator)
----Swift.(file).Sequence.suffix(_:Int)
preconditionFileLine({}, () => Int.infix_62_61({}, maxLength, 0), () => "Can't take a suffix of negative length from a sequence", '?3', '?3');
{
if(!((Int.infix_33_61({}, maxLength, 0)))) {
return _create(Array, 'initBuffer', {}, []);
}
};
let ringBuffer = _create(Array, 'initBuffer', {}, []);
ringBuffer.reserveCapacity({$setThis: $val => ringBuffer = $val}, /*dot_syntax_base_ignored*/min({}, maxLength, this.underestimatedCount));
let i = 0;
{
let $element$generator = this.makeIterator({}, );
while(true) {
const $ifLet0 = $element$generator.next({$setThis: $val => $element$generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
let _element = $ifLet0[0]
{
if((Int.infix_60({}, ringBuffer.count, maxLength))) {
ringBuffer.append({$setThis: $val => ringBuffer = $val}, _element);
}
else {
ringBuffer.subscript$set({$setThis: $val => ringBuffer = $val}, _element, i);
Int.infix_43_61({}, {get: () => i, set: $val => i = $val}, 1);
Int.infix_37_61({}, {get: () => i, set: $val => i = $val}, maxLength);
}
};
}
};
{
if((Int.infix_33_61({}, i, ringBuffer.startIndex))) {
let rotated = _create(Array, 'initBuffer', {}, []);
rotated.reserveCapacity({$setThis: $val => rotated = $val}, ringBuffer.count);
Array.infix_43_61({}, {get: () => rotated, set: $val => rotated = $val}, ringBuffer.subscriptRange$get({}, Int.infix_46_46_60({}, i, ringBuffer.endIndex)));
Array.infix_43_61({}, {get: () => rotated, set: $val => rotated = $val}, ringBuffer.subscriptRange$get({}, Int.infix_46_46_60({}, 0, i)));
return rotated;
}
else {
return ringBuffer;
}
}
----Swift.(file).Sequence.dropFirst(_:Int)
return _create(DropFirstSequence, 'initDroppingInt', {}, this, k)
----Swift.(file).Sequence.dropLast(_:Int)
preconditionFileLine({}, () => Int.infix_62_61({}, k, 0), () => "Can't drop a negative number of elements from a sequence", '?3', '?3');
{
if(!((Int.infix_33_61({}, k, 0)))) {
return _create(Array, 'initBuffer', {}, this);
}
};
let result = _create(Array, 'initBuffer', {}, []);
let ringBuffer = _create(Array, 'initBuffer', {}, []);
let i = ringBuffer.startIndex;
{
let $element$generator = this.makeIterator({}, );
while(true) {
const $ifLet0 = $element$generator.next({$setThis: $val => $element$generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
let _element = $ifLet0[0]
{
if((Int.infix_60({}, ringBuffer.count, k))) {
ringBuffer.append({$setThis: $val => ringBuffer = $val}, _element);
}
else {
result.append({$setThis: $val => result = $val}, ringBuffer.subscript$get({}, i));
ringBuffer.subscript$set({$setThis: $val => ringBuffer = $val}, _element, i);
Int.infix_43_61({}, {get: () => i, set: $val => i = $val}, 1);
Int.infix_37_61({}, {get: () => i, set: $val => i = $val}, k);
}
};
}
};
return result
----Swift.(file).Sequence.drop(while:(Self.Element) throws -> Bool)
return _create(DropWhileSequence, 'initPredicatefunction_type', {}, this, predicate)
----Swift.(file).Sequence.prefix(_:Int)
return _create(PrefixSequence, 'initMaxLengthInt', {}, this, maxLength)
----Swift.(file).Sequence.prefix(while:(Self.Element) throws -> Bool)
let result = _create(Array, 'initBuffer', {}, []);
{
let $element$generator = this.makeIterator({}, );
while(true) {
const $ifLet0 = $element$generator.next({$setThis: $val => $element$generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
let _element = $ifLet0[0]
{
if(!((predicate({}, _element)))) {
break;
}
};
result.append({$setThis: $val => result = $val}, _element);
}
};
return result
----Swift.(file).Sequence.withContiguousStorageIfAvailable(_:(UnsafeBufferPointer<Self.Element>) throws -> R)
return Optional.none
----Swift.(file).IteratorSequence.init(_:Base)
this._base = base;
return
----Swift.(file).IteratorSequence.next()
return this._base.next({$setThis: $val => this._base = $val}, )
----Swift.(file).Sequence.enumerated()
return _create(EnumeratedSequence, 'init_base', {}, this)
----Swift.(file).Sequence.min(by:(Self.Element, Self.Element) throws -> Bool)
let it = this.makeIterator({}, );
{const $ifLet0 = it.next({$setThis: $val => it = $val}, )
if(!($ifLet0.rawValue === 'some')) {
return Optional.none;
}let result = $ifLet0[0]
};
while(true){
const $ifLet0 = it.next({$setThis: $val => it = $val}, )
if(!($ifLet0.rawValue === 'some')) break
let e = $ifLet0[0]
{
if((areInIncreasingOrder({}, e, result))) {
result = e;
}
};
};
return _injectIntoOptional(result)
----Swift.(file).Sequence.max(by:(Self.Element, Self.Element) throws -> Bool)
let it = this.makeIterator({}, );
{const $ifLet0 = it.next({$setThis: $val => it = $val}, )
if(!($ifLet0.rawValue === 'some')) {
return Optional.none;
}let result = $ifLet0[0]
};
while(true){
const $ifLet0 = it.next({$setThis: $val => it = $val}, )
if(!($ifLet0.rawValue === 'some')) break
let e = $ifLet0[0]
{
if((areInIncreasingOrder({}, result, e))) {
result = e;
}
};
};
return _injectIntoOptional(result)
----Swift.(file).Sequence.min()
return this.minBy({}, this.first[0].constructor.infix_60)
----Swift.(file).Sequence.max()
return this.maxBy({}, this.first[0].constructor.infix_60)
----Swift.(file).Sequence.starts(with:PossiblePrefix,by:(Self.Element, PossiblePrefix.Element) throws -> Bool)
let possiblePrefixIterator = possiblePrefix.makeIterator({}, );
{
let $e0$generator = this.makeIterator({}, );
while(true) {
const $ifLet0 = $e0$generator.next({$setThis: $val => $e0$generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
let e0 = $ifLet0[0]
{const $ifLet0 = possiblePrefixIterator.next({$setThis: $val => possiblePrefixIterator = $val}, )
if($ifLet0.rawValue === 'some') {
let e1 = $ifLet0[0]
{
if((Bool.prefix_33({}, areEquivalent({}, e0, e1)))) {
return false;
}
};
}
else {
return true;
}
};
}
};
return Optional.wrappedEqualsOptionalNilComparisonType({}, possiblePrefixIterator.next({$setThis: $val => possiblePrefixIterator = $val}, ), _create(_OptionalNilComparisonType, 'initNilLiteraltuple_type', {}, {}))
----Swift.(file).Sequence.starts(with:PossiblePrefix)
return this.startsWithBy({}, possiblePrefix, this.first[0].constructor.infix_61_61)
----Swift.(file).Sequence.elementsEqual(_:OtherSequence,by:(Self.Element, OtherSequence.Element) throws -> Bool)
let iter1 = this.makeIterator({}, );
let iter2 = other.makeIterator({}, );
while(true){
if(!((true))) break
const $match = {0: iter1.next({$setThis: $val => iter1 = $val}, ), 1: iter2.next({$setThis: $val => iter2 = $val}, )}
if((($match[0].rawValue == 'some' && $match[1].rawValue == 'some'))) {
const e1 = $match[0][0]
const e2 = $match[1][0]
{
if((Bool.prefix_33({}, areEquivalent({}, e1, e2)))) {
return false;
}
};
}
else if((($match[0].rawValue == 'some' && $match[1].rawValue == Optional.none.rawValue) || ($match[0].rawValue == Optional.none.rawValue && $match[1].rawValue == 'some'))) {
return false;
}
else if((($match[0].rawValue == Optional.none.rawValue && $match[1].rawValue == Optional.none.rawValue))) {
return true;
};
}
----Swift.(file).Sequence.elementsEqual(_:OtherSequence)
return this.elementsEqualBy({}, other, this.first[0].constructor.infix_61_61)
----Swift.(file).Sequence.lexicographicallyPrecedes(_:OtherSequence,by:(Self.Element, Self.Element) throws -> Bool)
let iter1 = this.makeIterator({}, );
let iter2 = other.makeIterator({}, );
while(true){
if(!((true))) break
{const $ifLet0 = iter1.next({$setThis: $val => iter1 = $val}, )
if($ifLet0.rawValue === 'some') {
let e1 = $ifLet0[0]
{const $ifLet0 = iter2.next({$setThis: $val => iter2 = $val}, )
if($ifLet0.rawValue === 'some') {
let e2 = $ifLet0[0]
{
if((areInIncreasingOrder({}, e1, e2))) {
return true;
}
};
{
if((areInIncreasingOrder({}, e2, e1))) {
return false;
}
};
continue;
}
};
return false;
}
};
return Optional.wrappedNotEqualsOptionalNilComparisonType({}, iter2.next({$setThis: $val => iter2 = $val}, ), _create(_OptionalNilComparisonType, 'initNilLiteraltuple_type', {}, {}));
}
----Swift.(file).Sequence.lexicographicallyPrecedes(_:OtherSequence)
return this.lexicographicallyPrecedesBy({}, other, this.first[0].constructor.infix_60)
----Swift.(file).Sequence.contains(where:(Self.Element) throws -> Bool)
{
let $e$generator = this.makeIterator({}, );
while(true) {
const $ifLet0 = $e$generator.next({$setThis: $val => $e$generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
let e = $ifLet0[0]
{
if((predicate({}, e))) {
return true;
}
};
}
};
return false
----Swift.(file).Sequence.allSatisfy(_:(Self.Element) throws -> Bool)
return Bool.prefix_33({}, this.containsWhere({}, (($info, $0) => Bool.prefix_33({}, predicate({}, $0)))))
----Swift.(file).Sequence.contains(_:Self.Element)
{const $ifLet0 = this._customContainsEquatableElement({}, _element)
if($ifLet0.rawValue === 'some') {
let result = $ifLet0[0]
return result;
}
else {
return this.containsWhere({}, (($info, $0) => ($0).constructor.infix_61_61({}, $0, _element)));
}
}
----Swift.(file).Sequence.count(where:(Self.Element) throws -> Bool)
let count = 0;
{
let $e$generator = this.makeIterator({}, );
while(true) {
const $ifLet0 = $e$generator.next({$setThis: $val => $e$generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
let e = $ifLet0[0]
{
if((predicate({}, e))) {
Int.infix_43_61({}, {get: () => count, set: $val => count = $val}, 1);
}
};
}
};
return count
----Swift.(file).Sequence.reduce(_:Result,_:(Result, Self.Element) throws -> Result)
let accumulator = initialResult;
{
let $element$generator = this.makeIterator({}, );
while(true) {
const $ifLet0 = $element$generator.next({$setThis: $val => $element$generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
let _element = $ifLet0[0]
accumulator = nextPartialResult({}, accumulator, _element);
}
};
return accumulator
----Swift.(file).Sequence.reduce(into:Result,_:(inout Result, Self.Element) throws -> ())
let accumulator = initialResult;
{
let $element$generator = this.makeIterator({}, );
while(true) {
const $ifLet0 = $element$generator.next({$setThis: $val => $element$generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
let _element = $ifLet0[0]
updateAccumulatingResult({}, {get: () => accumulator, set: $val => accumulator = $val}, _element);
}
};
return accumulator
----Swift.(file).Sequence.reversed()
let result = _create(Array, 'initBuffer', {}, this);
const count = result.count;
{
let $i$generator = _cloneStruct(Int.infix_46_46_60({}, 0, Int.infix_47({}, count, 2)).makeIterator({}, ));
while(true) {
const $ifLet0 = $i$generator.next({$setThis: $val => $i$generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
let i = $ifLet0[0]
result.swapAt({$setThis: $val => result = $val}, i, Int.infix_45({}, count, Int.infix_43({}, i, 1)));
}
};
return result
----Swift.(file).Sequence.flatMap(_:(Self.Element) throws -> SegmentOfResult)
let result = _create(Array, 'initBuffer', {}, []);
{
let $element$generator = this.makeIterator({}, );
while(true) {
const $ifLet0 = $element$generator.next({$setThis: $val => $element$generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
let _element = $ifLet0[0]
result.appendContentsOf({$setThis: $val => result = $val}, transform({}, _element));
}
};
return result
----Swift.(file).Sequence.compactMap(_:(Self.Element) throws -> ElementOfResult?)
return this._compactMap({}, transform)
----Swift.(file).SetAlgebra.init(_:S)
this.init({}, );
{
let $e$generator = sequence.makeIterator({}, );
while(true) {
const $ifLet0 = $e$generator.next({$setThis: $val => $e$generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
let e = $ifLet0[0]
this.insert({$setThis: $val => $info.$setThis(_cloneStruct($val))}, e);
}
};
return
----Swift.(file).SetAlgebra.subtract(_:Self)
this.formIntersection({$setThis: $val => $info.$setThis(_cloneStruct($val))}, this.symmetricDifference({}, other))
----Swift.(file).SetAlgebra.isSubset(of:Self)
return (this.intersection({}, other)).constructor.infix_61_61({}, this.intersection({}, other), this)
----Swift.(file).SetAlgebra.isSuperset(of:Self)
return other.isSubsetOf({}, this)
----Swift.(file).SetAlgebra.isDisjoint(with:Self)
return this.intersection({}, other).isEmpty
----Swift.(file).SetAlgebra.subtracting(_:Self)
return this.intersection({}, this.symmetricDifference({}, other))
----Swift.(file).SetAlgebra.isEmpty
return (this).constructor.infix_61_61({}, this, _create(this.constructor, 'init', {}, ))
----Swift.(file).SetAlgebra.isStrictSuperset(of:Self)
return Bool.infix_38_38({}, this.isSupersetOf({}, other), () => (this).constructor.infix_33_61({}, this, other))
----Swift.(file).SetAlgebra.isStrictSubset(of:Self)
return other.isStrictSupersetOf({}, this)
----Swift.(file).SetAlgebra.init(arrayLiteral:[Self.Element])
this.initSource({}, arrayLiteral);
return
----Swift.(file).Set.insert(_:ConcreteElement)
const $tuple = this.insert({$setThis: $val => $info.$setThis(_cloneStruct($val))}, _create(AnyHashable, 'init', {}, newMember)), inserted = $tuple && $tuple[0], memberAfterInsert = $tuple && $tuple[1];
return {0: inserted, 1: memberAfterInsert.base}
----Swift.(file).Set.update(with:ConcreteElement)
return this.updateWith({$setThis: $val => $info.$setThis(_cloneStruct($val))}, _create(AnyHashable, 'init', {}, newMember)).mapSwift({}, (($info, $0) => $0.base))
----Swift.(file).Set.remove(_:ConcreteElement)
return this.remove({$setThis: $val => $info.$setThis(_cloneStruct($val))}, _create(AnyHashable, 'init', {}, member)).mapSwift({}, (($info, $0) => $0.base))
----Swift.(file)..(error_type).bridged()
const nsSet;
{
if((Bool.infix_124_124({}, infix_61_61_61({}, _injectIntoOptional(this._storage), _injectIntoOptional(_RawSetStorage.empty)), () => Int.infix_61_61({}, this.count, 0)))) {
nsSet = _cloneStruct(_RawSetStorage.empty);
}
else {
{
if((_isBridgedVerbatimToObjectiveC({}, ((function(){throw '!unclarifiedGeneric:Element'})())))) {
nsSet = _cloneStruct(unsafeDowncastTo({}, this._storage, _SetStorage));
}
else {
nsSet = _cloneStruct(_create(_SwiftDeferredNSSet, 'init_NativeSet', {}, this));
}
}
}
};
return nsSet
----Swift.(file)._CocoaSet.member(for:_CocoaSet.Index)
return index._element
----Swift.(file)._CocoaSet.member(for:AnyObject)
const nss = _cloneStruct(unsafeBitCastTo({}, this.object, _NSSet));
return nss.member({}, _element)
----Swift.(file)._CocoaSet.isEqual(to:_CocoaSet)
return _stdlib_NSObject_isEqual({}, this.object, other.object)
----Swift.(file)._CocoaSet.startIndex
const allKeys = _cloneStruct(_stdlib_NSSet_allObjects({}, this.object));
return _create(_CocoaSet.Index, 'init_CocoaSetIndexStorageOffsetInt', {}, _create(_CocoaSet.Index.Storage, 'init_CocoaSet_BridgingBuffer', {}, this, allKeys), 0)
----Swift.(file)._CocoaSet.endIndex
const allKeys = _cloneStruct(_stdlib_NSSet_allObjects({}, this.object));
return _create(_CocoaSet.Index, 'init_CocoaSetIndexStorageOffsetInt', {}, _create(_CocoaSet.Index.Storage, 'init_CocoaSet_BridgingBuffer', {}, this, allKeys), allKeys.count)
----Swift.(file)._CocoaSet.index(after:_CocoaSet.Index)
this.validate({}, index);
let result = _cloneStruct(index);
Int.infix_43_61({}, {get: () => result._offset, set: $val => result._offset = $val}, 1);
return result
----Swift.(file)._CocoaSet.validate(_:_CocoaSet.Index)
preconditionFileLine({}, () => infix_61_61_61({}, _injectIntoOptional(index.storage.base.object), _injectIntoOptional(this.object)), () => "Invalid index", '?3', '?3');
preconditionFileLine({}, () => Int.infix_60({}, index._offset, index.storage.allKeys.count), () => "Attempt to access endIndex", '?3', '?3')
----Swift.(file)._CocoaSet.formIndex(after:_CocoaSet.Index,isUnique:Bool)
let index = index$inout.get()
const $result = (() => {
this.validate({}, index);
Int.infix_43_61({}, {get: () => index._offset, set: $val => index._offset = $val}, 1);})()
index$inout.set(index)
return $result
----Swift.(file)._CocoaSet.count
const nss = _cloneStruct(unsafeBitCastTo({}, this.object, _NSSet));
return nss.count
----Swift.(file)._CocoaSet.contains(_:AnyObject)
const nss = _cloneStruct(unsafeBitCastTo({}, this.object, _NSSet));
return Optional.wrappedNotEqualsOptionalNilComparisonType({}, nss.member({}, _element), _create(_OptionalNilComparisonType, 'initNilLiteraltuple_type', {}, {}))
----Swift.(file)._CocoaSet.element(at:_CocoaSet.Index)
const _element = _injectIntoOptional(i._element);
return _element[0]
----Swift.(file)._CocoaSet.Index.handleBitPattern
return unsafeBitCastTo({}, this.storage, UInt)
----Swift.(file)._CocoaSet.Index.age
return _HashTable.ageFor({}, this.storage.base.object)
----Swift.(file)._CocoaSet.Index.==infix(_:_CocoaSet.Index,_:_CocoaSet.Index)
preconditionFileLine({}, () => infix_61_61_61({}, _injectIntoOptional(lhs.storage.base.object), _injectIntoOptional(rhs.storage.base.object)), () => "Comparing indexes from different sets", '?3', '?3');
return Int.infix_61_61({}, lhs._offset, rhs._offset)
----Swift.(file)._CocoaSet.Index.<infix(_:_CocoaSet.Index,_:_CocoaSet.Index)
preconditionFileLine({}, () => infix_61_61_61({}, _injectIntoOptional(lhs.storage.base.object), _injectIntoOptional(rhs.storage.base.object)), () => "Comparing indexes from different sets", '?3', '?3');
return Int.infix_60({}, lhs._offset, rhs._offset)
----Swift.(file)._CocoaSet.makeIterator()
return _create(_CocoaSet.Iterator, 'init_CocoaSet', {}, this)
----Swift.(file)._CocoaSet.Iterator.next()
{
if((Int.infix_60({}, this.itemIndex, 0))) {
return Optional.none;
}
};
const base = _cloneStruct(this.base);
{
if((Int.infix_61_61({}, this.itemIndex, this.itemCount))) {
const stackBufCount = this._fastEnumerationStackBuf.count;
this.itemCount = /*dynamic_member_ref_expr*/base.object[0]({}, this._fastEnumerationStatePtr, _create(UnsafeMutableRawPointer, 'initUnsafeMutablePointer', {}, this._fastEnumerationStackBufPtr).assumingMemoryBoundTo({}, AnyObject), stackBufCount);
{
if((Int.infix_61_61({}, this.itemCount, 0))) {
this.itemIndex = -1;
return Optional.none;
}
};
this.itemIndex = 0;
}
};
const itemsPtrUP = _cloneStruct(_create(UnsafeMutableRawPointer, 'initAutoreleasingUnsafeMutablePointer', {}, this._fastEnumerationState.itemsPtr[0]).assumingMemoryBoundTo({}, AnyObject));
const itemsPtr = _create(_UnmanagedAnyObjectArray, 'initUnsafeMutablePointer', {}, itemsPtrUP);
const key = _cloneStruct(itemsPtr.subscript$get({}, this.itemIndex));
Int.infix_43_61({}, {get: () => this.itemIndex, set: $val => this.itemIndex = $val}, 1);
return _injectIntoOptional(key)
----Swift.(file)._EmptySetSingleton.copy(with:<<error type>>)
return this
----Swift.(file)._EmptySetSingleton.count
return 0
----Swift.(file)._EmptySetSingleton.member(_:AnyObject)
return Optional.none
----Swift.(file)._EmptySetSingleton.objectEnumerator()
return _create(_SwiftEmptyNSEnumerator, 'init', {}, )
----Swift.(file)._SetStorage.copy(original:_RawSetStorage)
return _SetStorage.allocateScaleAgeSeed({}, original._scale, _injectIntoOptional(original._age), _injectIntoOptional(original._seed))
----Swift.(file)._SetStorage.resize(original:_RawSetStorage,capacity:Int,move:Bool)
const scale = _HashTable.scaleForCapacity({}, capacity);
return this.allocateScaleAgeSeed({}, scale, Optional.none, Optional.none)
----Swift.(file)._SetStorage.allocate(capacity:Int)
const scale = _HashTable.scaleForCapacity({}, capacity);
return this.allocateScaleAgeSeed({}, scale, Optional.none, Optional.none)
----Swift.(file)._SetStorage.convert(_:<<error type>>,capacity:Int)
const scale = _HashTable.scaleForCapacity({}, capacity);
const age = _HashTable.ageFor({}, cocoa.object);
return this.allocateScaleAgeSeed({}, scale, _injectIntoOptional(age), Optional.none)
----Swift.(file).Hasher._State.compress(_:UInt64)
UInt64.infix_94_61({}, {get: () => this.v3, set: $val => this.v3 = $val}, m);
this._round({$setThis: $val => $info.$setThis(_cloneStruct($val))}, );
UInt64.infix_94_61({}, {get: () => this.v0, set: $val => this.v0 = $val}, m)
----Swift.(file).Hasher._State.finalize(tailAndByteCount:UInt64)
this.compress({$setThis: $val => $info.$setThis(_cloneStruct($val))}, tailAndByteCount);
UInt64.infix_94_61({}, {get: () => this.v2, set: $val => this.v2 = $val}, 0xff);
{
let $generator = _cloneStruct(Int.infix_46_46_60({}, 0, 3).makeIterator({}, ));
while(true) {
const $ifLet0 = $generator.next({$setThis: $val => $generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
this._round({$setThis: $val => $info.$setThis(_cloneStruct($val))}, );
}
};
return this._extract({}, )
----Swift.(file).Hasher._State.init()
this.initRawSeedtuple_type({}, Hasher._executionSeed);
return
----Swift.(file).Hasher._State.init(seed:Int)
const executionSeed = Hasher._executionSeed;
const seed = _create(UInt, 'initBitPatternInt', {}, seed);
this.initRawSeedtuple_type({}, {0: UInt64.infix_94({}, executionSeed["0"], _create(UInt64, 'initTruncatingIfNeeded', {}, seed)), 1: executionSeed["1"]});
return
----Swift.(file).Slice.init(base:Base,bounds:Range<Base.Index>)
this._base = base;
this._startIndex = bounds.lowerBound;
this._endIndex = bounds.upperBound;
return
----Swift.(file).Slice.base
return this._base
----Swift.(file).Slice.startIndex
return this._startIndex
----Swift.(file).Slice.endIndex
return this._endIndex
----Swift.(file).Slice.subscript(_:Slice<Base>.Index)
return this._base.subscript$get({}, index)
----Swift.(file).Slice.subscript(_:Range<Slice<Base>.Index>)
return _create(Slice, 'initBaseBoundsRange', {}, this._base, bounds)
----Swift.(file).Slice.indices
return this._base.indices.subscriptRange$get({}, (this._startIndex).constructor.infix_46_46_60({}, this._startIndex, this._endIndex))
----Swift.(file).Slice.index(after:Slice<Base>.Index)
return this._base.indexAfter({}, i)
----Swift.(file).Slice.formIndex(after:Slice<Base>.Index)
let i = i$inout.get()
const $result = (() => {
this._base.formIndexAfter({}, {get: () => i, set: $val => i = $val});})()
i$inout.set(i)
return $result
----Swift.(file).Slice.index(_:Slice<Base>.Index,offsetBy:Int)
return this._base.indexOffsetBy({}, i, n)
----Swift.(file).Slice.index(_:Slice<Base>.Index,offsetBy:Int,limitedBy:Slice<Base>.Index)
return this._base.indexOffsetByLimitedBy({}, i, n, limit)
----Swift.(file).Slice.distance(from:Slice<Base>.Index,to:Slice<Base>.Index)
return this._base.distanceFromTo({}, start, end)
----Swift.(file).Slice.index(before:Slice<Base>.Index)
return this._base.indexBefore({}, i)
----Swift.(file).Slice.formIndex(before:Slice<Base>.Index)
let i = i$inout.get()
const $result = (() => {
this._base.formIndexBefore({}, {get: () => i, set: $val => i = $val});})()
i$inout.set(i)
return $result
----Swift.(file).Slice.subscript(_:Slice<Base>.Index)#ASS

this._base.subscript$set({$setThis: $val => this._base = $val}, newValue, index)
----Swift.(file).Slice.subscript(_:Slice<Base>.Index)
return this._base.subscript$get({}, index);

----Swift.(file).Slice.subscript(_:Range<Slice<Base>.Index>)#ASS

_writeBackMutableSliceBoundsSlice({}, {get: () => this, set: $val => $info.$setThis(_cloneStruct($val))}, bounds, newValue)
----Swift.(file).Slice.subscript(_:Range<Slice<Base>.Index>)
return _create(Slice, 'initBaseBoundsRange', {}, this._base, bounds);

----Swift.(file).Slice.init()
this._base = _create(((function(){throw '!unclarifiedGeneric:Base'})()), 'init', {}, );
this._startIndex = this._base.startIndex;
this._endIndex = this._base.endIndex;
return
----Swift.(file).Slice.init(repeating:Base.Element,count:Int)
this._base = _create(((function(){throw '!unclarifiedGeneric:Base'})()), 'initRepeatingCountInt', {}, repeatedValue, count);
this._startIndex = this._base.startIndex;
this._endIndex = this._base.endIndex;
return
----Swift.(file).Slice.init(_:S)
this._base = _create(((function(){throw '!unclarifiedGeneric:Base'})()), 'initBuffer', {}, _elements);
this._startIndex = this._base.startIndex;
this._endIndex = this._base.endIndex;
return
----Swift.(file).Slice.replaceSubrange(_:Range<Slice<Base>.Index>,with:C)
const sliceOffset = this._base.distanceFromTo({}, this._base.startIndex, this._startIndex);
const newSliceCount = Int.infix_43({}, Int.infix_43({}, this._base.distanceFromTo({}, this._startIndex, subRange.lowerBound), this._base.distanceFromTo({}, subRange.upperBound, this._endIndex)), numericCast({}, newElements.count));
this._base.replaceSubrangeWith({$setThis: $val => this._base = $val}, subRange, newElements);
this._startIndex = this._base.indexOffsetBy({}, this._base.startIndex, sliceOffset);
this._endIndex = this._base.indexOffsetBy({}, this._startIndex, newSliceCount)
----Swift.(file).Slice.insert(_:Base.Element,at:Slice<Base>.Index)
const sliceOffset = this._base.distanceFromTo({}, this._base.startIndex, this._startIndex);
const newSliceCount = Int.infix_43({}, this.count, 1);
this._base.insertAt({$setThis: $val => this._base = $val}, newElement, i);
this._startIndex = this._base.indexOffsetBy({}, this._base.startIndex, sliceOffset);
this._endIndex = this._base.indexOffsetBy({}, this._startIndex, newSliceCount)
----Swift.(file).Slice.insert(contentsOf:S,at:Slice<Base>.Index)
const sliceOffset = this._base.distanceFromTo({}, this._base.startIndex, this._startIndex);
const newSliceCount = Int.infix_43({}, this.count, newElements.count);
this._base.insertContentsOfAt({$setThis: $val => this._base = $val}, newElements, i);
this._startIndex = this._base.indexOffsetBy({}, this._base.startIndex, sliceOffset);
this._endIndex = this._base.indexOffsetBy({}, this._startIndex, newSliceCount)
----Swift.(file).Slice.remove(at:Slice<Base>.Index)
const sliceOffset = this._base.distanceFromTo({}, this._base.startIndex, this._startIndex);
const newSliceCount = Int.infix_45({}, this.count, 1);
const result = this._base.removeAt({$setThis: $val => this._base = $val}, i);
this._startIndex = this._base.indexOffsetBy({}, this._base.startIndex, sliceOffset);
this._endIndex = this._base.indexOffsetBy({}, this._startIndex, newSliceCount);
return result
----Swift.(file).Slice.removeSubrange(_:Range<Slice<Base>.Index>)
const sliceOffset = this._base.distanceFromTo({}, this._base.startIndex, this._startIndex);
const newSliceCount = Int.infix_45({}, this.count, this.distanceFromTo({}, bounds.lowerBound, bounds.upperBound));
this._base.removeSubrangeRange({$setThis: $val => this._base = $val}, bounds);
this._startIndex = this._base.indexOffsetBy({}, this._base.startIndex, sliceOffset);
this._endIndex = this._base.indexOffsetBy({}, this._startIndex, newSliceCount)
----Swift.(file).Slice.replaceSubrange(_:Range<Slice<Base>.Index>,with:C)
{
if(((subRange.lowerBound).constructor.infix_61_61({}, subRange.lowerBound, this._base.startIndex))) {
const newSliceCount = Int.infix_43({}, Int.infix_43({}, this._base.distanceFromTo({}, this._startIndex, subRange.lowerBound), this._base.distanceFromTo({}, subRange.upperBound, this._endIndex)), numericCast({}, newElements.count));
this._base.replaceSubrangeWith({$setThis: $val => this._base = $val}, subRange, newElements);
this._startIndex = this._base.startIndex;
this._endIndex = this._base.indexOffsetBy({}, this._startIndex, newSliceCount);
}
else {
const shouldUpdateStartIndex = (subRange.lowerBound).constructor.infix_61_61({}, subRange.lowerBound, this._startIndex);
const lastValidIndex = this._base.indexBefore({}, subRange.lowerBound);
const newEndIndexOffset = Int.infix_43({}, Int.infix_43({}, this._base.distanceFromTo({}, subRange.upperBound, this._endIndex), numericCast({}, newElements.count)), 1);
this._base.replaceSubrangeWith({$setThis: $val => this._base = $val}, subRange, newElements);
{
if((shouldUpdateStartIndex)) {
this._startIndex = this._base.indexAfter({}, lastValidIndex);
}
};
this._endIndex = this._base.indexOffsetBy({}, lastValidIndex, newEndIndexOffset);
}
}
----Swift.(file).Slice.insert(_:Base.Element,at:Slice<Base>.Index)
{
if(((i).constructor.infix_61_61({}, i, this._base.startIndex))) {
const newSliceCount = Int.infix_43({}, this.count, 1);
this._base.insertAt({$setThis: $val => this._base = $val}, newElement, i);
this._startIndex = this._base.startIndex;
this._endIndex = this._base.indexOffsetBy({}, this._startIndex, newSliceCount);
}
else {
const shouldUpdateStartIndex = (i).constructor.infix_61_61({}, i, this._startIndex);
const lastValidIndex = this._base.indexBefore({}, i);
const newEndIndexOffset = Int.infix_43({}, this._base.distanceFromTo({}, i, this._endIndex), 2);
this._base.insertAt({$setThis: $val => this._base = $val}, newElement, i);
{
if((shouldUpdateStartIndex)) {
this._startIndex = this._base.indexAfter({}, lastValidIndex);
}
};
this._endIndex = this._base.indexOffsetBy({}, lastValidIndex, newEndIndexOffset);
}
}
----Swift.(file).Slice.insert(contentsOf:S,at:Slice<Base>.Index)
{
if(((i).constructor.infix_61_61({}, i, this._base.startIndex))) {
const newSliceCount = Int.infix_43({}, this.count, numericCast({}, newElements.count));
this._base.insertContentsOfAt({$setThis: $val => this._base = $val}, newElements, i);
this._startIndex = this._base.startIndex;
this._endIndex = this._base.indexOffsetBy({}, this._startIndex, newSliceCount);
}
else {
const shouldUpdateStartIndex = (i).constructor.infix_61_61({}, i, this._startIndex);
const lastValidIndex = this._base.indexBefore({}, i);
const newEndIndexOffset = Int.infix_43({}, Int.infix_43({}, this._base.distanceFromTo({}, i, this._endIndex), numericCast({}, newElements.count)), 1);
this._base.insertContentsOfAt({$setThis: $val => this._base = $val}, newElements, i);
{
if((shouldUpdateStartIndex)) {
this._startIndex = this._base.indexAfter({}, lastValidIndex);
}
};
this._endIndex = this._base.indexOffsetBy({}, lastValidIndex, newEndIndexOffset);
}
}
----Swift.(file).Slice.remove(at:Slice<Base>.Index)
{
if(((i).constructor.infix_61_61({}, i, this._base.startIndex))) {
const newSliceCount = Int.infix_45({}, this.count, 1);
const result = this._base.removeAt({$setThis: $val => this._base = $val}, i);
this._startIndex = this._base.startIndex;
this._endIndex = this._base.indexOffsetBy({}, this._startIndex, newSliceCount);
return result;
}
else {
const shouldUpdateStartIndex = (i).constructor.infix_61_61({}, i, this._startIndex);
const lastValidIndex = this._base.indexBefore({}, i);
const newEndIndexOffset = this._base.distanceFromTo({}, i, this._endIndex);
const result = this._base.removeAt({$setThis: $val => this._base = $val}, i);
{
if((shouldUpdateStartIndex)) {
this._startIndex = this._base.indexAfter({}, lastValidIndex);
}
};
this._endIndex = this._base.indexOffsetBy({}, lastValidIndex, newEndIndexOffset);
return result;
}
}
----Swift.(file).Slice.removeSubrange(_:Range<Slice<Base>.Index>)
{
if(((bounds.lowerBound).constructor.infix_61_61({}, bounds.lowerBound, this._base.startIndex))) {
const newSliceCount = Int.infix_45({}, this.count, this._base.distanceFromTo({}, bounds.lowerBound, bounds.upperBound));
this._base.removeSubrangeRange({$setThis: $val => this._base = $val}, bounds);
this._startIndex = this._base.startIndex;
this._endIndex = this._base.indexOffsetBy({}, this._startIndex, newSliceCount);
}
else {
const shouldUpdateStartIndex = (bounds.lowerBound).constructor.infix_61_61({}, bounds.lowerBound, this._startIndex);
const lastValidIndex = this._base.indexBefore({}, bounds.lowerBound);
const newEndIndexOffset = Int.infix_43({}, Int.infix_45({}, this._base.distanceFromTo({}, bounds.lowerBound, this._endIndex), this._base.distanceFromTo({}, bounds.lowerBound, bounds.upperBound)), 1);
this._base.removeSubrangeRange({$setThis: $val => this._base = $val}, bounds);
{
if((shouldUpdateStartIndex)) {
this._startIndex = this._base.indexAfter({}, lastValidIndex);
}
};
this._endIndex = this._base.indexOffsetBy({}, lastValidIndex, newEndIndexOffset);
}
}
----Swift.(file)._SmallBuffer.stride
return MemoryLayout.stride
----Swift.(file)._SmallBuffer.byteCapacity
return MemoryLayout.strideOfValue({}, this._inlineStorage)
----Swift.(file)._SmallBuffer.capacity
return Int.infix_47({}, this.byteCapacity, this.stride)
----Swift.(file)._SmallBuffer.subscript(_:Int)#ASS

const capacity = this.capacity;
withUnsafeMutableBytesOf({}, {get: () => this._inlineStorage, set: $val => this._inlineStorage = $val}, (($info, $0) => { 
const rawPtr = _cloneStruct($0.baseAddress._unsafelyUnwrappedUnchecked);
const bufPtr = _create(UnsafeMutableBufferPointer, 'initStartOptionalCountInt', {}, _injectIntoOptional(/*pointer_to_pointer*/rawPtr.assumingMemoryBoundTo({}, ((function(){throw '!unclarifiedGeneric:T'})()))), capacity);
bufPtr.subscript_unchecked$set({$setThis: $val => bufPtr = _cloneStruct($val)}, newValue, i); }))
----Swift.(file)._SmallBuffer.subscript(_:Int)
const capacity = this.capacity;
return withUnsafeBytesOf({}, this._inlineStorage, (($info, $0) => { 
const rawPtr = _cloneStruct($0.baseAddress._unsafelyUnwrappedUnchecked);
const bufPtr = _create(UnsafeBufferPointer, 'initStartOptionalCountInt', {}, _injectIntoOptional(/*pointer_to_pointer*/rawPtr.assumingMemoryBoundTo({}, ((function(){throw '!unclarifiedGeneric:T'})()))), capacity);
return bufPtr.subscript_unchecked$get({}, i); }));

----Swift.(file)._SmallString.capacity
return 15;
}
static get capacity() { return this.capacity$get()
----Swift.(file)._SmallString.rawDiscriminatedObject
return this._storage["1"]
----Swift.(file)._SmallString.count
return _StringObject.getSmallCountFromRaw({}, this.rawDiscriminatedObject)
----Swift.(file)._SmallString.unusedCapacity
return Int.infix_38_45({}, this.capacity, this.count)
----Swift.(file)._SmallString.isASCII
return _StringObject.getSmallIsASCIIFromRaw({}, this.rawDiscriminatedObject)
----Swift.(file)._SmallString.zeroTerminatedRawCodeUnits
const smallStringCodeUnitMask = 0x00FFFFFFFFFFFFFF;
return {0: this._storage["0"], 1: UInt64.infix_38({}, this._storage["1"], smallStringCodeUnitMask)}
----Swift.(file)._SmallString.computeIsASCII()
const asciiMask = 0x8080808080808080;
const raw = this.zeroTerminatedRawCodeUnits;
return UInt64.infix_61_61({}, UInt64.infix_38({}, UInt64.infix_124({}, raw["0"], raw["1"]), asciiMask), 0)
----Swift.(file)._SmallString.startIndex
return 0
----Swift.(file)._SmallString.endIndex
return this.count
----Swift.(file)._SmallString.subscript(_:Int)#ASS

{
if((Int.infix_60({}, idx, 8))) {
this.leadingRawBits._uncheckedSetByteAtTo({$setThis: $val => this.leadingRawBits = $val}, idx, newValue);
}
else {
this.trailingRawBits._uncheckedSetByteAtTo({$setThis: $val => this.trailingRawBits = $val}, Int.infix_38_45({}, idx, 8), newValue);
}
}
----Swift.(file)._SmallString.subscript(_:Int)
{
if((Int.infix_60({}, idx, 8))) {
return this.leadingRawBits._uncheckedGetByteAt({}, idx);
}
else {
return this.trailingRawBits._uncheckedGetByteAt({}, Int.infix_38_45({}, idx, 8));
}
};

----Swift.(file)._SmallString.subscript(_:Range<_SmallString.Index>)
return this.withUTF8({}, (($info, utf8) => { 
const rebased = _create(UnsafeBufferPointer, 'initRebasingSlice', {}, utf8.subscriptRange$get({}, bounds));
return _create(_SmallString, 'initUnsafeBufferPointer', {}, rebased)._unsafelyUnwrappedUnchecked; }))
----Swift.(file)._SmallString.withUTF8(_:(UnsafeBufferPointer<UInt8>) throws -> Result)
let raw = this.zeroTerminatedRawCodeUnits;
return /*dot_syntax_base_ignored*/withUnsafeBytesOf({}, {get: () => raw, set: $val => raw = $val}, (($info, rawBufPtr) => { 
const ptr = _cloneStruct(rawBufPtr.baseAddress._unsafelyUnwrappedUnchecked.assumingMemoryBoundTo({}, UInt8));
return f({}, _create(UnsafeBufferPointer, 'initStartOptionalCountInt', {}, _injectIntoOptional(/*pointer_to_pointer*/ptr), this.count)); }))
----Swift.(file)._SmallString.withMutableCapacity(_:(UnsafeMutableBufferPointer<UInt8>) throws -> Int)
const len = withUnsafeMutableBytesOf({}, {get: () => this._storage, set: $val => this._storage = $val}, (($info, rawBufPtr) => { 
const ptr = _cloneStruct(rawBufPtr.baseAddress._unsafelyUnwrappedUnchecked.assumingMemoryBoundTo({}, UInt8));
return f({}, _create(UnsafeMutableBufferPointer, 'initStartOptionalCountInt', {}, _injectIntoOptional(/*pointer_to_pointer*/ptr), _SmallString.capacity)); }));
const $tuple = this.zeroTerminatedRawCodeUnits, leading = $tuple && $tuple[0], trailing = $tuple && $tuple[1];
$info.$setThis(_cloneStruct(_create(_SmallString, 'initLeadingUInt64TrailingUInt64CountInt', {}, leading, trailing, len)))
----Swift.(file)._SmallString.init(leading:UInt64,trailing:UInt64,count:Int)
const isASCII = UInt64.infix_61_61({}, UInt64.infix_38({}, UInt64.infix_124({}, leading, trailing), 0x8080808080808080), 0);
const countAndDiscriminator = UInt64.infix_124({}, UInt64.infix_38_60_60({}, _create(UInt64, 'initTruncatingIfNeeded', {}, count), 56), _StringObject.Nibbles.smallIsASCII({}, isASCII));
this.initRaw_SmallStringRawBitPattern({}, {0: leading, 1: UInt64.infix_124({}, trailing, countAndDiscriminator)});
return
----Swift.(file)._SmallString.init(_:UnsafeBufferPointer<UInt8>)
const count = input.count;
{
if(!((Int.infix_60_61({}, count, _SmallString.capacity)))) {
return (this.$failed = true);
}
};
const ptr = _cloneStruct(input.baseAddress._unsafelyUnwrappedUnchecked);
const leading = _bytesToUInt64({}, ptr, /*dot_syntax_base_ignored*/min({}, input.count, 8));
const trailing = (Int.infix_62({}, count, 8) ? _bytesToUInt64({}, UnsafePointer.infix_43({}, ptr, 8), Int.infix_38_45({}, count, 8)) : 0);
this.initLeadingUInt64TrailingUInt64CountInt({}, leading, trailing, count);
return
----Swift.(file)._SmallString.init(_:_SmallString,appending:_SmallString)
const totalCount = Int.infix_43({}, base.count, other.count);
{
if(!((Int.infix_60_61({}, totalCount, _SmallString.capacity)))) {
return (this.$failed = true);
}
};
let result = _cloneStruct(base);
let writeIdx = base.count;
{
let $readIdx$generator = _cloneStruct(Int.infix_46_46_60({}, 0, other.count).makeIterator({}, ));
while(true) {
const $ifLet0 = $readIdx$generator.next({$setThis: $val => $readIdx$generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
let readIdx = $ifLet0[0]
result.subscript$set({$setThis: $val => result = $val}, other.subscript$get({}, readIdx), writeIdx);
Int.infix_38_43_61({}, {get: () => writeIdx, set: $val => writeIdx = $val}, 1);
}
};
const $tuple = result.zeroTerminatedRawCodeUnits, leading = $tuple && $tuple[0], trailing = $tuple && $tuple[1];
this.initLeadingUInt64TrailingUInt64CountInt({}, leading, trailing, totalCount);
return
----Swift.(file).Sequence.sorted()
return this.sortedBy({}, this.first[0].constructor.infix_60)
----Swift.(file).Sequence.sorted(by:(Self.Element, Self.Element) throws -> Bool)
let result = _create(ContiguousArray, 'initBuffer', {}, this);
result.sortBy({$setThis: $val => result = $val}, areInIncreasingOrder);
return _create(Array, 'initBuffer', {}, result)
----Swift.(file).MutableCollection.sort()
this.sortBy({$setThis: $val => $info.$setThis(_cloneStruct($val))}, this.first[0].constructor.infix_60)
----Swift.(file).MutableCollection.sort(by:(Self.Element, Self.Element) throws -> Bool)
const didSortUnsafeBuffer = this._withUnsafeMutableBufferPointerIfSupported({$setThis: $val => $info.$setThis(_cloneStruct($val))}, (($info, buffer$inout) => _injectIntoOptional(buffer._stableSortImplBy({$setThis: $val => buffer = $val}, areInIncreasingOrder))));
{
if((Optional.wrappedEqualsOptionalNilComparisonType({}, didSortUnsafeBuffer, _create(_OptionalNilComparisonType, 'initNilLiteraltuple_type', {}, {})))) {
const sortedElements = _cloneStruct(this.sortedBy({}, areInIncreasingOrder));
{
let $generator = _cloneStruct(zip({}, this.indices, sortedElements.indices).makeIterator({}, ));
while(true) {
const $ifLet0 = $generator.next({$setThis: $val => $generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
let i = $ifLet0[0][0], j = $ifLet0[0][1]
this.subscript$set({$setThis: $val => $info.$setThis(_cloneStruct($val))}, sortedElements.subscript$get({}, j), i);
}
};
}
}
----Swift.(file).StaticString.utf8Start
preconditionFileLine({}, () => this.hasPointerRepresentation, () => "StaticString should have pointer representation", '?3', '?3');
return _create(UnsafePointer, 'initBitPatternUInt', {}, _create(UInt, 'initWord', {}, this._startPtrOrData))[0]
----Swift.(file).StaticString.unicodeScalar
preconditionFileLine({}, () => Bool.prefix_33({}, this.hasPointerRepresentation), () => "StaticString should have Unicode scalar representation", '?3', '?3');
return _create(Unicode.Scalar, 'initUInt32', {}, _create(UInt32, 'init', {}, _create(UInt, 'initWord', {}, this._startPtrOrData)))[0]
----Swift.(file).StaticString.utf8CodeUnitCount
preconditionFileLine({}, () => this.hasPointerRepresentation, () => "StaticString should have pointer representation", '?3', '?3');
return _create(Int, 'initWord', {}, this._utf8CodeUnitCount)
----Swift.(file).StaticString.hasPointerRepresentation
return UInt8.infix_61_61({}, UInt8.infix_38({}, _create(UInt8, 'initInt8', {}, this._flags), 0x1), 0)
----Swift.(file).StaticString.isASCII
return UInt8.infix_33_61({}, UInt8.infix_38({}, _create(UInt8, 'initInt8', {}, this._flags), 0x2), 0)
----Swift.(file).StaticString.init()
$info.$setThis(_cloneStruct(_cloneStruct("")));
return
----Swift.(file).StaticString.init(unicodeScalarLiteral:StaticString)
$info.$setThis(_cloneStruct(_cloneStruct(value)));
return
----Swift.(file).StaticString.init(extendedGraphemeClusterLiteral:StaticString)
$info.$setThis(_cloneStruct(_cloneStruct(value)));
return
----Swift.(file).StaticString.init(stringLiteral:StaticString)
$info.$setThis(_cloneStruct(_cloneStruct(value)));
return
----Swift.(file).StaticString.description
return this.withUTF8Buffer({}, (($info, $0) => String._uncheckedFromUTF8({}, $0)))
----Swift.(file).StaticString.debugDescription
return this.description.debugDescription
----Swift.(file).StaticString.customMirror
return _create(Mirror, 'initReflectingprotocol_composition_type', {}, this.description)
----Swift.(file).Strideable.<infix(_:Self,_:Self)
return (x.distanceTo({}, y)).constructor.infix_62({}, x.distanceTo({}, y), _create(((function(){throw '!unclarifiedGeneric:Self.Stride'})()), 'initIntegerLiteral', {}, 0))
----Swift.(file).Strideable.==infix(_:Self,_:Self)
return (x.distanceTo({}, y)).constructor.infix_61_61({}, x.distanceTo({}, y), _create(((function(){throw '!unclarifiedGeneric:Self.Stride'})()), 'initIntegerLiteral', {}, 0))
----Swift.(file).StrideToIterator.next()
const result = this._current["1"];
{
if((((this._stride).constructor.infix_62({}, this._stride, _create(((function(){throw '!unclarifiedGeneric:Element.Stride'})()), 'initIntegerLiteral', {}, 0)) ? (result).constructor.infix_62_61({}, result, this._end) : (result).constructor.infix_60_61({}, result, this._end)))) {
return Optional.none;
}
};
this._current = ((function(){throw '!unclarifiedGeneric:Element'})())._stepAfterFromBy({}, this._current, this._start, this._stride);
return _injectIntoOptional(result)
----Swift.(file).StrideTo.makeIterator()
return _create(StrideToIterator, 'init_startEndStride', {}, this._start, this._end, this._stride)
----Swift.(file).StrideTo.underestimatedCount
let it = _cloneStruct(this.makeIterator({}, ));
let count = 0;
while(true){
if(!((Optional.wrappedNotEqualsOptionalNilComparisonType({}, it.next({$setThis: $val => it = $val}, ), _create(_OptionalNilComparisonType, 'initNilLiteraltuple_type', {}, {}))))) break
Int.infix_43_61({}, {get: () => count, set: $val => count = $val}, 1);
};
return count
----Swift.(file).StrideTo.customMirror
return _create(Mirror, 'initChildrenKeyValuePairsDisplayStyleOptionalAncestorRepresentationMirrorAncestorRepresentation', {}, this, new Map([["from", this._start], ["to", this._end], ["by", this._stride]]), nil/*!default_value*/, .generated/*!default_value*/)
----Swift.(file).stride(from:T,to:T,by:T.Stride)
return _create(StrideTo, 'init_startEndStride', {}, start, end, stride)
----Swift.(file).StrideThroughIterator.next()
const result = this._current["1"];
{
if((((this._stride).constructor.infix_62({}, this._stride, _create(((function(){throw '!unclarifiedGeneric:Element.Stride'})()), 'initIntegerLiteral', {}, 0)) ? (result).constructor.infix_62_61({}, result, this._end) : (result).constructor.infix_60_61({}, result, this._end)))) {
{
if((Bool.infix_38_38({}, (result).constructor.infix_61_61({}, result, this._end), () => Bool.prefix_33({}, this._didReturnEnd)))) {
this._didReturnEnd = true;
return _injectIntoOptional(result);
}
};
return Optional.none;
}
};
this._current = ((function(){throw '!unclarifiedGeneric:Element'})())._stepAfterFromBy({}, this._current, this._start, this._stride);
return _injectIntoOptional(result)
----Swift.(file).StrideThrough.makeIterator()
return _create(StrideThroughIterator, 'init_startEndStride', {}, this._start, this._end, this._stride)
----Swift.(file).StrideThrough.underestimatedCount
let it = _cloneStruct(this.makeIterator({}, ));
let count = 0;
while(true){
if(!((Optional.wrappedNotEqualsOptionalNilComparisonType({}, it.next({$setThis: $val => it = $val}, ), _create(_OptionalNilComparisonType, 'initNilLiteraltuple_type', {}, {}))))) break
Int.infix_43_61({}, {get: () => count, set: $val => count = $val}, 1);
};
return count
----Swift.(file).StrideThrough.customMirror
return _create(Mirror, 'initChildrenKeyValuePairsDisplayStyleOptionalAncestorRepresentationMirrorAncestorRepresentation', {}, this, new Map([["from", this._start], ["through", this._end], ["by", this._stride]]), nil/*!default_value*/, .generated/*!default_value*/)
----Swift.(file).stride(from:T,through:T,by:T.Stride)
return _create(StrideThrough, 'init_startEndStride', {}, start, end, stride)
----Swift.(file).unimplemented_utf8_32bit(_:String,file:StaticString,line:UInt)
fatalErrorFileLine({}, () => "32-bit: Unimplemented for UTF-8 support", file, line)
----Swift.(file).String.init()
this.init_StringGuts({}, _create(_StringGuts, 'init', {}, ));
return
----Swift.(file).String.init(decoding:C,as:Encoding.Type)
{const $ifLet0 = _injectIntoOptional(codeUnits)
if($ifLet0.rawValue === 'some' && (infix_61_61({}, _injectIntoOptional(sourceEncoding), _injectIntoOptional(UTF8))) && (contigBytes._providesContiguousBytesNoCopy)) {
let contigBytes = $ifLet0[0]
$info.$setThis(_cloneStruct(contigBytes.withUnsafeBytes({}, (($info, rawBufPtr) => { 
const ptr = _cloneStruct(rawBufPtr.baseAddress._unsafelyUnwrappedUnchecked);
return String._fromUTF8Repairing({}, _create(UnsafeBufferPointer, 'initStartOptionalCountInt', {}, _injectIntoOptional(/*pointer_to_pointer*/ptr.assumingMemoryBoundTo({}, UInt8)), rawBufPtr.count))["0"]; }))));
return ;
}
};
$info.$setThis(_cloneStruct(String._fromCodeUnitsEncodingRepair({}, codeUnits, sourceEncoding, true)[0]["0"]));
return
----Swift.(file).String.withCString(encodedAs:TargetEncoding.Type,_:(UnsafePointer<TargetEncoding.CodeUnit>) throws -> Result)
{
if((infix_61_61({}, _injectIntoOptional(targetEncoding), _injectIntoOptional(UTF8)))) {
return this.withCString({}, (($info, cPtr) => { 
const ptr = _cloneStruct(_create(UnsafeRawPointer, 'init', {}, /*pointer_to_pointer*/cPtr).assumingMemoryBoundTo({}, ((function(){throw '!unclarifiedGeneric:TargetEncoding.CodeUnit'})())));
return body({}, ptr); }));
}
};
return this._slowWithCStringEncodedAs({}, targetEncoding, body)
----Swift.(file).String.init(_:Unicode.Scalar)
$info.$setThis(_cloneStruct(scalar.withUTF8CodeUnits({}, (($info, $0) => String._uncheckedFromUTF8({}, $0)))));
return
----Swift.(file).String.init(stringLiteral:String)
$info.$setThis(_cloneStruct(value));
return
----Swift.(file).String.debugDescription
let result = "\"";
{
let $us$generator = _cloneStruct(this.unicodeScalars.makeIterator({}, ));
while(true) {
const $ifLet0 = $us$generator.next({$setThis: $val => $us$generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
let us = $ifLet0[0]
String.infix_43_61({}, {get: () => result, set: $val => result = $val}, us.escapedAsASCII({}, false));
}
};
String.infix_43_61({}, {get: () => result, set: $val => result = $val}, "\"");
return result
----Swift.(file).String.+infix(_:String,_:String)
let result = lhs;
result.append({$setThis: $val => result = $val}, rhs);
return result
----Swift.(file).String.+=infix(_:String,_:String)
let lhs = lhs$inout.get()
const $result = (() => {
lhs.append({$setThis: $val => lhs = $val}, rhs);})()
lhs$inout.set(lhs)
return $result
----Swift.(file).Sequence.joined(separator:String)
return this._joinedSeparator({}, separator)
----Swift.(file).BidirectionalCollection.joined(separator:String)
return this._joinedSeparator({}, separator)
----Swift.(file).String.init(_:T)
$info.$setThis(_cloneStruct(value.description));
return
----Swift.(file).String.description
return this
----Swift.(file)._StringBreadcrumbs.stride
return _StringBreadcrumbs.breadcrumbStride
----Swift.(file)._StringBreadcrumbs.getBreadcrumb(forOffset:Int)
return {0: this.crumbs.subscript$get({}, Int.infix_47({}, offset, this.stride)), 1: Int.infix_37({}, offset, this.stride)}
----Swift.(file)._StringBreadcrumbs.getBreadcrumb(forIndex:String.Index)
let lowerBound = Int.infix_47({}, Int.infix_47({}, idx.encodedOffset, 3), this.stride);
let upperBound = /*dot_syntax_base_ignored*/min({}, Int.infix_43({}, 1, Int.infix_47({}, idx.encodedOffset, this.stride)), this.crumbs.count);
while(true){
if(!((Int.infix_62({}, Int.infix_38_45({}, upperBound, lowerBound), 1)))) break
const mid = Int.infix_43({}, lowerBound, Int.infix_47({}, Int.infix_38_45({}, upperBound, lowerBound), 2));
{
if((String.Index.infix_60_61({}, this.crumbs.subscript$get({}, mid), idx))) {
lowerBound = mid;
}
else {
upperBound = mid;
}
};
};
const crumb = _cloneStruct(this.crumbs.subscript$get({}, lowerBound));
return {0: crumb, 1: Int.infix_38_42({}, lowerBound, this.stride)}
----Swift.(file)._StringGuts.populateBreadcrumbs(_:UnsafeMutablePointer<_StringBreadcrumbs?>)
const crumbs = _create(_StringBreadcrumbs, 'initString', {}, _create(String, 'init_StringGuts', {}, this));
_stdlib_atomicInitializeARCRefObjectDesired({}, _create(UnsafeMutablePointer, 'initUnsafeMutablePointer', {}, mutPtr), crumbs)
----Swift.(file).String.count
return this.distanceFromTo({}, this.startIndex, this.endIndex)
----Swift.(file).String.index(after:String.Index)
preconditionFileLine({}, () => String.Index.infix_60({}, i, this.endIndex), () => "String index is out of bounds", '?3', '?3');
const stride = this._characterStrideStartingAt({}, i);
const nextOffset = Int.infix_38_43({}, i.encodedOffset, stride);
const nextStride = this._characterStrideStartingAt({}, _create(String.Index, 'initEncodedOffsetInt', {}, nextOffset));
return _create(String.Index, 'initEncodedOffsetIntCharacterStrideInt', {}, nextOffset, nextStride)
----Swift.(file).String.index(before:String.Index)
preconditionFileLine({}, () => String.Index.infix_62({}, i, this.startIndex), () => "String index is out of bounds", '?3', '?3');
const stride = this._characterStrideEndingAt({}, i);
const priorOffset = Int.infix_38_45({}, i.encodedOffset, stride);
return _create(String.Index, 'initEncodedOffsetIntCharacterStrideInt', {}, priorOffset, stride)
----Swift.(file).String.index(_:String.Index,offsetBy:String.IndexDistance)
return this._indexOffsetBy({}, i, n)
----Swift.(file).String.index(_:String.Index,offsetBy:String.IndexDistance,limitedBy:String.Index)
return this._indexOffsetByLimitedBy({}, i, n, limit)
----Swift.(file).String.distance(from:String.Index,to:String.Index)
return this._distanceFromTo({}, start, end)
----Swift.(file).StringProtocol.!=infix(_:Self,_:RHS)
return Bool.prefix_33({}, (lhs).constructor.infix_61_61({}, lhs, rhs))
----Swift.(file).StringProtocol.>infix(_:Self,_:RHS)
return (rhs).constructor.infix_60({}, rhs, lhs)
----Swift.(file).StringProtocol.<=infix(_:Self,_:RHS)
return Bool.prefix_33({}, (rhs).constructor.infix_60({}, rhs, lhs))
----Swift.(file).StringProtocol.>=infix(_:Self,_:RHS)
return Bool.prefix_33({}, (lhs).constructor.infix_60({}, lhs, rhs))
----Swift.(file)..(error_type).withNFCCodeUnitsIterator_2(_:<<error type>>)
let $defer = () => {
_fixLifetime({}, this);
}
try {;
return f({}, _create(_NormalizedUTF8CodeUnitIterator_2, 'init_StringGutsSlice', {}, this));}catch($error){$defer({}, );throw $error}$defer({}, )
----Swift.(file)._StringGuts.isOnGraphemeClusterBoundary(_:String.Index)
{
if(!((Int.infix_61_61({}, i.transcodedOffset, 0)))) {
return false;
}
};
const offset = i.encodedOffset;
{
if((Bool.infix_124_124({}, Int.infix_61_61({}, offset, 0), () => Int.infix_61_61({}, offset, this.count)))) {
return true;
}
};
{
if(!((this.isOnUnicodeScalarBoundary({}, i)))) {
return false;
}
};
const str = _create(String, 'init_StringGuts', {}, this);
return String.Index.infix_61_61({}, i, str.indexBefore({}, str.indexAfter({}, i)))
----Swift.(file)._StringGuts.rawBits
return this._object.rawBits
----Swift.(file)._StringGuts.init(_:<<error type>>)
this.init_StringObject({}, _create(_StringObject, 'init_SmallString', {}, smol));
return
----Swift.(file)._StringGuts.init(_:UnsafeBufferPointer<UInt8>,isASCII:Bool)
this.init_StringObject({}, _create(_StringObject, 'initImmortalUnsafeBufferPointerIsASCIIBool', {}, bufPtr, isASCII));
return
----Swift.(file)._StringGuts.init(_:<<error type>>)
this.init_StringObject({}, _create(_StringObject, 'init_StringStorage', {}, storage));
return
----Swift.(file)._StringGuts.init(_:<<error type>>)
this.init_StringObject({}, _create(_StringObject, 'init_SharedStringStorage', {}, storage));
return
----Swift.(file)._StringGuts.init(cocoa:AnyObject,providesFastUTF8:Bool,isASCII:Bool,length:Int)
this.init_StringObject({}, _create(_StringObject, 'initCocoaAnyObjectProvidesFastUTF8BoolIsASCIIBoolLengthInt', {}, cocoa, providesFastUTF8, isASCII, _length));
return
----Swift.(file)._StringGuts.count
return this._object.count
----Swift.(file)._StringGuts.isEmpty
return Int.infix_61_61({}, this.count, 0)
----Swift.(file)._StringGuts.isSmall
return this._object.isSmall
----Swift.(file)._StringGuts.isSmallASCII
return Bool.infix_38_38({}, this._object.isSmall, () => this._object.smallIsASCII)
----Swift.(file)._StringGuts.asSmall
return _create(_SmallString, 'init_StringObject', {}, this._object)
----Swift.(file)._StringGuts.isASCII
return this._object.isASCII
----Swift.(file)._StringGuts.isFastASCII
return Bool.infix_38_38({}, this.isFastUTF8, () => this._object.isASCII)
----Swift.(file)._StringGuts.isNFC
return this._object.isNFC
----Swift.(file)._StringGuts.isNFCFastUTF8
return Bool.infix_38_38({}, this._object.isNFC, () => this.isFastUTF8)
----Swift.(file)._StringGuts.hasNativeStorage
return this._object.hasNativeStorage
----Swift.(file)._StringGuts.hasSharedStorage
return this._object.hasSharedStorage
----Swift.(file)._StringGuts.hasBreadcrumbs
return Bool.infix_124_124({}, this.hasNativeStorage, () => this.hasSharedStorage)
----Swift.(file)._StringGuts.isFastUTF8
return _fastPath({}, this._object.providesFastUTF8)
----Swift.(file)._StringGuts.isForeign
return _slowPath({}, this._object.isForeign)
----Swift.(file)._StringGuts.withFastUTF8(_:(UnsafeBufferPointer<UInt8>) throws -> R)
{
if((this.isSmall)) {
return _create(_SmallString, 'init_StringObject', {}, this._object).withUTF8({}, f);
}
};
let $defer = () => {
_fixLifetime({}, this);
}
try {;
return f({}, this._object.fastUTF8);}catch($error){$defer({}, );throw $error}$defer({}, )
----Swift.(file)._StringGuts.withFastUTF8(range:Range<Int>,_:(UnsafeBufferPointer<UInt8>) throws -> R)
return this.withFastUTF8({}, (($info, wholeUTF8) => f({}, _create(UnsafeBufferPointer, 'initRebasingSlice', {}, wholeUTF8.subscriptRange$get({}, range)))))
----Swift.(file)._StringGuts.withFastCChar(_:(UnsafeBufferPointer<CChar>) throws -> R)
return this.withFastUTF8({}, (($info, utf8) => { 
const ptr = _cloneStruct(utf8.baseAddress._unsafelyUnwrappedUnchecked._asCChar);
return f({}, _create(UnsafeBufferPointer, 'initStartOptionalCountInt', {}, _injectIntoOptional(/*pointer_to_pointer*/ptr), utf8.count)); }))
----Swift.(file)._StringGuts.withCString(_:(UnsafePointer<Int8>) throws -> Result)
{
if((_slowPath({}, Bool.prefix_33({}, this._object.isFastZeroTerminated)))) {
return this._slowWithCString({}, body);
}
};
return this.withFastCChar({}, (($info, $0) => body({}, $0.baseAddress._unsafelyUnwrappedUnchecked)))
----Swift.(file)._StringGuts.copyUTF8(into:UnsafeMutableBufferPointer<UInt8>)
const ptr = _cloneStruct(mbp.baseAddress._unsafelyUnwrappedUnchecked);
{
if((_fastPath({}, this.isFastUTF8))) {
return this.withFastUTF8({}, (($info, utf8) => { 
{
if(!((Int.infix_60_61({}, utf8.count, mbp.count)))) {
return Optional.none;
}
};
const utf8Start = _cloneStruct(utf8.baseAddress._unsafelyUnwrappedUnchecked);
ptr.initializeFromCount({}, utf8Start, utf8.count);
return _injectIntoOptional(utf8.count); }));
}
};
return this._foreignCopyUTF8Into({}, mbp)
----Swift.(file)._StringGuts.utf8Count
{
if((_fastPath({}, this.isFastUTF8))) {
return this.count;
}
};
return _create(String, 'init_StringGuts', {}, this).utf8.count
----Swift.(file)._StringGuts.startIndex
return _create(_StringGuts.Index, 'initEncodedOffsetInt', {}, 0)
----Swift.(file)._StringGuts.endIndex
return _create(_StringGuts.Index, 'initEncodedOffsetInt', {}, this.count)
----Swift.(file)._StringGuts.startASCII
return _create(UnsafeMutablePointer, 'initMutatingUnsafePointer', {}, this._object.fastUTF8.baseAddress[0])
----Swift.(file)._StringGuts.startUTF16
fatalErrorFileLine({}, () => "Not contiguous UTF-16", '?3', '?3')
----Swift.(file)._StringGuts.nativeCapacity
{
if(!((this.hasNativeStorage))) {
return Optional.none;
}
};
return _injectIntoOptional(this._object.nativeStorage.capacity)
----Swift.(file)._StringGuts.nativeUnusedCapacity
{
if(!((this.hasNativeStorage))) {
return Optional.none;
}
};
return _injectIntoOptional(this._object.nativeStorage.unusedCapacity)
----Swift.(file)._StringGuts.uniqueNativeCapacity
{
if(!((this.isUniqueNative))) {
return Optional.none;
}
};
return _injectIntoOptional(this._object.nativeStorage.capacity)
----Swift.(file)._StringGuts.uniqueNativeUnusedCapacity
{
if(!((this.isUniqueNative))) {
return Optional.none;
}
};
return _injectIntoOptional(this._object.nativeStorage.unusedCapacity)
----Swift.(file)._StringGuts.isUniqueNative
{
if(!((this.hasNativeStorage))) {
return false;
}
};
let $defer = () => {
_fixLifetime({}, this);
}
try {;
let bits = this._object.largeAddressBits;
return _isUnique_native({}, {get: () => bits, set: $val => bits = $val});}catch($error){$defer({}, );throw $error}$defer({}, )
----Swift.(file)._StringGuts.init(_initialCapacity:Int)
this.init({}, );
{
if((_slowPath({}, Int.infix_62({}, capacity, _SmallString.capacity)))) {
this.grow({$setThis: $val => $info.$setThis(_cloneStruct($val))}, capacity);
}
};
return
----Swift.(file)._StringGuts.reserveCapacity(_:Int)
{
if((Int.infix_60_61({}, n, _SmallString.capacity))) {
return ;
}
};
{const $ifLet0 = this.uniqueNativeCapacity
if($ifLet0.rawValue === 'some' && (Int.infix_62_61({}, currentCap, n))) {
let currentCap = $ifLet0[0]
return ;
}
};
this.grow({$setThis: $val => $info.$setThis(_cloneStruct($val))}, n)
----Swift.(file)._StringGuts.append(_:_StringGuts)
{
if((Bool.infix_38_38({}, this.isSmall, () => other.isSmall))) {
{const $ifLet0 = _create(_SmallString, 'init_SmallStringAppending_SmallString', {}, this.asSmall, other.asSmall)
if($ifLet0.rawValue === 'some') {
let smol = $ifLet0[0]
$info.$setThis(_cloneStruct(_create(_StringGuts, 'init_SmallString', {}, smol)));
return ;
}
};
}
};
this.append({$setThis: $val => $info.$setThis(_cloneStruct($val))}, _create(_StringGutsSlice, 'init_StringGuts', {}, other))
----Swift.(file)._StringGuts.appendInPlace(_:UnsafeBufferPointer<UInt8>,isASCII:Bool)
this._object.nativeStorage.appendInPlaceIsASCII({}, other, isASCII);
$info.$setThis(_cloneStruct(_create(_StringGuts, 'init_StringStorage', {}, this._object.nativeStorage)))
----Swift.(file)._StringGuts.clear()
{
if(!((this.isUniqueNative))) {
$info.$setThis(_cloneStruct(_create(_StringGuts, 'init', {}, )));
return ;
}
};
this._object.nativeStorage.clear({}, );
$info.$setThis(_cloneStruct(_create(_StringGuts, 'init_StringStorage', {}, this._object.nativeStorage)))
----Swift.(file)._StringGuts.uniqueNativeReplaceSubrange(_:<<error type>>,with:UnsafeBufferPointer<UInt8>,isASCII:Bool)
const neededCapacity = Int.infix_43({}, Int.infix_43({}, bounds.lowerBound.encodedOffset, codeUnits.count), Int.infix_45({}, this.count, bounds.upperBound.encodedOffset));
this.reserveCapacity({$setThis: $val => $info.$setThis(_cloneStruct($val))}, neededCapacity);
this._object.nativeStorage.replaceFromToWith({}, bounds.lowerBound.encodedOffset, bounds.upperBound.encodedOffset, codeUnits);
$info.$setThis(_cloneStruct(_create(_StringGuts, 'init_StringStorage', {}, this._object.nativeStorage)))
----Swift.(file)._StringGuts.uniqueNativeReplaceSubrange(_:<<error type>>,with:C)
const replCount = codeUnits.count;
const neededCapacity = Int.infix_43({}, Int.infix_43({}, bounds.lowerBound.encodedOffset, replCount), Int.infix_45({}, this.count, bounds.upperBound.encodedOffset));
this.reserveCapacity({$setThis: $val => $info.$setThis(_cloneStruct($val))}, neededCapacity);
this._object.nativeStorage.replaceFromToWithReplacementCount({}, bounds.lowerBound.encodedOffset, bounds.upperBound.encodedOffset, codeUnits, replCount);
$info.$setThis(_cloneStruct(_create(_StringGuts, 'init_StringStorage', {}, this._object.nativeStorage)))
----Swift.(file).String.Index.init(_:UInt64)
this._rawBits = raw;
this._invariantCheck({}, );
return
----Swift.(file)..(error_type).orderingValue
return UInt64.infix_38_62_62({}, this._rawBits, 14)
----Swift.(file)..(error_type).isZeroPosition
return UInt64.infix_61_61({}, this.orderingValue, 0)
----Swift.(file)..(error_type).encodedOffset
return _create(Int, 'initTruncatingIfNeeded', {}, UInt64.infix_38_62_62({}, this._rawBits, 16))
----Swift.(file)..(error_type).transcodedOffset
return _create(Int, 'initTruncatingIfNeeded', {}, UInt64.infix_38({}, this.orderingValue, 0x3))
----Swift.(file)..(error_type).characterStride
const value = UInt64.infix_38_62_62({}, UInt64.infix_38({}, this._rawBits, 0x3F00), 8);
return (UInt64.infix_62({}, value, 0) ? _injectIntoOptional(_create(Int, 'initTruncatingIfNeeded', {}, value)) : Optional.none)
----Swift.(file)..(error_type).init(encodedOffset:Int,transcodedOffset:Int)
const pos = _create(UInt64, 'initTruncatingIfNeeded', {}, encodedOffset);
const trans = _create(UInt64, 'initTruncatingIfNeeded', {}, transcodedOffset);
this.initUInt64({}, UInt64.infix_124({}, UInt64.infix_38_60_60({}, pos, 16), UInt64.infix_38_60_60({}, trans, 14)));
return
----Swift.(file)..(error_type).init(encodedOffset:Int)
this.initEncodedOffsetIntTranscodedOffsetInt({}, encodedOffset, 0);
return
----Swift.(file)..(error_type).init(encodedOffset:Int,transcodedOffset:Int,characterStride:Int)
this.initEncodedOffsetIntTranscodedOffsetInt({}, encodedOffset, transcodedOffset);
{
if((_slowPath({}, Int.infix_62({}, characterStride, 63)))) {
return ;
}
};
UInt64.infix_124_61({}, {get: () => this._rawBits, set: $val => this._rawBits = $val}, _create(UInt64, 'initTruncatingIfNeeded', {}, Int.infix_38_60_60({}, characterStride, 8)));
this._invariantCheck({}, );
return
----Swift.(file)..(error_type).init(encodedOffset:Int,characterStride:Int)
this.initEncodedOffsetIntTranscodedOffsetIntCharacterStrideInt({}, pos, 0, char);
return
----Swift.(file)..(error_type).strippingTranscoding
return _create(String.Index, 'initEncodedOffsetInt', {}, this.encodedOffset)
----Swift.(file)..(error_type).nextEncoded
return _create(String.Index, 'initEncodedOffsetInt', {}, Int.infix_38_43({}, this.encodedOffset, 1))
----Swift.(file)..(error_type).priorEncoded
return _create(String.Index, 'initEncodedOffsetInt', {}, Int.infix_38_45({}, this.encodedOffset, 1))
----Swift.(file)..(error_type).nextTranscoded
return _create(String.Index, 'initEncodedOffsetIntTranscodedOffsetInt', {}, this.encodedOffset, Int.infix_38_43({}, this.transcodedOffset, 1))
----Swift.(file)..(error_type).priorTranscoded
return _create(String.Index, 'initEncodedOffsetIntTranscodedOffsetInt', {}, this.encodedOffset, Int.infix_38_45({}, this.transcodedOffset, 1))
----Swift.(file)..(error_type).encoded(offsetBy:Int)
return _create(String.Index, 'initEncodedOffsetInt', {}, Int.infix_38_43({}, this.encodedOffset, n))
----Swift.(file)..(error_type).transcoded(withOffset:Int)
return _create(String.Index, 'initEncodedOffsetIntTranscodedOffsetInt', {}, this.encodedOffset, n)
----Swift.(file)..(error_type).==infix(_:<<error type>>,_:<<error type>>)
return UInt64.infix_61_61({}, lhs.orderingValue, rhs.orderingValue)
----Swift.(file)..(error_type).<infix(_:<<error type>>,_:<<error type>>)
return UInt64.infix_60({}, lhs.orderingValue, rhs.orderingValue)
----Swift.(file)..(error_type).hash(into:Hasher)
let hasher = hasher$inout.get()
const $result = (() => {
hasher.combine({$setThis: $val => hasher = $val}, this.orderingValue);})()
hasher$inout.set(hasher)
return $result
----Swift.(file).String.Index.samePosition(in:String.UTF8View)
return _create(String.UTF8View.Index, 'initStringIndexWithinStringUTF8View', {}, this, utf8)
----Swift.(file).String.Index.samePosition(in:String.UTF16View)
return _create(String.UTF16View.Index, 'initStringIndexWithinStringUTF16View', {}, this, utf16)
----Swift.(file).DefaultStringInterpolation.init(literalCapacity:Int,interpolationCount:Int)
const capacityPerInterpolation = 2;
const initialCapacity = Int.infix_43({}, literalCapacity, Int.infix_42({}, interpolationCount, capacityPerInterpolation));
this._storage = _create(String, 'init_StringGuts', {}, _create(_StringGuts, 'init_initialCapacityInt', {}, initialCapacity));
return
----Swift.(file).DefaultStringInterpolation.appendLiteral(_:String)
literal.writeTo({}, {get: () => this, set: $val => $info.$setThis(_cloneStruct($val))})
----Swift.(file).DefaultStringInterpolation.appendInterpolation(_:T)
value.writeTo({}, {get: () => this, set: $val => $info.$setThis(_cloneStruct($val))})
----Swift.(file).DefaultStringInterpolation.appendInterpolation(_:T)
value.writeTo({}, {get: () => this, set: $val => $info.$setThis(_cloneStruct($val))})
----Swift.(file).DefaultStringInterpolation.appendInterpolation(_:T)
value.description.writeTo({}, {get: () => this, set: $val => $info.$setThis(_cloneStruct($val))})
----Swift.(file).DefaultStringInterpolation.appendInterpolation(_:T)
_print_unlocked({}, value, {get: () => this, set: $val => $info.$setThis(_cloneStruct($val))})
----Swift.(file).DefaultStringInterpolation.make()
return this._storage
----Swift.(file).DefaultStringInterpolation.description
return this._storage
----Swift.(file).DefaultStringInterpolation.write(_:String)
this._storage.append({$setThis: $val => this._storage = $val}, string)
----Swift.(file).String.init(stringInterpolation:DefaultStringInterpolation)
$info.$setThis(_cloneStruct(stringInterpolation.make({}, )));
return
----Swift.(file).Substring.init(stringInterpolation:DefaultStringInterpolation)
this.initString({}, stringInterpolation.make({}, ));
return
----Swift.(file).StringProtocol.hasPrefix(_:Prefix)
return this.startsWith({}, prefix)
----Swift.(file).StringProtocol.hasSuffix(_:Suffix)
return this.reversed({}, ).startsWith({}, suffix.reversed({}, ))
----Swift.(file).String.init(_:T,radix:Int,uppercase:Bool)
$info.$setThis(_cloneStruct(value._descriptionRadixUppercase({}, radix, uppercase)));
return
----Swift.(file)._StringObject.rawBits
return {0: this._countAndFlagsBits, 1: this.discriminatedObjectRawBits}
----Swift.(file)._StringObject.init(rawValue:_StringObject.RawBitPattern)
this.initRawUncheckedValue_StringObjectRawBitPattern({}, bits);
this._invariantCheck({}, );
return
----Swift.(file)._StringObject.CountAndFlags.rawBits
return this._storage
----Swift.(file)._StringObject.CountAndFlags.init(rawUnchecked:_StringObject.CountAndFlags.RawBitPattern)
this._storage = bits;
return
----Swift.(file)._StringObject.CountAndFlags.init(raw:_StringObject.CountAndFlags.RawBitPattern)
this.initRawUnchecked_StringObjectCountAndFlagsRawBitPattern({}, bits);
this._invariantCheck({}, );
return
----Swift.(file)._StringObject.Nibbles.emptyString
return _StringObject.Nibbles.smallIsASCII({}, true);
}
static get emptyString() { return this.emptyString$get()
----Swift.(file)._StringObject.Nibbles.largeAddressMask
return 0x0FFFFFFFFFFFFFFF;
}
static get largeAddressMask() { return this.largeAddressMask$get()
----Swift.(file)._StringObject.Nibbles.discriminatorMask
return UInt64.prefix_126({}, this.largeAddressMask);
}
static get discriminatorMask() { return this.discriminatorMask$get()
----Swift.(file)._StringObject.Nibbles.small(isASCII:Bool)
return (isASCII ? 0xE000000000000000 : 0xA000000000000000)
----Swift.(file)._StringObject.Nibbles.small(withCount:Int,isASCII:Bool)
return UInt64.infix_124({}, this.smallIsASCII({}, isASCII), UInt64.infix_38_60_60({}, _create(UInt64, 'initTruncatingIfNeeded', {}, count), 56))
----Swift.(file)._StringObject.Nibbles.largeImmortal()
return 0x8000000000000000
----Swift.(file)._StringObject.Nibbles.largeMortal()
return 0x0000000000000000
----Swift.(file)._StringObject.Nibbles.largeCocoa(providesFastUTF8:Bool)
return (providesFastUTF8 ? 0x4000000000000000 : 0x5000000000000000)
----Swift.(file)._StringObject.nativeBias
return 32;
}
static get nativeBias() { return this.nativeBias$get()
----Swift.(file)._StringObject.isImmortal
return UInt64.infix_33_61({}, UInt64.infix_38({}, this.discriminatedObjectRawBits, 0x8000000000000000), 0)
----Swift.(file)._StringObject.isMortal
return Bool.prefix_33({}, this.isImmortal)
----Swift.(file)._StringObject.isSmall
return UInt64.infix_33_61({}, UInt64.infix_38({}, this.discriminatedObjectRawBits, 0x2000000000000000), 0)
----Swift.(file)._StringObject.isLarge
return Bool.prefix_33({}, this.isSmall)
----Swift.(file)._StringObject.providesFastUTF8
return UInt64.infix_61_61({}, UInt64.infix_38({}, this.discriminatedObjectRawBits, 0x1000000000000000), 0)
----Swift.(file)._StringObject.isForeign
return Bool.prefix_33({}, this.providesFastUTF8)
----Swift.(file)._StringObject.hasStorage
return UInt64.infix_61_61({}, UInt64.infix_38({}, this.discriminatedObjectRawBits, 0xF000000000000000), 0)
----Swift.(file)._StringObject.hasNativeStorage
const bits = UInt64.infix_38({}, UInt64.prefix_126({}, this.discriminatedObjectRawBits), this._countAndFlagsBits);
const result = UInt64.infix_33_61({}, UInt64.infix_38({}, bits, 0x2000000000000000), 0);
return result
----Swift.(file)._StringObject.hasSharedStorage
return Bool.infix_38_38({}, this.hasStorage, () => Bool.prefix_33({}, this.hasNativeStorage))
----Swift.(file)._StringObject.largeFastIsTailAllocated
return this._countAndFlags.isTailAllocated
----Swift.(file)._StringObject.largeFastIsShared
return Bool.prefix_33({}, this.largeFastIsTailAllocated)
----Swift.(file)._StringObject.largeIsCocoa
return UInt64.infix_33_61({}, UInt64.infix_38({}, this.discriminatedObjectRawBits, 0x4000000000000000), 0)
----Swift.(file)._StringObject.init(_:<<error type>>)
this.initRawValue_StringObjectRawBitPattern({}, small.rawBits);
return
----Swift.(file)._StringObject.getSmallCount(fromRaw:UInt64)
return _create(Int, 'initTruncatingIfNeeded', {}, UInt64.infix_38_62_62({}, UInt64.infix_38({}, x, 0x0F00000000000000), 56))
----Swift.(file)._StringObject.smallCount
return _StringObject.getSmallCountFromRaw({}, this.discriminatedObjectRawBits)
----Swift.(file)._StringObject.getSmallIsASCII(fromRaw:UInt64)
return UInt64.infix_33_61({}, UInt64.infix_38({}, x, 0x4000000000000000), 0)
----Swift.(file)._StringObject.smallIsASCII
return _StringObject.getSmallIsASCIIFromRaw({}, this.discriminatedObjectRawBits)
----Swift.(file)._StringObject.CountAndFlags.countMask
return 0x0000FFFFFFFFFFFF;
}
static get countMask() { return this.countMask$get()
----Swift.(file)._StringObject.CountAndFlags.flagsMask
return UInt64.prefix_126({}, this.countMask);
}
static get flagsMask() { return this.flagsMask$get()
----Swift.(file)._StringObject.CountAndFlags.isASCIIMask
return 0x8000000000000000;
}
static get isASCIIMask() { return this.isASCIIMask$get()
----Swift.(file)._StringObject.CountAndFlags.isNFCMask
return 0x4000000000000000;
}
static get isNFCMask() { return this.isNFCMask$get()
----Swift.(file)._StringObject.CountAndFlags.isNativelyStoredMask
return 0x2000000000000000;
}
static get isNativelyStoredMask() { return this.isNativelyStoredMask$get()
----Swift.(file)._StringObject.CountAndFlags.isTailAllocatedMask
return 0x1000000000000000;
}
static get isTailAllocatedMask() { return this.isTailAllocatedMask$get()
----Swift.(file)._StringObject.CountAndFlags.init(count:Int,isASCII:Bool,isNFC:Bool,isNativelyStored:Bool,isTailAllocated:Bool)
let rawBits = _create(UInt64, 'initTruncatingIfNeeded', {}, count);
{
if((isASCII)) {
UInt64.infix_124_61({}, {get: () => rawBits, set: $val => rawBits = $val}, _StringObject.CountAndFlags.isASCIIMask);
}
};
{
if((isNFC)) {
UInt64.infix_124_61({}, {get: () => rawBits, set: $val => rawBits = $val}, _StringObject.CountAndFlags.isNFCMask);
}
};
{
if((isNativelyStored)) {
UInt64.infix_124_61({}, {get: () => rawBits, set: $val => rawBits = $val}, _StringObject.CountAndFlags.isNativelyStoredMask);
}
};
{
if((isTailAllocated)) {
UInt64.infix_124_61({}, {get: () => rawBits, set: $val => rawBits = $val}, _StringObject.CountAndFlags.isTailAllocatedMask);
}
};
this.initRaw_StringObjectCountAndFlagsRawBitPattern({}, rawBits);
return
----Swift.(file)._StringObject.CountAndFlags.init(count:Int,flags:UInt16)
const rawBits = UInt64.infix_124({}, UInt64.infix_38_60_60({}, _create(UInt64, 'initTruncatingIfNeeded', {}, flags), 48), _create(UInt64, 'initTruncatingIfNeeded', {}, count));
this.initRaw_StringObjectCountAndFlagsRawBitPattern({}, rawBits);
return
----Swift.(file)._StringObject.CountAndFlags.init(immortalCount:Int,isASCII:Bool)
this.initCountIntIsASCIIBoolIsNFCBoolIsNativelyStoredBoolIsTailAllocatedBool({}, immortalCount, isASCII, isASCII, false, true);
return
----Swift.(file)._StringObject.CountAndFlags.init(mortalCount:Int,isASCII:Bool)
this.initCountIntIsASCIIBoolIsNFCBoolIsNativelyStoredBoolIsTailAllocatedBool({}, mortalCount, isASCII, isASCII, true, true);
return
----Swift.(file)._StringObject.CountAndFlags.init(sharedCount:Int,isASCII:Bool)
this.initCountIntIsASCIIBoolIsNFCBoolIsNativelyStoredBoolIsTailAllocatedBool({}, sharedCount, isASCII, isASCII, false, false);
return
----Swift.(file)._StringObject.CountAndFlags.count
return _create(Int, 'initTruncatingIfNeeded', {}, UInt64.infix_38({}, this._storage, _StringObject.CountAndFlags.countMask))
----Swift.(file)._StringObject.CountAndFlags.flags
return _create(UInt16, 'initTruncatingIfNeeded', {}, UInt64.infix_38_62_62({}, this._storage, 48))
----Swift.(file)._StringObject.CountAndFlags.isASCII
return Int.infix_33_61({}, 0, UInt64.infix_38({}, this._storage, _StringObject.CountAndFlags.isASCIIMask))
----Swift.(file)._StringObject.CountAndFlags.isNFC
return Int.infix_33_61({}, 0, UInt64.infix_38({}, this._storage, _StringObject.CountAndFlags.isNFCMask))
----Swift.(file)._StringObject.CountAndFlags.isNativelyStored
return Int.infix_33_61({}, 0, UInt64.infix_38({}, this._storage, _StringObject.CountAndFlags.isNativelyStoredMask))
----Swift.(file)._StringObject.CountAndFlags.isTailAllocated
return Int.infix_33_61({}, 0, UInt64.infix_38({}, this._storage, _StringObject.CountAndFlags.isTailAllocatedMask))
----Swift.(file)._StringObject.largeCount
return this._countAndFlags.count
----Swift.(file)._StringObject.largeAddressBits
return _create(UInt, 'initTruncatingIfNeeded', {}, UInt64.infix_38({}, this.discriminatedObjectRawBits, _StringObject.Nibbles.largeAddressMask))
----Swift.(file)._StringObject.nativeUTF8Start
return _create(UnsafePointer, 'initBitPatternUInt', {}, UInt.infix_38_43({}, this.largeAddressBits, _StringObject.nativeBias))._unsafelyUnwrappedUnchecked
----Swift.(file)._StringObject.nativeUTF8
return _create(UnsafeBufferPointer, 'initStartOptionalCountInt', {}, _injectIntoOptional(/*pointer_to_pointer*/this.nativeUTF8Start), this.largeCount)
----Swift.(file)._StringObject.getSharedUTF8Start()
{
if((this.largeIsCocoa)) {
return _cocoaUTF8Pointer({}, this.cocoaObject)._unsafelyUnwrappedUnchecked;
}
};
return this.sharedStorage.start
----Swift.(file)._StringObject.sharedUTF8
const start = _cloneStruct(this.getSharedUTF8Start({}, ));
return _create(UnsafeBufferPointer, 'initStartOptionalCountInt', {}, _injectIntoOptional(/*pointer_to_pointer*/start), this.largeCount)
----Swift.(file)._StringObject.count
return (this.isSmall ? this.smallCount : this.largeCount)
----Swift.(file)._StringObject.isASCII
{
if((this.isSmall)) {
return this.smallIsASCII;
}
};
return this._countAndFlags.isASCII
----Swift.(file)._StringObject.isNFC
{
if((this.isSmall)) {
return this.smallIsASCII;
}
};
return this._countAndFlags.isNFC
----Swift.(file)._StringObject.fastUTF8
{
if(!((_fastPath({}, this.largeFastIsTailAllocated)))) {
return this.sharedUTF8;
}
};
return _create(UnsafeBufferPointer, 'initStartOptionalCountInt', {}, _injectIntoOptional(/*pointer_to_pointer*/this.nativeUTF8Start), this.largeCount)
----Swift.(file)._StringObject.hasObjCBridgeableObject
return Bool.prefix_33({}, this.isImmortal)
----Swift.(file)._StringObject.isFastZeroTerminated
{
if((_slowPath({}, Bool.prefix_33({}, this.providesFastUTF8)))) {
return false;
}
};
{
if((this.isSmall)) {
return true;
}
};
return this.largeFastIsTailAllocated
----Swift.(file)._StringObject.init(immortal:UnsafeBufferPointer<UInt8>,isASCII:Bool)
const countAndFlags = _create(_StringObject.CountAndFlags, 'initImmortalCountIntIsASCIIBool', {}, bufPtr.count, isASCII);
const biasedAddress = UInt.infix_38_45({}, _create(UInt, 'initBitPatternOptional', {}, _injectIntoOptional(bufPtr.baseAddress._unsafelyUnwrappedUnchecked)), _StringObject.nativeBias);
this.initPointerBitsUInt64DiscriminatorUInt64CountAndFlags_StringObjectCountAndFlags({}, _create(UInt64, 'initTruncatingIfNeeded', {}, biasedAddress), _StringObject.Nibbles.largeImmortal({}, ), countAndFlags);
return
----Swift.(file)._StringObject.init(_:<<error type>>)
this.initObjectAnyObjectDiscriminatorUInt64CountAndFlags_StringObjectCountAndFlags({}, storage, _StringObject.Nibbles.largeMortal({}, ), storage._countAndFlags);
return
----Swift.(file)._StringObject.init(_:<<error type>>)
this.initObjectAnyObjectDiscriminatorUInt64CountAndFlags_StringObjectCountAndFlags({}, storage, _StringObject.Nibbles.largeMortal({}, ), storage._countAndFlags);
return
----Swift.(file)._StringObject.init(cocoa:AnyObject,providesFastUTF8:Bool,isASCII:Bool,length:Int)
const countAndFlags = _create(_StringObject.CountAndFlags, 'initSharedCountIntIsASCIIBool', {}, _length, isASCII);
const discriminator = _StringObject.Nibbles.largeCocoaProvidesFastUTF8({}, providesFastUTF8);
this.initObjectAnyObjectDiscriminatorUInt64CountAndFlags_StringObjectCountAndFlags({}, cocoa, discriminator, countAndFlags);
return
----Swift.(file).String.init(repeating:Character,count:Int)
this.initRepeatingStringCountInt({}, repeatedValue._str, count);
return
----Swift.(file).String.init(_:S)
{const $ifLet0 = _injectIntoOptional(other)
if($ifLet0.rawValue === 'some') {
let str = $ifLet0[0]
$info.$setThis(_cloneStruct(str));
return ;
}
};
$info.$setThis(_cloneStruct(other.description));
return
----Swift.(file).String.init(_:S)
{const $ifLet0 = _injectIntoOptional(characters)
if($ifLet0.rawValue === 'some') {
let str = $ifLet0[0]
$info.$setThis(_cloneStruct(str));
return ;
}
};
{const $ifLet0 = _injectIntoOptional(characters)
if($ifLet0.rawValue === 'some') {
let subStr = $ifLet0[0]
this.initSubstring({}, subStr);
return ;
}
};
$info.$setThis(_cloneStruct(""));
this.appendContentsOf({$setThis: $val => $info.$setThis(_cloneStruct($val))}, characters);
return
----Swift.(file).String.append(_:Character)
this.append({$setThis: $val => $info.$setThis(_cloneStruct($val))}, c._str)
----Swift.(file).String.append(contentsOf:String)
this.append({$setThis: $val => $info.$setThis(_cloneStruct($val))}, newElements)
----Swift.(file).String.append(contentsOf:S)
{const $ifLet0 = _injectIntoOptional(newElements)
if($ifLet0.rawValue === 'some') {
let str = $ifLet0[0]
this.append({$setThis: $val => $info.$setThis(_cloneStruct($val))}, str);
return ;
}
};
{const $ifLet0 = _injectIntoOptional(newElements)
if($ifLet0.rawValue === 'some') {
let substr = $ifLet0[0]
this.appendContentsOf({$setThis: $val => $info.$setThis(_cloneStruct($val))}, substr);
return ;
}
};
{
let $c$generator = newElements.makeIterator({}, );
while(true) {
const $ifLet0 = $c$generator.next({$setThis: $val => $c$generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
let c = $ifLet0[0]
this.append({$setThis: $val => $info.$setThis(_cloneStruct($val))}, c._str);
}
}
----Swift.(file).String.insert(_:Character,at:String.Index)
this.replaceSubrangeWith({$setThis: $val => $info.$setThis(_cloneStruct($val))}, String.Index.infix_46_46_60({}, i, i), newElement._str)
----Swift.(file).String.insert(contentsOf:S,at:String.Index)
this.replaceSubrangeWith({$setThis: $val => $info.$setThis(_cloneStruct($val))}, String.Index.infix_46_46_60({}, i, i), newElements)
----Swift.(file).String.max(_:T,_:T)
return /*dot_syntax_base_ignored*/max({}, x, y)
----Swift.(file).String.min(_:T,_:T)
return /*dot_syntax_base_ignored*/min({}, x, y)
----Swift.(file).Sequence.+infix(_:Self,_:String)
fatalErrorFileLine({}, () => String()/*!default_value*/, '?3', '?3')
----Swift.(file).Sequence.+infix(_:String,_:Self)
fatalErrorFileLine({}, () => String()/*!default_value*/, '?3', '?3')
----Swift.(file)._StringStorage.create(capacity:Int,countAndFlags:<<error type>>)
const realCapacity = determineCodeUnitCapacity({}, capacity);
return _StringStorage.createRealCodeUnitCapacityCountAndFlags({}, realCapacity, countAndFlags)
----Swift.(file)._StringStorage.create(initializingFrom:UnsafeBufferPointer<UInt8>,capacity:Int,isASCII:Bool)
const countAndFlags = _create(CountAndFlags, 'initMortalCountIntIsASCIIBool', {}, bufPtr.count, isASCII);
const storage = _StringStorage.createCapacityCountAndFlags({}, capacity, countAndFlags);
const addr = _cloneStruct(bufPtr.baseAddress._unsafelyUnwrappedUnchecked);
storage.mutableStart.initializeFromCount({}, addr, bufPtr.count);
storage._invariantCheck({}, );
return storage
----Swift.(file)._StringStorage.create(initializingFrom:UnsafeBufferPointer<UInt8>,isASCII:Bool)
return _StringStorage.createInitializingFromCapacityIsASCII({}, bufPtr, bufPtr.count, isASCII)
----Swift.(file)._StringStorage.mutableEnd
return UnsafeMutablePointer.infix_43({}, this.mutableStart, this.count)
----Swift.(file)._StringStorage.start
return _create(UnsafePointer, 'initUnsafeMutablePointer', {}, this.mutableStart)
----Swift.(file)._StringStorage.end
return _create(UnsafePointer, 'initUnsafeMutablePointer', {}, this.mutableEnd)
----Swift.(file)._StringStorage.terminator
return this.mutableEnd
----Swift.(file)._StringStorage.codeUnits
return _create(UnsafeBufferPointer, 'initStartOptionalCountInt', {}, _injectIntoOptional(/*pointer_to_pointer*/this.start), this.count)
----Swift.(file)._StringStorage.capacity
return Int.infix_38_45({}, this._realCapacity, 1)
----Swift.(file)._StringStorage.unusedStorage
return _create(UnsafeMutableBufferPointer, 'initStartOptionalCountInt', {}, _injectIntoOptional(/*pointer_to_pointer*/this.mutableEnd), this.unusedCapacity)
----Swift.(file)._StringStorage.unusedCapacity
return Int.infix_38_45({}, Int.infix_38_45({}, this._realCapacity, this.count), 1)
----Swift.(file)._StringStorage.appendInPlace(_:UnsafeBufferPointer<UInt8>,isASCII:Bool)
const srcAddr = _cloneStruct(other.baseAddress._unsafelyUnwrappedUnchecked);
const srcCount = other.count;
this.mutableEnd.initializeFromCount({}, srcAddr, srcCount);
this._postAppendAdjustAppendedCountAppendedIsASCII({}, srcCount, isASCII)
----Swift.(file)._StringStorage.appendInPlace(_:Iter,isASCII:Bool)
let other = other$inout.get()
const $result = (() => {
let srcCount = 0;
while(true){
const $ifLet0 = other.next({$setThis: $val => other = $val}, )
if(!($ifLet0.rawValue === 'some')) break
let cu = $ifLet0[0]
this.unusedStorage.subscript$set({$setThis: $val => this.unusedStorage = _cloneStruct($val)}, cu, srcCount);
Int.infix_43_61({}, {get: () => srcCount, set: $val => srcCount = $val}, 1);
};
this._postAppendAdjustAppendedCountAppendedIsASCII({}, srcCount, isASCII);})()
other$inout.set(other)
return $result
----Swift.(file)._StringStorage.clear()
this._postRRCAdjustNewCountNewIsASCII({}, 0, true)
----Swift.(file)._StringStorage.remove(from:Int,to:Int)
const lowerPtr = _cloneStruct(UnsafeMutablePointer.infix_43({}, this.mutableStart, lower));
const upperPtr = _cloneStruct(UnsafeMutablePointer.infix_43({}, this.mutableStart, upper));
const tailCount = UnsafeMutablePointer.infix_45({}, this.mutableEnd, upperPtr);
lowerPtr.moveInitializeFromCount({}, upperPtr, tailCount);
this._postRRCAdjustNewCountNewIsASCII({}, Int.infix_38_45({}, this.count, Int.infix_38_45({}, upper, lower)), this.isASCII)
----Swift.(file)._StringStorage.replace(from:Int,to:Int,with:UnsafeBufferPointer<UInt8>)
const replCount = replacement.count;
const lowerPtr = _cloneStruct(UnsafeMutablePointer.infix_43({}, this.mutableStart, lower));
const tailCount = this._slideTailSrcDst({}, UnsafeMutablePointer.infix_43({}, this.mutableStart, upper), UnsafeMutablePointer.infix_43({}, lowerPtr, replCount));
lowerPtr.moveInitializeFromCount({}, _create(UnsafeMutablePointer, 'initMutatingUnsafePointer', {}, replacement.baseAddress._unsafelyUnwrappedUnchecked), replCount);
const isASCII = Bool.infix_38_38({}, this.isASCII, () => _allASCII({}, replacement));
this._postRRCAdjustNewCountNewIsASCII({}, Int.infix_43({}, Int.infix_43({}, lower, replCount), tailCount), isASCII)
----Swift.(file)._StringStorage.replace(from:Int,to:Int,with:C,replacementCount:Int)
const lowerPtr = _cloneStruct(UnsafeMutablePointer.infix_43({}, this.mutableStart, lower));
const tailCount = this._slideTailSrcDst({}, UnsafeMutablePointer.infix_43({}, this.mutableStart, upper), UnsafeMutablePointer.infix_43({}, lowerPtr, replCount));
let isASCII = this.isASCII;
let srcCount = 0;
{
let $cu$generator = replacement.makeIterator({}, );
while(true) {
const $ifLet0 = $cu$generator.next({$setThis: $val => $cu$generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
let cu = $ifLet0[0]
{
if((UInt8.infix_62_61({}, cu, 0x80))) {
isASCII = false;
}
};
lowerPtr.subscript$set({$setThis: $val => lowerPtr = _cloneStruct($val)}, cu, srcCount);
Int.infix_43_61({}, {get: () => srcCount, set: $val => srcCount = $val}, 1);
}
};
this._postRRCAdjustNewCountNewIsASCII({}, Int.infix_43({}, Int.infix_43({}, lower, replCount), tailCount), isASCII)
----Swift.(file)..(error_type).debugDescription
return (("StringUTF16(") + (this.description.debugDescription) + (")"))
----Swift.(file)..(error_type).samePosition(in:String.UnicodeScalarView)
return _create(String.UnicodeScalarIndex, 'initStringIndexWithinStringUnicodeScalarView', {}, this, unicodeScalars)
----Swift.(file)..(error_type).customMirror
return _create(Mirror, 'initUnlabeledChildrenDisplayStyleOptionalAncestorRepresentationMirrorAncestorRepresentation', {}, this, this, nil/*!default_value*/, .generated/*!default_value*/)
----Swift.(file)..(error_type).subscript(_:Range<String.UTF16View.Index>)
return _create(Substring.UTF16View, 'initStringUTF16View_boundsRange', {}, this, r)
----Swift.(file).repairUTF8(_:UnsafeBufferPointer<UInt8>,firstKnownBrokenRange:Range<Int>)
let result = _create(_StringGuts, 'init', {}, );
const replacementCharacterCount = Unicode.Scalar._replacementCharacter.withUTF8CodeUnits({}, (($info, $0) => $0.count));
result.reserveCapacity({$setThis: $val => result = $val}, Int.infix_43({}, input.count, Int.infix_42({}, 5, replacementCharacterCount)));
let brokenRange = _cloneStruct(firstKnownBrokenRange);
let remainingInput = _cloneStruct(input);
do {
const goodChunk = _cloneStruct(remainingInput.subscript$get({}, Int.prefix_46_46_60({}, brokenRange.startIndex)));
result.reserveCapacity({$setThis: $val => result = $val}, Int.infix_43({}, Int.infix_43({}, result.count, remainingInput.count), replacementCharacterCount));
result.appendInPlaceIsASCII({$setThis: $val => result = $val}, _create(UnsafeBufferPointer, 'initRebasingSlice', {}, goodChunk), false);
Unicode.Scalar._replacementCharacter.withUTF8CodeUnits({}, (($info, $0) => result.appendInPlaceIsASCII({$setThis: $val => result = $val}, $0, false)));
remainingInput = _create(UnsafeBufferPointer, 'initRebasingSlice', {}, remainingInput.subscript$get({}, Int.postfix_46_46_46({}, brokenRange.endIndex)));
const $match = validateUTF8({}, remainingInput)
if((($match.rawValue == UTF8ValidationResult.success().rawValue))) {
result.appendInPlaceIsASCII({$setThis: $val => result = $val}, remainingInput, false);
return _create(String, 'init_StringGuts', {}, result);
}
else if((($match.rawValue == UTF8ValidationResult.error().rawValue))) {
const newBrokenRange = $match[0]
brokenRange = _cloneStruct(newBrokenRange);
};
} while(Int.infix_62({}, remainingInput.count, 0));
return _create(String, 'init_StringGuts', {}, result)
----Swift.(file)..(error_type).debugDescription
return (("UTF8View(") + (this.description.debugDescription) + (")"))
----Swift.(file)..(error_type).customMirror
return _create(Mirror, 'initUnlabeledChildrenDisplayStyleOptionalAncestorRepresentationMirrorAncestorRepresentation', {}, this, this, nil/*!default_value*/, .generated/*!default_value*/)
----Swift.(file)..(error_type).subscript(_:Range<String.UTF8View.Index>)
return _create(Substring.UTF8View, 'initStringUTF8View_boundsRange', {}, this, r)
----Swift.(file)..(error_type).debugDescription
return (("StringUnicodeScalarView(") + (this.description.debugDescription) + (")"))
----Swift.(file)..(error_type).init()
this.init_StringGuts({}, _create(_StringGuts, 'init', {}, ));
return
----Swift.(file)..(error_type).samePosition(in:String)
return _create(String.Index, 'initStringIndexWithinString', {}, this, characters)
----Swift.(file)..(error_type).customMirror
return _create(Mirror, 'initUnlabeledChildrenDisplayStyleOptionalAncestorRepresentationMirrorAncestorRepresentation', {}, this, this, nil/*!default_value*/, .generated/*!default_value*/)
----Swift.(file)..(error_type).subscript(_:Range<String.UnicodeScalarView.Index>)
return _create(String.UnicodeScalarView.SubSequence, 'initStringUnicodeScalarView_boundsRange', {}, this, r)
----Swift.(file).String.init(_:Substring)
$info.$setThis(_cloneStruct(String._fromSubstring({}, substring)));
return
----Swift.(file).Substring.init(_:Slice<String>)
this._slice = _cloneStruct(slice);
this._invariantCheck({}, );
return
----Swift.(file).Substring.init()
this.initSlice({}, _create(Slice, 'init', {}, ));
return
----Swift.(file).Substring.startIndex
return this._slice.startIndex
----Swift.(file).Substring.endIndex
return this._slice.endIndex
----Swift.(file).Substring.index(after:Substring.Index)
preconditionFileLine({}, () => String.Index.infix_60({}, i, this.endIndex), () => "Cannot increment beyond endIndex", '?3', '?3');
preconditionFileLine({}, () => Substring.Index.infix_62_61({}, i, this.startIndex), () => "Cannot increment an invalid index", '?3', '?3');
return this._slice.indexAfter({}, i)
----Swift.(file).Substring.index(before:Substring.Index)
preconditionFileLine({}, () => Substring.Index.infix_60_61({}, i, this.endIndex), () => "Cannot decrement an invalid index", '?3', '?3');
preconditionFileLine({}, () => Substring.Index.infix_62({}, i, this.startIndex), () => "Cannot decrement beyond startIndex", '?3', '?3');
return this._slice.indexBefore({}, i)
----Swift.(file).Substring.index(_:Substring.Index,offsetBy:Int)
const result = _cloneStruct(this._slice.indexOffsetBy({}, i, n));
preconditionFileLine({}, () => String.Index.infix_46_46_46({}, this._slice._startIndex, this._slice.endIndex).contains({}, result), () => "Operation results in an invalid index", '?3', '?3');
return result
----Swift.(file).Substring.index(_:Substring.Index,offsetBy:Int,limitedBy:Substring.Index)
const result = this._slice.indexOffsetByLimitedBy({}, i, n, limit);
preconditionFileLine({}, () => infix_63_63({}, result.mapSwift({}, (($info, $0) => String.Index.infix_46_46_46({}, this._slice._startIndex, this._slice.endIndex).contains({}, $0))), () => true), () => "Operation results in an invalid index", '?3', '?3');
return result
----Swift.(file).Substring.distance(from:Substring.Index,to:Substring.Index)
return this._slice.distanceFromTo({}, start, end)
----Swift.(file).Substring.subscript(_:Substring.Index)
return this._slice.subscript$get({}, i)
----Swift.(file).Substring.replaceSubrange(_:Range<Substring.Index>,with:C)
this._slice.replaceSubrangeWith({$setThis: $val => this._slice = $val}, bounds, newElements)
----Swift.(file).Substring.replaceSubrange(_:Range<Substring.Index>,with:Substring)
this.replaceSubrangeWith({$setThis: $val => $info.$setThis(_cloneStruct($val))}, bounds, newElements._slice)
----Swift.(file).Substring.init(decoding:C,as:Encoding.Type)
this.initString({}, _create(String, 'initDecodingAs', {}, codeUnits, sourceEncoding));
return
----Swift.(file).Substring.init(cString:UnsafePointer<CChar>)
this.initString({}, _create(String, 'initCStringUnsafePointer', {}, nullTerminatedUTF8));
return
----Swift.(file).Substring.init(decodingCString:UnsafePointer<Encoding.CodeUnit>,as:Encoding.Type)
this.initString({}, _create(String, 'initDecodingCStringUnsafePointerAs', {}, nullTerminatedCodeUnits, sourceEncoding));
return
----Swift.(file).Substring.withCString(_:(UnsafePointer<CChar>) throws -> Result)
return _create(String, 'initSubstring', {}, this).withCString({}, body)
----Swift.(file).Substring.withCString(encodedAs:TargetEncoding.Type,_:(UnsafePointer<TargetEncoding.CodeUnit>) throws -> Result)
return _create(String, 'initSubstring', {}, this).withCStringEncodedAs({}, targetEncoding, body)
----Swift.(file).Substring.customMirror
return _create(String, 'initSubstring', {}, this).customMirror
----Swift.(file).Substring.description
return _create(String, 'initSubstring', {}, this)
----Swift.(file).Substring.debugDescription
return _create(String, 'initSubstring', {}, this).debugDescription
----Swift.(file).Substring.init(_:String)
$info.$setThis(_cloneStruct(_cloneStruct(content.subscriptUnboundedRange$get({}, UnboundedRange_.postfix_46_46_46))));
return
----Swift.(file).Substring.UTF8View.startIndex
return this._slice.startIndex
----Swift.(file).Substring.UTF8View.endIndex
return this._slice.endIndex
----Swift.(file).Substring.UTF8View.subscript(_:Substring.UTF8View.Index)
return this._slice.subscript$get({}, index)
----Swift.(file).Substring.UTF8View.indices
return this._slice.indices
----Swift.(file).Substring.UTF8View.index(after:Substring.UTF8View.Index)
return this._slice.indexAfter({}, i)
----Swift.(file).Substring.UTF8View.formIndex(after:Substring.UTF8View.Index)
let i = i$inout.get()
const $result = (() => {
this._slice.formIndexAfter({}, {get: () => i, set: $val => i = $val});})()
i$inout.set(i)
return $result
----Swift.(file).Substring.UTF8View.index(_:Substring.UTF8View.Index,offsetBy:Int)
return this._slice.indexOffsetBy({}, i, n)
----Swift.(file).Substring.UTF8View.index(_:Substring.UTF8View.Index,offsetBy:Int,limitedBy:Substring.UTF8View.Index)
return this._slice.indexOffsetByLimitedBy({}, i, n, limit)
----Swift.(file).Substring.UTF8View.distance(from:Substring.UTF8View.Index,to:Substring.UTF8View.Index)
return this._slice.distanceFromTo({}, start, end)
----Swift.(file).Substring.UTF8View.index(before:Substring.UTF8View.Index)
return this._slice.indexBefore({}, i)
----Swift.(file).Substring.UTF8View.formIndex(before:Substring.UTF8View.Index)
let i = i$inout.get()
const $result = (() => {
this._slice.formIndexBefore({}, {get: () => i, set: $val => i = $val});})()
i$inout.set(i)
return $result
----Swift.(file).Substring.UTF8View.subscript(_:Range<Substring.UTF8View.Index>)
preconditionFileLine({}, () => Bool.infix_38_38({}, Substring.UTF8View.Index.infix_62_61({}, r.lowerBound, this.startIndex), () => Substring.UTF8View.Index.infix_60_61({}, r.upperBound, this.endIndex)), () => "UTF8View index range out of bounds", '?3', '?3');
return _create(Substring.UTF8View, 'initStringUTF8View_boundsRange', {}, this._slice.base, r)
----Swift.(file).Substring.utf8
return this._wholeString.utf8.subscriptRange$get({}, String.UTF8View.Index.infix_46_46_60({}, this.startIndex, this.endIndex))
----Swift.(file).Substring.UTF16View.startIndex
return this._slice.startIndex
----Swift.(file).Substring.UTF16View.endIndex
return this._slice.endIndex
----Swift.(file).Substring.UTF16View.subscript(_:Substring.UTF16View.Index)
return this._slice.subscript$get({}, index)
----Swift.(file).Substring.UTF16View.indices
return this._slice.indices
----Swift.(file).Substring.UTF16View.index(after:Substring.UTF16View.Index)
return this._slice.indexAfter({}, i)
----Swift.(file).Substring.UTF16View.formIndex(after:Substring.UTF16View.Index)
let i = i$inout.get()
const $result = (() => {
this._slice.formIndexAfter({}, {get: () => i, set: $val => i = $val});})()
i$inout.set(i)
return $result
----Swift.(file).Substring.UTF16View.index(_:Substring.UTF16View.Index,offsetBy:Int)
return this._slice.indexOffsetBy({}, i, n)
----Swift.(file).Substring.UTF16View.index(_:Substring.UTF16View.Index,offsetBy:Int,limitedBy:Substring.UTF16View.Index)
return this._slice.indexOffsetByLimitedBy({}, i, n, limit)
----Swift.(file).Substring.UTF16View.distance(from:Substring.UTF16View.Index,to:Substring.UTF16View.Index)
return this._slice.distanceFromTo({}, start, end)
----Swift.(file).Substring.UTF16View.index(before:Substring.UTF16View.Index)
return this._slice.indexBefore({}, i)
----Swift.(file).Substring.UTF16View.formIndex(before:Substring.UTF16View.Index)
let i = i$inout.get()
const $result = (() => {
this._slice.formIndexBefore({}, {get: () => i, set: $val => i = $val});})()
i$inout.set(i)
return $result
----Swift.(file).Substring.UTF16View.subscript(_:Range<Substring.UTF16View.Index>)
return _create(Substring.UTF16View, 'initStringUTF16View_boundsRange', {}, this._slice.base, r)
----Swift.(file).Substring.utf16
return this._wholeString.utf16.subscriptRange$get({}, String.UTF16View.Index.infix_46_46_60({}, this.startIndex, this.endIndex))
----Swift.(file).Substring.UnicodeScalarView.startIndex
return this._slice.startIndex
----Swift.(file).Substring.UnicodeScalarView.endIndex
return this._slice.endIndex
----Swift.(file).Substring.UnicodeScalarView.subscript(_:Substring.UnicodeScalarView.Index)
return this._slice.subscript$get({}, index)
----Swift.(file).Substring.UnicodeScalarView.indices
return this._slice.indices
----Swift.(file).Substring.UnicodeScalarView.index(after:Substring.UnicodeScalarView.Index)
return this._slice.indexAfter({}, i)
----Swift.(file).Substring.UnicodeScalarView.formIndex(after:Substring.UnicodeScalarView.Index)
let i = i$inout.get()
const $result = (() => {
this._slice.formIndexAfter({}, {get: () => i, set: $val => i = $val});})()
i$inout.set(i)
return $result
----Swift.(file).Substring.UnicodeScalarView.index(_:Substring.UnicodeScalarView.Index,offsetBy:Int)
return this._slice.indexOffsetBy({}, i, n)
----Swift.(file).Substring.UnicodeScalarView.index(_:Substring.UnicodeScalarView.Index,offsetBy:Int,limitedBy:Substring.UnicodeScalarView.Index)
return this._slice.indexOffsetByLimitedBy({}, i, n, limit)
----Swift.(file).Substring.UnicodeScalarView.distance(from:Substring.UnicodeScalarView.Index,to:Substring.UnicodeScalarView.Index)
return this._slice.distanceFromTo({}, start, end)
----Swift.(file).Substring.UnicodeScalarView.index(before:Substring.UnicodeScalarView.Index)
return this._slice.indexBefore({}, i)
----Swift.(file).Substring.UnicodeScalarView.formIndex(before:Substring.UnicodeScalarView.Index)
let i = i$inout.get()
const $result = (() => {
this._slice.formIndexBefore({}, {get: () => i, set: $val => i = $val});})()
i$inout.set(i)
return $result
----Swift.(file).Substring.UnicodeScalarView.subscript(_:Range<Substring.UnicodeScalarView.Index>)
return _create(Substring.UnicodeScalarView, 'initStringUnicodeScalarView_boundsRange', {}, this._slice.base, r)
----Swift.(file).Substring.unicodeScalars
return this._wholeString.unicodeScalars.subscriptRange$get({}, String.UnicodeScalarView.Index.infix_46_46_60({}, this.startIndex, this.endIndex))
----Swift.(file).String.init(_:Substring.UnicodeScalarView)
$info.$setThis(_cloneStruct(_create(String, 'initSubstring', {}, _create(Substring, 'initSubstringUnicodeScalarView', {}, content))));
return
----Swift.(file).Substring.UnicodeScalarView.init()
this._slice = _create(Slice, 'init', {}, );
return
----Swift.(file).Substring.UnicodeScalarView.replaceSubrange(_:Range<Substring.UnicodeScalarView.Index>,with:C)
this._slice.replaceSubrangeWith({$setThis: $val => this._slice = $val}, target, replacement)
----Swift.(file).Substring.init(_:S)
{const $ifLet0 = _injectIntoOptional(_elements)
if($ifLet0.rawValue === 'some') {
let str = $ifLet0[0]
$info.$setThis(_cloneStruct(_cloneStruct(str.subscriptUnboundedRange$get({}, UnboundedRange_.postfix_46_46_46))));
return ;
}
};
{const $ifLet0 = _injectIntoOptional(_elements)
if($ifLet0.rawValue === 'some') {
let subStr = $ifLet0[0]
$info.$setThis(_cloneStruct(_cloneStruct(subStr)));
return ;
}
};
$info.$setThis(_cloneStruct(_cloneStruct(_create(String, 'initBuffer', {}, _elements).subscriptUnboundedRange$get({}, UnboundedRange_.postfix_46_46_46))));
return
----Swift.(file).Substring.append(contentsOf:S)
let string = _create(String, 'initSubstring', {}, this);
$info.$setThis(_cloneStruct(_create(Substring, 'init', {}, )));
string.appendContentsOf({$setThis: $val => string = $val}, _elements);
$info.$setThis(_cloneStruct(_create(Substring, 'initString', {}, string)))
----Swift.(file).Substring.lowercased()
return _create(String, 'initSubstring', {}, this).lowercased({}, )
----Swift.(file).Substring.uppercased()
return _create(String, 'initSubstring', {}, this).uppercased({}, )
----Swift.(file).Substring.filter(_:(Substring.Element) throws -> Bool)
return _create(String, 'initBuffer', {}, this.lazy.filterSwift({}, isIncluded))
----Swift.(file).Substring.write(_:String)
this.appendContentsOf({$setThis: $val => $info.$setThis(_cloneStruct($val))}, other)
----Swift.(file).Substring.write(to:Target)
let target = target$inout.get()
const $result = (() => {
target.write({$setThis: $val => target = $val}, _create(String, 'initSubstring', {}, this));})()
target$inout.set(target)
return $result
----Swift.(file).Substring.init(unicodeScalarLiteral:String)
this.initString({}, value);
return
----Swift.(file).Substring.init(extendedGraphemeClusterLiteral:String)
this.initString({}, value);
return
----Swift.(file).Substring.init(stringLiteral:String)
this.initString({}, value);
return
----Swift.(file).String.subscript(_:Range<String.Index>)
this._boundsCheck({}, r);
return _create(Substring, 'initSlice', {}, _create(Slice, 'initBaseBoundsRange', {}, this, r))
----Swift.(file).Substring.subscript(_:Range<Substring.Index>)
return _create(Substring, 'initSlice', {}, this._slice.subscriptRange$get({}, r))
----Swift.(file).__SwiftNativeNSArrayWithContiguousStorage.objectAt(_:Int)
return this.withUnsafeBufferOfObjects({}, (($info, objects) => { 
preconditionFileLine({}, () => _isValidArraySubscriptCount({}, index, objects.count), () => "Array index out of range", '?3', '?3');
return objects.subscript$get({}, index); }))
----Swift.(file).__SwiftNativeNSArrayWithContiguousStorage.copy(with:<<error type>>)
return this
----Swift.(file)._UIntBuffer.Iterator.init(_:_UIntBuffer<Element>)
this._impl = _cloneStruct(x);
return
----Swift.(file)._UIntBuffer.Iterator.next()
{
if((UInt8.infix_61_61({}, this._impl._bitCount, 0))) {
return Optional.none;
}
};
let $defer = () => {
this._impl._storage = _UIntBuffer.Storage.infix_38_62_62({}, this._impl._storage, ((function(){throw '!unclarifiedGeneric:Element'})()).bitWidth);
this._impl._bitCount = UInt8.infix_38_45({}, this._impl._bitCount, this._impl._elementWidth);
}
try {;
return _injectIntoOptional(_create(((function(){throw '!unclarifiedGeneric:Element'})()), 'initTruncatingIfNeeded', {}, this._impl._storage));}catch($error){$defer({}, );throw $error}$defer({}, )
----Swift.(file)._UIntBuffer.makeIterator()
return _create(_UIntBuffer.Iterator, 'init_UIntBuffer', {}, this)
----Swift.(file)._UIntBuffer.Index.init(bitOffset:UInt8)
this.bitOffset = bitOffset;
return
----Swift.(file)._UIntBuffer.startIndex
return _create(_UIntBuffer.Index, 'initBitOffsetUInt8', {}, 0)
----Swift.(file)._UIntBuffer.endIndex
return _create(_UIntBuffer.Index, 'initBitOffsetUInt8', {}, this._bitCount)
----Swift.(file)._UIntBuffer.index(after:_UIntBuffer<Element>.Index)
return _create(_UIntBuffer.Index, 'initBitOffsetUInt8', {}, UInt8.infix_38_43({}, i.bitOffset, this._elementWidth))
----Swift.(file)._UIntBuffer.subscript(_:_UIntBuffer<Element>.Index)
return _create(((function(){throw '!unclarifiedGeneric:Element'})()), 'initTruncatingIfNeeded', {}, _UIntBuffer.Storage.infix_38_62_62({}, this._storage, i.bitOffset))
----Swift.(file)._UIntBuffer.index(before:_UIntBuffer<Element>.Index)
return _create(_UIntBuffer.Index, 'initBitOffsetUInt8', {}, UInt8.infix_38_45({}, i.bitOffset, this._elementWidth))
----Swift.(file)._UIntBuffer.index(_:_UIntBuffer<Element>.Index,offsetBy:Int)
const x = Int.infix_38_43({}, _create(Int, 'init', {}, i.bitOffset), Int.infix_38_42({}, n, ((function(){throw '!unclarifiedGeneric:Element'})()).bitWidth));
return _create(_UIntBuffer.Index, 'initBitOffsetUInt8', {}, _create(UInt8, 'initTruncatingIfNeeded', {}, x))
----Swift.(file)._UIntBuffer.distance(from:_UIntBuffer<Element>.Index,to:_UIntBuffer<Element>.Index)
return Int.infix_47({}, Int.infix_38_45({}, _create(Int, 'init', {}, j.bitOffset), _create(Int, 'init', {}, i.bitOffset)), ((function(){throw '!unclarifiedGeneric:Element'})()).bitWidth)
----Swift.(file)._UIntBuffer.init()
this._storage = 0;
this._bitCount = 0;
return
----Swift.(file)._UIntBuffer.capacity
return Int.infix_47({}, _UIntBuffer.Storage.bitWidth, ((function(){throw '!unclarifiedGeneric:Element'})()).bitWidth)
----Swift.(file)._UIntBuffer.append(_:Element)
preconditionFileLine({}, () => Int.infix_60_61({}, Int.infix_43({}, this.count, 1), this.capacity), () => String()/*!default_value*/, '?3', '?3');
UInt32.infix_38_61({}, {get: () => this._storage, set: $val => this._storage = $val}, UInt32.prefix_126({}, _UIntBuffer.Storage.infix_38_60_60({}, _create(_UIntBuffer.Storage, 'init', {}, ((function(){throw '!unclarifiedGeneric:Element'})()).max), this._bitCount)));
UInt32.infix_124_61({}, {get: () => this._storage, set: $val => this._storage = $val}, UInt32.infix_38_60_60({}, _create(_UIntBuffer.Storage, 'init', {}, newElement), this._bitCount));
this._bitCount = UInt8.infix_38_43({}, this._bitCount, this._elementWidth)
----Swift.(file)._UIntBuffer.removeFirst()
preconditionFileLine({}, () => Bool.prefix_33({}, this.isEmpty), () => String()/*!default_value*/, '?3', '?3');
const result = _create(((function(){throw '!unclarifiedGeneric:Element'})()), 'initTruncatingIfNeeded', {}, this._storage);
this._bitCount = UInt8.infix_38_45({}, this._bitCount, this._elementWidth);
this._storage = this._storage._fullShiftRight({}, this._elementWidth);
return result
----Swift.(file)._UIntBuffer.replaceSubrange(_:Range<_UIntBuffer<Element>.Index>,with:C)
preconditionFileLine({}, () => UInt8.infix_46_46_60({}, 0, this._bitCount)._contains_({}, UInt8.infix_46_46_60({}, target.lowerBound.bitOffset, target.upperBound.bitOffset)), () => String()/*!default_value*/, '?3', '?3');
const replacement1 = _create(_UIntBuffer, 'initBuffer', {}, replacement);
const targetCount = this.distanceFromTo({}, target.lowerBound, target.upperBound);
const growth = Int.infix_38_45({}, replacement1.count, targetCount);
preconditionFileLine({}, () => Int.infix_60_61({}, Int.infix_43({}, this.count, growth), this.capacity), () => String()/*!default_value*/, '?3', '?3');
const headCount = this.distanceFromTo({}, this.startIndex, target.lowerBound);
const tailOffset = this.distanceFromTo({}, this.startIndex, target.upperBound);
const w = ((function(){throw '!unclarifiedGeneric:Element'})()).bitWidth;
const headBits = UInt32.infix_38({}, this._storage, UInt32._lowBits({}, Int.infix_38_42({}, headCount, w)));
const tailBits = this._storage._fullShiftRight({}, Int.infix_38_42({}, tailOffset, w));
this._storage = headBits;
UInt32.infix_124_61({}, {get: () => this._storage, set: $val => this._storage = $val}, UInt32.infix_38_60_60({}, replacement1._storage, Int.infix_38_42({}, headCount, w)));
UInt32.infix_124_61({}, {get: () => this._storage, set: $val => this._storage = $val}, UInt32.infix_38_60_60({}, tailBits, Int.infix_38_42({}, Int.infix_38_43({}, tailOffset, growth), w)));
this._bitCount = _create(UInt8, 'initTruncatingIfNeeded', {}, Int.infix_38_43({}, _create(Int, 'init', {}, this._bitCount), Int.infix_38_42({}, growth, w)))
----Swift.(file)..(error_type).encodedReplacementCharacter
return _create(Unicode.UTF16.EncodedScalar, 'init_storage_UIntBufferStorage_bitCountUInt8', {}, 0xFFFD, 16);
}
static get encodedReplacementCharacter() { return this.encodedReplacementCharacter$get()
----Swift.(file)..(error_type).decode(_:Unicode.UTF16.EncodedScalar)
const bits = source._storage;
{
if((_fastPath({}, UInt8.infix_61_61({}, source._bitCount, 16)))) {
return _create(Unicode.Scalar, 'init_uncheckedUInt32', {}, UInt32.infix_38({}, bits, 0xffff));
}
};
const lower = UInt32.infix_38({}, UInt32.infix_62_62({}, bits, 16), 0x03ff);
const upper = UInt32.infix_60_60({}, UInt32.infix_38({}, bits, 0x03ff), 10);
const value = UInt32.infix_43({}, 0x10000, UInt32.infix_124({}, lower, upper));
return _create(Unicode.Scalar, 'init_uncheckedUInt32', {}, value)
----Swift.(file)..(error_type).encode(_:Unicode.Scalar)
const x = source.value;
{
if((_fastPath({}, UInt32.infix_60({}, x, UInt32.infix_60_60({}, 1, 16))))) {
return _injectIntoOptional(_create(Unicode.UTF16.EncodedScalar, 'init_storage_UIntBufferStorage_bitCountUInt8', {}, x, 16));
}
};
const x1 = UInt32.infix_45({}, x, UInt32.infix_60_60({}, 1, 16));
let r = UInt32.infix_43({}, 0xdc00, UInt32.infix_38({}, x1, 0x3ff));
UInt32.infix_38_60_60_61({}, {get: () => r, set: $val => r = $val}, 16);
UInt32.infix_124_61({}, {get: () => r, set: $val => r = $val}, UInt32.infix_43({}, 0xd800, UInt32.infix_38({}, UInt32.infix_38_62_62({}, x1, 10), 0x3ff)));
return _injectIntoOptional(_create(Unicode.UTF16.EncodedScalar, 'init_storage_UIntBufferStorage_bitCountUInt8', {}, r, 32))
----Swift.(file)..(error_type).transcode(_:FromEncoding.EncodedScalar,from:FromEncoding.Type)
{
if((_fastPath({}, infix_61_61({}, _injectIntoOptional(((function(){throw '!unclarifiedGeneric:FromEncoding'})())), _injectIntoOptional(UTF8))))) {
const c = _cloneStruct(_identityCastTo({}, content, UTF8.EncodedScalar));
let b = c.count;
b = Int.infix_38_45({}, b, 1);
{
if((_fastPath({}, Int.infix_61_61({}, b, 0)))) {
return _injectIntoOptional(_create(Unicode.UTF16.EncodedScalar, 'init_storage_UIntBufferStorage_bitCountUInt8', {}, UInt32.infix_38({}, UInt32.infix_38_45({}, c._biasedBits, 0x1), 0b01111111), 16));
}
};
let s = UInt32.infix_38_45({}, c._biasedBits, 0x01010101);
let r = s;
UInt32.infix_38_60_60_61({}, {get: () => r, set: $val => r = $val}, 6);
UInt32.infix_38_62_62_61({}, {get: () => s, set: $val => s = $val}, 8);
UInt32.infix_124_61({}, {get: () => r, set: $val => r = $val}, UInt32.infix_38({}, s, 0b0111111));
b = Int.infix_38_45({}, b, 1);
{
if((_fastPath({}, Int.infix_61_61({}, b, 0)))) {
return _injectIntoOptional(_create(Unicode.UTF16.EncodedScalar, 'init_storage_UIntBufferStorage_bitCountUInt8', {}, UInt32.infix_38({}, r, 0b011111111111), 16));
}
};
UInt32.infix_38_60_60_61({}, {get: () => r, set: $val => r = $val}, 6);
UInt32.infix_38_62_62_61({}, {get: () => s, set: $val => s = $val}, 8);
UInt32.infix_124_61({}, {get: () => r, set: $val => r = $val}, UInt32.infix_38({}, s, 0b0111111));
b = Int.infix_38_45({}, b, 1);
{
if((_fastPath({}, Int.infix_61_61({}, b, 0)))) {
return _injectIntoOptional(_create(Unicode.UTF16.EncodedScalar, 'init_storage_UIntBufferStorage_bitCountUInt8', {}, UInt32.infix_38({}, r, 0xFFFF), 16));
}
};
UInt32.infix_38_60_60_61({}, {get: () => r, set: $val => r = $val}, 6);
UInt32.infix_38_62_62_61({}, {get: () => s, set: $val => s = $val}, 8);
UInt32.infix_124_61({}, {get: () => r, set: $val => r = $val}, UInt32.infix_38({}, s, 0b0111111));
UInt32.infix_38_61({}, {get: () => r, set: $val => r = $val}, UInt32.infix_45({}, UInt32.infix_38_60_60({}, 1, 21), 1));
return this.encode({}, _create(Unicode.Scalar, 'init_uncheckedUInt32', {}, r));
}
else {
{
if((_fastPath({}, infix_61_61({}, _injectIntoOptional(((function(){throw '!unclarifiedGeneric:FromEncoding'})())), _injectIntoOptional(UTF16))))) {
return _injectIntoOptional(unsafeBitCastTo({}, content, UTF16.EncodedScalar));
}
}
}
};
return this.encode({}, ((function(){throw '!unclarifiedGeneric:FromEncoding'})()).decode({}, content))
----Swift.(file)..(error_type).encodedReplacementCharacter
return _create(Unicode.UTF32.EncodedScalar, 'init', {}, this._replacementCodeUnit);
}
static get encodedReplacementCharacter() { return this.encodedReplacementCharacter$get()
----Swift.(file)..(error_type).decode(_:Unicode.UTF32.EncodedScalar)
return _create(Unicode.Scalar, 'init_uncheckedUInt32', {}, source.first[0])
----Swift.(file)..(error_type).encode(_:Unicode.Scalar)
return _injectIntoOptional(_create(Unicode.UTF32.EncodedScalar, 'init', {}, source.value))
----Swift.(file).UTF32.Parser.parseScalar(from:I)
let input = input$inout.get()
const $result = (() => {
const n = input.next({$setThis: $val => input = $val}, );
{const $ifLet0 = n
if((_fastPath({}, Optional.wrappedNotEqualsOptionalNilComparisonType({}, n, _create(_OptionalNilComparisonType, 'initNilLiteraltuple_type', {}, {})))) && $ifLet0.rawValue === 'some') {
let x = $ifLet0[0]
{
if(!((_fastPath({}, Bool.infix_38_38({}, UInt32.infix_33_61({}, UInt32.infix_38_62_62({}, x, 11), 0b11011), () => UInt32.infix_60_61({}, x, 0x10ffff)))))) {
return Unicode.ParseResult.error({}, 1);
}
};
return Unicode.ParseResult.valid({}, _create(UTF32.EncodedScalar, 'init', {}, x));
}
};
return Unicode.ParseResult.emptyInput;})()
input$inout.set(input)
return $result
----Swift.(file)..(error_type).encodedReplacementCharacter
return Unicode.UTF8.EncodedScalar.encodedReplacementCharacter;
}
static get encodedReplacementCharacter() { return this.encodedReplacementCharacter$get()
----Swift.(file)..(error_type).decode(_:Unicode.UTF8.EncodedScalar)
const $match = source.count
if((((infix_126_61({}, 1, $match))))) {
return _create(Unicode.Scalar, 'init_uncheckedUInt32', {}, UInt32.infix_38_45({}, source._biasedBits, 0x01));
}
else if((((infix_126_61({}, 2, $match))))) {
const bits = UInt32.infix_38_45({}, source._biasedBits, 0x0101);
let value = UInt32.infix_38_62_62({}, UInt32.infix_38({}, bits, 0b011111100000000), 8);
UInt32.infix_124_61({}, {get: () => value, set: $val => value = $val}, UInt32.infix_38_60_60({}, UInt32.infix_38({}, bits, 0b000011111), 6));
return _create(Unicode.Scalar, 'init_uncheckedUInt32', {}, value);
}
else if((((infix_126_61({}, 3, $match))))) {
const bits = UInt32.infix_38_45({}, source._biasedBits, 0x010101);
let value = UInt32.infix_38_62_62({}, UInt32.infix_38({}, bits, 0b01111110000000000000000), 16);
UInt32.infix_124_61({}, {get: () => value, set: $val => value = $val}, UInt32.infix_38_62_62({}, UInt32.infix_38({}, bits, 0b011111100000000), 2));
UInt32.infix_124_61({}, {get: () => value, set: $val => value = $val}, UInt32.infix_38_60_60({}, UInt32.infix_38({}, bits, 0b000001111), 12));
return _create(Unicode.Scalar, 'init_uncheckedUInt32', {}, value);
}
else if(((true))) {
const bits = UInt32.infix_38_45({}, source._biasedBits, 0x01010101);
let value = UInt32.infix_38_62_62({}, UInt32.infix_38({}, bits, 0b0111111000000000000000000000000), 24);
UInt32.infix_124_61({}, {get: () => value, set: $val => value = $val}, UInt32.infix_38_62_62({}, UInt32.infix_38({}, bits, 0b01111110000000000000000), 10));
UInt32.infix_124_61({}, {get: () => value, set: $val => value = $val}, UInt32.infix_38_60_60({}, UInt32.infix_38({}, bits, 0b011111100000000), 4));
UInt32.infix_124_61({}, {get: () => value, set: $val => value = $val}, UInt32.infix_38_60_60({}, UInt32.infix_38({}, bits, 0b000000111), 18));
return _create(Unicode.Scalar, 'init_uncheckedUInt32', {}, value);
}
----Swift.(file)..(error_type).encode(_:Unicode.Scalar)
let c = source.value;
{
if((_fastPath({}, UInt32.infix_60({}, c, Int.infix_38_60_60({}, 1, 7))))) {
return _injectIntoOptional(_create(Unicode.UTF8.EncodedScalar, 'init_containing_ValidUTF8BufferElement', {}, _create(UInt8, 'init', {}, c)));
}
};
let o = UInt32.infix_38({}, c, 0b000111111);
UInt32.infix_38_62_62_61({}, {get: () => c, set: $val => c = $val}, 6);
UInt32.infix_38_60_60_61({}, {get: () => o, set: $val => o = $val}, 8);
{
if((_fastPath({}, UInt32.infix_60({}, c, Int.infix_38_60_60({}, 1, 5))))) {
return _injectIntoOptional(_create(Unicode.UTF8.EncodedScalar, 'init_biasedBitsUInt32', {}, UInt32.infix_38_43({}, UInt32.infix_124({}, o, c), 0b01000000111000001)));
}
};
UInt32.infix_124_61({}, {get: () => o, set: $val => o = $val}, UInt32.infix_38({}, c, 0b000111111));
UInt32.infix_38_62_62_61({}, {get: () => c, set: $val => c = $val}, 6);
UInt32.infix_38_60_60_61({}, {get: () => o, set: $val => o = $val}, 8);
{
if((_fastPath({}, UInt32.infix_60({}, c, Int.infix_38_60_60({}, 1, 4))))) {
return _injectIntoOptional(_create(Unicode.UTF8.EncodedScalar, 'init_biasedBitsUInt32', {}, UInt32.infix_38_43({}, UInt32.infix_124({}, o, c), 0b0100000011000000111100001)));
}
};
UInt32.infix_124_61({}, {get: () => o, set: $val => o = $val}, UInt32.infix_38({}, c, 0b000111111));
UInt32.infix_38_62_62_61({}, {get: () => c, set: $val => c = $val}, 6);
UInt32.infix_38_60_60_61({}, {get: () => o, set: $val => o = $val}, 8);
return _injectIntoOptional(_create(Unicode.UTF8.EncodedScalar, 'init_biasedBitsUInt32', {}, UInt32.infix_38_43({}, UInt32.infix_124({}, o, c), 0b010000001100000011000000111110001)))
----Swift.(file)..(error_type).transcode(_:FromEncoding.EncodedScalar,from:FromEncoding.Type)
{
if((_fastPath({}, infix_61_61({}, _injectIntoOptional(((function(){throw '!unclarifiedGeneric:FromEncoding'})())), _injectIntoOptional(UTF16))))) {
const c = _cloneStruct(_identityCastTo({}, content, UTF16.EncodedScalar));
let u0 = _create(UInt16, 'initTruncatingIfNeeded', {}, c._storage);
{
if((_fastPath({}, UInt16.infix_60({}, u0, 0x80)))) {
return _injectIntoOptional(_create(Unicode.UTF8.EncodedScalar, 'init_containing_ValidUTF8BufferElement', {}, _create(UInt8, 'initTruncatingIfNeeded', {}, u0)));
}
};
let r = _create(UInt32, 'init', {}, UInt16.infix_38({}, u0, 0b0111111));
UInt32.infix_38_60_60_61({}, {get: () => r, set: $val => r = $val}, 8);
UInt16.infix_38_62_62_61({}, {get: () => u0, set: $val => u0 = $val}, 6);
{
if((_fastPath({}, UInt16.infix_60({}, u0, Int.infix_38_60_60({}, 1, 5))))) {
return _injectIntoOptional(_create(Unicode.UTF8.EncodedScalar, 'init_biasedBitsUInt32', {}, UInt32.infix_38_43({}, UInt32.infix_124({}, _create(UInt32, 'init', {}, u0), r), 0b01000000111000001)));
}
};
UInt32.infix_124_61({}, {get: () => r, set: $val => r = $val}, _create(UInt32, 'init', {}, UInt16.infix_38({}, u0, 0b0111111)));
UInt32.infix_38_60_60_61({}, {get: () => r, set: $val => r = $val}, 8);
{
if((_fastPath({}, UInt16.infix_33_61({}, UInt16.infix_38({}, u0, UInt16.infix_38_62_62({}, 0xF800, 6)), Int.infix_38_62_62({}, 0xD800, 6))))) {
UInt16.infix_38_62_62_61({}, {get: () => u0, set: $val => u0 = $val}, 6);
return _injectIntoOptional(_create(Unicode.UTF8.EncodedScalar, 'init_biasedBitsUInt32', {}, UInt32.infix_38_43({}, UInt32.infix_124({}, _create(UInt32, 'init', {}, u0), r), 0b0100000011000000111100001)));
}
};
}
else {
{
if((_fastPath({}, infix_61_61({}, _injectIntoOptional(((function(){throw '!unclarifiedGeneric:FromEncoding'})())), _injectIntoOptional(UTF8))))) {
return _injectIntoOptional(_identityCastTo({}, content, UTF8.EncodedScalar));
}
}
}
};
return this.encode({}, ((function(){throw '!unclarifiedGeneric:FromEncoding'})()).decode({}, content))
----Swift.(file)._UTFParser.parseScalar(from:I)
let input = input$inout.get()
const $result = (() => {
{
if((_fastPath({}, this._buffer.isEmpty))) {
{const $ifLet0 = input.next({$setThis: $val => input = $val}, )
if(!($ifLet0.rawValue === 'some')) {
return Unicode.ParseResult.emptyInput;
}let codeUnit = $ifLet0[0]
};
{
if((((function(){throw '!unclarifiedGeneric:Self.Encoding'})())._isScalar({}, codeUnit))) {
return Unicode.ParseResult.valid({}, _create(((function(){throw '!unclarifiedGeneric:Self.Encoding.EncodedScalar'})()), 'initBuffer', {}, _create(CollectionOfOne, 'init', {}, codeUnit)));
}
};
this._buffer.append({$setThis: $val => this._buffer = $val}, codeUnit);
}
else {
{
if((((function(){throw '!unclarifiedGeneric:Self.Encoding'})())._isScalar({}, _create(((function(){throw '!unclarifiedGeneric:I.Element'})()), 'initTruncatingIfNeeded', {}, this._buffer._storage)))) {
const codeUnit = _create(((function(){throw '!unclarifiedGeneric:I.Element'})()), 'initTruncatingIfNeeded', {}, this._buffer._storage);
this._buffer.removeAt({$setThis: $val => this._buffer = $val}, this._buffer.startIndex);
return Unicode.ParseResult.valid({}, _create(((function(){throw '!unclarifiedGeneric:Self.Encoding.EncodedScalar'})()), 'initBuffer', {}, _create(CollectionOfOne, 'init', {}, codeUnit)));
}
}
}
};
do {
{const $ifLet0 = input.next({$setThis: $val => input = $val}, )
if($ifLet0.rawValue === 'some') {
let codeUnit = $ifLet0[0]
this._buffer.append({$setThis: $val => this._buffer = $val}, codeUnit);
}
else {
{
if((this._buffer.isEmpty)) {
return Unicode.ParseResult.emptyInput;
}
};
break;
}
};
} while(Int.infix_60({}, this._buffer.count, this._buffer.capacity));
const $tuple = this._parseMultipleCodeUnits({}, ), isValid = $tuple && $tuple[0], scalarBitCount = $tuple && $tuple[1];
const encodedScalar = this._bufferedScalarBitCount({}, scalarBitCount);
this._buffer._storage = _create(UInt32, 'initTruncatingIfNeeded', {}, UInt64.infix_38_62_62({}, _create(UInt64, 'init', {}, this._buffer._storage), scalarBitCount));
this._buffer._bitCount = UInt8.infix_38_45({}, this._buffer._bitCount, scalarBitCount);
{
if((_fastPath({}, isValid))) {
return Unicode.ParseResult.valid({}, encodedScalar);
}
};
return Unicode.ParseResult.error({}, _create(Int, 'init', {}, UInt8.infix_47({}, scalarBitCount, numericCast({}, ((function(){throw '!unclarifiedGeneric:I.Element'})()).bitWidth))));})()
input$inout.set(input)
return $result
----Swift.(file).UnicodeDecodingResult.==infix(_:UnicodeDecodingResult,_:UnicodeDecodingResult)
const $match = {0: lhs, 1: rhs}
if((($match[0].rawValue == UnicodeDecodingResult.scalarValue().rawValue && $match[1].rawValue == UnicodeDecodingResult.scalarValue().rawValue))) {
const lhsScalar = $match[0][0]
const rhsScalar = $match[1][0]
return Unicode.Scalar.infix_61_61({}, lhsScalar, rhsScalar);
}
else if((($match[0].rawValue == UnicodeDecodingResult.emptyInput.rawValue && $match[1].rawValue == UnicodeDecodingResult.emptyInput.rawValue))) {
return true;
}
else if((($match[0].rawValue == UnicodeDecodingResult.error.rawValue && $match[1].rawValue == UnicodeDecodingResult.error.rawValue))) {
return true;
}
else if(((true))) {
return false;
}
----Swift.(file)..(error_type).init()
$info.$setThis(_cloneStruct(Unicode.UTF8._swift3Buffer({}, _create(Unicode.UTF8.ForwardParser, 'init', {}, ))));
return
----Swift.(file)..(error_type).encode(_:<<error type>>,into:<<error type>>)
let s = this.encode({}, input)[0]._biasedBits;
processCodeUnit({}, Unicode.UTF8.CodeUnit.infix_38_45({}, _create(UInt8, 'initTruncatingIfNeeded', {}, s), 0x01));
UInt32.infix_38_62_62_61({}, {get: () => s, set: $val => s = $val}, 8);
{
if((_fastPath({}, UInt32.infix_61_61({}, s, 0)))) {
return ;
}
};
processCodeUnit({}, Unicode.UTF8.CodeUnit.infix_38_45({}, _create(UInt8, 'initTruncatingIfNeeded', {}, s), 0x01));
UInt32.infix_38_62_62_61({}, {get: () => s, set: $val => s = $val}, 8);
{
if((_fastPath({}, UInt32.infix_61_61({}, s, 0)))) {
return ;
}
};
processCodeUnit({}, Unicode.UTF8.CodeUnit.infix_38_45({}, _create(UInt8, 'initTruncatingIfNeeded', {}, s), 0x01));
UInt32.infix_38_62_62_61({}, {get: () => s, set: $val => s = $val}, 8);
{
if((_fastPath({}, UInt32.infix_61_61({}, s, 0)))) {
return ;
}
};
processCodeUnit({}, Unicode.UTF8.CodeUnit.infix_38_45({}, _create(UInt8, 'initTruncatingIfNeeded', {}, s), 0x01))
----Swift.(file)..(error_type).isContinuation(_:<<error type>>)
return UInt8.infix_61_61({}, UInt8.infix_38({}, _byte, 0b11000000), 0b10000000)
----Swift.(file)..(error_type).init()
$info.$setThis(_cloneStruct(Unicode.UTF16._swift3Buffer({}, _create(Unicode.UTF16.ForwardParser, 'init', {}, ))));
return
----Swift.(file)..(error_type).encode(_:<<error type>>,into:<<error type>>)
let s = this.encode({}, input)[0]._storage;
processCodeUnit({}, _create(UInt16, 'initTruncatingIfNeeded', {}, s));
UInt32.infix_38_62_62_61({}, {get: () => s, set: $val => s = $val}, 16);
{
if((_fastPath({}, UInt32.infix_61_61({}, s, 0)))) {
return ;
}
};
processCodeUnit({}, _create(UInt16, 'initTruncatingIfNeeded', {}, s))
----Swift.(file)..(error_type).init()
$info.$setThis(_cloneStruct(Unicode.UTF32._swift3Codec));
return
----Swift.(file)..(error_type).decode(_:I)
let input = input$inout.get()
const $result = (() => {
let parser = _create(Unicode.UTF32.ForwardParser, 'init', {}, );
const $match = parser.parseScalarFrom({$setThis: $val => parser = $val}, {get: () => input, set: $val => input = $val})
if((($match.rawValue == Unicode.ParseResult.valid().rawValue))) {
const s = $match[0]
return UnicodeDecodingResult.scalarValue({}, UTF32.decode({}, s));
}
else if((($match.rawValue == Unicode.ParseResult.error().rawValue))) {
return UnicodeDecodingResult.error;
}
else if((($match.rawValue == Unicode.ParseResult.emptyInput.rawValue))) {
return UnicodeDecodingResult.emptyInput;
};})()
input$inout.set(input)
return $result
----Swift.(file)..(error_type).encode(_:<<error type>>,into:<<error type>>)
processCodeUnit({}, _create(UInt32, 'initUnicodeScalar', {}, input))
----Swift.(file).transcode(_:Input,from:InputEncoding.Type,to:OutputEncoding.Type,stoppingOnError:Bool,into:<<error type>>)
let input_dupl = input;
let p = _create(((function(){throw '!unclarifiedGeneric:InputEncoding.ForwardParser'})()), 'init', {}, );
let hadError = false;
while(true){
if(!((true))) break
const $match = p.parseScalarFrom({$setThis: $val => p = $val}, {get: () => input_dupl, set: $val => input_dupl = $val})
if((($match.rawValue == Unicode.ParseResult.valid().rawValue))) {
const s = $match[0]
const t = ((function(){throw '!unclarifiedGeneric:OutputEncoding'})()).transcodeFrom({}, s, inputEncoding);
{const $ifLet0 = t
if(!((_fastPath({}, Optional.wrappedNotEqualsOptionalNilComparisonType({}, t, _create(_OptionalNilComparisonType, 'initNilLiteraltuple_type', {}, {})))) && $ifLet0.rawValue === 'some')) {
break;
}let s = $ifLet0[0]
};
s.forEachSwift({}, processCodeUnit);
continue;
}
else if((($match.rawValue == Unicode.ParseResult.emptyInput.rawValue))) {
return hadError;
}
else if((($match.rawValue == Unicode.ParseResult.error().rawValue))) {
{
if((_slowPath({}, stopOnError))) {
return true;
}
};
hadError = true;
};
((function(){throw '!unclarifiedGeneric:OutputEncoding'})()).encodedReplacementCharacter.forEachSwift({}, processCodeUnit);
}
----Swift.(file).UTF16.width(_:<<error type>>)
return (UInt32.infix_60_61({}, x.value, 0xFFFF) ? 1 : 2)
----Swift.(file).UTF16.leadSurrogate(_:<<error type>>)
preconditionFileLine({}, () => Int.infix_61_61({}, this.width({}, x), 2), () => String()/*!default_value*/, '?3', '?3');
return UInt16.infix_43({}, 0xD800, _create(UTF16.CodeUnit, 'initTruncatingIfNeeded', {}, UInt32.infix_38_62_62({}, UInt32.infix_45({}, x.value, 0x10000), 10)))
----Swift.(file).UTF16.trailSurrogate(_:<<error type>>)
preconditionFileLine({}, () => Int.infix_61_61({}, this.width({}, x), 2), () => String()/*!default_value*/, '?3', '?3');
return UInt16.infix_43({}, 0xDC00, _create(UTF16.CodeUnit, 'initTruncatingIfNeeded', {}, UInt32.infix_38({}, UInt32.infix_45({}, x.value, 0x10000), UInt32.infix_45({}, UInt32.infix_38_60_60({}, 1, 10), 1))))
----Swift.(file).UTF16.isLeadSurrogate(_:Unicode.UTF16.CodeUnit)
return UInt16.infix_61_61({}, UInt16.infix_38({}, x, 0xFC00), 0xD800)
----Swift.(file).UTF16.isTrailSurrogate(_:Unicode.UTF16.CodeUnit)
return UInt16.infix_61_61({}, UInt16.infix_38({}, x, 0xFC00), 0xDC00)
----Swift.(file).UTF16.transcodedLength(of:Input,decodedAs:Encoding.Type,repairingIllFormedSequences:Bool)
let utf16Count = 0;
let i = input;
let d = _create(((function(){throw '!unclarifiedGeneric:Encoding.ForwardParser'})()), 'init', {}, );
{
if((infix_61_61({}, _injectIntoOptional(sourceEncoding), _injectIntoOptional(Unicode.UTF8)))) {
let peek = _create(((function(){throw '!unclarifiedGeneric:Input.Element'})()), 'initIntegerLiteral', {}, 0);
while(true){
const $ifLet0 = i.next({$setThis: $val => i = $val}, )
if(!($ifLet0.rawValue === 'some')) break
let u = $ifLet0[0]
peek = u;
{
if(!((_fastPath({}, (peek).constructor.infix_60({}, peek, 0x80))))) {
break;
}
};
utf16Count = Int.infix_43({}, utf16Count, 1);
};
{
if((_fastPath({}, (peek).constructor.infix_60({}, peek, 0x80)))) {
return _injectIntoOptional({0: utf16Count, 1: true});
}
};
let d1 = _create(UTF8.ForwardParser, 'init', {}, );
d1._buffer.append({$setThis: $val => d1._buffer = $val}, numericCast({}, peek));
d = _identityCastTo({}, d1, ((function(){throw '!unclarifiedGeneric:Encoding.ForwardParser'})()));
}
};
let utf16BitUnion = 0;
while(true){
if(!((true))) break
const s = d.parseScalarFrom({$setThis: $val => d = $val}, {get: () => i, set: $val => i = $val});
{const $ifLet0 = s._valid
if((_fastPath({}, Optional.wrappedNotEqualsOptionalNilComparisonType({}, s._valid, _create(_OptionalNilComparisonType, 'initNilLiteraltuple_type', {}, {})))) && $ifLet0.rawValue === 'some') {
let scalarContent = $ifLet0[0]
const utf16 = _cloneStruct(this.transcodeFrom({}, scalarContent, sourceEncoding)._unsafelyUnwrappedUnchecked);
Int.infix_43_61({}, {get: () => utf16Count, set: $val => utf16Count = $val}, utf16.count);
{
let $x$generator = _cloneStruct(utf16.makeIterator({}, ));
while(true) {
const $ifLet0 = $x$generator.next({$setThis: $val => $x$generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
let x = $ifLet0[0]
UInt16.infix_124_61({}, {get: () => utf16BitUnion, set: $val => utf16BitUnion = $val}, x);
}
};
}
else {
{const $ifLet0 = s._error
if($ifLet0.rawValue === 'some') {
{
if(!((_fastPath({}, repairingIllFormedSequences)))) {
return Optional.none;
}
};
Int.infix_43_61({}, {get: () => utf16Count, set: $val => utf16Count = $val}, 1);
UInt16.infix_124_61({}, {get: () => utf16BitUnion, set: $val => utf16BitUnion = $val}, UTF16._replacementCodeUnit);
}
else {
return _injectIntoOptional({0: utf16Count, 1: UInt16.infix_60({}, utf16BitUnion, 0x80)});
}
}
}
};
}
----Swift.(file)._UnicodeEncoding.transcode(_:<<error type>>,from:FromEncoding.Type)
return this.encode({}, ((function(){throw '!unclarifiedGeneric:FromEncoding'})()).decode({}, content))
----Swift.(file)._StringGuts.scalarAlign(_:<<error type>>)
{
if((_slowPath({}, Bool.infix_124_124({}, Int.infix_33_61({}, idx.transcodedOffset, 0), () => Int.infix_61_61({}, idx.encodedOffset, 0))))) {
return _create(String.Index, 'initEncodedOffsetInt', {}, idx.encodedOffset);
}
};
{
if((_slowPath({}, this.isForeign))) {
return this.foreignScalarAlign({}, idx);
}
};
return this.withFastUTF8({}, (($info, utf8) => { 
const i = _scalarAlign({}, utf8, idx.encodedOffset);
{
if((Int.infix_61_61({}, i, idx.encodedOffset))) {
return idx;
}
};
return _create(_StringGuts.Index, 'initEncodedOffsetInt', {}, i); }))
----Swift.(file)._StringGuts.fastUTF8ScalarLength(startingAt:Int)
const len = _utf8ScalarLength({}, this.withFastUTF8({}, (($info, $0) => $0.subscript$get({}, i))));
return len
----Swift.(file)._StringGuts.fastUTF8ScalarLength(endingAt:Int)
return this.withFastUTF8({}, (($info, utf8) => { 
let len = 1;
while(true){
if(!((_isContinuation({}, utf8.subscript$get({}, Int.infix_38_45({}, i, len)))))) break
Int.infix_43_61({}, {get: () => len, set: $val => len = $val}, 1);
};
return len; }))
----Swift.(file)._StringGuts.fastUTF8Scalar(startingAt:Int)
return this.withFastUTF8({}, (($info, $0) => _decodeScalarStartingAt({}, $0, i)["0"]))
----Swift.(file)._StringGuts.isOnUnicodeScalarBoundary(_:String.Index)
{
if(!((Int.infix_61_61({}, i.transcodedOffset, 0)))) {
return false;
}
};
{
if((Bool.infix_124_124({}, String.Index.infix_61_61({}, i, this.startIndex), () => String.Index.infix_61_61({}, i, this.endIndex)))) {
return true;
}
};
{
if((_fastPath({}, this.isFastUTF8))) {
return this.withFastUTF8({}, (($info, $0) => Bool.prefix_33({}, _isContinuation({}, $0.subscript$get({}, i.encodedOffset)))));
}
};
return String.Index.infix_61_61({}, i, this.foreignScalarAlign({}, i))
----Swift.(file)._StringGuts.foreignErrorCorrectedScalar(startingAt:String.Index)
const start = idx.encodedOffset;
const leading = this._getForeignCodeUnitAt({}, start);
{
if((_fastPath({}, Bool.prefix_33({}, _isSurrogate({}, leading))))) {
return {0: _create(Unicode.Scalar, 'init_uncheckedUInt32', {}, _create(UInt32, 'init', {}, leading)), 1: 1};
}
};
const nextOffset = Int.infix_38_43({}, start, 1);
{
if((_slowPath({}, Bool.infix_124_124({}, _isTrailingSurrogate({}, leading), () => Int.infix_61_61({}, nextOffset, this.count))))) {
return {0: Unicode.Scalar._replacementCharacter, 1: 1};
}
};
const trailing = this._getForeignCodeUnitAt({}, nextOffset);
{
if((_slowPath({}, Bool.prefix_33({}, _isTrailingSurrogate({}, trailing))))) {
return {0: Unicode.Scalar._replacementCharacter, 1: 1};
}
};
return {0: _create(Unicode.Scalar, 'init_uncheckedUInt32', {}, _decodeSurrogatePairLeadingTrailing({}, leading, trailing)), 1: 2}
----Swift.(file)._StringGuts.foreignErrorCorrectedScalar(endingAt:String.Index)
const end = idx.encodedOffset;
const trailing = this._getForeignCodeUnitAt({}, Int.infix_38_45({}, end, 1));
{
if((_fastPath({}, Bool.prefix_33({}, _isSurrogate({}, trailing))))) {
return {0: _create(Unicode.Scalar, 'init_uncheckedUInt32', {}, _create(UInt32, 'init', {}, trailing)), 1: 1};
}
};
const priorOffset = Int.infix_38_45({}, end, 2);
{
if((_slowPath({}, Bool.infix_124_124({}, _isLeadingSurrogate({}, trailing), () => Int.infix_60({}, priorOffset, 0))))) {
return {0: Unicode.Scalar._replacementCharacter, 1: 1};
}
};
const leading = this._getForeignCodeUnitAt({}, priorOffset);
{
if((_slowPath({}, Bool.prefix_33({}, _isLeadingSurrogate({}, leading))))) {
return {0: Unicode.Scalar._replacementCharacter, 1: 1};
}
};
return {0: _create(Unicode.Scalar, 'init_uncheckedUInt32', {}, _decodeSurrogatePairLeadingTrailing({}, leading, trailing)), 1: 2}
----Swift.(file)._StringGuts.foreignErrorCorrectedUTF16CodeUnit(at:String.Index)
const start = idx.encodedOffset;
const cu = this._getForeignCodeUnitAt({}, start);
{
if((_fastPath({}, Bool.prefix_33({}, _isSurrogate({}, cu))))) {
return cu;
}
};
{
if((_isLeadingSurrogate({}, cu))) {
const nextOffset = Int.infix_38_43({}, start, 1);
{
if(!((Int.infix_60({}, nextOffset, this.count)) && (_isTrailingSurrogate({}, this._getForeignCodeUnitAt({}, nextOffset))))) {
return UTF16._replacementCodeUnit;
}
};
}
else {
const priorOffset = Int.infix_38_45({}, start, 1);
{
if(!((Int.infix_62_61({}, priorOffset, 0)) && (_isLeadingSurrogate({}, this._getForeignCodeUnitAt({}, priorOffset))))) {
return UTF16._replacementCodeUnit;
}
};
}
};
return cu
----Swift.(file)._StringGuts.foreignErrorCorrectedGrapheme(startingAt:Int,endingAt:Int)
const count = Int.infix_38_45({}, end, start);
{
if((Int.infix_61_61({}, Int.infix_38_45({}, start, end), 1))) {
return _create(Character, 'initString', {}, _create(String, 'initUnicodeScalar', {}, this.foreignErrorCorrectedScalarStartingAt({}, _create(String.Index, 'initEncodedOffsetInt', {}, start))["0"]));
}
};
let cus = _create(Array, 'initRepeatingCountInt', {}, 0, count);
cus.withUnsafeMutableBufferPointer({$setThis: $val => cus = $val}, (($info, $0$inout) => _cocoaStringCopyCharactersFromRangeInto({}, this._object.cocoaObject, Int.infix_46_46_60({}, start, end), $0.baseAddress._unsafelyUnwrappedUnchecked)));
return cus.withUnsafeBufferPointer({}, (($info, $0) => _create(Character, 'initString', {}, String._uncheckedFromUTF16({}, $0))))
----Swift.(file)._StringGuts.errorCorrectedScalar(startingAt:Int)
{
if((_fastPath({}, this.isFastUTF8))) {
return this.withFastUTF8({}, (($info, $0) => _decodeScalarStartingAt({}, $0, i)));
}
};
return this.foreignErrorCorrectedScalarStartingAt({}, _create(String.Index, 'initEncodedOffsetInt', {}, i))
----Swift.(file)._StringGuts.errorCorrectedCharacter(startingAt:Int,endingAt:Int)
{
if((_fastPath({}, this.isFastUTF8))) {
return this.withFastUTF8Range({}, Int.infix_46_46_60({}, start, end), (($info, utf8) => _create(Character, 'initUncheckedString', {}, String._uncheckedFromUTF8({}, utf8))));
}
};
return this.foreignErrorCorrectedGraphemeStartingAtEndingAt({}, start, end)
----Swift.(file).Unicode.Scalar.init(_value:UInt32)
this._value = _value;
return
----Swift.(file)..(error_type).value
return this._value
----Swift.(file)..(error_type).init(unicodeScalarLiteral:<<error type>>)
$info.$setThis(_cloneStruct(_cloneStruct(value)));
return
----Swift.(file)..(error_type).init(_:UInt32)
{
if((Bool.infix_38_38({}, Bool.infix_124_124({}, UInt32.infix_60({}, v, 0xD800), () => UInt32.infix_62({}, v, 0xDFFF)), () => UInt32.infix_60_61({}, v, 0x10FFFF)))) {
this._value = v;
return ;
}
};
return (this.$failed = true)
----Swift.(file)..(error_type).init(_:UInt16)
this.initUInt32({}, _create(UInt32, 'init', {}, v));
return
----Swift.(file)..(error_type).init(_:UInt8)
this._value = _create(UInt32, 'init', {}, v);
return
----Swift.(file)..(error_type).init(_:<<error type>>)
$info.$setThis(_cloneStruct(_cloneStruct(v)));
return
----Swift.(file)..(error_type).escaped(asASCII:Bool)
function lowNibbleAsHex($info, v){
const nibble = UInt32.infix_38({}, v, 15);
{
if((UInt32.infix_60({}, nibble, 10))) {
return _create(String, 'initUnicodeScalar', {}, _create(Unicode.Scalar, 'initUInt32', {}, UInt32.infix_43({}, nibble, 48))[0]);
}
else {
return _create(String, 'initUnicodeScalar', {}, _create(Unicode.Scalar, 'initUInt32', {}, UInt32.infix_43({}, UInt32.infix_45({}, nibble, 10), 65))[0]);
}
};
}
{
if((Unicode.Scalar.infix_61_61({}, this, "\\"))) {
return "\\\\";
}
else {
{
if((Unicode.Scalar.infix_61_61({}, this, "'"))) {
return "\\'";
}
else {
{
if((Unicode.Scalar.infix_61_61({}, this, "\""))) {
return "\\\"";
}
else {
{
if((this._isPrintableASCII)) {
return _create(String, 'initUnicodeScalar', {}, this);
}
else {
{
if((Unicode.Scalar.infix_61_61({}, this, "\0"))) {
return "\\0";
}
else {
{
if((Unicode.Scalar.infix_61_61({}, this, "\n"))) {
return "\\n";
}
else {
{
if((Unicode.Scalar.infix_61_61({}, this, "\r"))) {
return "\\r";
}
else {
{
if((Unicode.Scalar.infix_61_61({}, this, "\t"))) {
return "\\t";
}
else {
{
if((UInt32.infix_60({}, _create(UInt32, 'initUnicodeScalar', {}, this), 128))) {
return String.infix_43({}, String.infix_43({}, String.infix_43({}, "\\u{", lowNibbleAsHex({}, UInt32.infix_62_62({}, _create(UInt32, 'initUnicodeScalar', {}, this), 4))), lowNibbleAsHex({}, _create(UInt32, 'initUnicodeScalar', {}, this))), "}");
}
else {
{
if((Bool.prefix_33({}, forceASCII))) {
return _create(String, 'initUnicodeScalar', {}, this);
}
else {
{
if((UInt32.infix_60_61({}, _create(UInt32, 'initUnicodeScalar', {}, this), 0xFFFF))) {
let result = "\\u{";
String.infix_43_61({}, {get: () => result, set: $val => result = $val}, lowNibbleAsHex({}, UInt32.infix_62_62({}, _create(UInt32, 'initUnicodeScalar', {}, this), 12)));
String.infix_43_61({}, {get: () => result, set: $val => result = $val}, lowNibbleAsHex({}, UInt32.infix_62_62({}, _create(UInt32, 'initUnicodeScalar', {}, this), 8)));
String.infix_43_61({}, {get: () => result, set: $val => result = $val}, lowNibbleAsHex({}, UInt32.infix_62_62({}, _create(UInt32, 'initUnicodeScalar', {}, this), 4)));
String.infix_43_61({}, {get: () => result, set: $val => result = $val}, lowNibbleAsHex({}, _create(UInt32, 'initUnicodeScalar', {}, this)));
String.infix_43_61({}, {get: () => result, set: $val => result = $val}, "}");
return result;
}
else {
let result = "\\u{";
String.infix_43_61({}, {get: () => result, set: $val => result = $val}, lowNibbleAsHex({}, UInt32.infix_62_62({}, _create(UInt32, 'initUnicodeScalar', {}, this), 28)));
String.infix_43_61({}, {get: () => result, set: $val => result = $val}, lowNibbleAsHex({}, UInt32.infix_62_62({}, _create(UInt32, 'initUnicodeScalar', {}, this), 24)));
String.infix_43_61({}, {get: () => result, set: $val => result = $val}, lowNibbleAsHex({}, UInt32.infix_62_62({}, _create(UInt32, 'initUnicodeScalar', {}, this), 20)));
String.infix_43_61({}, {get: () => result, set: $val => result = $val}, lowNibbleAsHex({}, UInt32.infix_62_62({}, _create(UInt32, 'initUnicodeScalar', {}, this), 16)));
String.infix_43_61({}, {get: () => result, set: $val => result = $val}, lowNibbleAsHex({}, UInt32.infix_62_62({}, _create(UInt32, 'initUnicodeScalar', {}, this), 12)));
String.infix_43_61({}, {get: () => result, set: $val => result = $val}, lowNibbleAsHex({}, UInt32.infix_62_62({}, _create(UInt32, 'initUnicodeScalar', {}, this), 8)));
String.infix_43_61({}, {get: () => result, set: $val => result = $val}, lowNibbleAsHex({}, UInt32.infix_62_62({}, _create(UInt32, 'initUnicodeScalar', {}, this), 4)));
String.infix_43_61({}, {get: () => result, set: $val => result = $val}, lowNibbleAsHex({}, _create(UInt32, 'initUnicodeScalar', {}, this)));
String.infix_43_61({}, {get: () => result, set: $val => result = $val}, "}");
return result;
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
}
----Swift.(file)..(error_type).isASCII
return UInt32.infix_60_61({}, this.value, 127)
----Swift.(file)..(error_type).description
return _create(String, 'initUnicodeScalar', {}, this)
----Swift.(file)..(error_type).debugDescription
return (("\"") + (this.escapedAsASCII({}, true)) + ("\""))
----Swift.(file)..(error_type).init(_:String)
const scalars = _cloneStruct(description.unicodeScalars);
{const $ifLet0 = scalars.first
if(!($ifLet0.rawValue === 'some' && (Int.infix_61_61({}, scalars.count, 1)))) {
return (this.$failed = true);
}let v = $ifLet0[0]
};
$info.$setThis(_cloneStruct(_cloneStruct(v)));
return
----Swift.(file)..(error_type).hash(into:Hasher)
let hasher = hasher$inout.get()
const $result = (() => {
hasher.combine({$setThis: $val => hasher = $val}, this.value);})()
hasher$inout.set(hasher)
return $result
----Swift.(file)..(error_type).init(_:Int)
{const $ifLet0 = _create(Unicode.Scalar, 'initUInt32', {}, _create(UInt32, 'init', {}, v))
if($ifLet0.rawValue === 'some') {
let us = $ifLet0[0]
$info.$setThis(_cloneStruct(_cloneStruct(us)));
}
else {
return (this.$failed = true);
}
};
return
----Swift.(file).UInt8.init(ascii:<<error type>>)
preconditionFileLine({}, () => UInt32.infix_60({}, v.value, 128), () => "Code point value does not fit into ASCII", '?3', '?3');
$info.$setThis(_cloneStruct(_create(UInt8, 'init', {}, v.value)));
return
----Swift.(file).UInt32.init(_:<<error type>>)
$info.$setThis(_cloneStruct(v.value));
return
----Swift.(file).UInt64.init(_:<<error type>>)
$info.$setThis(_cloneStruct(_create(UInt64, 'init', {}, v.value)));
return
----Swift.(file)..(error_type).==infix(_:<<error type>>,_:<<error type>>)
return UInt32.infix_61_61({}, lhs.value, rhs.value)
----Swift.(file)..(error_type).<infix(_:<<error type>>,_:<<error type>>)
return UInt32.infix_60({}, lhs.value, rhs.value)
----Swift.(file)..(error_type).utf16
return _create(Unicode.Scalar.UTF16View, 'initValueUnicodeScalar', {}, this)
----Swift.(file)..(error_type).startIndex
return 0
----Swift.(file)..(error_type).endIndex
return Int.infix_43({}, 0, UTF16.width({}, this.value))
----Swift.(file)..(error_type).subscript(_:Int)
return (Int.infix_61_61({}, position, 0) ? (Int.infix_61_61({}, this.endIndex, 1) ? _create(UTF16.CodeUnit, 'init', {}, this.value.value) : UTF16.leadSurrogate({}, this.value)) : UTF16.trailSurrogate({}, this.value))
----Swift.(file)..(error_type).withUTF16CodeUnits(_:(UnsafeBufferPointer<UInt16>) throws -> Result)
let codeUnits = {0: this.utf16.subscript$get({}, 0), 1: 0};
const utf16Count = this.utf16.count;
{
if((Int.infix_62({}, utf16Count, 1))) {
codeUnits["1"] = this.utf16.subscript$get({}, 1);
}
};
return /*dot_syntax_base_ignored*/withUnsafePointerTo({}, {get: () => codeUnits, set: $val => codeUnits = $val}, (($info, $0) => $0.withMemoryReboundToCapacity({}, UInt16, 2, (($info, $0) => body({}, _create(UnsafeBufferPointer, 'initStartOptionalCountInt', {}, _injectIntoOptional(/*pointer_to_pointer*/$0), utf16Count))))))
----Swift.(file)..(error_type).withUTF8CodeUnits(_:(UnsafeBufferPointer<UInt8>) throws -> Result)
const encodedScalar = _cloneStruct(UTF8.encode({}, this)[0]);
let $tuple = encodedScalar._bytes, codeUnits = $tuple && $tuple[0], utf8Count = $tuple && $tuple[1];
return /*dot_syntax_base_ignored*/withUnsafePointerTo({}, {get: () => codeUnits, set: $val => codeUnits = $val}, (($info, $0) => $0.withMemoryReboundToCapacity({}, UInt8, 4, (($info, $0) => body({}, _create(UnsafeBufferPointer, 'initStartOptionalCountInt', {}, _injectIntoOptional(/*pointer_to_pointer*/$0), utf8Count))))))
----Swift.(file).Unicode.Scalar.Properties.init(_:Unicode.Scalar)
this._scalar = _cloneStruct(scalar);
return
----Swift.(file).Unicode.Scalar.properties
return _create(Unicode.Scalar.Properties, 'initUnicodeScalar', {}, this)
----Swift.(file).Unicode.CanonicalCombiningClass.hashValue
return this.rawValue.hashValue
----Swift.(file).Unicode.CanonicalCombiningClass.hash(into:Hasher)
let hasher = hasher$inout.get()
const $result = (() => {
hasher.combine({$setThis: $val => hasher = $val}, this.rawValue);})()
hasher$inout.set(hasher)
return $result
----Swift.(file).Unmanaged.init(_private:Instance)
this._value = _private;
return
----Swift.(file).Unmanaged.fromOpaque(_:UnsafeRawPointer)
return _create(Unmanaged, 'init_private', {}, unsafeBitCastTo({}, value, ((function(){throw '!unclarifiedGeneric:Instance'})())))
----Swift.(file).Unmanaged.toOpaque()
return unsafeBitCastTo({}, this._value, UnsafeMutableRawPointer)
----Swift.(file).Unmanaged.passRetained(_:Instance)
return _create(Unmanaged, 'init_private', {}, value).retain({}, )
----Swift.(file).Unmanaged.passUnretained(_:Instance)
return _create(Unmanaged, 'init_private', {}, value)
----Swift.(file).Unmanaged.takeUnretainedValue()
return this._value
----Swift.(file).Unmanaged.takeRetainedValue()
const result = this._value;
this.release({}, );
return result
----Swift.(file).UnsafePointer.pointee
 return this.pointee$internal
----Swift.(file).UnsafePointer.subscript(_:Int)
return UnsafePointer.infix_43({}, this, i)
----Swift.(file).UnsafeMutablePointer.init(mutating:UnsafePointer<Pointee>?)
{const $ifLet0 = other
if(!($ifLet0.rawValue === 'some')) {
return (this.$failed = true);
}let unwrapped = $ifLet0[0]
};
this.initMutatingUnsafePointer({}, unwrapped);
return
----Swift.(file).UnsafeMutablePointer.pointee
 return this.pointee$internal
----Swift.(file).UnsafeMutablePointer.assign(repeating:Pointee,count:Int)
preconditionFileLine({}, () => Int.infix_62_61({}, count, 0), () => "UnsafeMutablePointer.assign(repeating:count:) with negative count", '?3', '?3');
{
let $i$generator = _cloneStruct(Int.infix_46_46_60({}, 0, count).makeIterator({}, ));
while(true) {
const $ifLet0 = $i$generator.next({$setThis: $val => $i$generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
let i = $ifLet0[0]
this.subscript$set({$setThis: $val => $info.$setThis(_cloneStruct(_cloneStruct($val)))}, repeatedValue, i);
}
}
----Swift.(file).UnsafeMutablePointer.subscript(_:Int)
return _create(UnsafePointer, 'initUnsafeMutablePointer', {}, UnsafeMutablePointer.infix_43({}, this, i));
}subscript$unsafeMutableAddress($info, i){
return UnsafeMutablePointer.infix_43({}, this, i)
----Swift.(file).UnsafeRawPointer.assumingMemoryBound(to:T.Type)
return _create(UnsafePointer, 'initRawPointer', {}, this._rawValue)
----Swift.(file).UnsafeMutableRawPointer.assumingMemoryBound(to:T.Type)
return _create(UnsafeMutablePointer, 'initRawPointer', {}, this._rawValue)
----Swift.(file).UnsafeMutableRawPointer.copyMemory(from:UnsafeRawPointer,byteCount:Int)
preconditionFileLine({}, () => Int.infix_62_61({}, byteCount, 0), () => "UnsafeMutableRawPointer.copyMemory with negative count", '?3', '?3');
_memmoveDestSrcSize({}, this, source, _create(UInt, 'init', {}, byteCount))
----Swift.(file).OpaquePointer.init(_:UnsafeMutableRawPointer)
this._rawValue = from._rawValue;
return
----Swift.(file).OpaquePointer.init(_:UnsafeMutableRawPointer?)
{const $ifLet0 = from
if(!($ifLet0.rawValue === 'some')) {
return (this.$failed = true);
}let unwrapped = $ifLet0[0]
};
this._rawValue = unwrapped._rawValue;
return
----Swift.(file).OpaquePointer.init(_:UnsafeRawPointer)
this._rawValue = from._rawValue;
return
----Swift.(file).OpaquePointer.init(_:UnsafeRawPointer?)
{const $ifLet0 = from
if(!($ifLet0.rawValue === 'some')) {
return (this.$failed = true);
}let unwrapped = $ifLet0[0]
};
this._rawValue = unwrapped._rawValue;
return
----Swift.(file)._ValidUTF8Buffer.Iterator.init(_:_ValidUTF8Buffer)
this._biasedBits = x._biasedBits;
return
----Swift.(file)._ValidUTF8Buffer.Iterator.next()
{
if((UInt32.infix_61_61({}, this._biasedBits, 0))) {
return Optional.none;
}
};
let $defer = () => {
UInt32.infix_62_62_61({}, {get: () => this._biasedBits, set: $val => this._biasedBits = $val}, 8);
}
try {;
return _injectIntoOptional(_ValidUTF8Buffer.Iterator.Element.infix_38_45({}, _create(_ValidUTF8Buffer.Iterator.Element, 'initTruncatingIfNeeded', {}, this._biasedBits), 1));}catch($error){$defer({}, );throw $error}$defer({}, )
----Swift.(file)._ValidUTF8Buffer.makeIterator()
return _create(_ValidUTF8Buffer.Iterator, 'init_ValidUTF8Buffer', {}, this)
----Swift.(file)._ValidUTF8Buffer.Index.init(_biasedBits:UInt32)
this._biasedBits = _biasedBits;
return
----Swift.(file)._ValidUTF8Buffer.startIndex
return _create(_ValidUTF8Buffer.Index, 'init_biasedBitsUInt32', {}, this._biasedBits)
----Swift.(file)._ValidUTF8Buffer.endIndex
return _create(_ValidUTF8Buffer.Index, 'init_biasedBitsUInt32', {}, 0)
----Swift.(file)._ValidUTF8Buffer.count
return Int.infix_38_45({}, Int.infix_38_62_62({}, UInt32.bitWidth, 3), Int.infix_38_62_62({}, this._biasedBits.leadingZeroBitCount, 3))
----Swift.(file)._ValidUTF8Buffer.isEmpty
return UInt32.infix_61_61({}, this._biasedBits, 0)
----Swift.(file)._ValidUTF8Buffer.index(after:_ValidUTF8Buffer.Index)
preconditionFileLine({}, () => UInt32.infix_33_61({}, i._biasedBits, 0), () => String()/*!default_value*/, '?3', '?3');
return _create(_ValidUTF8Buffer.Index, 'init_biasedBitsUInt32', {}, UInt32.infix_62_62({}, i._biasedBits, 8))
----Swift.(file)._ValidUTF8Buffer.subscript(_:_ValidUTF8Buffer.Index)
return _ValidUTF8Buffer.Element.infix_38_45({}, _create(_ValidUTF8Buffer.Element, 'initTruncatingIfNeeded', {}, i._biasedBits), 1)
----Swift.(file)._ValidUTF8Buffer.index(before:_ValidUTF8Buffer.Index)
const offset = _create(_ValidUTF8Buffer, 'init_biasedBitsUInt32', {}, i._biasedBits).count;
preconditionFileLine({}, () => Int.infix_33_61({}, offset, 0), () => String()/*!default_value*/, '?3', '?3');
return _create(_ValidUTF8Buffer.Index, 'init_biasedBitsUInt32', {}, UInt32.infix_38_62_62({}, this._biasedBits, Int.infix_45({}, Int.infix_38_60_60({}, offset, 3), 8)))
----Swift.(file)._ValidUTF8Buffer.distance(from:_ValidUTF8Buffer.Index,to:_ValidUTF8Buffer.Index)
preconditionFileLine({}, () => this._isValid({}, i), () => String()/*!default_value*/, '?3', '?3');
preconditionFileLine({}, () => this._isValid({}, j), () => String()/*!default_value*/, '?3', '?3');
return Int.infix_38_62_62({}, Int.infix_45({}, i._biasedBits.leadingZeroBitCount, j._biasedBits.leadingZeroBitCount), 3)
----Swift.(file)._ValidUTF8Buffer.index(_:_ValidUTF8Buffer.Index,offsetBy:Int)
const startOffset = this.distanceFromTo({}, this.startIndex, i);
const newOffset = Int.infix_43({}, startOffset, n);
preconditionFileLine({}, () => Int.infix_62_61({}, newOffset, 0), () => String()/*!default_value*/, '?3', '?3');
preconditionFileLine({}, () => Int.infix_60_61({}, newOffset, this.count), () => String()/*!default_value*/, '?3', '?3');
return _create(_ValidUTF8Buffer.Index, 'init_biasedBitsUInt32', {}, this._biasedBits._fullShiftRight({}, Int.infix_38_60_60({}, newOffset, 3)))
----Swift.(file)._ValidUTF8Buffer.init()
this._biasedBits = 0;
return
----Swift.(file)._ValidUTF8Buffer.capacity
return Int.infix_47({}, UInt32.bitWidth, _ValidUTF8Buffer.Element.bitWidth);
}
static get capacity() { return this.capacity$get()
----Swift.(file)._ValidUTF8Buffer.removeFirst()
preconditionFileLine({}, () => Bool.prefix_33({}, this.isEmpty), () => String()/*!default_value*/, '?3', '?3');
const result = _ValidUTF8Buffer.Element.infix_38_45({}, _create(_ValidUTF8Buffer.Element, 'initTruncatingIfNeeded', {}, this._biasedBits), 1);
this._biasedBits = this._biasedBits._fullShiftRight({}, 8);
return result
----Swift.(file)._ValidUTF8Buffer.replaceSubrange(_:Range<_ValidUTF8Buffer.Index>,with:C)
preconditionFileLine({}, () => this._isValid({}, target.lowerBound), () => String()/*!default_value*/, '?3', '?3');
preconditionFileLine({}, () => this._isValid({}, target.upperBound), () => String()/*!default_value*/, '?3', '?3');
let r = _create(_ValidUTF8Buffer, 'init', {}, );
{
let $x$generator = _cloneStruct(this.subscript$get({}, _ValidUTF8Buffer.Index.prefix_46_46_60({}, target.lowerBound)).makeIterator({}, ));
while(true) {
const $ifLet0 = $x$generator.next({$setThis: $val => $x$generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
let x = $ifLet0[0]
r.append({$setThis: $val => r = $val}, x);
}
};
{
let $x$generator = replacement.makeIterator({}, );
while(true) {
const $ifLet0 = $x$generator.next({$setThis: $val => $x$generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
let x = $ifLet0[0]
r.append({$setThis: $val => r = $val}, x);
}
};
{
let $x$generator = _cloneStruct(this.subscript$get({}, _ValidUTF8Buffer.Index.postfix_46_46_46({}, target.upperBound)).makeIterator({}, ));
while(true) {
const $ifLet0 = $x$generator.next({$setThis: $val => $x$generator = $val}, );
if(!($ifLet0.rawValue === 'some')) break
let x = $ifLet0[0]
r.append({$setThis: $val => r = $val}, x);
}
};
$info.$setThis(_cloneStruct(_cloneStruct(r)))
----Swift.(file)._ValidUTF8Buffer.append(contentsOf:_ValidUTF8Buffer)
preconditionFileLine({}, () => Int.infix_60_61({}, Int.infix_43({}, this.count, other.count), this.capacity), () => String()/*!default_value*/, '?3', '?3');
UInt32.infix_124_61({}, {get: () => this._biasedBits, set: $val => this._biasedBits = $val}, UInt32.infix_38_60_60({}, _create(UInt32, 'initTruncatingIfNeeded', {}, other._biasedBits), Int.infix_38_60_60({}, this.count, 3)))
----Swift.(file)._ValidUTF8Buffer.encodedReplacementCharacter
return _create(_ValidUTF8Buffer, 'init_biasedBitsUInt32', {}, UInt32.infix_38_43({}, 0xBDBFEF, 0x010101));
}
static get encodedReplacementCharacter() { return this.encodedReplacementCharacter$get()
