----Swift.(file).ASCII.encodedReplacementCharacter
return _create(Unicode.ASCII.EncodedScalar, 'init', {Element: Unicode.ASCII.CodeUnit}, 0x1a);
}
static get encodedReplacementCharacter() { return this.encodedReplacementCharacter$get()
----Swift.(file).ASCII.encode(_:Unicode.Scalar)
{
if(!((UInt32.infix_60({Self: UInt32, Self: UInt32, Other: Int}, source.value, Int.infix_38_60_60({Self: Int}, 1, 7))))) {
return null;
}
};
return _create(Unicode.ASCII.EncodedScalar, 'init', {Element: Unicode.ASCII.CodeUnit}, _create(UInt8, 'initTruncatingIfNeeded', {Self: UInt8, T: UInt32}, source.value))
----Swift.(file).ASCII.transcode(_:FromEncoding.EncodedScalar,from:FromEncoding.Type)
{
if((_fastPath({}, infix_61_61({}, $info.FromEncoding, UTF16)))) {
const c = _cloneStruct(_identityCastTo({T: $info.FromEncoding.EncodedScalar, U: UTF16.EncodedScalar}, content, UTF16.EncodedScalar));
{
if(!((UInt32.infix_61_61({Self: UInt32}, UInt32.infix_38({Self: UInt32}, c._storage, 0xFF80), 0)))) {
return null;
}
};
return _create(Unicode.ASCII.EncodedScalar, 'init', {Element: Unicode.ASCII.CodeUnit}, _create(Unicode.ASCII.CodeUnit, 'init', {Self: Unicode.ASCII.CodeUnit, T: UInt32}, UInt32.infix_38({Self: UInt32}, c._storage, 0x7f)));
}
else {
{
if((_fastPath({}, infix_61_61({}, $info.FromEncoding, UTF8)))) {
const c = _cloneStruct(_identityCastTo({T: $info.FromEncoding.EncodedScalar, U: UTF8.EncodedScalar}, content, UTF8.EncodedScalar));
const first = c.first.unsafelyUnwrapped;
{
if(!((UInt8.infix_60({Self: UInt8}, first, 0x80)))) {
return null;
}
};
return _create(Unicode.ASCII.EncodedScalar, 'init', {Element: Unicode.ASCII.CodeUnit}, _create(Unicode.ASCII.CodeUnit, 'init', {Self: Unicode.ASCII.CodeUnit, T: _ValidUTF8Buffer.Element}, first));
}
}
}
};
return this.encode({Self: Unicode.ASCII}, $info.FromEncoding.decode({Self: $info.FromEncoding, Self: $info.FromEncoding}, content))
----Swift.(file).Parser.parseScalar(from:I)
let input = input$inout.get()
const $result = (() => {
const n = input.next({$setThis: $val => input = $val, Self: $info.I}, );
{const x = n
if((_fastPath({}, Optional.infix_33_61({Self: Optional, Wrapped: Unicode.ASCII.Parser.Encoding.CodeUnit}, n, null))) && (x != null)) {
{
if(!((_fastPath({}, Int8.infix_62_61({Self: Int8}, _create(Int8, 'initTruncatingIfNeeded', {Self: Int8, T: Unicode.ASCII.Parser.Encoding.CodeUnit}, x), 0))))) {
return Unicode.ParseResult.error({T: Unicode.ASCII.Parser.Encoding.EncodedScalar}, 1);
}
};
return Unicode.ParseResult.valid({T: Unicode.ASCII.Parser.Encoding.EncodedScalar}, _create(Unicode.ASCII.EncodedScalar, 'init', {Element: Unicode.ASCII.CodeUnit}, x));
}
};
return Unicode.ParseResult.emptyInput;})()
input$inout.set(input)
return $result
----Swift.(file).min(_:T,_:T)
return ($info.T.infix_60({Self: $info.T, Self: $info.T}, y, x) ? y : x)
----Swift.(file).min(_:T,_:T,_:T,_:[T])
let minValue = ($info.T.infix_60({Self: $info.T, Self: $info.T}, y, x) ? y : x);
{
if(($info.T.infix_60({Self: $info.T, Self: $info.T}, z, minValue))) {
minValue = z;
}
};
{
if((Optional.infix_33_61({Self: Optional, Wrapped: _clarifyGenerics({Self:Array, Element: $info.T})}, rest, null))) {
{
let $value$generator = _cloneStruct(rest.makeIterator({Self: _clarifyGenerics({Self:Array, Element: $info.T})}, ));
while(true) {
const value = $value$generator.next({$setThis: $val => $value$generator = $val, Elements: _clarifyGenerics({Self:Array, Element: $info.T})}, );
if(!((value != null))) break;
if(!($info.T.infix_60({Self: $info.T, Self: $info.T}, value, minValue))) break;
minValue = value;
}
};
}
};
return minValue
----Swift.(file).max(_:T,_:T)
return ($info.T.infix_62_61({Self: $info.T, Self: $info.T}, y, x) ? y : x)
----Swift.(file).max(_:T,_:T,_:T,_:[T])
let maxValue = ($info.T.infix_62_61({Self: $info.T, Self: $info.T}, y, x) ? y : x);
{
if(($info.T.infix_62_61({Self: $info.T, Self: $info.T}, z, maxValue))) {
maxValue = z;
}
};
{
if((Optional.infix_33_61({Self: Optional, Wrapped: _clarifyGenerics({Self:Array, Element: $info.T})}, rest, null))) {
{
let $value$generator = _cloneStruct(rest.makeIterator({Self: _clarifyGenerics({Self:Array, Element: $info.T})}, ));
while(true) {
const value = $value$generator.next({$setThis: $val => $value$generator = $val, Elements: _clarifyGenerics({Self:Array, Element: $info.T})}, );
if(!((value != null))) break;
if(!($info.T.infix_62_61({Self: $info.T, Self: $info.T}, value, maxValue))) break;
maxValue = value;
}
};
}
};
return maxValue
----Swift.(file).AnyHashable.description
return _create(String, 'initDescribing', {Subject: '?protocol_composition_type'}, this.base)
----Swift.(file).AnyHashable.debugDescription
return String.infix_43({Self: String}, String.infix_43({Self: String}, "AnyHashable(", _create(String, 'initReflecting', {Subject: '?protocol_composition_type'}, this.base)), ")")
----Swift.(file).AnyHashable.customMirror
return _create(Mirror, 'initChildrenKeyValuePairsDisplayStyleOptionalAncestorRepresentationMirrorAncestorRepresentation', {Subject: AnyHashable}, this, new Map([["value", this.base]]), null, null)
----Swift.(file).Array.startIndex
return 0
----Swift.(file).Array.endIndex
return this.count
----Swift.(file).Array.index(after:Int)
return Int.infix_43({Self: Int}, i, 1)
----Swift.(file).Array.formIndex(after:Int)
let i = i$inout.get()
const $result = (() => {
Int.infix_43_61({Self: Int}, {get: () => i, set: $val => i = $val}, 1);})()
i$inout.set(i)
return $result
----Swift.(file).Array.index(before:Int)
return Int.infix_45({Self: Int}, i, 1)
----Swift.(file).Array.formIndex(before:Int)
let i = i$inout.get()
const $result = (() => {
Int.infix_45_61({Self: Int}, {get: () => i, set: $val => i = $val}, 1);})()
i$inout.set(i)
return $result
----Swift.(file).Array.index(_:Int,offsetBy:Int)
return Int.infix_43({Self: Int}, i, distance)
----Swift.(file).Array.index(_:Int,offsetBy:Int,limitedBy:Int)
const l = Int.infix_45({Self: Int}, limit, i);
{
if(((Int.infix_62({Self: Int}, distance, 0) ? Bool.infix_38_38({Self: Bool}, Int.infix_62_61({Self: Int}, l, 0), () => Int.infix_60({Self: Int}, l, distance)) : Bool.infix_38_38({Self: Bool}, Int.infix_60_61({Self: Int}, l, 0), () => Int.infix_60({Self: Int}, distance, l))))) {
return null;
}
};
return Int.infix_43({Self: Int}, i, distance)
----Swift.(file).Array.distance(from:Int,to:Int)
return Int.infix_45({Self: Int}, end, start)
----Swift.(file).Array.init(arrayLiteral:[Element])
$info.$setThis(_cloneStruct(_cloneStruct(_elements)));
return
----Swift.(file).Array.init(repeating:Element,count:Int)
let result = _create(Array, 'init', {Element: this.$info.Element}, );
{
let $generator = _cloneStruct(Int.infix_46_46_60({Self: Int, Self: Int}, 0, count).makeIterator({Self: _clarifyGenerics({Self:Range, Bound: Int})}, ));
while(true) {
if($generator.next({$setThis: $val => $generator = $val, Elements: _clarifyGenerics({Self:Range, Bound: Int})}, ) == null) break;
result.append({$setThis: $val => result = $val, Element: this.$info.Element}, repeatedValue);
}
};
return
----Swift.(file).Array.append(contentsOf:S)
{
let $el$generator = newElements.makeIterator({Self: $info.S}, );
while(true) {
const el = $el$generator.next({$setThis: $val => $el$generator = $val, Self: $info.S.Iterator}, );
if(!((el != null))) break;
this.append({$setThis: $val => $info.$setThis(_cloneStruct($val)), Element: $info.Element}, el);
}
}
----Swift.(file).Array.insert(_:Element,at:Int)
this.replaceSubrangeWith({$setThis: $val => $info.$setThis(_cloneStruct($val)), Element: this.$info.Element, C: _clarifyGenerics({Self:CollectionOfOne, Element: this.$info.Element})}, Int.infix_46_46_60({Self: Int, Self: Int}, i, i), _create(CollectionOfOne, 'init', {Element: this.$info.Element}, newElement))
----Swift.(file).Array.removeAll(keepingCapacity:Bool)
this.replaceSubrangeWith({$setThis: $val => $info.$setThis(_cloneStruct($val)), Element: this.$info.Element, C: _clarifyGenerics({Self:EmptyCollection, Element: this.$info.Element})}, this.indices, _create(EmptyCollection, 'init', {Element: this.$info.Element}, ))
----Swift.(file).Array.withContiguousMutableStorageIfAvailable(_:(inout UnsafeMutableBufferPointer<Element>) throws -> R)
return this.withUnsafeMutableBufferPointer({$setThis: $val => $info.$setThis(_cloneStruct($val)), Element: $info.Element, R: $info.R}, (($info, bufferPointer$inout) => body({}, {get: () => bufferPointer, set: $val => bufferPointer = $val})))
----Swift.(file).Array.withContiguousStorageIfAvailable(_:(UnsafeBufferPointer<Element>) throws -> R)
return this.withUnsafeBufferPointer({Element: $info.Element, R: $info.R}, (($info, bufferPointer) => body({}, bufferPointer)))
----Swift.(file).Array.+infix(_:Array<Element>,_:Array<Element>)
let lhs_dupl = _cloneStruct(lhs);
lhs_dupl.appendContentsOf({$setThis: $val => lhs_dupl = $val, Element: $info.Element, S: _clarifyGenerics({Self:Array, Element: $info.Element})}, rhs);
return lhs_dupl
----Swift.(file).Array.+=infix(_:Array<Element>,_:Array<Element>)
let lhs = lhs$inout.get()
const $result = (() => {
lhs.appendContentsOf({$setThis: $val => lhs = $val, Element: $info.Element, S: _clarifyGenerics({Self:Array, Element: $info.Element})}, rhs);})()
lhs$inout.set(lhs)
return $result
----Swift.(file).Array.customMirror
return _create(Mirror, 'initUnlabeledChildrenDisplayStyleOptionalAncestorRepresentationMirrorAncestorRepresentation', {Subject: _clarifyGenerics({Self:Array, Element: this.$info.Element}), C: _clarifyGenerics({Self:Array, Element: this.$info.Element})}, this, this, Mirror.DisplayStyle.collection, null)
----Swift.(file).Array.==infix(_:Array<Element>,_:Array<Element>)
const lhsCount = lhs.count;
{
if((Int.infix_33_61({Self: Int, Self: Int}, lhsCount, rhs.count))) {
return false;
}
};
{
if((Int.infix_61_61({Self: Int}, lhsCount, 0))) {
return true;
}
};
{
let $idx$generator = _cloneStruct(Int.infix_46_46_60({Self: Int, Self: Int}, 0, lhsCount).makeIterator({Self: _clarifyGenerics({Self:Range, Bound: Int})}, ));
while(true) {
const idx = $idx$generator.next({$setThis: $val => $idx$generator = $val, Elements: _clarifyGenerics({Self:Range, Bound: Int})}, );
if(!((idx != null))) break;
{
if(($info.Element.infix_33_61({Self: $info.Element, Self: $info.Element}, lhs.subscript$get({}, idx), rhs.subscript$get({}, idx)))) {
return false;
}
};
}
};
return true
----Swift.(file).Array.hash(into:Hasher)
let hasher = hasher$inout.get()
const $result = (() => {
hasher.combine({$setThis: $val => hasher = $val, H: Int}, this.count);
{
let $element$generator = _cloneStruct(this.makeIterator({Self: _clarifyGenerics({Self:Array, Element: this.$info.Element})}, ));
while(true) {
const _element = $element$generator.next({$setThis: $val => $element$generator = $val, Elements: _clarifyGenerics({Self:Array, Element: this.$info.Element})}, );
if(!((_element != null))) break;
hasher.combine({$setThis: $val => hasher = $val, H: this.$info.Element}, _element);
}
};})()
hasher$inout.set(hasher)
return $result
----Swift.(file).Array.withUnsafeMutableBytes(_:(UnsafeMutableRawBufferPointer) throws -> R)
return this.withUnsafeMutableBufferPointer({$setThis: $val => $info.$setThis(_cloneStruct($val)), Element: $info.Element, R: $info.R}, (($info, $0$inout) => body({}, _create(UnsafeMutableRawBufferPointer, 'initUnsafeMutableBufferPointer', {T: $info.Element}, $0))))
----Swift.(file).Array.withUnsafeBytes(_:(UnsafeRawBufferPointer) throws -> R)
return this.withUnsafeBufferPointer({Element: $info.Element, R: $info.R}, (($info, $0) => body({}, _create(UnsafeRawBufferPointer, 'initUnsafeBufferPointer', {T: $info.Element}, $0))))
----Swift.(file).ArraySlice.index(after:Int)
return Int.infix_43({Self: Int}, i, 1)
----Swift.(file).ArraySlice.formIndex(after:Int)
let i = i$inout.get()
const $result = (() => {
Int.infix_43_61({Self: Int}, {get: () => i, set: $val => i = $val}, 1);})()
i$inout.set(i)
return $result
----Swift.(file).ArraySlice.index(before:Int)
return Int.infix_45({Self: Int}, i, 1)
----Swift.(file).ArraySlice.formIndex(before:Int)
let i = i$inout.get()
const $result = (() => {
Int.infix_45_61({Self: Int}, {get: () => i, set: $val => i = $val}, 1);})()
i$inout.set(i)
return $result
----Swift.(file).ArraySlice.index(_:Int,offsetBy:Int)
return Int.infix_43({Self: Int}, i, distance)
----Swift.(file).ArraySlice.index(_:Int,offsetBy:Int,limitedBy:Int)
const l = Int.infix_45({Self: Int}, limit, i);
{
if(((Int.infix_62({Self: Int}, distance, 0) ? Bool.infix_38_38({Self: Bool}, Int.infix_62_61({Self: Int}, l, 0), () => Int.infix_60({Self: Int}, l, distance)) : Bool.infix_38_38({Self: Bool}, Int.infix_60_61({Self: Int}, l, 0), () => Int.infix_60({Self: Int}, distance, l))))) {
return null;
}
};
return Int.infix_43({Self: Int}, i, distance)
----Swift.(file).ArraySlice.distance(from:Int,to:Int)
return Int.infix_45({Self: Int}, end, start)
----Swift.(file).ArraySlice.remove(at:Int)
const result = this.subscript$get({}, index);
this.replaceSubrangeWith({$setThis: $val => $info.$setThis(_cloneStruct($val)), Element: this.$info.Element, C: _clarifyGenerics({Self:EmptyCollection, Element: this.$info.Element})}, Int.infix_46_46_60({Self: Int, Self: Int}, index, Int.infix_43({Self: Int}, index, 1)), _create(EmptyCollection, 'init', {Element: this.$info.Element}, ));
return result
----Swift.(file).ArraySlice.withContiguousMutableStorageIfAvailable(_:(inout UnsafeMutableBufferPointer<Element>) throws -> R)
return this.withUnsafeMutableBufferPointer({$setThis: $val => $info.$setThis(_cloneStruct($val)), Element: $info.Element, R: $info.R}, (($info, bufferPointer$inout) => body({}, {get: () => bufferPointer, set: $val => bufferPointer = $val})))
----Swift.(file).ArraySlice.withContiguousStorageIfAvailable(_:(UnsafeBufferPointer<Element>) throws -> R)
return this.withUnsafeBufferPointer({Element: $info.Element, R: $info.R}, (($info, bufferPointer) => body({}, bufferPointer)))
----Swift.(file).ArraySlice.customMirror
return _create(Mirror, 'initUnlabeledChildrenDisplayStyleOptionalAncestorRepresentationMirrorAncestorRepresentation', {Subject: _clarifyGenerics({Self:ArraySlice, Element: this.$info.Element}), C: _clarifyGenerics({Self:ArraySlice, Element: this.$info.Element})}, this, this, Mirror.DisplayStyle.collection, null)
----Swift.(file).ArraySlice.hash(into:Hasher)
let hasher = hasher$inout.get()
const $result = (() => {
hasher.combine({$setThis: $val => hasher = $val, H: Int}, this.count);
{
let $element$generator = _cloneStruct(this.makeIterator({Self: _clarifyGenerics({Self:ArraySlice, Element: this.$info.Element})}, ));
while(true) {
const _element = $element$generator.next({$setThis: $val => $element$generator = $val, Elements: _clarifyGenerics({Self:ArraySlice, Element: this.$info.Element})}, );
if(!((_element != null))) break;
hasher.combine({$setThis: $val => hasher = $val, H: this.$info.Element}, _element);
}
};})()
hasher$inout.set(hasher)
return $result
----Swift.(file).ArraySlice.withUnsafeMutableBytes(_:(UnsafeMutableRawBufferPointer) throws -> R)
return this.withUnsafeMutableBufferPointer({$setThis: $val => $info.$setThis(_cloneStruct($val)), Element: $info.Element, R: $info.R}, (($info, $0$inout) => body({}, _create(UnsafeMutableRawBufferPointer, 'initUnsafeMutableBufferPointer', {T: $info.Element}, $0))))
----Swift.(file).ArraySlice.withUnsafeBytes(_:(UnsafeRawBufferPointer) throws -> R)
return this.withUnsafeBufferPointer({Element: $info.Element, R: $info.R}, (($info, $0) => body({}, _create(UnsafeRawBufferPointer, 'initUnsafeBufferPointer', {T: $info.Element}, $0))))
----Swift.(file)._ArrayProtocol.filter(_:(Self.Element) throws -> Bool)
let result = _create(Array, 'init', {Element: this.$info.Element}, );
let iterator = _cloneStruct(this.makeIterator({Self: _clarifyGenerics({Self:Array, Element: this.$info.Element})}, ));
while(true){
const _element = iterator.next({$setThis: $val => iterator = $val, Elements: _clarifyGenerics({Self:Array, Element: this.$info.Element})}, )
if(!((_element != null))) break
{
if((isIncluded({}, _element))) {
result.append({$setThis: $val => result = $val, Element: this.$info.Element}, _element);
}
};
};
return _create(Array, 'initBuffer', {Element: this.$info.Element, S: _clarifyGenerics({Self:Array, Element: this.$info.Element})}, result)
----Swift.(file).BidirectionalCollection.formIndex(before:Self.Index)
let i = i$inout.get()
const $result = (() => {
i = this.indexBefore({Self: this.$info.Self}, i);})()
i$inout.set(i)
return $result
----Swift.(file).BidirectionalCollection.popLast()
{
if(!((Bool.prefix_33({Self: Bool}, this.isEmpty)))) {
return null;
}
};
const _element = this.last;
$info.$setThis(_cloneStruct(this.subscriptRange$get({}, this.$info.Self.Index.infix_46_46_60({Self: this.$info.Self.Index, Self: this.$info.Self.Index}, this.startIndex, this.indexBefore({Self: this.$info.Self}, this.endIndex)))));
return _element
----Swift.(file).BidirectionalCollection.removeLast()
const _element = this.last;
$info.$setThis(_cloneStruct(this.subscriptRange$get({}, this.$info.Self.Index.infix_46_46_60({Self: this.$info.Self.Index, Self: this.$info.Self.Index}, this.startIndex, this.indexBefore({Self: this.$info.Self}, this.endIndex)))));
return _element
----Swift.(file).BidirectionalCollection.removeLast(_:Int)
{
if((Int.infix_61_61({Self: Int}, k, 0))) {
return ;
}
};
preconditionFileLine({}, () => Int.infix_62_61({Self: Int}, k, 0), () => "Number of elements to remove should be non-negative", '?3', '?3');
preconditionFileLine({}, () => Int.infix_62_61({Self: Int}, this.count, k), () => "Can't remove more items from a collection than it contains", '?3', '?3');
$info.$setThis(_cloneStruct(this.subscriptRange$get({}, this.$info.Self.Index.infix_46_46_60({Self: this.$info.Self.Index, Self: this.$info.Self.Index}, this.startIndex, this.indexOffsetBy({Self: this.$info.Self}, this.endIndex, Int.prefix_45({Self: Int, Self: Int}, k))))))
----Swift.(file).BidirectionalCollection.dropLast(_:Int)
preconditionFileLine({}, () => Int.infix_62_61({Self: Int}, k, 0), () => "Can't drop a negative number of elements from a collection", '?3', '?3');
const end = infix_63_63({T: this.$info.Self.Index}, this.indexOffsetByLimitedBy({Self: this.$info.Self}, this.endIndex, Int.prefix_45({Self: Int, Self: Int}, k), this.startIndex), () => this.startIndex);
return this.subscriptRange$get({}, this.$info.Self.Index.infix_46_46_60({Self: this.$info.Self.Index, Self: this.$info.Self.Index}, this.startIndex, end))
----Swift.(file).BidirectionalCollection.suffix(_:Int)
preconditionFileLine({}, () => Int.infix_62_61({Self: Int}, maxLength, 0), () => "Can't take a suffix of negative length from a collection", '?3', '?3');
const start = infix_63_63({T: this.$info.Self.Index}, this.indexOffsetByLimitedBy({Self: this.$info.Self}, this.endIndex, Int.prefix_45({Self: Int, Self: Int}, maxLength), this.startIndex), () => this.startIndex);
return this.subscriptRange$get({}, this.$info.Self.Index.infix_46_46_60({Self: this.$info.Self.Index, Self: this.$info.Self.Index}, start, this.endIndex))
----Swift.(file).Bool.init(_:Bool)
$info.$setThis(_cloneStruct(value));
return
----Swift.(file).Bool.random(using:T)
let generator = generator$inout.get()
const $result = (() => {
return UInt64.infix_61_61({Self: UInt64}, UInt64.infix_38({Self: UInt64}, UInt64.infix_62_62({Self: UInt64, Self: UInt64, Other: Int}, generator.next({$setThis: $val => generator = $val, Self: $info.T}, ), 17), 1), 0);})()
generator$inout.set(generator)
return $result
----Swift.(file).Bool.random()
let g = _create(SystemRandomNumberGenerator, 'init', {}, );
return Bool.randomUsing({Self: Bool, T: SystemRandomNumberGenerator}, {get: () => g, set: $val => g = $val})
----Swift.(file).Bool.init(booleanLiteral:Bool)
$info.$setThis(_cloneStruct(value));
return
----Swift.(file).Bool.description
return (this ? "true" : "false")
----Swift.(file).Bool.hash(into:Hasher)
let hasher = hasher$inout.get()
const $result = (() => {
hasher.combine({$setThis: $val => hasher = $val, H: UInt8}, (this ? 1 : 0));})()
hasher$inout.set(hasher)
return $result
----Swift.(file).Bool.&&infix(_:Bool,_:() throws -> Bool)
return (lhs ? rhs({}, ) : false)
----Swift.(file).Bool.||infix(_:Bool,_:() throws -> Bool)
return (lhs ? true : rhs({}, ))
----Swift.(file).Bool.toggle()
$info.$setThis(_cloneStruct(Bool.prefix_33({Self: Bool}, this)))
----Swift.(file).AutoreleasingUnsafeMutablePointer.subscript(_:Int)
/*yield*/
----Swift.(file).UnsafeMutableRawPointer.init(_:AutoreleasingUnsafeMutablePointer<T>?)
{const unwrapped = other
if(!((unwrapped != null))) {
return (this.$failed = true);
}
};
this.initAutoreleasingUnsafeMutablePointer({}, unwrapped);
return
----Swift.(file).UnsafeRawPointer.init(_:AutoreleasingUnsafeMutablePointer<T>?)
{const unwrapped = other
if(!((unwrapped != null))) {
return (this.$failed = true);
}
};
this.init({}, /*pointer_to_pointer*/unwrapped);
return
----Swift.(file).!=infix(_:Any.Type?,_:Any.Type?)
return Bool.prefix_33({Self: Bool}, infix_61_61({}, t0, t1))
----Swift.(file).OpaquePointer.init(_:UnsafePointer<T>?)
{const unwrapped = from
if(!((unwrapped != null))) {
return (this.$failed = true);
}
};
this.initUnsafeRawPointer({}, /*pointer_to_pointer*/unwrapped);
return
----Swift.(file).OpaquePointer.init(_:UnsafeMutablePointer<T>?)
{const unwrapped = from
if(!((unwrapped != null))) {
return (this.$failed = true);
}
};
this.initUnsafeMutablePointer({}, unwrapped);
return
----Swift.(file).Int.init(bitPattern:OpaquePointer?)
this.initBitPatternOptional({}, _create(UnsafeRawPointer, 'initOptional', {Self: UnsafeRawPointer}, pointer));
return
----Swift.(file).UInt.init(bitPattern:OpaquePointer?)
this.initBitPatternOptional({}, _create(UnsafeRawPointer, 'initOptional', {Self: UnsafeRawPointer}, pointer));
return
----Swift.(file).Character.isASCII
return Optional.infix_33_61({Self: Optional, Wrapped: UInt8}, this.asciiValue, null)
----Swift.(file).Character.isWholeNumber
return Optional.infix_33_61({Self: Optional, Wrapped: Int}, this.wholeNumberValue, null)
----Swift.(file).Character.isHexDigit
return Optional.infix_33_61({Self: Optional, Wrapped: Int}, this.hexDigitValue, null)
----Swift.(file).Character.uppercased()
return _create(String, 'initCharacter', {}, this).uppercased({}, )
----Swift.(file).Character.lowercased()
return _create(String, 'initCharacter', {}, this).lowercased({}, )
----Swift.(file).ClosedRange.init(uncheckedBounds:(lower: Bound, upper: Bound))
this.lowerBound = bounds["0"];
this.upperBound = bounds["1"];
return
----Swift.(file).ClosedRange.isEmpty
return false
----Swift.(file).ClosedRange.relative(to:C)
return _create(Range, 'initUncheckedBoundstuple_type', {Bound: $info.Bound}, {0: this.lowerBound, 1: collection.indexAfter({Self: $info.C}, this.upperBound)})
----Swift.(file).ClosedRange.contains(_:Bound)
return Bool.infix_38_38({Self: Bool}, this.$info.Bound.infix_62_61({Self: this.$info.Bound, Self: this.$info.Bound}, _element, this.lowerBound), () => this.$info.Bound.infix_60_61({Self: this.$info.Bound, Self: this.$info.Bound}, _element, this.upperBound))
----Swift.(file).Index.==infix(_:ClosedRange<Bound>.Index,_:ClosedRange<Bound>.Index)
const $match = {0: lhs, 1: rhs}
if((($match[0].rawValue == ClosedRange.Index.inRange().rawValue && $match[1].rawValue == ClosedRange.Index.inRange().rawValue))) {
const l = $match[0][0]
const r = $match[1][0]
return $info.Bound.infix_61_61({Self: $info.Bound, Self: $info.Bound}, l, r);
}
else if((($match[0].rawValue == ClosedRange.Index.pastEnd.rawValue && $match[1].rawValue == ClosedRange.Index.pastEnd.rawValue))) {
return true;
}
else if(((true))) {
return false;
}
----Swift.(file).Index.<infix(_:ClosedRange<Bound>.Index,_:ClosedRange<Bound>.Index)
const $match = {0: lhs, 1: rhs}
if((($match[0].rawValue == ClosedRange.Index.inRange().rawValue && $match[1].rawValue == ClosedRange.Index.inRange().rawValue))) {
const l = $match[0][0]
const r = $match[1][0]
return $info.Bound.infix_60({Self: $info.Bound, Self: $info.Bound}, l, r);
}
else if((($match[0].rawValue == ClosedRange.Index.inRange().rawValue && $match[1].rawValue == ClosedRange.Index.pastEnd.rawValue))) {
return true;
}
else if(((true))) {
return false;
}
----Swift.(file).Index.hash(into:Hasher)
let hasher = hasher$inout.get()
const $result = (() => {
const $match = this
if((($match.rawValue == ClosedRange.Index.inRange().rawValue))) {
const value = $match[0]
hasher.combine({$setThis: $val => hasher = $val, H: Int8}, 0);
hasher.combine({$setThis: $val => hasher = $val, H: this.$info.Bound}, value);
}
else if((($match.rawValue == ClosedRange.Index.pastEnd.rawValue))) {
hasher.combine({$setThis: $val => hasher = $val, H: Int8}, 1);
};})()
hasher$inout.set(hasher)
return $result
----Swift.(file).ClosedRange.startIndex
return ClosedRange.Index.inRange({Bound: this.$info.Bound}, this.lowerBound)
----Swift.(file).ClosedRange.endIndex
return ClosedRange.Index.pastEnd
----Swift.(file).ClosedRange.index(after:ClosedRange<Bound>.Index)
const $match = i
if((($match.rawValue == ClosedRange.Index.inRange().rawValue))) {
const x = $match[0]
return (this.$info.Bound.infix_61_61({Self: this.$info.Bound, Self: this.$info.Bound}, x, this.upperBound) ? ClosedRange.Index.pastEnd : ClosedRange.Index.inRange({Bound: this.$info.Bound}, x.advancedBy({Self: this.$info.Bound}, _create(this.$info.Bound.Stride, 'initIntegerLiteral', {Self: this.$info.Bound.Stride}, 1))));
}
else if((($match.rawValue == ClosedRange.Index.pastEnd.rawValue))) {
preconditionFailureFileLine({}, () => "Incrementing past end index", '?3', '?3');
}
----Swift.(file).ClosedRange.index(before:ClosedRange<Bound>.Index)
const $match = i
if((($match.rawValue == ClosedRange.Index.inRange().rawValue))) {
const x = $match[0]
preconditionFileLine({}, () => this.$info.Bound.infix_62({Self: this.$info.Bound, Self: this.$info.Bound}, x, this.lowerBound), () => "Incrementing past start index", '?3', '?3');
return ClosedRange.Index.inRange({Bound: this.$info.Bound}, x.advancedBy({Self: this.$info.Bound}, _create(this.$info.Bound.Stride, 'initIntegerLiteral', {Self: this.$info.Bound.Stride}, -1)));
}
else if((($match.rawValue == ClosedRange.Index.pastEnd.rawValue))) {
preconditionFileLine({}, () => this.$info.Bound.infix_62_61({Self: this.$info.Bound, Self: this.$info.Bound}, this.upperBound, this.lowerBound), () => "Incrementing past start index", '?3', '?3');
return ClosedRange.Index.inRange({Bound: this.$info.Bound}, this.upperBound);
}
----Swift.(file).ClosedRange.index(_:ClosedRange<Bound>.Index,offsetBy:Int)
const $match = i
if((($match.rawValue == ClosedRange.Index.inRange().rawValue))) {
const x = $match[0]
const d = x.distanceTo({Self: this.$info.Bound}, this.upperBound);
{
if((Int.infix_60_61({Self: Int, Self: Int, Other: this.$info.Bound.Stride}, distance, d))) {
const newPosition = x.advancedBy({Self: this.$info.Bound}, numericCast({T: Int, U: this.$info.Bound.Stride}, distance));
preconditionFileLine({}, () => this.$info.Bound.infix_62_61({Self: this.$info.Bound, Self: this.$info.Bound}, newPosition, this.lowerBound), () => "Advancing past start index", '?3', '?3');
return ClosedRange.Index.inRange({Bound: this.$info.Bound}, newPosition);
}
};
{
if((this.$info.Bound.Stride.infix_61_61({Self: this.$info.Bound.Stride, Self: this.$info.Bound.Stride, Other: Int}, this.$info.Bound.Stride.infix_45({Self: this.$info.Bound.Stride, Self: this.$info.Bound.Stride}, d, _create(this.$info.Bound.Stride, 'initIntegerLiteral', {Self: this.$info.Bound.Stride}, -1)), distance))) {
return ClosedRange.Index.pastEnd;
}
};
preconditionFailureFileLine({}, () => "Advancing past end index", '?3', '?3');
}
else if((($match.rawValue == ClosedRange.Index.pastEnd.rawValue))) {
{
if((Int.infix_61_61({Self: Int}, distance, 0))) {
return i;
}
};
{
if((Int.infix_60({Self: Int}, distance, 0))) {
return this.indexOffsetBy({Bound: this.$info.Bound}, ClosedRange.Index.inRange({Bound: this.$info.Bound}, this.upperBound), numericCast({T: Int, U: Int}, Int.infix_43({Self: Int}, distance, 1)));
}
};
preconditionFailureFileLine({}, () => "Advancing past end index", '?3', '?3');
}
----Swift.(file).ClosedRange.distance(from:ClosedRange<Bound>.Index,to:ClosedRange<Bound>.Index)
const $match = {0: start, 1: end}
if((($match[0].rawValue == ClosedRange.Index.inRange().rawValue && $match[1].rawValue == ClosedRange.Index.inRange().rawValue))) {
const left = $match[0][0]
const right = $match[1][0]
return numericCast({T: this.$info.Bound.Stride, U: Int}, left.distanceTo({Self: this.$info.Bound}, right));
}
else if((($match[0].rawValue == ClosedRange.Index.inRange().rawValue && $match[1].rawValue == ClosedRange.Index.pastEnd.rawValue))) {
const left = $match[0][0]
return numericCast({T: this.$info.Bound.Stride, U: Int}, this.$info.Bound.Stride.infix_43({Self: this.$info.Bound.Stride, Self: this.$info.Bound.Stride}, _create(this.$info.Bound.Stride, 'initIntegerLiteral', {Self: this.$info.Bound.Stride}, 1), left.distanceTo({Self: this.$info.Bound}, this.upperBound)));
}
else if((($match[0].rawValue == ClosedRange.Index.pastEnd.rawValue && $match[1].rawValue == ClosedRange.Index.inRange().rawValue))) {
const right = $match[1][0]
return numericCast({T: this.$info.Bound.Stride, U: Int}, this.$info.Bound.Stride.infix_45({Self: this.$info.Bound.Stride, Self: this.$info.Bound.Stride}, this.upperBound.distanceTo({Self: this.$info.Bound}, right), _create(this.$info.Bound.Stride, 'initIntegerLiteral', {Self: this.$info.Bound.Stride}, 1)));
}
else if((($match[0].rawValue == ClosedRange.Index.pastEnd.rawValue && $match[1].rawValue == ClosedRange.Index.pastEnd.rawValue))) {
return 0;
}
----Swift.(file).ClosedRange.subscript(_:ClosedRange<Bound>.Index)
const $match = position
if((($match.rawValue == ClosedRange.Index.inRange().rawValue))) {
const x = $match[0]
return x;
}
else if((($match.rawValue == ClosedRange.Index.pastEnd.rawValue))) {
preconditionFailureFileLine({}, () => "Index out of range", '?3', '?3');
}
----Swift.(file).ClosedRange.subscript(_:Range<ClosedRange<Bound>.Index>)
return _create(Slice, 'initBaseBoundsRange', {Base: _clarifyGenerics({Self:ClosedRange, Bound: this.$info.Bound})}, this, bounds)
----Swift.(file).Comparable....infix(_:Self,_:Self)
preconditionFileLine({}, () => $info.Self.infix_60_61({Self: $info.Self, Self: $info.Self}, minimum, maximum), () => "Can't form Range with upperBound < lowerBound", '?3', '?3');
return _create(ClosedRange, 'initUncheckedBoundstuple_type', {Bound: $info.Self}, {0: minimum, 1: maximum})
----Swift.(file).ClosedRange.==infix(_:ClosedRange<Bound>,_:ClosedRange<Bound>)
return Bool.infix_38_38({Self: Bool}, $info.Bound.infix_61_61({Self: $info.Bound, Self: $info.Bound}, lhs.lowerBound, rhs.lowerBound), () => $info.Bound.infix_61_61({Self: $info.Bound, Self: $info.Bound}, lhs.upperBound, rhs.upperBound))
----Swift.(file).ClosedRange.hash(into:Hasher)
let hasher = hasher$inout.get()
const $result = (() => {
hasher.combine({$setThis: $val => hasher = $val, H: this.$info.Bound}, this.lowerBound);
hasher.combine({$setThis: $val => hasher = $val, H: this.$info.Bound}, this.upperBound);})()
hasher$inout.set(hasher)
return $result
----Swift.(file).ClosedRange.description
return (("") + (this.lowerBound) + ("...") + (this.upperBound) + (""))
----Swift.(file).ClosedRange.debugDescription
return String.infix_43({Self: String}, (("ClosedRange(") + (_create(String, 'initReflecting', {Subject: this.$info.Bound}, this.lowerBound)) + ("")), (("...") + (_create(String, 'initReflecting', {Subject: this.$info.Bound}, this.upperBound)) + (")")))
----Swift.(file).ClosedRange.customMirror
return _create(Mirror, 'initChildrenKeyValuePairsDisplayStyleOptionalAncestorRepresentationMirrorAncestorRepresentation', {Subject: _clarifyGenerics({Self:ClosedRange, Bound: this.$info.Bound})}, this, new Map([["lowerBound", this.lowerBound], ["upperBound", this.upperBound]]), null, null)
----Swift.(file).ClosedRange.clamped(to:ClosedRange<Bound>)
const lower = (this.$info.Bound.infix_62({Self: this.$info.Bound, Self: this.$info.Bound}, limits.lowerBound, this.lowerBound) ? limits.lowerBound : (this.$info.Bound.infix_60({Self: this.$info.Bound, Self: this.$info.Bound}, limits.upperBound, this.lowerBound) ? limits.upperBound : this.lowerBound));
const upper = (this.$info.Bound.infix_60({Self: this.$info.Bound, Self: this.$info.Bound}, limits.upperBound, this.upperBound) ? limits.upperBound : (this.$info.Bound.infix_62({Self: this.$info.Bound, Self: this.$info.Bound}, limits.lowerBound, this.upperBound) ? limits.lowerBound : this.upperBound));
return _create(ClosedRange, 'initUncheckedBoundstuple_type', {Bound: this.$info.Bound}, {0: lower, 1: upper})
----Swift.(file).ClosedRange.init(_:Range<Bound>)
preconditionFileLine({}, () => Bool.prefix_33({Self: Bool}, other.isEmpty), () => "Can't form an empty closed range", '?3', '?3');
const upperBound = other.upperBound.advancedBy({Self: this.$info.Bound}, _create(this.$info.Bound.Stride, 'initIntegerLiteral', {Self: this.$info.Bound.Stride}, -1));
this.initUncheckedBoundstuple_type({}, {0: other.lowerBound, 1: upperBound});
return
----Swift.(file).ClosedRange.overlaps(_:ClosedRange<Bound>)
return Bool.infix_124_124({Self: Bool}, this.contains({Bound: this.$info.Bound}, other.lowerBound), () => other.contains({Bound: this.$info.Bound}, this.lowerBound))
----Swift.(file).ClosedRange.overlaps(_:Range<Bound>)
return other.overlaps({Bound: this.$info.Bound}, this)
----Swift.(file).IndexingIterator.init(_elements:Elements)
this._elements = _elements;
this._position = _elements.startIndex;
return
----Swift.(file).IndexingIterator.next()
{
if((this.$info.Elements.Index.infix_61_61({Self: this.$info.Elements.Index, Self: this.$info.Elements.Index}, this._position, this._elements.endIndex))) {
return null;
}
};
const _element = this._elements.subscript$get({}, this._position);
this._elements.formIndexAfter({Self: this.$info.Elements}, {get: () => this._position, set: $val => this._position = $val});
return _element
----Swift.(file).Collection.formIndex(after:Self.Index)
let i = i$inout.get()
const $result = (() => {
i = this.indexAfter({Self: this.$info.Self}, i);})()
i$inout.set(i)
return $result
----Swift.(file).Collection.formIndex(_:Self.Index,offsetBy:Int)
let i = i$inout.get()
const $result = (() => {
i = this.indexOffsetBy({Self: this.$info.Self}, i, distance);})()
i$inout.set(i)
return $result
----Swift.(file).Collection.formIndex(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)
let i = i$inout.get()
const $result = (() => {
{const advancedIndex = this.indexOffsetByLimitedBy({Self: this.$info.Self}, i, distance, limit)
if((advancedIndex != null)) {
i = advancedIndex;
return true;
}
};
i = limit;
return false;})()
i$inout.set(i)
return $result
----Swift.(file).Collection.distance(from:Self.Index,to:Self.Index)
preconditionFileLine({}, () => this.$info.Self.Index.infix_60_61({Self: this.$info.Self.Index, Self: this.$info.Self.Index}, start, end), () => "Only BidirectionalCollections can have end come before start", '?3', '?3');
let start_dupl = start;
let count = 0;
while(true){
if(!((this.$info.Self.Index.infix_33_61({Self: this.$info.Self.Index, Self: this.$info.Self.Index}, start_dupl, end)))) break
count = Int.infix_43({Self: Int}, count, 1);
this.formIndexAfter({Self: this.$info.Self}, {get: () => start_dupl, set: $val => start_dupl = $val});
};
return count
----Swift.(file).Collection.randomElement(using:T)
let generator = generator$inout.get()
const $result = (() => {
{
if(!((Bool.prefix_33({Self: Bool}, this.isEmpty)))) {
return null;
}
};
const random = Int.randomInUsing({Self: Int, Self: Int, T: $info.T}, Int.infix_46_46_60({Self: Int, Self: Int}, 0, this.count), {get: () => generator, set: $val => generator = $val});
const idx = this.indexOffsetBy({Self: $info.Self}, this.startIndex, random);
return this.subscript$get({}, idx);})()
generator$inout.set(generator)
return $result
----Swift.(file).Collection.randomElement()
let g = _create(SystemRandomNumberGenerator, 'init', {}, );
return this.randomElementUsing({Self: this.$info.Self, T: SystemRandomNumberGenerator}, {get: () => g, set: $val => g = $val})
----Swift.(file).Collection.makeIterator()
return _create(IndexingIterator, 'init_elements', {Elements: this.$info.Self}, this)
----Swift.(file).Collection.subscript(_:Range<Self.Index>)
this._failEarlyRangeCheckBounds({Self: this.$info.Self}, bounds, this.$info.Self.Index.infix_46_46_60({Self: this.$info.Self.Index, Self: this.$info.Self.Index}, this.startIndex, this.endIndex));
return _create(Slice, 'initBaseBoundsRange', {Base: this.$info.Self}, this, bounds)
----Swift.(file).Collection.popFirst()
{
if(!((Bool.prefix_33({Self: Bool}, this.isEmpty)))) {
return null;
}
};
const _element = this.first;
$info.$setThis(_cloneStruct(this.subscriptRange$get({}, this.$info.Self.Index.infix_46_46_60({Self: this.$info.Self.Index, Self: this.$info.Self.Index}, this.indexAfter({Self: this.$info.Self}, this.startIndex), this.endIndex))));
return _element
----Swift.(file).Collection.isEmpty
return this.$info.Self.Index.infix_61_61({Self: this.$info.Self.Index, Self: this.$info.Self.Index}, this.startIndex, this.endIndex)
----Swift.(file).Collection.first
const start = this.startIndex;
{
if((this.$info.Self.Index.infix_33_61({Self: this.$info.Self.Index, Self: this.$info.Self.Index}, start, this.endIndex))) {
return this.subscript$get({}, start);
}
else {
return null;
}
}
----Swift.(file).Collection.underestimatedCount
return this.count
----Swift.(file).Collection.count
return this.distanceFromTo({Self: this.$info.Self}, this.startIndex, this.endIndex)
----Swift.(file).Collection.dropFirst(_:Int)
preconditionFileLine({}, () => Int.infix_62_61({Self: Int}, k, 0), () => "Can't drop a negative number of elements from a collection", '?3', '?3');
const start = infix_63_63({T: this.$info.Self.Index}, this.indexOffsetByLimitedBy({Self: this.$info.Self}, this.startIndex, k, this.endIndex), () => this.endIndex);
return this.subscriptRange$get({}, this.$info.Self.Index.infix_46_46_60({Self: this.$info.Self.Index, Self: this.$info.Self.Index}, start, this.endIndex))
----Swift.(file).Collection.dropLast(_:Int)
preconditionFileLine({}, () => Int.infix_62_61({Self: Int}, k, 0), () => "Can't drop a negative number of elements from a collection", '?3', '?3');
const amount = /*dot_syntax_base_ignored*/max({}, 0, Int.infix_45({Self: Int}, this.count, k));
const end = infix_63_63({T: this.$info.Self.Index}, this.indexOffsetByLimitedBy({Self: this.$info.Self}, this.startIndex, amount, this.endIndex), () => this.endIndex);
return this.subscriptRange$get({}, this.$info.Self.Index.infix_46_46_60({Self: this.$info.Self.Index, Self: this.$info.Self.Index}, this.startIndex, end))
----Swift.(file).Collection.drop(while:(Self.Element) throws -> Bool)
let start = this.startIndex;
while(true){
if(!((Bool.infix_38_38({Self: Bool}, this.$info.Self.Index.infix_33_61({Self: this.$info.Self.Index, Self: this.$info.Self.Index}, start, this.endIndex), () => predicate({}, this.subscript$get({}, start)))))) break
this.formIndexAfter({Self: this.$info.Self}, {get: () => start, set: $val => start = $val});
};
return this.subscriptRange$get({}, this.$info.Self.Index.infix_46_46_60({Self: this.$info.Self.Index, Self: this.$info.Self.Index}, start, this.endIndex))
----Swift.(file).Collection.prefix(_:Int)
preconditionFileLine({}, () => Int.infix_62_61({Self: Int}, maxLength, 0), () => "Can't take a prefix of negative length from a collection", '?3', '?3');
const end = infix_63_63({T: this.$info.Self.Index}, this.indexOffsetByLimitedBy({Self: this.$info.Self}, this.startIndex, maxLength, this.endIndex), () => this.endIndex);
return this.subscriptRange$get({}, this.$info.Self.Index.infix_46_46_60({Self: this.$info.Self.Index, Self: this.$info.Self.Index}, this.startIndex, end))
----Swift.(file).Collection.prefix(while:(Self.Element) throws -> Bool)
let end = this.startIndex;
while(true){
if(!((Bool.infix_38_38({Self: Bool}, this.$info.Self.Index.infix_33_61({Self: this.$info.Self.Index, Self: this.$info.Self.Index}, end, this.endIndex), () => predicate({}, this.subscript$get({}, end)))))) break
this.formIndexAfter({Self: this.$info.Self}, {get: () => end, set: $val => end = $val});
};
return this.subscriptRange$get({}, this.$info.Self.Index.infix_46_46_60({Self: this.$info.Self.Index, Self: this.$info.Self.Index}, this.startIndex, end))
----Swift.(file).Collection.suffix(_:Int)
preconditionFileLine({}, () => Int.infix_62_61({Self: Int}, maxLength, 0), () => "Can't take a suffix of negative length from a collection", '?3', '?3');
const amount = /*dot_syntax_base_ignored*/max({}, 0, Int.infix_45({Self: Int}, this.count, maxLength));
const start = infix_63_63({T: this.$info.Self.Index}, this.indexOffsetByLimitedBy({Self: this.$info.Self}, this.startIndex, amount, this.endIndex), () => this.endIndex);
return this.subscriptRange$get({}, this.$info.Self.Index.infix_46_46_60({Self: this.$info.Self.Index, Self: this.$info.Self.Index}, start, this.endIndex))
----Swift.(file).Collection.prefix(upTo:Self.Index)
return this.subscriptRange$get({}, this.$info.Self.Index.infix_46_46_60({Self: this.$info.Self.Index, Self: this.$info.Self.Index}, this.startIndex, end))
----Swift.(file).Collection.suffix(from:Self.Index)
return this.subscriptRange$get({}, this.$info.Self.Index.infix_46_46_60({Self: this.$info.Self.Index, Self: this.$info.Self.Index}, start, this.endIndex))
----Swift.(file).Collection.prefix(through:Self.Index)
return this.prefixUpTo({Self: this.$info.Self}, this.indexAfter({Self: this.$info.Self}, position))
----Swift.(file).Collection.split(maxSplits:Int,omittingEmptySubsequences:Bool,whereSeparator:(Self.Element) throws -> Bool)
preconditionFileLine({}, () => Int.infix_62_61({Self: Int}, maxSplits, 0), () => "Must take zero or more splits", '?3', '?3');
let result = _create(Array, 'initBuffer', {Element: this.$info.Self.SubSequence}, []);
let subSequenceStart = this.startIndex;
function appendSubsequenceEnd($info, end){
{
if((Bool.infix_38_38({Self: Bool}, this.$info.Self.Index.infix_61_61({Self: this.$info.Self.Index, Self: this.$info.Self.Index}, subSequenceStart, end), () => omittingEmptySubsequences))) {
return false;
}
};
result.append({$setThis: $val => result = $val, Element: this.$info.Self.SubSequence}, this.subscriptRange$get({}, this.$info.Self.Index.infix_46_46_60({Self: this.$info.Self.Index, Self: this.$info.Self.Index}, subSequenceStart, end)));
return true;
}
{
if((Bool.infix_124_124({Self: Bool}, Int.infix_61_61({Self: Int}, maxSplits, 0), () => this.isEmpty))) {
_.discardAssignment = appendSubsequenceEnd({Self: this.$info.Self}, this.endIndex);
return result;
}
};
let subSequenceEnd = subSequenceStart;
const cachedEndIndex = this.endIndex;
while(true){
if(!((this.$info.Self.Index.infix_33_61({Self: this.$info.Self.Index, Self: this.$info.Self.Index}, subSequenceEnd, cachedEndIndex)))) break
{
if((isSeparator({}, this.subscript$get({}, subSequenceEnd)))) {
const didAppend = appendSubsequenceEnd({Self: this.$info.Self}, subSequenceEnd);
this.formIndexAfter({Self: this.$info.Self}, {get: () => subSequenceEnd, set: $val => subSequenceEnd = $val});
subSequenceStart = subSequenceEnd;
{
if((Bool.infix_38_38({Self: Bool}, didAppend, () => Int.infix_61_61({Self: Int}, result.count, maxSplits)))) {
break;
}
};
continue;
}
};
this.formIndexAfter({Self: this.$info.Self}, {get: () => subSequenceEnd, set: $val => subSequenceEnd = $val});
};
{
if((Bool.infix_124_124({Self: Bool}, this.$info.Self.Index.infix_33_61({Self: this.$info.Self.Index, Self: this.$info.Self.Index}, subSequenceStart, cachedEndIndex), () => Bool.prefix_33({Self: Bool}, omittingEmptySubsequences)))) {
result.append({$setThis: $val => result = $val, Element: this.$info.Self.SubSequence}, this.subscriptRange$get({}, this.$info.Self.Index.infix_46_46_60({Self: this.$info.Self.Index, Self: this.$info.Self.Index}, subSequenceStart, cachedEndIndex)));
}
};
return result
----Swift.(file).Collection.split(separator:Self.Element,maxSplits:Int,omittingEmptySubsequences:Bool)
return this.splitMaxSplitsOmittingEmptySubsequencesWhereSeparator({Self: this.$info.Self}, maxSplits, omittingEmptySubsequences, (($info, $0) => this.$info.Self.Element.infix_61_61({Self: this.$info.Self.Element, Self: this.$info.Self.Element}, $0, separator)))
----Swift.(file).Collection.removeFirst()
preconditionFileLine({}, () => Bool.prefix_33({Self: Bool}, this.isEmpty), () => "Can't remove items from an empty collection", '?3', '?3');
const _element = this.first;
$info.$setThis(_cloneStruct(this.subscriptRange$get({}, this.$info.Self.Index.infix_46_46_60({Self: this.$info.Self.Index, Self: this.$info.Self.Index}, this.indexAfter({Self: this.$info.Self}, this.startIndex), this.endIndex))));
return _element
----Swift.(file).Collection.removeFirst(_:Int)
{
if((Int.infix_61_61({Self: Int}, k, 0))) {
return ;
}
};
preconditionFileLine({}, () => Int.infix_62_61({Self: Int}, k, 0), () => "Number of elements to remove should be non-negative", '?3', '?3');
preconditionFileLine({}, () => Int.infix_62_61({Self: Int}, this.count, k), () => "Can't remove more items from a collection than it contains", '?3', '?3');
$info.$setThis(_cloneStruct(this.subscriptRange$get({}, this.$info.Self.Index.infix_46_46_60({Self: this.$info.Self.Index, Self: this.$info.Self.Index}, this.indexOffsetBy({Self: this.$info.Self}, this.startIndex, k), this.endIndex))))
----Swift.(file).BidirectionalCollection.last
return (this.isEmpty ? null : this.subscript$get({}, this.indexBefore({Self: this.$info.Self}, this.endIndex)))
----Swift.(file).Collection.firstIndex(of:Self.Element)
{const result = this._customIndexOfEquatableElement({Self: this.$info.Self}, _element)
if((result != null)) {
return result;
}
};
let i = this.startIndex;
while(true){
if(!((this.$info.Self.Index.infix_33_61({Self: this.$info.Self.Index, Self: this.$info.Self.Index}, i, this.endIndex)))) break
{
if((this.$info.Self.Element.infix_61_61({Self: this.$info.Self.Element, Self: this.$info.Self.Element}, this.subscript$get({}, i), _element))) {
return i;
}
};
this.formIndexAfter({Self: this.$info.Self}, {get: () => i, set: $val => i = $val});
};
return null
----Swift.(file).Collection.firstIndex(where:(Self.Element) throws -> Bool)
let i = this.startIndex;
while(true){
if(!((this.$info.Self.Index.infix_33_61({Self: this.$info.Self.Index, Self: this.$info.Self.Index}, i, this.endIndex)))) break
{
if((predicate({}, this.subscript$get({}, i)))) {
return i;
}
};
this.formIndexAfter({Self: this.$info.Self}, {get: () => i, set: $val => i = $val});
};
return null
----Swift.(file).BidirectionalCollection.last(where:(Self.Element) throws -> Bool)
return this.lastIndexWhere({Self: this.$info.Self}, predicate).mapSwift({Wrapped: this.$info.Self.Index, U: this.$info.Self.Element}, (($info, $0) => this.subscript$get({}, $0)))
----Swift.(file).BidirectionalCollection.lastIndex(where:(Self.Element) throws -> Bool)
let i = this.endIndex;
while(true){
if(!((this.$info.Self.Index.infix_33_61({Self: this.$info.Self.Index, Self: this.$info.Self.Index}, i, this.startIndex)))) break
this.formIndexBefore({Self: this.$info.Self}, {get: () => i, set: $val => i = $val});
{
if((predicate({}, this.subscript$get({}, i)))) {
return i;
}
};
};
return null
----Swift.(file).BidirectionalCollection.lastIndex(of:Self.Element)
{const result = this._customLastIndexOfEquatableElement({Self: this.$info.Self}, _element)
if((result != null)) {
return result;
}
};
return this.lastIndexWhere({Self: this.$info.Self}, (($info, $0) => this.$info.Self.Element.infix_61_61({Self: this.$info.Self.Element, Self: this.$info.Self.Element}, $0, _element)))
----Swift.(file).Sequence.shuffled(using:T)
let generator = generator$inout.get()
const $result = (() => {
let result = _create(ContiguousArray, 'initBuffer', {Element: $info.Self.Element, S: $info.Self}, this);
result.shuffleUsing({$setThis: $val => result = $val, Self: _clarifyGenerics({Self:ContiguousArray, Element: $info.Self.Element}), T: $info.T}, {get: () => generator, set: $val => generator = $val});
return _create(Array, 'initBuffer', {Element: $info.Self.Element, S: _clarifyGenerics({Self:ContiguousArray, Element: $info.Self.Element})}, result);})()
generator$inout.set(generator)
return $result
----Swift.(file).Sequence.shuffled()
let g = _create(SystemRandomNumberGenerator, 'init', {}, );
return this.shuffledUsing({Self: this.$info.Self, T: SystemRandomNumberGenerator}, {get: () => g, set: $val => g = $val})
----Swift.(file).MutableCollection.shuffle(using:T)
let generator = generator$inout.get()
const $result = (() => {
{
if(!((Int.infix_62({Self: Int}, this.count, 1)))) {
return ;
}
};
let amount = this.count;
let currentIndex = this.startIndex;
while(true){
if(!((Int.infix_62({Self: Int}, amount, 1)))) break
const random = Int.randomInUsing({Self: Int, Self: Int, T: $info.T}, Int.infix_46_46_60({Self: Int, Self: Int}, 0, amount), {get: () => generator, set: $val => generator = $val});
Int.infix_45_61({Self: Int}, {get: () => amount, set: $val => amount = $val}, 1);
this.swapAt({$setThis: $val => $info.$setThis(_cloneStruct($val)), Self: $info.Self}, currentIndex, this.indexOffsetBy({Self: $info.Self}, currentIndex, random));
this.formIndexAfter({Self: $info.Self}, {get: () => currentIndex, set: $val => currentIndex = $val});
};})()
generator$inout.set(generator)
return $result
----Swift.(file).MutableCollection.shuffle()
let g = _create(SystemRandomNumberGenerator, 'init', {}, );
this.shuffleUsing({$setThis: $val => $info.$setThis(_cloneStruct($val)), Self: this.$info.Self, T: SystemRandomNumberGenerator}, {get: () => g, set: $val => g = $val})
----Swift.(file).Comparable.>infix(_:Self,_:Self)
return $info.Self.infix_60({Self: $info.Self, Self: $info.Self}, rhs, lhs)
----Swift.(file).Comparable.<=infix(_:Self,_:Self)
return Bool.prefix_33({Self: Bool}, $info.Self.infix_60({Self: $info.Self, Self: $info.Self}, rhs, lhs))
----Swift.(file).Comparable.>=infix(_:Self,_:Self)
return Bool.prefix_33({Self: Bool}, $info.Self.infix_60({Self: $info.Self, Self: $info.Self}, lhs, rhs))
----Swift.(file).==infix(_:T,_:T)
return $info.T.RawValue.infix_61_61({Self: $info.T.RawValue, Self: $info.T.RawValue}, lhs.rawValue, rhs.rawValue)
----Swift.(file).!=infix(_:T,_:T)
return $info.T.RawValue.infix_33_61({Self: $info.T.RawValue, Self: $info.T.RawValue}, lhs.rawValue, rhs.rawValue)
----Swift.(file).!=infix(_:T,_:T)
return $info.T.RawValue.infix_33_61({Self: $info.T.RawValue, Self: $info.T.RawValue}, lhs.rawValue, rhs.rawValue)
----Swift.(file).RawRepresentable.hashValue
return this.rawValue.hashValue
----Swift.(file).RawRepresentable.hash(into:Hasher)
let hasher = hasher$inout.get()
const $result = (() => {
hasher.combine({$setThis: $val => hasher = $val, H: this.$info.Self.RawValue}, this.rawValue);})()
hasher$inout.set(hasher)
return $result
----Swift.(file).ExpressibleByExtendedGraphemeClusterLiteral.init(unicodeScalarLiteral:Self.ExtendedGraphemeClusterLiteralType)
this.initExtendedGraphemeClusterLiteral({}, value);
return
----Swift.(file).ExpressibleByStringLiteral.init(extendedGraphemeClusterLiteral:Self.StringLiteralType)
this.initStringLiteral({}, value);
return
----Swift.(file).ContiguousArray.startIndex
return 0
----Swift.(file).ContiguousArray.index(after:Int)
return Int.infix_43({Self: Int}, i, 1)
----Swift.(file).ContiguousArray.formIndex(after:Int)
let i = i$inout.get()
const $result = (() => {
Int.infix_43_61({Self: Int}, {get: () => i, set: $val => i = $val}, 1);})()
i$inout.set(i)
return $result
----Swift.(file).ContiguousArray.index(before:Int)
return Int.infix_45({Self: Int}, i, 1)
----Swift.(file).ContiguousArray.formIndex(before:Int)
let i = i$inout.get()
const $result = (() => {
Int.infix_45_61({Self: Int}, {get: () => i, set: $val => i = $val}, 1);})()
i$inout.set(i)
return $result
----Swift.(file).ContiguousArray.index(_:Int,offsetBy:Int)
return Int.infix_43({Self: Int}, i, distance)
----Swift.(file).ContiguousArray.index(_:Int,offsetBy:Int,limitedBy:Int)
const l = Int.infix_45({Self: Int}, limit, i);
{
if(((Int.infix_62({Self: Int}, distance, 0) ? Bool.infix_38_38({Self: Bool}, Int.infix_62_61({Self: Int}, l, 0), () => Int.infix_60({Self: Int}, l, distance)) : Bool.infix_38_38({Self: Bool}, Int.infix_60_61({Self: Int}, l, 0), () => Int.infix_60({Self: Int}, distance, l))))) {
return null;
}
};
return Int.infix_43({Self: Int}, i, distance)
----Swift.(file).ContiguousArray.distance(from:Int,to:Int)
return Int.infix_45({Self: Int}, end, start)
----Swift.(file).ContiguousArray.withContiguousMutableStorageIfAvailable(_:(inout UnsafeMutableBufferPointer<Element>) throws -> R)
return this.withUnsafeMutableBufferPointer({$setThis: $val => $info.$setThis(_cloneStruct($val)), Element: $info.Element, R: $info.R}, (($info, bufferPointer$inout) => body({}, {get: () => bufferPointer, set: $val => bufferPointer = $val})))
----Swift.(file).ContiguousArray.withContiguousStorageIfAvailable(_:(UnsafeBufferPointer<Element>) throws -> R)
return this.withUnsafeBufferPointer({Element: $info.Element, R: $info.R}, (($info, bufferPointer) => body({}, bufferPointer)))
----Swift.(file).ContiguousArray.customMirror
return _create(Mirror, 'initUnlabeledChildrenDisplayStyleOptionalAncestorRepresentationMirrorAncestorRepresentation', {Subject: _clarifyGenerics({Self:ContiguousArray, Element: this.$info.Element}), C: _clarifyGenerics({Self:ContiguousArray, Element: this.$info.Element})}, this, this, Mirror.DisplayStyle.collection, null)
----Swift.(file).ContiguousArray.hash(into:Hasher)
let hasher = hasher$inout.get()
const $result = (() => {
hasher.combine({$setThis: $val => hasher = $val, H: Int}, this.count);
{
let $element$generator = _cloneStruct(this.makeIterator({Self: _clarifyGenerics({Self:ContiguousArray, Element: this.$info.Element})}, ));
while(true) {
const _element = $element$generator.next({$setThis: $val => $element$generator = $val, Elements: _clarifyGenerics({Self:ContiguousArray, Element: this.$info.Element})}, );
if(!((_element != null))) break;
hasher.combine({$setThis: $val => hasher = $val, H: this.$info.Element}, _element);
}
};})()
hasher$inout.set(hasher)
return $result
----Swift.(file).ContiguousArray.withUnsafeMutableBytes(_:(UnsafeMutableRawBufferPointer) throws -> R)
return this.withUnsafeMutableBufferPointer({$setThis: $val => $info.$setThis(_cloneStruct($val)), Element: $info.Element, R: $info.R}, (($info, $0$inout) => body({}, _create(UnsafeMutableRawBufferPointer, 'initUnsafeMutableBufferPointer', {T: $info.Element}, $0))))
----Swift.(file).ContiguousArray.withUnsafeBytes(_:(UnsafeRawBufferPointer) throws -> R)
return this.withUnsafeBufferPointer({Element: $info.Element, R: $info.R}, (($info, $0) => body({}, _create(UnsafeRawBufferPointer, 'initUnsafeBufferPointer', {T: $info.Element}, $0))))
----Swift.(file).Dictionary.isEmpty
return Int.infix_61_61({Self: Int}, this.count, 0)
----Swift.(file).Dictionary.merging(_:[Key : Value],uniquingKeysWith:(Value, Value) throws -> Value)
let result = _cloneStruct(this);
result.mergeUniquingKeysWith({$setThis: $val => result = $val, Key: this.$info.Key, Value: this.$info.Value}, other, combine);
return result
----Swift.(file).Dictionary.customMirror
const style = Mirror.DisplayStyle.dictionary;
return _create(Mirror, 'initUnlabeledChildrenDisplayStyleOptionalAncestorRepresentationMirrorAncestorRepresentation', {Subject: _clarifyGenerics({Self:Dictionary, Key: this.$info.Key, Value: this.$info.Value}), C: _clarifyGenerics({Self:Dictionary, Key: this.$info.Key, Value: this.$info.Value})}, this, this, style, null)
----Swift.(file).Dictionary.popFirst()
{
if(!((Bool.prefix_33({Self: Bool}, this.isEmpty)))) {
return null;
}
};
return this.removeAt({$setThis: $val => $info.$setThis(_cloneStruct($val)), Key: this.$info.Key, Value: this.$info.Value}, this.startIndex)
----Swift.(file).EmptyCollection.init()
return
----Swift.(file).Iterator.next()
return null
----Swift.(file).EmptyCollection.makeIterator()
return _create(EmptyCollection.Iterator, 'init', {Element: this.$info.Element}, )
----Swift.(file).EmptyCollection.startIndex
return 0
----Swift.(file).EmptyCollection.endIndex
return 0
----Swift.(file).EmptyCollection.index(after:EmptyCollection<Element>.Index)
preconditionFailureFileLine({}, () => "EmptyCollection can't advance indices", '?3', '?3')
----Swift.(file).EmptyCollection.index(before:EmptyCollection<Element>.Index)
preconditionFailureFileLine({}, () => "EmptyCollection can't advance indices", '?3', '?3')
----Swift.(file).EmptyCollection.subscript(_:EmptyCollection<Element>.Index)#ASS

preconditionFailureFileLine({}, () => "Index out of range", '?3', '?3')
----Swift.(file).EmptyCollection.subscript(_:EmptyCollection<Element>.Index)
preconditionFailureFileLine({}, () => "Index out of range", '?3', '?3');

----Swift.(file).EmptyCollection.subscript(_:Range<EmptyCollection<Element>.Index>)#ASS

preconditionFileLine({}, () => Bool.infix_38_38({Self: Bool}, Int.infix_61_61({Self: Int}, bounds.lowerBound, 0), () => Int.infix_61_61({Self: Int}, bounds.upperBound, 0)), () => "Index out of range", '?3', '?3')
----Swift.(file).EmptyCollection.subscript(_:Range<EmptyCollection<Element>.Index>)
preconditionFileLine({}, () => Bool.infix_38_38({Self: Bool}, Int.infix_61_61({Self: Int}, bounds.lowerBound, 0), () => Int.infix_61_61({Self: Int}, bounds.upperBound, 0)), () => "Index out of range", '?3', '?3');
return this;

----Swift.(file).EmptyCollection.count
return 0
----Swift.(file).EmptyCollection.index(_:EmptyCollection<Element>.Index,offsetBy:Int)
preconditionFileLine({}, () => Bool.infix_38_38({Self: Bool}, Int.infix_61_61({Self: Int}, i, this.startIndex), () => Int.infix_61_61({Self: Int}, n, 0)), () => "Index out of range", '?3', '?3');
return i
----Swift.(file).EmptyCollection.index(_:EmptyCollection<Element>.Index,offsetBy:Int,limitedBy:EmptyCollection<Element>.Index)
preconditionFileLine({}, () => Bool.infix_38_38({Self: Bool}, Int.infix_61_61({Self: Int}, i, this.startIndex), () => Int.infix_61_61({Self: Int}, limit, this.startIndex)), () => "Index out of range", '?3', '?3');
return (Int.infix_61_61({Self: Int}, n, 0) ? i : null)
----Swift.(file).EmptyCollection.distance(from:EmptyCollection<Element>.Index,to:EmptyCollection<Element>.Index)
preconditionFileLine({}, () => Int.infix_61_61({Self: Int}, start, 0), () => "From must be startIndex (or endIndex)", '?3', '?3');
preconditionFileLine({}, () => Int.infix_61_61({Self: Int}, end, 0), () => "To must be endIndex (or startIndex)", '?3', '?3');
return 0
----Swift.(file).EmptyCollection.==infix(_:EmptyCollection<Element>,_:EmptyCollection<Element>)
return true
----Swift.(file).Equatable.!=infix(_:Self,_:Self)
return Bool.prefix_33({Self: Bool}, $info.Self.infix_61_61({Self: $info.Self, Self: $info.Self}, lhs, rhs))
----Swift.(file).===infix(_:AnyObject?,_:AnyObject?)
const $match = {0: lhs, 1: rhs}
if(((true))) {
const l = $match[0]
const r = $match[1]
return ObjectIdentifier.infix_61_61({Self: ObjectIdentifier}, _create(ObjectIdentifier, 'initAnyObject', {}, l), _create(ObjectIdentifier, 'initAnyObject', {}, r));
}
else if((($match[0].rawValue == Optional.none.rawValue && $match[1].rawValue == Optional.none.rawValue))) {
return true;
}
else if(((true))) {
return false;
}
----Swift.(file).!==infix(_:AnyObject?,_:AnyObject?)
return Bool.prefix_33({Self: Bool}, infix_61_61_61({}, lhs, rhs))
----Swift.(file).LazyFilterSequence.underestimatedCount
return 0
----Swift.(file).LazyFilterSequence.index(after:LazyFilterSequence<Base>.Index)
let i_dupl = i;
this.formIndexAfter({Base: this.$info.Base}, {get: () => i_dupl, set: $val => i_dupl = $val});
return i_dupl
----Swift.(file).LazyFilterSequence.formIndex(_:LazyFilterSequence<Base>.Index,offsetBy:Int)
let i = i$inout.get()
const $result = (() => {
i = this.indexOffsetBy({Base: this.$info.Base}, i, n);})()
i$inout.set(i)
return $result
----Swift.(file).LazyFilterSequence.formIndex(_:LazyFilterSequence<Base>.Index,offsetBy:Int,limitedBy:LazyFilterSequence<Base>.Index)
let i = i$inout.get()
const $result = (() => {
{const advancedIndex = this.indexOffsetByLimitedBy({Base: this.$info.Base}, i, n, limit)
if((advancedIndex != null)) {
i = advancedIndex;
return true;
}
};
i = limit;
return false;})()
i$inout.set(i)
return $result
----Swift.(file).LazyFilterSequence.index(before:LazyFilterSequence<Base>.Index)
let i_dupl = i;
this.formIndexBefore({Base: this.$info.Base}, {get: () => i_dupl, set: $val => i_dupl = $val});
return i_dupl
----Swift.(file).LazySequenceProtocol.filter(_:(Self.Elements.Element) -> Bool)
return _create(LazyFilterSequence, 'init_basefunction_type', {Base: this.$info.Self.Elements}, this._elements, isIncluded)
----Swift.(file).LazySequenceProtocol.flatMap(_:(Self.Elements.Element) -> SegmentOfResult)
return this.mapSwift({Self: $info.Self, U: $info.SegmentOfResult}, transform).joined({Self: _clarifyGenerics({Self:LazyMapSequence, Base: $info.Self.Elements, Element: $info.SegmentOfResult})}, )
----Swift.(file).LazySequenceProtocol.compactMap(_:(Self.Elements.Element) -> ElementOfResult?)
return this.mapSwift({Self: $info.Self, U: _clarifyGenerics({Self:Optional, Wrapped: $info.ElementOfResult})}, transform).filterSwift({Self: _clarifyGenerics({Self:LazyMapSequence, Base: $info.Self.Elements, Element: _clarifyGenerics({Self:Optional, Wrapped: $info.ElementOfResult})})}, (($info, $0) => Optional.infix_33_61({Self: Optional, Wrapped: $info.ElementOfResult}, $0, null))).mapSwift({Self: _clarifyGenerics({Self:LazyFilterSequence, Base: _clarifyGenerics({Self:LazyMapSequence, Base: $info.Self.Elements, Element: _clarifyGenerics({Self:Optional, Wrapped: $info.ElementOfResult})})}), U: $info.ElementOfResult}, (($info, $0) => $0))
----Swift.(file).FlattenSequence.formIndex(after:FlattenSequence<Base>.Index)
let i = i$inout.get()
const $result = (() => {
i = _cloneStruct(this.indexAfter({Base: this.$info.Base}, i));})()
i$inout.set(i)
return $result
----Swift.(file).FlattenSequence.formIndex(_:FlattenSequence<Base>.Index,offsetBy:Int)
let i = i$inout.get()
const $result = (() => {
i = _cloneStruct(this.indexOffsetBy({Base: this.$info.Base}, i, n));})()
i$inout.set(i)
return $result
----Swift.(file).FlattenSequence.formIndex(_:FlattenSequence<Base>.Index,offsetBy:Int,limitedBy:FlattenSequence<Base>.Index)
let i = i$inout.get()
const $result = (() => {
{const advancedIndex = this.indexOffsetByLimitedBy({Base: this.$info.Base}, i, n, limit)
if((advancedIndex != null)) {
i = _cloneStruct(advancedIndex);
return true;
}
};
i = _cloneStruct(limit);
return false;})()
i$inout.set(i)
return $result
----Swift.(file).FlattenSequence.subscript(_:Range<FlattenSequence<Base>.Index>)
return _create(Slice, 'initBaseBoundsRange', {Base: _clarifyGenerics({Self:FlattenSequence, Base: this.$info.Base})}, this, bounds)
----Swift.(file).FlattenSequence.formIndex(before:FlattenSequence<Base>.Index)
let i = i$inout.get()
const $result = (() => {
i = _cloneStruct(this.indexBefore({Base: this.$info.Base}, i));})()
i$inout.set(i)
return $result
----Swift.(file).FloatingPointSign.rawValue
const $match = this
if((($match.rawValue == FloatingPointSign.plus.rawValue))) {
return 0;
}
else if((($match.rawValue == FloatingPointSign.minus.rawValue))) {
return 1;
}
----Swift.(file).FloatingPointSign.==infix(_:FloatingPointSign,_:FloatingPointSign)
return Int.infix_61_61({Self: Int}, a.rawValue, b.rawValue)
----Swift.(file).FloatingPointSign.hashValue
return this.rawValue.hashValue
----Swift.(file).FloatingPointSign.hash(into:Hasher)
let hasher = hasher$inout.get()
const $result = (() => {
hasher.combine({$setThis: $val => hasher = $val, H: Int}, this.rawValue);})()
hasher$inout.set(hasher)
return $result
----Swift.(file).FloatingPoint.==infix(_:Self,_:Self)
return lhs.isEqualTo({Self: $info.Self}, rhs)
----Swift.(file).FloatingPoint.<infix(_:Self,_:Self)
return lhs.isLessThan({Self: $info.Self}, rhs)
----Swift.(file).FloatingPoint.<=infix(_:Self,_:Self)
return lhs.isLessThanOrEqualTo({Self: $info.Self}, rhs)
----Swift.(file).FloatingPoint.>infix(_:Self,_:Self)
return rhs.isLessThan({Self: $info.Self}, lhs)
----Swift.(file).FloatingPoint.>=infix(_:Self,_:Self)
return rhs.isLessThanOrEqualTo({Self: $info.Self}, lhs)
----Swift.(file).FloatingPoint.ulpOfOne
return _create($info.Self, 'initIntegerLiteral', {Self: $info.Self}, 1).ulp;
}
static get ulpOfOne() { return this.ulpOfOne$get()
----Swift.(file).FloatingPoint.rounded(_:FloatingPointRoundingRule)
let lhs = this;
lhs.round({$setThis: $val => lhs = $val, Self: this.$info.Self}, rule);
return lhs
----Swift.(file).FloatingPoint.rounded()
return this.rounded({Self: this.$info.Self}, FloatingPointRoundingRule.toNearestOrAwayFromZero)
----Swift.(file).FloatingPoint.round()
this.round({$setThis: $val => $info.$setThis(_cloneStruct($val)), Self: this.$info.Self}, FloatingPointRoundingRule.toNearestOrAwayFromZero)
----Swift.(file).FloatingPoint.nextDown
return this.$info.Self.prefix_45({Self: this.$info.Self, Self: this.$info.Self}, this.$info.Self.prefix_45({Self: this.$info.Self, Self: this.$info.Self}, this).nextUp)
----Swift.(file).FloatingPoint.truncatingRemainder(dividingBy:Self)
let lhs = this;
lhs.formTruncatingRemainderDividingBy({$setThis: $val => lhs = $val, Self: this.$info.Self}, other);
return lhs
----Swift.(file).FloatingPoint.remainder(dividingBy:Self)
let lhs = this;
lhs.formRemainderDividingBy({$setThis: $val => lhs = $val, Self: this.$info.Self}, other);
return lhs
----Swift.(file).FloatingPoint.squareRoot()
let lhs = this;
lhs.formSquareRoot({$setThis: $val => lhs = $val, Self: this.$info.Self}, );
return lhs
----Swift.(file).FloatingPoint.addingProduct(_:Self,_:Self)
let addend = this;
addend.addProduct({$setThis: $val => addend = $val, Self: this.$info.Self}, lhs, rhs);
return addend
----Swift.(file).FloatingPoint.minimum(_:Self,_:Self)
{
if((Bool.infix_124_124({Self: Bool}, x.isSignalingNaN, () => y.isSignalingNaN))) {
return $info.Self.infix_43({Self: $info.Self, Self: $info.Self}, x, y);
}
};
{
if((Bool.infix_124_124({Self: Bool}, $info.Self.infix_60_61({Self: $info.Self, Self: $info.Self}, x, y), () => y._isNaN))) {
return x;
}
};
return y
----Swift.(file).FloatingPoint.maximum(_:Self,_:Self)
{
if((Bool.infix_124_124({Self: Bool}, x.isSignalingNaN, () => y.isSignalingNaN))) {
return $info.Self.infix_43({Self: $info.Self, Self: $info.Self}, x, y);
}
};
{
if((Bool.infix_124_124({Self: Bool}, $info.Self.infix_62({Self: $info.Self, Self: $info.Self}, x, y), () => y._isNaN))) {
return x;
}
};
return y
----Swift.(file).FloatingPoint.minimumMagnitude(_:Self,_:Self)
{
if((Bool.infix_124_124({Self: Bool}, x.isSignalingNaN, () => y.isSignalingNaN))) {
return $info.Self.infix_43({Self: $info.Self, Self: $info.Self}, x, y);
}
};
{
if((Bool.infix_124_124({Self: Bool}, $info.Self.infix_60_61({Self: $info.Self, Self: $info.Self}, x.magnitude, y.magnitude), () => y._isNaN))) {
return x;
}
};
return y
----Swift.(file).FloatingPoint.maximumMagnitude(_:Self,_:Self)
{
if((Bool.infix_124_124({Self: Bool}, x.isSignalingNaN, () => y.isSignalingNaN))) {
return $info.Self.infix_43({Self: $info.Self, Self: $info.Self}, x, y);
}
};
{
if((Bool.infix_124_124({Self: Bool}, $info.Self.infix_62({Self: $info.Self, Self: $info.Self}, x.magnitude, y.magnitude), () => y._isNaN))) {
return x;
}
};
return y
----Swift.(file).FloatingPoint.floatingPointClass
{
if((this.isSignalingNaN)) {
return FloatingPointClassification.signalingNaN;
}
};
{
if((this._isNaN)) {
return FloatingPointClassification.quietNaN;
}
};
{
if((this.isInfinite)) {
return (FloatingPointSign.infix_61_61({Self: FloatingPointSign}, this.sign, FloatingPointSign.minus) ? FloatingPointClassification.negativeInfinity : FloatingPointClassification.positiveInfinity);
}
};
{
if((this.isNormal)) {
return (FloatingPointSign.infix_61_61({Self: FloatingPointSign}, this.sign, FloatingPointSign.minus) ? FloatingPointClassification.negativeNormal : FloatingPointClassification.positiveNormal);
}
};
{
if((this.isSubnormal)) {
return (FloatingPointSign.infix_61_61({Self: FloatingPointSign}, this.sign, FloatingPointSign.minus) ? FloatingPointClassification.negativeSubnormal : FloatingPointClassification.positiveSubnormal);
}
};
return (FloatingPointSign.infix_61_61({Self: FloatingPointSign}, this.sign, FloatingPointSign.minus) ? FloatingPointClassification.negativeZero : FloatingPointClassification.positiveZero)
----Swift.(file).BinaryFloatingPoint.radix
return 2;
}
static get radix() { return this.radix$get()
----Swift.(file).BinaryFloatingPoint.init(signOf:Self,magnitudeOf:Self)
this.initSignFloatingPointSignExponentBitPatternSignificandBitPattern({}, signOf.sign, magnitudeOf.exponentBitPattern, magnitudeOf.significandBitPattern);
return
----Swift.(file).BinaryFloatingPoint.isTotallyOrdered(belowOrEqualTo:Self)
{
if((this.$info.Self.infix_60({Self: this.$info.Self, Self: this.$info.Self}, this, other))) {
return true;
}
};
{
if((this.$info.Self.infix_62({Self: this.$info.Self, Self: this.$info.Self}, other, this))) {
return false;
}
};
{
if((FloatingPointSign.infix_33_61({Self: FloatingPointSign, Self: FloatingPointSign}, this.sign, other.sign))) {
return FloatingPointSign.infix_61_61({Self: FloatingPointSign}, this.sign, FloatingPointSign.minus);
}
};
{
if((this.$info.Self.RawExponent.infix_62({Self: this.$info.Self.RawExponent, Self: this.$info.Self.RawExponent}, this.exponentBitPattern, other.exponentBitPattern))) {
return FloatingPointSign.infix_61_61({Self: FloatingPointSign}, this.sign, FloatingPointSign.minus);
}
};
{
if((this.$info.Self.RawExponent.infix_60({Self: this.$info.Self.RawExponent, Self: this.$info.Self.RawExponent}, this.exponentBitPattern, other.exponentBitPattern))) {
return FloatingPointSign.infix_61_61({Self: FloatingPointSign}, this.sign, FloatingPointSign.plus);
}
};
{
if((this.$info.Self.RawSignificand.infix_62({Self: this.$info.Self.RawSignificand, Self: this.$info.Self.RawSignificand}, this.significandBitPattern, other.significandBitPattern))) {
return FloatingPointSign.infix_61_61({Self: FloatingPointSign}, this.sign, FloatingPointSign.minus);
}
};
{
if((this.$info.Self.RawSignificand.infix_60({Self: this.$info.Self.RawSignificand, Self: this.$info.Self.RawSignificand}, this.significandBitPattern, other.significandBitPattern))) {
return FloatingPointSign.infix_61_61({Self: FloatingPointSign}, this.sign, FloatingPointSign.plus);
}
};
return true
----Swift.(file).BinaryFloatingPoint.random(in:Range<Self>,using:T)
let generator = generator$inout.get()
const $result = (() => {
preconditionFileLine({}, () => Bool.prefix_33({Self: Bool}, range.isEmpty), () => "Can't get random value with an empty range", '?3', '?3');
const delta = $info.Self.infix_45({Self: $info.Self, Self: $info.Self}, range.upperBound, range.lowerBound);
preconditionFileLine({}, () => delta._isFinite, () => "There is no uniform distribution on an infinite range", '?3', '?3');
const rand;
{
if((Int.infix_61_61({Self: Int}, $info.Self.RawSignificand.bitWidth, Int.infix_43({Self: Int}, $info.Self.significandBitCount, 1)))) {
rand = generator.next({$setThis: $val => generator = $val, Self: $info.T, T: $info.Self.RawSignificand}, );
}
else {
const significandCount = Int.infix_43({Self: Int}, $info.Self.significandBitCount, 1);
const maxSignificand = $info.Self.RawSignificand.infix_60_60({Self: $info.Self.RawSignificand, Self: $info.Self.RawSignificand, RHS: Int}, _create($info.Self.RawSignificand, 'initIntegerLiteral', {Self: $info.Self.RawSignificand}, 1), significandCount);
rand = $info.Self.RawSignificand.infix_38({Self: $info.Self.RawSignificand, Self: $info.Self.RawSignificand}, generator.next({$setThis: $val => generator = $val, Self: $info.T, T: $info.Self.RawSignificand}, ), $info.Self.RawSignificand.infix_45({Self: $info.Self.RawSignificand, Self: $info.Self.RawSignificand}, maxSignificand, _create($info.Self.RawSignificand, 'initIntegerLiteral', {Self: $info.Self.RawSignificand}, 1)));
}
};
const unitRandom = $info.Self.infix_42({Self: $info.Self, Self: $info.Self}, _create($info.Self, 'init', {Self: $info.Self, Source: $info.Self.RawSignificand}, rand), $info.Self.infix_47({Self: $info.Self, Self: $info.Self}, $info.Self.ulpOfOne, _create($info.Self, 'initIntegerLiteral', {Self: $info.Self}, 2)));
const randFloat = $info.Self.infix_43({Self: $info.Self, Self: $info.Self}, $info.Self.infix_42({Self: $info.Self, Self: $info.Self}, delta, unitRandom), range.lowerBound);
{
if(($info.Self.infix_61_61({Self: $info.Self, Self: $info.Self}, randFloat, range.upperBound))) {
return $info.Self.randomInUsing({Self: $info.Self, Self: $info.Self, T: $info.T}, range, {get: () => generator, set: $val => generator = $val});
}
};
return randFloat;})()
generator$inout.set(generator)
return $result
----Swift.(file).BinaryFloatingPoint.random(in:Range<Self>)
let g = _create(SystemRandomNumberGenerator, 'init', {}, );
return $info.Self.randomInUsing({Self: $info.Self, Self: $info.Self, T: SystemRandomNumberGenerator}, range, {get: () => g, set: $val => g = $val})
----Swift.(file).BinaryFloatingPoint.random(in:ClosedRange<Self>,using:T)
let generator = generator$inout.get()
const $result = (() => {
preconditionFileLine({}, () => Bool.prefix_33({Self: Bool}, range.isEmpty), () => "Can't get random value with an empty range", '?3', '?3');
const delta = $info.Self.infix_45({Self: $info.Self, Self: $info.Self}, range.upperBound, range.lowerBound);
preconditionFileLine({}, () => delta._isFinite, () => "There is no uniform distribution on an infinite range", '?3', '?3');
const rand;
{
if((Int.infix_61_61({Self: Int}, $info.Self.RawSignificand.bitWidth, Int.infix_43({Self: Int}, $info.Self.significandBitCount, 1)))) {
rand = generator.next({$setThis: $val => generator = $val, Self: $info.T, T: $info.Self.RawSignificand}, );
const tmp = UInt8.infix_38({Self: UInt8}, generator.next({$setThis: $val => generator = $val, Self: $info.T, T: UInt8}, ), 1);
{
if((Bool.infix_38_38({Self: Bool}, $info.Self.RawSignificand.infix_61_61({Self: $info.Self.RawSignificand, Self: $info.Self.RawSignificand}, rand, $info.Self.RawSignificand.max), () => UInt8.infix_61_61({Self: UInt8}, tmp, 1)))) {
return range.upperBound;
}
};
}
else {
const significandCount = Int.infix_43({Self: Int}, $info.Self.significandBitCount, 1);
const maxSignificand = $info.Self.RawSignificand.infix_60_60({Self: $info.Self.RawSignificand, Self: $info.Self.RawSignificand, RHS: Int}, _create($info.Self.RawSignificand, 'initIntegerLiteral', {Self: $info.Self.RawSignificand}, 1), significandCount);
rand = generator.nextUpperBound({$setThis: $val => generator = $val, Self: $info.T, T: $info.Self.RawSignificand}, $info.Self.RawSignificand.infix_43({Self: $info.Self.RawSignificand, Self: $info.Self.RawSignificand}, maxSignificand, _create($info.Self.RawSignificand, 'initIntegerLiteral', {Self: $info.Self.RawSignificand}, 1)));
{
if(($info.Self.RawSignificand.infix_61_61({Self: $info.Self.RawSignificand, Self: $info.Self.RawSignificand}, rand, maxSignificand))) {
return range.upperBound;
}
};
}
};
const unitRandom = $info.Self.infix_42({Self: $info.Self, Self: $info.Self}, _create($info.Self, 'init', {Self: $info.Self, Source: $info.Self.RawSignificand}, rand), $info.Self.infix_47({Self: $info.Self, Self: $info.Self}, $info.Self.ulpOfOne, _create($info.Self, 'initIntegerLiteral', {Self: $info.Self}, 2)));
const randFloat = $info.Self.infix_43({Self: $info.Self, Self: $info.Self}, $info.Self.infix_42({Self: $info.Self, Self: $info.Self}, delta, unitRandom), range.lowerBound);
return randFloat;})()
generator$inout.set(generator)
return $result
----Swift.(file).BinaryFloatingPoint.random(in:ClosedRange<Self>)
let g = _create(SystemRandomNumberGenerator, 'init', {}, );
return $info.Self.randomInUsing({Self: $info.Self, Self: $info.Self, T: SystemRandomNumberGenerator}, range, {get: () => g, set: $val => g = $val})
----Swift.(file).Hasher.combine(_:H)
value.hashInto({Self: $info.H}, {get: () => this, set: $val => $info.$setThis(_cloneStruct($val))})
----Swift.(file).DefaultIndices.subscript(_:DefaultIndices<Elements>.Index)
return i
----Swift.(file).DefaultIndices.indices
return this
----Swift.(file).FixedWidthInteger.init(_:String)
this.initRadixInt({}, description, 10);
return
----Swift.(file).ExpressibleByIntegerLiteral.init(integerLiteral:Self)
$info.$setThis(_cloneStruct(value));
return
----Swift.(file).AdditiveArithmetic.zero
return _create($info.Self, 'initIntegerLiteral', {Self: $info.Self}, 0);
}
static get zero() { return this.zero$get()
----Swift.(file).SignedNumeric.-prefix(_:Self)
let result = operand;
result.negate({$setThis: $val => result = $val, Self: $info.Self}, );
return result
----Swift.(file).SignedNumeric.negate()
$info.$setThis(_cloneStruct(this.$info.Self.prefix_45({Self: this.$info.Self, Self: this.$info.Self}, this)))
----Swift.(file).abs(_:T)
{
if((infix_61_61({}, $info.T, $info.T.Magnitude))) {
return unsafeBitCastTo({T: $info.T.Magnitude, U: $info.T}, x.magnitude, $info.T);
}
};
return ($info.T.infix_60({Self: $info.T, Self: $info.T}, x, _create($info.T, 'initIntegerLiteral', {Self: $info.T}, 0)) ? $info.T.prefix_45({Self: $info.T, Self: $info.T}, x) : x)
----Swift.(file).AdditiveArithmetic.+prefix(_:Self)
return x
----Swift.(file).BinaryInteger.init()
$info.$setThis(_cloneStruct(_create(this.$info.Self, 'initIntegerLiteral', {Self: this.$info.Self}, 0)));
return
----Swift.(file).BinaryInteger.signum()
return this.$info.Self.infix_45({Self: this.$info.Self, Self: this.$info.Self}, (this.$info.Self.infix_62({Self: this.$info.Self, Self: this.$info.Self}, this, _create(this.$info.Self, 'initIntegerLiteral', {Self: this.$info.Self}, 0)) ? _create(this.$info.Self, 'initIntegerLiteral', {Self: this.$info.Self}, 1) : _create(this.$info.Self, 'initIntegerLiteral', {Self: this.$info.Self}, 0)), (this.$info.Self.infix_60({Self: this.$info.Self, Self: this.$info.Self}, this, _create(this.$info.Self, 'initIntegerLiteral', {Self: this.$info.Self}, 0)) ? _create(this.$info.Self, 'initIntegerLiteral', {Self: this.$info.Self}, 1) : _create(this.$info.Self, 'initIntegerLiteral', {Self: this.$info.Self}, 0)))
----Swift.(file).BinaryInteger.quotientAndRemainder(dividingBy:Self)
return {0: this.$info.Self.infix_47({Self: this.$info.Self, Self: this.$info.Self}, this, rhs), 1: this.$info.Self.infix_37({Self: this.$info.Self, Self: this.$info.Self}, this, rhs)}
----Swift.(file).BinaryInteger.isMultiple(of:Self)
{
if((this.$info.Self.infix_61_61({Self: this.$info.Self, Self: this.$info.Self, Other: Int}, other, 0))) {
return this.$info.Self.infix_61_61({Self: this.$info.Self, Self: this.$info.Self, Other: Int}, this, 0);
}
};
return this.$info.Self.Magnitude.infix_61_61({Self: this.$info.Self.Magnitude, Self: this.$info.Self.Magnitude, Other: Int}, this.$info.Self.Magnitude.infix_37({Self: this.$info.Self.Magnitude, Self: this.$info.Self.Magnitude}, this.magnitude, other.magnitude), 0)
----Swift.(file).BinaryInteger.&infix(_:Self,_:Self)
let lhs_dupl = lhs;
$info.Self.infix_38_61({Self: $info.Self, Self: $info.Self}, {get: () => lhs_dupl, set: $val => lhs_dupl = $val}, rhs);
return lhs_dupl
----Swift.(file).BinaryInteger.|infix(_:Self,_:Self)
let lhs_dupl = lhs;
$info.Self.infix_124_61({Self: $info.Self, Self: $info.Self}, {get: () => lhs_dupl, set: $val => lhs_dupl = $val}, rhs);
return lhs_dupl
----Swift.(file).BinaryInteger.^infix(_:Self,_:Self)
let lhs_dupl = lhs;
$info.Self.infix_94_61({Self: $info.Self, Self: $info.Self}, {get: () => lhs_dupl, set: $val => lhs_dupl = $val}, rhs);
return lhs_dupl
----Swift.(file).BinaryInteger.>>infix(_:Self,_:RHS)
let r = lhs;
$info.Self.infix_62_62_61({Self: $info.Self, Self: $info.Self, RHS: $info.RHS}, {get: () => r, set: $val => r = $val}, rhs);
return r
----Swift.(file).BinaryInteger.<<infix(_:Self,_:RHS)
let r = lhs;
$info.Self.infix_60_60_61({Self: $info.Self, Self: $info.Self, RHS: $info.RHS}, {get: () => r, set: $val => r = $val}, rhs);
return r
----Swift.(file).BinaryInteger.distance(to:Self)
{
if((Bool.prefix_33({Self: Bool}, this.$info.Self.isSigned))) {
{
if((this.$info.Self.infix_62({Self: this.$info.Self, Self: this.$info.Self}, this, other))) {
{const result = _create(Int, 'initExactly', {Self: Int, T: this.$info.Self}, this.$info.Self.infix_45({Self: this.$info.Self, Self: this.$info.Self}, this, other))
if((result != null)) {
return Int.prefix_45({Self: Int, Self: Int}, result);
}
};
}
else {
{const result = _create(Int, 'initExactly', {Self: Int, T: this.$info.Self}, this.$info.Self.infix_45({Self: this.$info.Self, Self: this.$info.Self}, other, this))
if((result != null)) {
return result;
}
};
}
};
}
else {
const isNegative = this.$info.Self.infix_60({Self: this.$info.Self, Self: this.$info.Self}, this, _create(this.$info.Self, 'initIntegerLiteral', {Self: this.$info.Self}, 0));
{
if((Bool.infix_61_61({Self: Bool}, isNegative, this.$info.Self.infix_60({Self: this.$info.Self, Self: this.$info.Self}, other, _create(this.$info.Self, 'initIntegerLiteral', {Self: this.$info.Self}, 0))))) {
{const result = _create(Int, 'initExactly', {Self: Int, T: this.$info.Self}, this.$info.Self.infix_45({Self: this.$info.Self, Self: this.$info.Self}, other, this))
if((result != null)) {
return result;
}
};
}
else {
{const result = _create(Int, 'initExactly', {Self: Int, T: this.$info.Self.Magnitude}, this.$info.Self.Magnitude.infix_43({Self: this.$info.Self.Magnitude, Self: this.$info.Self.Magnitude}, this.magnitude, other.magnitude))
if((result != null)) {
return (isNegative ? result : Int.prefix_45({Self: Int, Self: Int}, result));
}
};
}
};
}
};
preconditionFailureFileLine({}, () => "Distance is not representable in Int", '?3', '?3')
----Swift.(file).BinaryInteger.advanced(by:Int)
{
if((Bool.prefix_33({Self: Bool}, this.$info.Self.isSigned))) {
return (Int.infix_60({Self: Int}, n, 0) ? this.$info.Self.infix_45({Self: this.$info.Self, Self: this.$info.Self}, this, _create(this.$info.Self, 'init', {Self: this.$info.Self, T: Int}, Int.prefix_45({Self: Int, Self: Int}, n))) : this.$info.Self.infix_43({Self: this.$info.Self, Self: this.$info.Self}, this, _create(this.$info.Self, 'init', {Self: this.$info.Self, T: Int}, n)));
}
};
{
if((Bool.infix_61_61({Self: Bool}, this.$info.Self.infix_60({Self: this.$info.Self, Self: this.$info.Self}, this, _create(this.$info.Self, 'initIntegerLiteral', {Self: this.$info.Self}, 0)), Int.infix_60({Self: Int, Self: Int, Other: this.$info.Self}, n, _create(this.$info.Self, 'initIntegerLiteral', {Self: this.$info.Self}, 0))))) {
return this.$info.Self.infix_43({Self: this.$info.Self, Self: this.$info.Self}, this, _create(this.$info.Self, 'init', {Self: this.$info.Self, T: Int}, n));
}
};
return (this.$info.Self.Magnitude.infix_60({Self: this.$info.Self.Magnitude, Self: this.$info.Self.Magnitude, Other: UInt}, this.magnitude, n.magnitude) ? _create(this.$info.Self, 'init', {Self: this.$info.Self, T: Int}, Int.infix_43({Self: Int}, _create(Int, 'init', {Self: Int, T: this.$info.Self}, this), n)) : this.$info.Self.infix_43({Self: this.$info.Self, Self: this.$info.Self}, this, _create(this.$info.Self, 'init', {Self: this.$info.Self, T: Int}, n)))
----Swift.(file).BinaryInteger.==infix(_:Self,_:Other)
const lhsNegative = Bool.infix_38_38({Self: Bool}, $info.Self.isSigned, () => $info.Self.infix_60({Self: $info.Self, Self: $info.Self}, lhs, _create($info.Self, 'initIntegerLiteral', {Self: $info.Self}, 0)));
const rhsNegative = Bool.infix_38_38({Self: Bool}, $info.Other.isSigned, () => $info.Other.infix_60({Self: $info.Other, Self: $info.Other}, rhs, _create($info.Other, 'initIntegerLiteral', {Self: $info.Other}, 0)));
{
if((Bool.infix_33_61({Self: Bool, Self: Bool}, lhsNegative, rhsNegative))) {
return false;
}
};
{
if((Int.infix_60({Self: Int}, lhs.bitWidth, rhs.bitWidth))) {
return $info.Other.infix_61_61({Self: $info.Other, Self: $info.Other}, _create($info.Other, 'initTruncatingIfNeeded', {Self: $info.Other, T: $info.Self}, lhs), rhs);
}
};
{
if((Int.infix_62({Self: Int}, lhs.bitWidth, rhs.bitWidth))) {
return $info.Self.infix_61_61({Self: $info.Self, Self: $info.Self}, lhs, _create($info.Self, 'initTruncatingIfNeeded', {Self: $info.Self, T: $info.Other}, rhs));
}
};
{
if(($info.Self.isSigned)) {
return $info.Other.infix_61_61({Self: $info.Other, Self: $info.Other}, _create($info.Other, 'initTruncatingIfNeeded', {Self: $info.Other, T: $info.Self}, lhs), rhs);
}
};
return $info.Self.infix_61_61({Self: $info.Self, Self: $info.Self}, lhs, _create($info.Self, 'initTruncatingIfNeeded', {Self: $info.Self, T: $info.Other}, rhs))
----Swift.(file).BinaryInteger.!=infix(_:Self,_:Other)
return Bool.prefix_33({Self: Bool}, $info.Self.infix_61_61({Self: $info.Self, Self: $info.Self, Other: $info.Other}, lhs, rhs))
----Swift.(file).BinaryInteger.<infix(_:Self,_:Other)
const lhsNegative = Bool.infix_38_38({Self: Bool}, $info.Self.isSigned, () => $info.Self.infix_60({Self: $info.Self, Self: $info.Self}, lhs, _create($info.Self, 'initIntegerLiteral', {Self: $info.Self}, 0)));
const rhsNegative = Bool.infix_38_38({Self: Bool}, $info.Other.isSigned, () => $info.Other.infix_60({Self: $info.Other, Self: $info.Other}, rhs, _create($info.Other, 'initIntegerLiteral', {Self: $info.Other}, 0)));
{
if((Bool.infix_33_61({Self: Bool, Self: Bool}, lhsNegative, rhsNegative))) {
return lhsNegative;
}
};
{
if((Bool.infix_38_38({Self: Bool}, $info.Self.infix_61_61({Self: $info.Self, Self: $info.Self}, lhs, _create($info.Self, 'initIntegerLiteral', {Self: $info.Self}, 0)), () => $info.Other.infix_61_61({Self: $info.Other, Self: $info.Other}, rhs, _create($info.Other, 'initIntegerLiteral', {Self: $info.Other}, 0))))) {
return false;
}
};
const rhsAsSelf = _create($info.Self, 'initTruncatingIfNeeded', {Self: $info.Self, T: $info.Other}, rhs);
const rhsAsSelfNegative = $info.Self.infix_60({Self: $info.Self, Self: $info.Self}, rhsAsSelf, _create($info.Self, 'initIntegerLiteral', {Self: $info.Self}, 0));
{
if((Bool.infix_38_38({Self: Bool}, $info.Other.infix_61_61({Self: $info.Other, Self: $info.Other}, _create($info.Other, 'initTruncatingIfNeeded', {Self: $info.Other, T: $info.Self}, rhsAsSelf), rhs), () => Bool.infix_61_61({Self: Bool}, rhsNegative, rhsAsSelfNegative)))) {
return $info.Self.infix_60({Self: $info.Self, Self: $info.Self}, lhs, rhsAsSelf);
}
};
return $info.Other.infix_60({Self: $info.Other, Self: $info.Other}, _create($info.Other, 'initTruncatingIfNeeded', {Self: $info.Other, T: $info.Self}, lhs), rhs)
----Swift.(file).BinaryInteger.<=infix(_:Self,_:Other)
return Bool.prefix_33({Self: Bool}, $info.Other.infix_60({Self: $info.Other, Self: $info.Other, Other: $info.Self}, rhs, lhs))
----Swift.(file).BinaryInteger.>=infix(_:Self,_:Other)
return Bool.prefix_33({Self: Bool}, $info.Self.infix_60({Self: $info.Self, Self: $info.Self, Other: $info.Other}, lhs, rhs))
----Swift.(file).BinaryInteger.>infix(_:Self,_:Other)
return $info.Other.infix_60({Self: $info.Other, Self: $info.Other, Other: $info.Self}, rhs, lhs)
----Swift.(file).BinaryInteger.!=infix(_:Self,_:Self)
return Bool.prefix_33({Self: Bool}, $info.Self.infix_61_61({Self: $info.Self, Self: $info.Self}, lhs, rhs))
----Swift.(file).BinaryInteger.<=infix(_:Self,_:Self)
return Bool.prefix_33({Self: Bool}, $info.Self.infix_60({Self: $info.Self, Self: $info.Self}, rhs, lhs))
----Swift.(file).BinaryInteger.>=infix(_:Self,_:Self)
return Bool.prefix_33({Self: Bool}, $info.Self.infix_60({Self: $info.Self, Self: $info.Self}, lhs, rhs))
----Swift.(file).BinaryInteger.>infix(_:Self,_:Self)
return $info.Self.infix_60({Self: $info.Self, Self: $info.Self}, rhs, lhs)
----Swift.(file).FixedWidthInteger.bitWidth
return this.$info.Self.bitWidth
----Swift.(file).FixedWidthInteger.init(littleEndian:Self)
$info.$setThis(_cloneStruct(value));
return
----Swift.(file).FixedWidthInteger.init(bigEndian:Self)
$info.$setThis(_cloneStruct(value.byteSwapped));
return
----Swift.(file).FixedWidthInteger.littleEndian
return this
----Swift.(file).FixedWidthInteger.bigEndian
return this.byteSwapped
----Swift.(file).FixedWidthInteger.&>>infix(_:Self,_:Self)
let lhs_dupl = lhs;
$info.Self.infix_38_62_62_61({Self: $info.Self, Self: $info.Self}, {get: () => lhs_dupl, set: $val => lhs_dupl = $val}, rhs);
return lhs_dupl
----Swift.(file).FixedWidthInteger.&>>infix(_:Self,_:Other)
return $info.Self.infix_38_62_62({Self: $info.Self, Self: $info.Self}, lhs, _create($info.Self, 'initTruncatingIfNeeded', {Self: $info.Self, T: $info.Other}, rhs))
----Swift.(file).FixedWidthInteger.&>>=infix(_:Self,_:Other)
let lhs = lhs$inout.get()
const $result = (() => {
lhs = $info.Self.infix_38_62_62({Self: $info.Self, Self: $info.Self, Other: $info.Other}, lhs, rhs);})()
lhs$inout.set(lhs)
return $result
----Swift.(file).FixedWidthInteger.&<<infix(_:Self,_:Self)
let lhs_dupl = lhs;
$info.Self.infix_38_60_60_61({Self: $info.Self, Self: $info.Self}, {get: () => lhs_dupl, set: $val => lhs_dupl = $val}, rhs);
return lhs_dupl
----Swift.(file).FixedWidthInteger.&<<infix(_:Self,_:Other)
return $info.Self.infix_38_60_60({Self: $info.Self, Self: $info.Self}, lhs, _create($info.Self, 'initTruncatingIfNeeded', {Self: $info.Self, T: $info.Other}, rhs))
----Swift.(file).FixedWidthInteger.&<<=infix(_:Self,_:Other)
let lhs = lhs$inout.get()
const $result = (() => {
lhs = $info.Self.infix_38_60_60({Self: $info.Self, Self: $info.Self, Other: $info.Other}, lhs, rhs);})()
lhs$inout.set(lhs)
return $result
----Swift.(file).FixedWidthInteger.random(in:Range<Self>,using:T)
let generator = generator$inout.get()
const $result = (() => {
preconditionFileLine({}, () => Bool.prefix_33({Self: Bool}, range.isEmpty), () => "Can't get random value with an empty range", '?3', '?3');
const delta = _create($info.Self.Magnitude, 'initTruncatingIfNeeded', {Self: $info.Self.Magnitude, T: $info.Self}, $info.Self.infix_38_45({Self: $info.Self, Self: $info.Self}, range.upperBound, range.lowerBound));
return _create($info.Self, 'initTruncatingIfNeeded', {Self: $info.Self, T: $info.Self.Magnitude}, $info.Self.Magnitude.infix_38_43({Self: $info.Self.Magnitude, Self: $info.Self.Magnitude}, _create($info.Self.Magnitude, 'initTruncatingIfNeeded', {Self: $info.Self.Magnitude, T: $info.Self}, range.lowerBound), generator.nextUpperBound({$setThis: $val => generator = $val, Self: $info.T, T: $info.Self.Magnitude}, delta)));})()
generator$inout.set(generator)
return $result
----Swift.(file).FixedWidthInteger.random(in:Range<Self>)
let g = _create(SystemRandomNumberGenerator, 'init', {}, );
return $info.Self.randomInUsing({Self: $info.Self, Self: $info.Self, T: SystemRandomNumberGenerator}, range, {get: () => g, set: $val => g = $val})
----Swift.(file).FixedWidthInteger.random(in:ClosedRange<Self>,using:T)
let generator = generator$inout.get()
const $result = (() => {
preconditionFileLine({}, () => Bool.prefix_33({Self: Bool}, range.isEmpty), () => "Can't get random value with an empty range", '?3', '?3');
let delta = _create($info.Self.Magnitude, 'initTruncatingIfNeeded', {Self: $info.Self.Magnitude, T: $info.Self}, $info.Self.infix_38_45({Self: $info.Self, Self: $info.Self}, range.upperBound, range.lowerBound));
{
if(($info.Self.Magnitude.infix_61_61({Self: $info.Self.Magnitude, Self: $info.Self.Magnitude}, delta, $info.Self.Magnitude.max))) {
return _create($info.Self, 'initTruncatingIfNeeded', {Self: $info.Self, T: $info.Self.Magnitude}, generator.next({$setThis: $val => generator = $val, Self: $info.T, T: $info.Self.Magnitude}, ));
}
};
$info.Self.Magnitude.infix_43_61({Self: $info.Self.Magnitude, Self: $info.Self.Magnitude}, {get: () => delta, set: $val => delta = $val}, _create($info.Self.Magnitude, 'initIntegerLiteral', {Self: $info.Self.Magnitude}, 1));
return _create($info.Self, 'initTruncatingIfNeeded', {Self: $info.Self, T: $info.Self.Magnitude}, $info.Self.Magnitude.infix_38_43({Self: $info.Self.Magnitude, Self: $info.Self.Magnitude}, _create($info.Self.Magnitude, 'initTruncatingIfNeeded', {Self: $info.Self.Magnitude, T: $info.Self}, range.lowerBound), generator.nextUpperBound({$setThis: $val => generator = $val, Self: $info.T, T: $info.Self.Magnitude}, delta)));})()
generator$inout.set(generator)
return $result
----Swift.(file).FixedWidthInteger.random(in:ClosedRange<Self>)
let g = _create(SystemRandomNumberGenerator, 'init', {}, );
return $info.Self.randomInUsing({Self: $info.Self, Self: $info.Self, T: SystemRandomNumberGenerator}, range, {get: () => g, set: $val => g = $val})
----Swift.(file).FixedWidthInteger.~prefix(_:Self)
return $info.Self.infix_38_45({Self: $info.Self, Self: $info.Self}, $info.Self.infix_38_45({Self: $info.Self, Self: $info.Self}, _create($info.Self, 'initIntegerLiteral', {Self: $info.Self}, 0), x), _create($info.Self, 'initIntegerLiteral', {Self: $info.Self}, 1))
----Swift.(file).FixedWidthInteger.>>infix(_:Self,_:Other)
let lhs_dupl = lhs;
this._nonMaskingRightShiftGeneric({Self: $info.Self, Self: $info.Self, Other: $info.Other}, {get: () => lhs_dupl, set: $val => lhs_dupl = $val}, rhs);
return lhs_dupl
----Swift.(file).FixedWidthInteger.>>=infix(_:Self,_:Other)
let lhs = lhs$inout.get()
const $result = (() => {
this._nonMaskingRightShiftGeneric({Self: $info.Self, Self: $info.Self, Other: $info.Other}, {get: () => lhs, set: $val => lhs = $val}, rhs);})()
lhs$inout.set(lhs)
return $result
----Swift.(file).FixedWidthInteger.<<infix(_:Self,_:Other)
let lhs_dupl = lhs;
this._nonMaskingLeftShiftGeneric({Self: $info.Self, Self: $info.Self, Other: $info.Other}, {get: () => lhs_dupl, set: $val => lhs_dupl = $val}, rhs);
return lhs_dupl
----Swift.(file).FixedWidthInteger.<<=infix(_:Self,_:Other)
let lhs = lhs$inout.get()
const $result = (() => {
this._nonMaskingLeftShiftGeneric({Self: $info.Self, Self: $info.Self, Other: $info.Other}, {get: () => lhs, set: $val => lhs = $val}, rhs);})()
lhs$inout.set(lhs)
return $result
----Swift.(file).FixedWidthInteger.init(truncatingIfNeeded:T)
{
if((Int.infix_60_61({Self: Int}, $info.Self.bitWidth, Int.bitWidth))) {
$info.$setThis(_cloneStruct(_create($info.Self, 'init_truncatingBitsUInt', {Self: $info.Self}, source._lowWord)));
}
else {
const neg = $info.T.infix_60({Self: $info.T, Self: $info.T}, source, _create($info.T, 'initIntegerLiteral', {Self: $info.T}, 0));
let result = (neg ? $info.Self.prefix_126({Self: $info.Self, Self: $info.Self}, _create($info.Self, 'initIntegerLiteral', {Self: $info.Self}, 0)) : _create($info.Self, 'initIntegerLiteral', {Self: $info.Self}, 0));
let shift = _create($info.Self, 'initIntegerLiteral', {Self: $info.Self}, 0);
const width = _create($info.Self, 'init_truncatingBitsUInt', {Self: $info.Self}, $info.Self.bitWidth._lowWord);
{
let $word$generator = source.words.makeIterator({Self: $info.T.Words}, );
while(true) {
const word = $word$generator.next({$setThis: $val => $word$generator = $val, Self: $info.T.Words.Iterator}, );
if(!((word != null))) break;
{
if(!(($info.Self.infix_60({Self: $info.Self, Self: $info.Self}, shift, width)))) {
break;
}
};
$info.Self.infix_94_61({Self: $info.Self, Self: $info.Self}, {get: () => result, set: $val => result = $val}, $info.Self.infix_38_60_60({Self: $info.Self, Self: $info.Self}, _create($info.Self, 'init_truncatingBitsUInt', {Self: $info.Self}, (neg ? UInt.prefix_126({Self: UInt, Self: UInt}, word) : word)), shift));
$info.Self.infix_43_61({Self: $info.Self, Self: $info.Self}, {get: () => shift, set: $val => shift = $val}, _create($info.Self, 'init_truncatingBitsUInt', {Self: $info.Self}, Int.bitWidth._lowWord));
}
};
$info.$setThis(_cloneStruct(result));
}
};
return
----Swift.(file).FixedWidthInteger.&+infix(_:Self,_:Self)
return lhs.addingReportingOverflow({Self: $info.Self}, rhs)["0"]
----Swift.(file).FixedWidthInteger.&+=infix(_:Self,_:Self)
let lhs = lhs$inout.get()
const $result = (() => {
lhs = $info.Self.infix_38_43({Self: $info.Self, Self: $info.Self}, lhs, rhs);})()
lhs$inout.set(lhs)
return $result
----Swift.(file).FixedWidthInteger.&-infix(_:Self,_:Self)
return lhs.subtractingReportingOverflow({Self: $info.Self}, rhs)["0"]
----Swift.(file).FixedWidthInteger.&-=infix(_:Self,_:Self)
let lhs = lhs$inout.get()
const $result = (() => {
lhs = $info.Self.infix_38_45({Self: $info.Self, Self: $info.Self}, lhs, rhs);})()
lhs$inout.set(lhs)
return $result
----Swift.(file).FixedWidthInteger.&*infix(_:Self,_:Self)
return lhs.multipliedReportingOverflowBy({Self: $info.Self}, rhs)["0"]
----Swift.(file).FixedWidthInteger.&*=infix(_:Self,_:Self)
let lhs = lhs$inout.get()
const $result = (() => {
lhs = $info.Self.infix_38_42({Self: $info.Self, Self: $info.Self}, lhs, rhs);})()
lhs$inout.set(lhs)
return $result
----Swift.(file).UnsignedInteger.magnitude
return this
----Swift.(file).UnsignedInteger.isSigned
return false;
}
static get isSigned() { return this.isSigned$get()
----Swift.(file).UnsignedInteger.init(_:T)
{
if(($info.T.isSigned)) {
preconditionFileLine({}, () => $info.T.infix_62_61({Self: $info.T, Self: $info.T}, source, _create($info.T, 'initIntegerLiteral', {Self: $info.T}, 0)), () => "Negative value is not representable", '?3', '?3');
}
};
{
if((Int.infix_62_61({Self: Int}, source.bitWidth, $info.Self.bitWidth))) {
preconditionFileLine({}, () => $info.T.infix_60_61({Self: $info.T, Self: $info.T, Other: $info.Self}, source, $info.Self.max), () => "Not enough bits to represent the passed value", '?3', '?3');
}
};
this.initTruncatingIfNeeded({}, source);
return
----Swift.(file).UnsignedInteger.init(exactly:T)
{
if((Bool.infix_38_38({Self: Bool}, $info.T.isSigned, () => $info.T.infix_60({Self: $info.T, Self: $info.T}, source, _create($info.T, 'initIntegerLiteral', {Self: $info.T}, 0))))) {
return (this.$failed = true);
}
};
{
if((Bool.infix_38_38({Self: Bool}, Int.infix_62_61({Self: Int}, source.bitWidth, $info.Self.bitWidth), () => $info.T.infix_62({Self: $info.T, Self: $info.T, Other: $info.Self}, source, $info.Self.max)))) {
return (this.$failed = true);
}
};
this.initTruncatingIfNeeded({}, source);
return
----Swift.(file).UnsignedInteger.max
return $info.Self.prefix_126({Self: $info.Self, Self: $info.Self}, _create($info.Self, 'initIntegerLiteral', {Self: $info.Self}, 0));
}
static get max() { return this.max$get()
----Swift.(file).UnsignedInteger.min
return _create($info.Self, 'initIntegerLiteral', {Self: $info.Self}, 0);
}
static get min() { return this.min$get()
----Swift.(file).SignedInteger.isSigned
return true;
}
static get isSigned() { return this.isSigned$get()
----Swift.(file).SignedInteger.init(_:T)
{
if((Bool.infix_38_38({Self: Bool}, $info.T.isSigned, () => Int.infix_62({Self: Int}, source.bitWidth, $info.Self.bitWidth)))) {
preconditionFileLine({}, () => $info.T.infix_62_61({Self: $info.T, Self: $info.T, Other: $info.Self}, source, $info.Self.min), () => "Not enough bits to represent a signed value", '?3', '?3');
}
};
{
if((Bool.infix_124_124({Self: Bool}, Int.infix_62({Self: Int}, source.bitWidth, $info.Self.bitWidth), () => Bool.infix_38_38({Self: Bool}, Int.infix_61_61({Self: Int}, source.bitWidth, $info.Self.bitWidth), () => Bool.prefix_33({Self: Bool}, $info.T.isSigned))))) {
preconditionFileLine({}, () => $info.T.infix_60_61({Self: $info.T, Self: $info.T, Other: $info.Self}, source, $info.Self.max), () => "Not enough bits to represent the passed value", '?3', '?3');
}
};
this.initTruncatingIfNeeded({}, source);
return
----Swift.(file).SignedInteger.init(exactly:T)
{
if((Bool.infix_38_38({Self: Bool}, Bool.infix_38_38({Self: Bool}, $info.T.isSigned, () => Int.infix_62({Self: Int}, source.bitWidth, $info.Self.bitWidth)), () => $info.T.infix_60({Self: $info.T, Self: $info.T, Other: $info.Self}, source, $info.Self.min)))) {
return (this.$failed = true);
}
};
{
if((Bool.infix_38_38({Self: Bool}, Bool.infix_124_124({Self: Bool}, Int.infix_62({Self: Int}, source.bitWidth, $info.Self.bitWidth), () => Bool.infix_38_38({Self: Bool}, Int.infix_61_61({Self: Int}, source.bitWidth, $info.Self.bitWidth), () => Bool.prefix_33({Self: Bool}, $info.T.isSigned))), () => $info.T.infix_62({Self: $info.T, Self: $info.T, Other: $info.Self}, source, $info.Self.max)))) {
return (this.$failed = true);
}
};
this.initTruncatingIfNeeded({}, source);
return
----Swift.(file).SignedInteger.max
return $info.Self.prefix_126({Self: $info.Self, Self: $info.Self}, this.min);
}
static get max() { return this.max$get()
----Swift.(file).SignedInteger.min
return $info.Self.infix_38_60_60({Self: $info.Self, Self: $info.Self}, _create($info.Self, 'initIntegerLiteral', {Self: $info.Self}, -1), $info.Self._highBitIndex);
}
static get min() { return this.min$get()
----Swift.(file).SignedInteger.isMultiple(of:Self)
{
if((this.$info.Self.infix_61_61({Self: this.$info.Self, Self: this.$info.Self, Other: Int}, other, 0))) {
return this.$info.Self.infix_61_61({Self: this.$info.Self, Self: this.$info.Self, Other: Int}, this, 0);
}
};
{
if((this.$info.Self.infix_61_61({Self: this.$info.Self, Self: this.$info.Self, Other: Int}, other, -1))) {
return true;
}
};
return this.$info.Self.infix_61_61({Self: this.$info.Self, Self: this.$info.Self, Other: Int}, this.$info.Self.infix_37({Self: this.$info.Self, Self: this.$info.Self}, this, other), 0)
----Swift.(file).numericCast(_:T)
return _create($info.U, 'init', {Self: $info.U, T: $info.T}, x)
----Swift.(file).FixedWidthInteger.>>infix(_:Self,_:Self)
let lhs_dupl = lhs;
this._nonMaskingRightShiftGeneric({Self: $info.Self, Self: $info.Self, Other: $info.Self}, {get: () => lhs_dupl, set: $val => lhs_dupl = $val}, rhs);
return lhs_dupl
----Swift.(file).FixedWidthInteger.>>=infix(_:Self,_:Self)
let lhs = lhs$inout.get()
const $result = (() => {
this._nonMaskingRightShiftGeneric({Self: $info.Self, Self: $info.Self, Other: $info.Self}, {get: () => lhs, set: $val => lhs = $val}, rhs);})()
lhs$inout.set(lhs)
return $result
----Swift.(file).FixedWidthInteger.<<infix(_:Self,_:Self)
let lhs_dupl = lhs;
this._nonMaskingLeftShiftGeneric({Self: $info.Self, Self: $info.Self, Other: $info.Self}, {get: () => lhs_dupl, set: $val => lhs_dupl = $val}, rhs);
return lhs_dupl
----Swift.(file).FixedWidthInteger.<<=infix(_:Self,_:Self)
let lhs = lhs$inout.get()
const $result = (() => {
this._nonMaskingLeftShiftGeneric({Self: $info.Self, Self: $info.Self, Other: $info.Self}, {get: () => lhs, set: $val => lhs = $val}, rhs);})()
lhs$inout.set(lhs)
return $result
----Swift.(file).FixedWidthInteger.addWithOverflow(_:Self,_:Self)
const $tuple = lhs.addingReportingOverflow({Self: $info.Self}, rhs), partialValue = $tuple && $tuple[0], overflow = $tuple && $tuple[1];
return {0: partialValue, 1: overflow}
----Swift.(file).FixedWidthInteger.subtractWithOverflow(_:Self,_:Self)
const $tuple = lhs.subtractingReportingOverflow({Self: $info.Self}, rhs), partialValue = $tuple && $tuple[0], overflow = $tuple && $tuple[1];
return {0: partialValue, 1: overflow}
----Swift.(file).FixedWidthInteger.multiplyWithOverflow(_:Self,_:Self)
const $tuple = lhs.multipliedReportingOverflowBy({Self: $info.Self}, rhs), partialValue = $tuple && $tuple[0], overflow = $tuple && $tuple[1];
return {0: partialValue, 1: overflow}
----Swift.(file).FixedWidthInteger.divideWithOverflow(_:Self,_:Self)
const $tuple = lhs.dividedReportingOverflowBy({Self: $info.Self}, rhs), partialValue = $tuple && $tuple[0], overflow = $tuple && $tuple[1];
return {0: partialValue, 1: overflow}
----Swift.(file).FixedWidthInteger.remainderWithOverflow(_:Self,_:Self)
const $tuple = lhs.remainderReportingOverflowDividingBy({Self: $info.Self}, rhs), partialValue = $tuple && $tuple[0], overflow = $tuple && $tuple[1];
return {0: partialValue, 1: overflow}
----Swift.(file).BinaryInteger.addWithOverflow(_:Self,_:Self)
fatalErrorFileLine({}, () => "Unavailable", '?3', '?3')
----Swift.(file).BinaryInteger.subtractWithOverflow(_:Self,_:Self)
fatalErrorFileLine({}, () => "Unavailable", '?3', '?3')
----Swift.(file).BinaryInteger.multiplyWithOverflow(_:Self,_:Self)
fatalErrorFileLine({}, () => "Unavailable", '?3', '?3')
----Swift.(file).BinaryInteger.divideWithOverflow(_:Self,_:Self)
fatalErrorFileLine({}, () => "Unavailable", '?3', '?3')
----Swift.(file).BinaryInteger.remainderWithOverflow(_:Self,_:Self)
fatalErrorFileLine({}, () => "Unavailable", '?3', '?3')
----Swift.(file).SignedInteger.&+infix(_:Self,_:Self)
return this._maskingAdd({Self: $info.Self, Self: $info.Self}, lhs, rhs)
----Swift.(file).SignedInteger.&-infix(_:Self,_:Self)
return this._maskingSubtract({Self: $info.Self, Self: $info.Self}, lhs, rhs)
----Swift.(file).SignedInteger.&+infix(_:Self,_:Self)
return this._maskingAdd({Self: $info.Self, Self: $info.Self}, lhs, rhs)
----Swift.(file).SignedInteger.&-infix(_:Self,_:Self)
return this._maskingSubtract({Self: $info.Self, Self: $info.Self}, lhs, rhs)
----Swift.(file).Sequence.joined(separator:Separator)
return _create(JoinedSequence, 'initBaseSeparator', {Base: $info.Self, Separator: $info.Separator}, this, separator)
----Swift.(file).AnyKeyPath.hashValue
return _hashValueFor({H: AnyKeyPath}, this)
----Swift.(file).KeyValuePairs.startIndex
return 0
----Swift.(file).LazyCollectionProtocol.lazy
return this._elements.lazy
----Swift.(file).LazyCollectionProtocol.lazy
return this._elements
----Swift.(file).LazySequenceProtocol.lazy
return this._elements.lazy
----Swift.(file).LazySequenceProtocol.lazy
return this._elements
----Swift.(file).withExtendedLifetime(_:T,_:() throws -> Result)
let $defer = () => {
_fixLifetime({T: $info.T}, x);
}
try {;
return body({}, );}catch($error){$defer({T: $info.T, Result: $info.Result}, );throw $error}$defer({T: $info.T, Result: $info.Result}, )
----Swift.(file).withExtendedLifetime(_:T,_:(T) throws -> Result)
let $defer = () => {
_fixLifetime({T: $info.T}, x);
}
try {;
return body({}, x);}catch($error){$defer({T: $info.T, Result: $info.Result}, );throw $error}$defer({T: $info.T, Result: $info.Result}, )
----Swift.(file).ManagedBuffer.withUnsafeMutablePointerToHeader(_:(UnsafeMutablePointer<Header>) throws -> R)
return this.withUnsafeMutablePointers({Header: $info.Header, Element: $info.Element, R: $info.R}, (($info, v, _) => body({}, v)))
----Swift.(file).ManagedBuffer.withUnsafeMutablePointerToElements(_:(UnsafeMutablePointer<Element>) throws -> R)
return this.withUnsafeMutablePointers({Header: $info.Header, Element: $info.Element, R: $info.R}, (($info, $0, $1) => body({}, $1)))
----Swift.(file).ManagedBufferPointer.withUnsafeMutablePointerToHeader(_:(UnsafeMutablePointer<Header>) throws -> R)
return this.withUnsafeMutablePointers({Header: $info.Header, Element: $info.Element, R: $info.R}, (($info, v, _) => body({}, v)))
----Swift.(file).ManagedBufferPointer.withUnsafeMutablePointerToElements(_:(UnsafeMutablePointer<Element>) throws -> R)
return this.withUnsafeMutablePointers({Header: $info.Header, Element: $info.Element, R: $info.R}, (($info, $0, $1) => body({}, $1)))
----Swift.(file).MemoryLayout.size(ofValue:T)
return MemoryLayout.size
----Swift.(file).MemoryLayout.stride(ofValue:T)
return MemoryLayout.stride
----Swift.(file).MemoryLayout.alignment(ofValue:T)
return MemoryLayout.alignment
----Swift.(file).Range.init(_:Range<Bound>)
$info.$setThis(_cloneStruct(_cloneStruct(other)));
return
----Swift.(file).ClosedRange.init(_:ClosedRange<Bound>)
$info.$setThis(_cloneStruct(_cloneStruct(other)));
return
----Swift.(file).LazySequenceProtocol.flatMap(_:(Self.Elements.Element) -> ElementOfResult?)
return this.compactMap({Self: $info.Self, ElementOfResult: $info.ElementOfResult}, transform)
----Swift.(file).String.characters
return this
----Swift.(file).String.withMutableCharacters(_:(inout String) -> R)
return body({}, {get: () => this, set: $val => $info.$setThis(_cloneStruct($val))})
----Swift.(file).UnicodeScalarView.customPlaygroundQuickLook
return _PlaygroundQuickLook._text({}, this.description)
----Swift.(file).UTF16View.customPlaygroundQuickLook
return _PlaygroundQuickLook._text({}, this.description)
----Swift.(file).UTF8View.customPlaygroundQuickLook
return _PlaygroundQuickLook._text({}, this.description)
----Swift.(file).Substring.characters
return this
----Swift.(file).Substring.withMutableCharacters(_:(inout Substring) -> R)
return body({}, {get: () => this, set: $val => $info.$setThis(_cloneStruct($val))})
----Swift.(file).Substring.customPlaygroundQuickLook
return _create(String, 'initSubstring', {}, this).customPlaygroundQuickLook
----Swift.(file).Collection.index(_:Self.Index,offsetBy:T)
return this.indexOffsetBy({Self: $info.Self}, i, _create(Int, 'init', {Self: Int, T: $info.T}, n))
----Swift.(file).Collection.formIndex(_:Self.Index,offsetBy:T)
let i = i$inout.get()
const $result = (() => {
return this.formIndexOffsetBy({Self: $info.Self}, {get: () => i, set: $val => i = $val}, _create(Int, 'init', {Self: Int, T: $info.T}, n));})()
i$inout.set(i)
return $result
----Swift.(file).Collection.index(_:Self.Index,offsetBy:T,limitedBy:Self.Index)
return this.indexOffsetByLimitedBy({Self: $info.Self}, i, _create(Int, 'init', {Self: Int, T: $info.T}, n), limit)
----Swift.(file).Collection.formIndex(_:Self.Index,offsetBy:T,limitedBy:Self.Index)
let i = i$inout.get()
const $result = (() => {
return this.formIndexOffsetByLimitedBy({Self: $info.Self}, {get: () => i, set: $val => i = $val}, _create(Int, 'init', {Self: Int, T: $info.T}, n), limit);})()
i$inout.set(i)
return $result
----Swift.(file).Collection.distance(from:Self.Index,to:Self.Index)
return numericCast({T: Int, U: $info.T}, this.distanceFromTo({Self: $info.Self}, start, end))
----Swift.(file).UnsafeMutablePointer.initialize(to:Pointee,count:Int)
this.initializeRepeatingCount({Pointee: this.$info.Pointee}, newValue, count)
----Swift.(file).UnsafeMutablePointer.deinitialize()
return this.deinitializeCount({Pointee: this.$info.Pointee}, 1)
----Swift.(file).UnsafeMutablePointer.deallocate(capacity:Int)
this.deallocate({Pointee: this.$info.Pointee}, )
----Swift.(file).UnsafeMutablePointer.initialize(from:C)
const buf = _create(UnsafeMutableBufferPointer, 'initStartOptionalCountInt', {Element: $info.Pointee}, /*pointer_to_pointer*/this, numericCast({T: Int, U: Int}, source.count));
let $tuple = source._copyContentsInitializing({Self: $info.C}, buf), remainders = $tuple && $tuple[0], writtenUpTo = $tuple && $tuple[1];
preconditionFileLine({}, () => Optional.infix_61_61({Self: Optional, Wrapped: $info.Pointee}, remainders.next({$setThis: $val => remainders = $val, Self: $info.C.Iterator}, ), null), () => "rhs underreported its count", '?3', '?3');
preconditionFileLine({}, () => Int.infix_61_61({Self: Int}, writtenUpTo, buf.endIndex), () => "rhs overreported its count", '?3', '?3')
----Swift.(file).UnsafeMutableRawPointer.allocate(bytes:Int,alignedTo:Int)
return UnsafeMutableRawPointer.allocateByteCountAlignment({Self: UnsafeMutableRawPointer}, size, alignment)
----Swift.(file).UnsafeMutableRawPointer.deallocate(bytes:Int,alignedTo:Int)
this.deallocate({}, )
----Swift.(file).UnsafeMutableRawPointer.copyBytes(from:UnsafeRawPointer,count:Int)
this.copyMemoryFromByteCount({}, source, count)
----Swift.(file).UnsafeMutableRawPointer.initializeMemory(as:T.Type,at:Int,count:Int,to:T)
return UnsafeMutableRawPointer.infix_43({Self: UnsafeMutableRawPointer, Self: UnsafeMutableRawPointer}, this, Int.infix_42({Self: Int}, offset, MemoryLayout.stride)).initializeMemoryAsRepeatingCount({T: $info.T}, type, repeatedValue, count)
----Swift.(file).UnsafeMutableRawPointer.initializeMemory(as:C.Element.Type,from:C)
let ptr = _cloneStruct(this);
{
let $element$generator = source.makeIterator({Self: $info.C}, );
while(true) {
const _element = $element$generator.next({$setThis: $val => $element$generator = $val, Self: $info.C.Iterator}, );
if(!((_element != null))) break;
ptr.initializeMemoryAsRepeatingCount({T: $info.C.Element}, $info.C.Element, _element, 1);
UnsafeMutableRawPointer.infix_43_61({Self: UnsafeMutableRawPointer, Self: UnsafeMutableRawPointer}, {get: () => ptr, set: $val => ptr = $val}, MemoryLayout.stride);
}
};
return _create(UnsafeMutablePointer, 'initRawPointer', {Pointee: $info.C.Element}, this._rawValue)
----Swift.(file).UnsafeMutableRawBufferPointer.allocate(count:Int)
return UnsafeMutableRawBufferPointer.allocateByteCountAlignment({Self: UnsafeMutableRawBufferPointer}, count, MemoryLayout.alignment)
----Swift.(file).UnsafeMutableRawBufferPointer.copyBytes(from:UnsafeRawBufferPointer)
this.copyMemoryFrom({}, source)
----Swift.(file).Sequence.flatMap(_:(Self.Element) throws -> ElementOfResult?)
return this._compactMap({Self: $info.Self, ElementOfResult: $info.ElementOfResult}, transform)
----Swift.(file).Sequence.flatMap(_:(Self.Element) throws -> String)
return this.mapSwift({Self: this.$info.Self, T: String}, transform)
----Swift.(file).Collection.flatMap(_:(Self.Element) throws -> String?)
return this._compactMap({Self: this.$info.Self, ElementOfResult: String}, transform)
----Swift.(file).Collection.index(where:(Self.Element) throws -> Bool)
return this.firstIndexWhere({Self: this.$info.Self}, _predicate)
----Swift.(file).Collection.index(of:Self.Element)
return this.firstIndexOf({Self: this.$info.Self}, _element)
----Swift.(file).MutableCollection.withContiguousMutableStorageIfAvailable(_:(inout UnsafeMutableBufferPointer<Self.Element>) throws -> R)
return null
----Swift.(file).MutableCollection.swapAt(_:Self.Index,_:Self.Index)
{
if(!((this.$info.Self.Index.infix_33_61({Self: this.$info.Self.Index, Self: this.$info.Self.Index}, i, j)))) {
return ;
}
};
const tmp = this.subscript$get({}, i);
this.subscript$set({$setThis: $val => $info.$setThis(_cloneStruct($val))}, this.subscript$get({}, j), i);
this.subscript$set({$setThis: $val => $info.$setThis(_cloneStruct($val))}, tmp, j)
----Swift.(file)._SwiftNewtypeWrapper.hashValue
return this.rawValue.hashValue
----Swift.(file)._SwiftNewtypeWrapper.hash(into:Hasher)
let hasher = hasher$inout.get()
const $result = (() => {
hasher.combine({$setThis: $val => hasher = $val, H: this.$info.Self.RawValue}, this.rawValue);})()
hasher$inout.set(hasher)
return $result
----Swift.(file).ObjectIdentifier.<infix(_:ObjectIdentifier,_:ObjectIdentifier)
return UInt.infix_60({Self: UInt}, _create(UInt, 'initBitPatternObjectIdentifier', {}, lhs), _create(UInt, 'initBitPatternObjectIdentifier', {}, rhs))
----Swift.(file).Int.init(bitPattern:ObjectIdentifier)
this.initBitPatternUInt({}, _create(UInt, 'initBitPatternObjectIdentifier', {}, objectID));
return
----Swift.(file).OptionSet.union(_:Self)
let r = _create(this.$info.Self, 'initRawValue', {Self: this.$info.Self}, this.rawValue);
r.formUnion({$setThis: $val => r = $val, Self: this.$info.Self}, other);
return r
----Swift.(file).OptionSet.intersection(_:Self)
let r = _create(this.$info.Self, 'initRawValue', {Self: this.$info.Self}, this.rawValue);
r.formIntersection({$setThis: $val => r = $val, Self: this.$info.Self}, other);
return r
----Swift.(file).OptionSet.symmetricDifference(_:Self)
let r = _create(this.$info.Self, 'initRawValue', {Self: this.$info.Self}, this.rawValue);
r.formSymmetricDifference({$setThis: $val => r = $val, Self: this.$info.Self}, other);
return r
----Swift.(file).OptionSet.contains(_:Self)
return this.isSupersetOf({Self: this.$info.Self}, member)
----Swift.(file).OptionSet.insert(_:Self.Element)
const oldMember = this.intersection({Self: this.$info.Self}, newMember);
const shouldInsert = this.$info.Self.infix_33_61({Self: this.$info.Self, Self: this.$info.Self}, oldMember, newMember);
const result = {0: shouldInsert, 1: (shouldInsert ? newMember : oldMember)};
{
if((shouldInsert)) {
this.formUnion({$setThis: $val => $info.$setThis(_cloneStruct($val)), Self: this.$info.Self}, newMember);
}
};
return result
----Swift.(file).OptionSet.remove(_:Self.Element)
const r = (this.isSupersetOf({Self: this.$info.Self}, member) ? _create(Optional, 'init', {Wrapped: this.$info.Self}, member) : null);
this.subtract({$setThis: $val => $info.$setThis(_cloneStruct($val)), Self: this.$info.Self}, member);
return r
----Swift.(file).OptionSet.update(with:Self.Element)
const r = this.intersection({Self: this.$info.Self}, newMember);
this.formUnion({$setThis: $val => $info.$setThis(_cloneStruct($val)), Self: this.$info.Self}, newMember);
return (r.isEmpty ? null : r)
----Swift.(file).OptionSet.init()
this.initRawValue({}, _create(this.$info.Self.RawValue, 'initIntegerLiteral', {Self: this.$info.Self.RawValue}, 0));
return
----Swift.(file).OptionSet.formUnion(_:Self)
$info.$setThis(_cloneStruct(_create(this.$info.Self, 'initRawValue', {Self: this.$info.Self}, this.$info.Self.RawValue.infix_124({Self: this.$info.Self.RawValue, Self: this.$info.Self.RawValue}, this.rawValue, other.rawValue))))
----Swift.(file).OptionSet.formIntersection(_:Self)
$info.$setThis(_cloneStruct(_create(this.$info.Self, 'initRawValue', {Self: this.$info.Self}, this.$info.Self.RawValue.infix_38({Self: this.$info.Self.RawValue, Self: this.$info.Self.RawValue}, this.rawValue, other.rawValue))))
----Swift.(file).OptionSet.formSymmetricDifference(_:Self)
$info.$setThis(_cloneStruct(_create(this.$info.Self, 'initRawValue', {Self: this.$info.Self}, this.$info.Self.RawValue.infix_94({Self: this.$info.Self.RawValue, Self: this.$info.Self.RawValue}, this.rawValue, other.rawValue))))
----Swift.(file).Optional.init(_:Wrapped)
$info.$setThis(_cloneStruct(Optional.some({Wrapped: this.$info.Wrapped}, some)));
return
----Swift.(file).Optional.map(_:(Wrapped) throws -> U)
const $match = this
if((($match.rawValue == Optional.some().rawValue))) {
const y = $match[0]
return Optional.some({Wrapped: $info.U}, transform({}, y));
}
else if((($match.rawValue == Optional.none.rawValue))) {
return null;
}
----Swift.(file).Optional.flatMap(_:(Wrapped) throws -> U?)
const $match = this
if((($match.rawValue == Optional.some().rawValue))) {
const y = $match[0]
return transform({}, y);
}
else if((($match.rawValue == Optional.none.rawValue))) {
return null;
}
----Swift.(file).Optional.init(nilLiteral:())
$info.$setThis(_cloneStruct(null));
return
----Swift.(file).Optional.unsafelyUnwrapped
{const x = this
if((x != null)) {
return x;
}
};
preconditionFailureFileLine({}, () => "unsafelyUnwrapped of nil optional", '?3', '?3')
----Swift.(file).Optional.debugDescription
const $match = this
if((($match.rawValue == Optional.some().rawValue))) {
const value = $match[0]
let result = "Optional(";
debugPrintSeparatorTerminatorTo({Target: String}, _create(Array, 'initBuffer', {Element: Array}, [value]), null, "", {get: () => result, set: $val => result = $val});
String.infix_43_61({Self: String}, {get: () => result, set: $val => result = $val}, ")");
return result;
}
else if((($match.rawValue == Optional.none.rawValue))) {
return "nil";
}
----Swift.(file).Optional.customMirror
const $match = this
if((($match.rawValue == Optional.some().rawValue))) {
const value = $match[0]
return _create(Mirror, 'initChildrenKeyValuePairsDisplayStyleOptionalAncestorRepresentationMirrorAncestorRepresentation', {Subject: _clarifyGenerics({Self:Optional, Wrapped: this.$info.Wrapped})}, this, new Map([["some", value]]), Mirror.DisplayStyle.optional, null);
}
else if((($match.rawValue == Optional.none.rawValue))) {
return _create(Mirror, 'initChildrenKeyValuePairsDisplayStyleOptionalAncestorRepresentationMirrorAncestorRepresentation', {Subject: _clarifyGenerics({Self:Optional, Wrapped: this.$info.Wrapped})}, this, new Map([]), Mirror.DisplayStyle.optional, null);
}
----Swift.(file).Optional.==infix(_:Wrapped?,_:Wrapped?)
const $match = {0: lhs, 1: rhs}
if(((true))) {
const l = $match[0]
const r = $match[1]
return $info.Wrapped.infix_61_61({Self: $info.Wrapped, Self: $info.Wrapped}, l, r);
}
else if((($match[0].rawValue == Optional.none.rawValue && $match[1].rawValue == Optional.none.rawValue))) {
return true;
}
else if(((true))) {
return false;
}
----Swift.(file).Optional.hash(into:Hasher)
let hasher = hasher$inout.get()
const $result = (() => {
const $match = this
if((($match.rawValue == Optional.none.rawValue))) {
hasher.combine({$setThis: $val => hasher = $val, H: UInt8}, 0);
}
else if((($match.rawValue == Optional.some().rawValue))) {
const wrapped = $match[0]
hasher.combine({$setThis: $val => hasher = $val, H: UInt8}, 1);
hasher.combine({$setThis: $val => hasher = $val, H: this.$info.Wrapped}, wrapped);
};})()
hasher$inout.set(hasher)
return $result
----Swift.(file).Optional.~=infix(_:_OptionalNilComparisonType,_:Wrapped?)
const $match = rhs
if((($match.rawValue == Optional.some().rawValue))) {
return false;
}
else if((($match.rawValue == Optional.none.rawValue))) {
return true;
}
----Swift.(file).Optional.==infix(_:Wrapped?,_:_OptionalNilComparisonType)
const $match = lhs
if((($match.rawValue == Optional.some().rawValue))) {
return false;
}
else if((($match.rawValue == Optional.none.rawValue))) {
return true;
}
----Swift.(file).Optional.!=infix(_:Wrapped?,_:_OptionalNilComparisonType)
const $match = lhs
if((($match.rawValue == Optional.some().rawValue))) {
return true;
}
else if((($match.rawValue == Optional.none.rawValue))) {
return false;
}
----Swift.(file).Optional.==infix(_:_OptionalNilComparisonType,_:Wrapped?)
const $match = rhs
if((($match.rawValue == Optional.some().rawValue))) {
return false;
}
else if((($match.rawValue == Optional.none.rawValue))) {
return true;
}
----Swift.(file).Optional.!=infix(_:_OptionalNilComparisonType,_:Wrapped?)
const $match = rhs
if((($match.rawValue == Optional.some().rawValue))) {
return true;
}
else if((($match.rawValue == Optional.none.rawValue))) {
return false;
}
----Swift.(file).??infix(_:T?,_:() throws -> T)
const $match = optional
if((($match.rawValue == Optional.some().rawValue))) {
const value = $match[0]
return value;
}
else if((($match.rawValue == Optional.none.rawValue))) {
return defaultValue({}, );
}
----Swift.(file).??infix(_:T?,_:() throws -> T?)
const $match = optional
if((($match.rawValue == Optional.some().rawValue))) {
const value = $match[0]
return value;
}
else if((($match.rawValue == Optional.none.rawValue))) {
return defaultValue({}, );
}
----Swift.(file).String.write(_:String)
String.infix_43_61({Self: String}, {get: () => this, set: $val => $info.$setThis(_cloneStruct($val))}, other)
----Swift.(file).String.write(to:Target)
let target = target$inout.get()
const $result = (() => {
target.write({$setThis: $val => target = $val, Self: $info.Target}, this);})()
target$inout.set(target)
return $result
----Swift.(file).Character.write(to:Target)
let target = target$inout.get()
const $result = (() => {
target.write({$setThis: $val => target = $val, Self: $info.Target}, _create(String, 'initCharacter', {}, this));})()
target$inout.set(target)
return $result
----Swift.(file).Scalar.write(to:Target)
let target = target$inout.get()
const $result = (() => {
target.write({$setThis: $val => target = $val, Self: $info.Target}, _create(String, 'initCharacter', {}, _create(Character, 'initUnicodeScalar', {}, this)));})()
target$inout.set(target)
return $result
----Swift.(file)._Pointer.init(_:OpaquePointer?)
{const unwrapped = from
if(!((unwrapped != null))) {
return (this.$failed = true);
}
};
this.initOpaquePointer({}, unwrapped);
return
----Swift.(file)._Pointer.init(_:Self)
this.initRawPointer({}, other._rawValue);
return
----Swift.(file)._Pointer.init(_:Self?)
{const unwrapped = other
if(!((unwrapped != null))) {
return (this.$failed = true);
}
};
this.initRawPointer({}, unwrapped._rawValue);
return
----Swift.(file)._Pointer.init(_:UnsafeMutablePointer<T>)
this.initRawPointer({}, other._rawValue);
return
----Swift.(file)._Pointer.init(_:UnsafeMutablePointer<T>?)
{const unwrapped = other
if(!((unwrapped != null))) {
return (this.$failed = true);
}
};
this.initUnsafeMutablePointer({}, unwrapped);
return
----Swift.(file)._Pointer.successor()
return this.advancedBy({Self: this.$info.Self}, 1)
----Swift.(file)._Pointer.predecessor()
return this.advancedBy({Self: this.$info.Self}, -1)
----Swift.(file)._Pointer.hash(into:Hasher)
let hasher = hasher$inout.get()
const $result = (() => {
hasher.combine({$setThis: $val => hasher = $val, H: UInt}, _create(UInt, 'initBitPatternOptional', {P: this.$info.Self}, this));})()
hasher$inout.set(hasher)
return $result
----Swift.(file).Strideable.+infix(_:Self,_:Self.Stride)
return lhs.advancedBy({Self: $info.Self}, rhs)
----Swift.(file).Strideable.+infix(_:Self.Stride,_:Self)
return rhs.advancedBy({Self: $info.Self}, lhs)
----Swift.(file).Strideable.-infix(_:Self,_:Self.Stride)
return lhs.advancedBy({Self: $info.Self}, $info.Self.Stride.prefix_45({Self: $info.Self.Stride, Self: $info.Self.Stride}, rhs))
----Swift.(file).Strideable.-infix(_:Self,_:Self)
return rhs.distanceTo({Self: $info.Self}, lhs)
----Swift.(file).Strideable.+=infix(_:Self,_:Self.Stride)
let lhs = lhs$inout.get()
const $result = (() => {
lhs = lhs.advancedBy({Self: $info.Self}, rhs);})()
lhs$inout.set(lhs)
return $result
----Swift.(file).Strideable.-=infix(_:Self,_:Self.Stride)
let lhs = lhs$inout.get()
const $result = (() => {
lhs = lhs.advancedBy({Self: $info.Self}, $info.Self.Stride.prefix_45({Self: $info.Self.Stride, Self: $info.Self.Stride}, rhs));})()
lhs$inout.set(lhs)
return $result
----Swift.(file).Never.<infix(_:Never,_:Never)

----Swift.(file).~=infix(_:T,_:T)
return $info.T.infix_61_61({Self: $info.T, Self: $info.T}, a, b)
----Swift.(file).RandomNumberGenerator.next()
return $info.T._randomUsing({Self: $info.T, Self: $info.T, R: $info.Self}, {get: () => this, set: $val => $info.$setThis(_cloneStruct($val))})
----Swift.(file).RandomNumberGenerator.next(upperBound:T)
preconditionFileLine({}, () => $info.T.infix_33_61({Self: $info.T, Self: $info.T, Other: Int}, upperBound, 0), () => "upperBound cannot be zero.", '?3', '?3');
const tmp = $info.T.infix_43({Self: $info.T, Self: $info.T}, $info.T.infix_37({Self: $info.T, Self: $info.T}, $info.T.max, upperBound), _create($info.T, 'initIntegerLiteral', {Self: $info.T}, 1));
const range = ($info.T.infix_61_61({Self: $info.T, Self: $info.T}, tmp, upperBound) ? _create($info.T, 'initIntegerLiteral', {Self: $info.T}, 0) : tmp);
let random = _create($info.T, 'initIntegerLiteral', {Self: $info.T}, 0);
do {
random = this.next({$setThis: $val => $info.$setThis(_cloneStruct($val)), Self: $info.Self, T: $info.T}, );
} while($info.T.infix_60({Self: $info.T, Self: $info.T}, random, range));
return $info.T.infix_37({Self: $info.T, Self: $info.T}, random, upperBound)
----Swift.(file).SystemRandomNumberGenerator.init()
return
----Swift.(file).RandomAccessCollection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)
const l = this.distanceFromTo({Self: this.$info.Self}, i, limit);
{
if(((Int.infix_62({Self: Int}, distance, 0) ? Bool.infix_38_38({Self: Bool}, Int.infix_62_61({Self: Int}, l, 0), () => Int.infix_60({Self: Int}, l, distance)) : Bool.infix_38_38({Self: Bool}, Int.infix_60_61({Self: Int}, l, 0), () => Int.infix_60({Self: Int}, distance, l))))) {
return null;
}
};
return this.indexOffsetBy({Self: this.$info.Self}, i, distance)
----Swift.(file).RandomAccessCollection.indices
return this.$info.Self.Index.infix_46_46_60({Self: this.$info.Self.Index, Self: this.$info.Self.Index}, this.startIndex, this.endIndex)
----Swift.(file).RandomAccessCollection.index(after:Self.Index)
this._failEarlyRangeCheckBounds({Self: this.$info.Self}, i, _create(Range, 'initUncheckedBoundstuple_type', {Bound: this.$info.Self.Index}, {0: this.startIndex, 1: this.endIndex}));
return i.advancedBy({Self: this.$info.Self.Index}, 1)
----Swift.(file).RandomAccessCollection.index(before:Self.Index)
const result = i.advancedBy({Self: this.$info.Self.Index}, -1);
this._failEarlyRangeCheckBounds({Self: this.$info.Self}, result, _create(Range, 'initUncheckedBoundstuple_type', {Bound: this.$info.Self.Index}, {0: this.startIndex, 1: this.endIndex}));
return result
----Swift.(file).RandomAccessCollection.index(_:Self.Index,offsetBy:Self.Index.Stride)
const result = i.advancedBy({Self: this.$info.Self.Index}, distance);
this._failEarlyRangeCheckBounds({Self: this.$info.Self}, result, _create(ClosedRange, 'initUncheckedBoundstuple_type', {Bound: this.$info.Self.Index}, {0: this.startIndex, 1: this.endIndex}));
return result
----Swift.(file).RandomAccessCollection.distance(from:Self.Index,to:Self.Index)
this._failEarlyRangeCheckBounds({Self: this.$info.Self}, start, _create(ClosedRange, 'initUncheckedBoundstuple_type', {Bound: this.$info.Self.Index}, {0: this.startIndex, 1: this.endIndex}));
this._failEarlyRangeCheckBounds({Self: this.$info.Self}, end, _create(ClosedRange, 'initUncheckedBoundstuple_type', {Bound: this.$info.Self.Index}, {0: this.startIndex, 1: this.endIndex}));
return start.distanceTo({Self: this.$info.Self.Index}, end)
----Swift.(file).RangeExpression.~=infix(_:Self,_:Self.Bound)
return pattern.contains({Self: $info.Self}, value)
----Swift.(file).Range.init(uncheckedBounds:(lower: Bound, upper: Bound))
this.lowerBound = bounds["0"];
this.upperBound = bounds["1"];
return
----Swift.(file).Range.contains(_:Bound)
return Bool.infix_38_38({Self: Bool}, this.$info.Bound.infix_60_61({Self: this.$info.Bound, Self: this.$info.Bound}, this.lowerBound, _element), () => this.$info.Bound.infix_60({Self: this.$info.Bound, Self: this.$info.Bound}, _element, this.upperBound))
----Swift.(file).Range.isEmpty
return this.$info.Bound.infix_61_61({Self: this.$info.Bound, Self: this.$info.Bound}, this.lowerBound, this.upperBound)
----Swift.(file).Range.startIndex
return this.lowerBound
----Swift.(file).Range.endIndex
return this.upperBound
----Swift.(file).Range.index(after:Range<Bound>.Index)
this._failEarlyRangeCheckBounds({Self: _clarifyGenerics({Self:Range, Bound: this.$info.Bound})}, i, this.$info.Bound.infix_46_46_60({Self: this.$info.Bound, Self: this.$info.Bound}, this.startIndex, this.endIndex));
return i.advancedBy({Self: this.$info.Bound}, _create(this.$info.Bound.Stride, 'initIntegerLiteral', {Self: this.$info.Bound.Stride}, 1))
----Swift.(file).Range.index(before:Range<Bound>.Index)
preconditionFileLine({}, () => this.$info.Bound.infix_62({Self: this.$info.Bound, Self: this.$info.Bound}, i, this.lowerBound), null, '?3', '?3');
preconditionFileLine({}, () => this.$info.Bound.infix_60_61({Self: this.$info.Bound, Self: this.$info.Bound}, i, this.upperBound), null, '?3', '?3');
return i.advancedBy({Self: this.$info.Bound}, _create(this.$info.Bound.Stride, 'initIntegerLiteral', {Self: this.$info.Bound.Stride}, -1))
----Swift.(file).Range.index(_:Range<Bound>.Index,offsetBy:Int)
const r = i.advancedBy({Self: this.$info.Bound}, numericCast({T: Int, U: this.$info.Bound.Stride}, n));
preconditionFileLine({}, () => this.$info.Bound.infix_62_61({Self: this.$info.Bound, Self: this.$info.Bound}, r, this.lowerBound), null, '?3', '?3');
preconditionFileLine({}, () => this.$info.Bound.infix_60_61({Self: this.$info.Bound, Self: this.$info.Bound}, r, this.upperBound), null, '?3', '?3');
return r
----Swift.(file).Range.distance(from:Range<Bound>.Index,to:Range<Bound>.Index)
return numericCast({T: this.$info.Bound.Stride, U: Int}, start.distanceTo({Self: this.$info.Bound}, end))
----Swift.(file).Range.subscript(_:Range<Range<Bound>.Index>)
return bounds
----Swift.(file).Range.indices
return this
----Swift.(file).Range.subscript(_:Range<Bound>.Index)
preconditionFileLine({}, () => this.contains({Bound: this.$info.Bound}, position), () => "Index out of range", '?3', '?3');
return position
----Swift.(file).Range.init(_:ClosedRange<Bound>)
const upperBound = other.upperBound.advancedBy({Self: this.$info.Bound}, _create(this.$info.Bound.Stride, 'initIntegerLiteral', {Self: this.$info.Bound.Stride}, 1));
this.initUncheckedBoundstuple_type({}, {0: other.lowerBound, 1: upperBound});
return
----Swift.(file).Range.relative(to:C)
return _create(Range, 'initUncheckedBoundstuple_type', {Bound: $info.Bound}, {0: this.lowerBound, 1: this.upperBound})
----Swift.(file).Range.clamped(to:Range<Bound>)
const lower = (this.$info.Bound.infix_62({Self: this.$info.Bound, Self: this.$info.Bound}, limits.lowerBound, this.lowerBound) ? limits.lowerBound : (this.$info.Bound.infix_60({Self: this.$info.Bound, Self: this.$info.Bound}, limits.upperBound, this.lowerBound) ? limits.upperBound : this.lowerBound));
const upper = (this.$info.Bound.infix_60({Self: this.$info.Bound, Self: this.$info.Bound}, limits.upperBound, this.upperBound) ? limits.upperBound : (this.$info.Bound.infix_62({Self: this.$info.Bound, Self: this.$info.Bound}, limits.lowerBound, this.upperBound) ? limits.lowerBound : this.upperBound));
return _create(Range, 'initUncheckedBoundstuple_type', {Bound: this.$info.Bound}, {0: lower, 1: upper})
----Swift.(file).Range.description
return (("") + (this.lowerBound) + ("..<") + (this.upperBound) + (""))
----Swift.(file).Range.debugDescription
return String.infix_43({Self: String}, (("Range(") + (_create(String, 'initReflecting', {Subject: this.$info.Bound}, this.lowerBound)) + ("")), (("..<") + (_create(String, 'initReflecting', {Subject: this.$info.Bound}, this.upperBound)) + (")")))
----Swift.(file).Range.customMirror
return _create(Mirror, 'initChildrenKeyValuePairsDisplayStyleOptionalAncestorRepresentationMirrorAncestorRepresentation', {Subject: _clarifyGenerics({Self:Range, Bound: this.$info.Bound})}, this, new Map([["lowerBound", this.lowerBound], ["upperBound", this.upperBound]]), null, null)
----Swift.(file).Range.==infix(_:Range<Bound>,_:Range<Bound>)
return Bool.infix_38_38({Self: Bool}, $info.Bound.infix_61_61({Self: $info.Bound, Self: $info.Bound}, lhs.lowerBound, rhs.lowerBound), () => $info.Bound.infix_61_61({Self: $info.Bound, Self: $info.Bound}, lhs.upperBound, rhs.upperBound))
----Swift.(file).Range.hash(into:Hasher)
let hasher = hasher$inout.get()
const $result = (() => {
hasher.combine({$setThis: $val => hasher = $val, H: this.$info.Bound}, this.lowerBound);
hasher.combine({$setThis: $val => hasher = $val, H: this.$info.Bound}, this.upperBound);})()
hasher$inout.set(hasher)
return $result
----Swift.(file).PartialRangeUpTo.relative(to:C)
return $info.Bound.infix_46_46_60({Self: $info.Bound, Self: $info.Bound}, collection.startIndex, this.upperBound)
----Swift.(file).PartialRangeUpTo.contains(_:Bound)
return this.$info.Bound.infix_60({Self: this.$info.Bound, Self: this.$info.Bound}, _element, this.upperBound)
----Swift.(file).PartialRangeThrough.relative(to:C)
return $info.Bound.infix_46_46_60({Self: $info.Bound, Self: $info.Bound}, collection.startIndex, collection.indexAfter({Self: $info.C}, this.upperBound))
----Swift.(file).PartialRangeThrough.contains(_:Bound)
return this.$info.Bound.infix_60_61({Self: this.$info.Bound, Self: this.$info.Bound}, _element, this.upperBound)
----Swift.(file).PartialRangeFrom.relative(to:C)
return $info.Bound.infix_46_46_60({Self: $info.Bound, Self: $info.Bound}, this.lowerBound, collection.endIndex)
----Swift.(file).PartialRangeFrom.contains(_:Bound)
return this.$info.Bound.infix_60_61({Self: this.$info.Bound, Self: this.$info.Bound}, this.lowerBound, _element)
----Swift.(file).PartialRangeFrom.makeIterator()
return _create(PartialRangeFrom.Iterator, 'init_current', {Bound: this.$info.Bound}, this.lowerBound)
----Swift.(file).Comparable...<infix(_:Self,_:Self)
preconditionFileLine({}, () => $info.Self.infix_60_61({Self: $info.Self, Self: $info.Self}, minimum, maximum), () => "Can't form Range with upperBound < lowerBound", '?3', '?3');
return _create(Range, 'initUncheckedBoundstuple_type', {Bound: $info.Self}, {0: minimum, 1: maximum})
----Swift.(file).Comparable...<prefix(_:Self)
return _create(PartialRangeUpTo, 'init', {Bound: $info.Self}, maximum)
----Swift.(file).Comparable....prefix(_:Self)
return _create(PartialRangeThrough, 'init', {Bound: $info.Self}, maximum)
----Swift.(file).Comparable....postfix(_:Self)
return _create(PartialRangeFrom, 'init', {Bound: $info.Self}, minimum)
----Swift.(file).UnboundedRange_....postfix(_:UnboundedRange_)

----Swift.(file).Collection.subscript(_:(UnboundedRange_) -> ())
return this.subscript$get({}, this.$info.Self.Index.postfix_46_46_46({Self: this.$info.Self.Index, Self: this.$info.Self.Index}, this.startIndex))
----Swift.(file).MutableCollection.subscript(_:(UnboundedRange_) -> ())#ASS

this.subscript$set({$setThis: $val => $info.$setThis(_cloneStruct($val))}, newValue, this.$info.Self.Index.postfix_46_46_46({Self: this.$info.Self.Index, Self: this.$info.Self.Index}, this.startIndex))
----Swift.(file).MutableCollection.subscript(_:(UnboundedRange_) -> ())
return this.subscript$get({}, this.$info.Self.Index.postfix_46_46_46({Self: this.$info.Self.Index, Self: this.$info.Self.Index}, this.startIndex));

----Swift.(file).Range.overlaps(_:Range<Bound>)
return Bool.infix_124_124({Self: Bool}, Bool.infix_38_38({Self: Bool}, Bool.prefix_33({Self: Bool}, other.isEmpty), () => this.contains({Bound: this.$info.Bound}, other.lowerBound)), () => Bool.infix_38_38({Self: Bool}, Bool.prefix_33({Self: Bool}, this.isEmpty), () => other.contains({Bound: this.$info.Bound}, this.lowerBound)))
----Swift.(file).Range.overlaps(_:ClosedRange<Bound>)
return Bool.infix_124_124({Self: Bool}, this.contains({Bound: this.$info.Bound}, other.lowerBound), () => Bool.infix_38_38({Self: Bool}, Bool.prefix_33({Self: Bool}, this.isEmpty), () => other.contains({Bound: this.$info.Bound}, this.lowerBound)))
----Swift.(file).RangeReplaceableCollection.init(_:S)
this.init({}, );
this.appendContentsOf({$setThis: $val => $info.$setThis(_cloneStruct($val)), Self: $info.Self, S: $info.S}, _elements);
return
----Swift.(file).RangeReplaceableCollection.append(_:Self.Element)
this.insertAt({$setThis: $val => $info.$setThis(_cloneStruct($val)), Self: this.$info.Self}, newElement, this.endIndex)
----Swift.(file).RangeReplaceableCollection.append(contentsOf:S)
const approximateCapacity = Int.infix_43({Self: Int}, this.count, numericCast({T: Int, U: Int}, newElements.underestimatedCount));
this.reserveCapacity({$setThis: $val => $info.$setThis(_cloneStruct($val)), Self: $info.Self}, approximateCapacity);
{
let $element$generator = newElements.makeIterator({Self: $info.S}, );
while(true) {
const _element = $element$generator.next({$setThis: $val => $element$generator = $val, Self: $info.S.Iterator}, );
if(!((_element != null))) break;
this.append({$setThis: $val => $info.$setThis(_cloneStruct($val)), Self: $info.Self}, _element);
}
}
----Swift.(file).RangeReplaceableCollection.insert(_:Self.Element,at:Self.Index)
this.replaceSubrangeWith({$setThis: $val => $info.$setThis(_cloneStruct($val)), Self: this.$info.Self, C: _clarifyGenerics({Self:CollectionOfOne, Element: this.$info.Self.Element})}, this.$info.Self.Index.infix_46_46_60({Self: this.$info.Self.Index, Self: this.$info.Self.Index}, i, i), _create(CollectionOfOne, 'init', {Element: this.$info.Self.Element}, newElement))
----Swift.(file).RangeReplaceableCollection.insert(contentsOf:C,at:Self.Index)
this.replaceSubrangeWith({$setThis: $val => $info.$setThis(_cloneStruct($val)), Self: $info.Self, C: $info.C}, $info.Self.Index.infix_46_46_60({Self: $info.Self.Index, Self: $info.Self.Index}, i, i), newElements)
----Swift.(file).RangeReplaceableCollection.remove(at:Self.Index)
preconditionFileLine({}, () => Bool.prefix_33({Self: Bool}, this.isEmpty), () => "Can't remove from an empty collection", '?3', '?3');
const result = this.subscript$get({}, position);
this.replaceSubrangeWith({$setThis: $val => $info.$setThis(_cloneStruct($val)), Self: this.$info.Self, C: _clarifyGenerics({Self:EmptyCollection, Element: this.$info.Self.Element})}, this.$info.Self.Index.infix_46_46_60({Self: this.$info.Self.Index, Self: this.$info.Self.Index}, position, this.indexAfter({Self: this.$info.Self}, position)), _create(EmptyCollection, 'init', {Element: this.$info.Self.Element}, ));
return result
----Swift.(file).RangeReplaceableCollection.removeSubrange(_:Range<Self.Index>)
this.replaceSubrangeWith({$setThis: $val => $info.$setThis(_cloneStruct($val)), Self: this.$info.Self, C: _clarifyGenerics({Self:EmptyCollection, Element: this.$info.Self.Element})}, bounds, _create(EmptyCollection, 'init', {Element: this.$info.Self.Element}, ))
----Swift.(file).RangeReplaceableCollection.removeFirst(_:Int)
{
if((Int.infix_61_61({Self: Int}, k, 0))) {
return ;
}
};
preconditionFileLine({}, () => Int.infix_62_61({Self: Int}, k, 0), () => "Number of elements to remove should be non-negative", '?3', '?3');
preconditionFileLine({}, () => Int.infix_62_61({Self: Int}, this.count, k), () => "Can't remove more items from a collection than it has", '?3', '?3');
const end = this.indexOffsetBy({Self: this.$info.Self}, this.startIndex, k);
this.removeSubrange({$setThis: $val => $info.$setThis(_cloneStruct($val)), Self: this.$info.Self}, this.$info.Self.Index.infix_46_46_60({Self: this.$info.Self.Index, Self: this.$info.Self.Index}, this.startIndex, end))
----Swift.(file).RangeReplaceableCollection.removeFirst()
preconditionFileLine({}, () => Bool.prefix_33({Self: Bool}, this.isEmpty), () => "Can't remove first element from an empty collection", '?3', '?3');
const firstElement = this.first;
this.removeFirstMultiple({$setThis: $val => $info.$setThis(_cloneStruct($val)), Self: this.$info.Self}, 1);
return firstElement
----Swift.(file).RangeReplaceableCollection.removeAll(keepingCapacity:Bool)
{
if((Bool.prefix_33({Self: Bool}, keepCapacity))) {
$info.$setThis(_cloneStruct(_create(this.$info.Self, 'init', {Self: this.$info.Self}, )));
}
else {
this.replaceSubrangeWith({$setThis: $val => $info.$setThis(_cloneStruct($val)), Self: this.$info.Self, C: _clarifyGenerics({Self:EmptyCollection, Element: this.$info.Self.Element})}, this.$info.Self.Index.infix_46_46_60({Self: this.$info.Self.Index, Self: this.$info.Self.Index}, this.startIndex, this.endIndex), _create(EmptyCollection, 'init', {Element: this.$info.Self.Element}, ));
}
}
----Swift.(file).RangeReplaceableCollection.reserveCapacity(_:Int)

----Swift.(file).RangeReplaceableCollection.removeFirst()
preconditionFileLine({}, () => Bool.prefix_33({Self: Bool}, this.isEmpty), () => "Can't remove items from an empty collection", '?3', '?3');
const _element = this.first;
$info.$setThis(_cloneStruct(this.subscriptRange$get({}, this.$info.Self.Index.infix_46_46_60({Self: this.$info.Self.Index, Self: this.$info.Self.Index}, this.indexAfter({Self: this.$info.Self}, this.startIndex), this.endIndex))));
return _element
----Swift.(file).RangeReplaceableCollection.removeFirst(_:Int)
{
if((Int.infix_61_61({Self: Int}, k, 0))) {
return ;
}
};
preconditionFileLine({}, () => Int.infix_62_61({Self: Int}, k, 0), () => "Number of elements to remove should be non-negative", '?3', '?3');
preconditionFileLine({}, () => Int.infix_62_61({Self: Int}, this.count, k), () => "Can't remove more items from a collection than it contains", '?3', '?3');
$info.$setThis(_cloneStruct(this.subscriptRange$get({}, this.$info.Self.Index.infix_46_46_60({Self: this.$info.Self.Index, Self: this.$info.Self.Index}, this.indexOffsetBy({Self: this.$info.Self}, this.startIndex, k), this.endIndex))))
----Swift.(file).RangeReplaceableCollection.replaceSubrange(_:R,with:C)
this.replaceSubrangeWith({$setThis: $val => $info.$setThis(_cloneStruct($val)), Self: $info.Self, C: $info.C}, subrange.relativeTo({Self: $info.R, C: $info.Self}, this), newElements)
----Swift.(file).RangeReplaceableCollection.removeSubrange(_:R)
this.removeSubrange({$setThis: $val => $info.$setThis(_cloneStruct($val)), Self: $info.Self}, bounds.relativeTo({Self: $info.R, C: $info.Self}, this))
----Swift.(file).RangeReplaceableCollection.popLast()
{
if((this.isEmpty)) {
return null;
}
};
{const result = this._customRemoveLast({$setThis: $val => $info.$setThis(_cloneStruct($val)), Self: this.$info.Self}, )
if((result != null)) {
return result;
}
};
return this.removeAt({$setThis: $val => $info.$setThis(_cloneStruct($val)), Self: this.$info.Self}, this.indexBefore({Self: this.$info.Self}, this.endIndex))
----Swift.(file).RangeReplaceableCollection.removeLast()
return this.removeAt({$setThis: $val => $info.$setThis(_cloneStruct($val)), Self: this.$info.Self}, this.indexBefore({Self: this.$info.Self}, this.endIndex))
----Swift.(file).RangeReplaceableCollection.removeLast(_:Int)
{
if((Int.infix_61_61({Self: Int}, k, 0))) {
return ;
}
};
preconditionFileLine({}, () => Int.infix_62_61({Self: Int}, k, 0), () => "Number of elements to remove should be non-negative", '?3', '?3');
preconditionFileLine({}, () => Int.infix_62_61({Self: Int}, this.count, k), () => "Can't remove more items from a collection than it contains", '?3', '?3');
{
if((this._customRemoveLast({$setThis: $val => $info.$setThis(_cloneStruct($val)), Self: this.$info.Self}, k))) {
return ;
}
};
const end = this.endIndex;
this.removeSubrange({$setThis: $val => $info.$setThis(_cloneStruct($val)), Self: this.$info.Self}, this.$info.Self.Index.infix_46_46_60({Self: this.$info.Self.Index, Self: this.$info.Self.Index}, this.indexOffsetBy({Self: this.$info.Self}, end, Int.prefix_45({Self: Int, Self: Int}, k)), end))
----Swift.(file).RangeReplaceableCollection.popLast()
{
if((this.isEmpty)) {
return null;
}
};
{const result = this._customRemoveLast({$setThis: $val => $info.$setThis(_cloneStruct($val)), Self: this.$info.Self}, )
if((result != null)) {
return result;
}
};
return this.removeAt({$setThis: $val => $info.$setThis(_cloneStruct($val)), Self: this.$info.Self}, this.indexBefore({Self: this.$info.Self}, this.endIndex))
----Swift.(file).RangeReplaceableCollection.removeLast()
return this.removeAt({$setThis: $val => $info.$setThis(_cloneStruct($val)), Self: this.$info.Self}, this.indexBefore({Self: this.$info.Self}, this.endIndex))
----Swift.(file).RangeReplaceableCollection.removeLast(_:Int)
{
if((Int.infix_61_61({Self: Int}, k, 0))) {
return ;
}
};
preconditionFileLine({}, () => Int.infix_62_61({Self: Int}, k, 0), () => "Number of elements to remove should be non-negative", '?3', '?3');
preconditionFileLine({}, () => Int.infix_62_61({Self: Int}, this.count, k), () => "Can't remove more items from a collection than it contains", '?3', '?3');
{
if((this._customRemoveLast({$setThis: $val => $info.$setThis(_cloneStruct($val)), Self: this.$info.Self}, k))) {
return ;
}
};
const end = this.endIndex;
this.removeSubrange({$setThis: $val => $info.$setThis(_cloneStruct($val)), Self: this.$info.Self}, this.$info.Self.Index.infix_46_46_60({Self: this.$info.Self.Index, Self: this.$info.Self.Index}, this.indexOffsetBy({Self: this.$info.Self}, end, Int.prefix_45({Self: Int, Self: Int}, k)), end))
----Swift.(file).RangeReplaceableCollection.+infix(_:Self,_:Other)
let lhs_dupl = lhs;
lhs_dupl.appendContentsOf({$setThis: $val => lhs_dupl = $val, Self: $info.Self, S: $info.Other}, rhs);
return lhs_dupl
----Swift.(file).RangeReplaceableCollection.+infix(_:Other,_:Self)
let result = _create($info.Self, 'init', {Self: $info.Self}, );
result.reserveCapacity({$setThis: $val => result = $val, Self: $info.Self}, Int.infix_43({Self: Int}, rhs.count, numericCast({T: Int, U: Int}, lhs.underestimatedCount)));
result.appendContentsOf({$setThis: $val => result = $val, Self: $info.Self, S: $info.Other}, lhs);
result.appendContentsOf({$setThis: $val => result = $val, Self: $info.Self, S: $info.Self}, rhs);
return result
----Swift.(file).RangeReplaceableCollection.+=infix(_:Self,_:Other)
let lhs = lhs$inout.get()
const $result = (() => {
lhs.appendContentsOf({$setThis: $val => lhs = $val, Self: $info.Self, S: $info.Other}, rhs);})()
lhs$inout.set(lhs)
return $result
----Swift.(file).RangeReplaceableCollection.+infix(_:Self,_:Other)
let lhs_dupl = lhs;
lhs_dupl.appendContentsOf({$setThis: $val => lhs_dupl = $val, Self: $info.Self, S: $info.Other}, rhs);
return lhs_dupl
----Swift.(file).RangeReplaceableCollection.filter(_:(Self.Element) throws -> Bool)
return _create(this.$info.Self, 'initBuffer', {Self: this.$info.Self, S: _clarifyGenerics({Self:Array, Element: this.$info.Self.Element})}, this.lazy.filterSwift({Self: _clarifyGenerics({Self:LazySequence, Base: this.$info.Self})}, isIncluded))
----Swift.(file).RangeReplaceableCollection.removeAll(where:(Self.Element) throws -> Bool)
$info.$setThis(_cloneStruct(_create(this.$info.Self, 'initBuffer', {Self: this.$info.Self, S: _clarifyGenerics({Self:Array, Element: this.$info.Self.Element})}, this.lazy.filterSwift({Self: _clarifyGenerics({Self:LazySequence, Base: this.$info.Self})}, (($info, $0) => Bool.prefix_33({Self: Bool}, shouldBeRemoved({}, $0)))))))
----Swift.(file).Repeated.startIndex
return 0
----Swift.(file).Repeated.endIndex
return this.count
----Swift.(file).Repeated.subscript(_:Int)
preconditionFileLine({}, () => Bool.infix_38_38({Self: Bool}, Int.infix_62_61({Self: Int}, position, 0), () => Int.infix_60({Self: Int}, position, this.count)), () => "Index out of range", '?3', '?3');
return this.repeatedValue
----Swift.(file).Result.map(_:(Success) -> NewSuccess)
const $match = this
if((($match.rawValue == Result.success().rawValue))) {
const success = $match[0]
return Result.success({Success: $info.NewSuccess, Failure: $info.Failure}, transform({}, success));
}
else if((($match.rawValue == Result.failure().rawValue))) {
const failure = $match[0]
return Result.failure({Success: $info.NewSuccess, Failure: $info.Failure}, failure);
}
----Swift.(file).Result.mapError(_:(Failure) -> NewFailure)
const $match = this
if((($match.rawValue == Result.success().rawValue))) {
const success = $match[0]
return Result.success({Success: $info.Success, Failure: $info.NewFailure}, success);
}
else if((($match.rawValue == Result.failure().rawValue))) {
const failure = $match[0]
return Result.failure({Success: $info.Success, Failure: $info.NewFailure}, transform({}, failure));
}
----Swift.(file).Result.flatMap(_:(Success) -> Result<NewSuccess, Failure>)
const $match = this
if((($match.rawValue == Result.success().rawValue))) {
const success = $match[0]
return transform({}, success);
}
else if((($match.rawValue == Result.failure().rawValue))) {
const failure = $match[0]
return Result.failure({Success: $info.NewSuccess, Failure: $info.Failure}, failure);
}
----Swift.(file).Result.flatMapError(_:(Failure) -> Result<Success, NewFailure>)
const $match = this
if((($match.rawValue == Result.success().rawValue))) {
const success = $match[0]
return Result.success({Success: $info.Success, Failure: $info.NewFailure}, success);
}
else if((($match.rawValue == Result.failure().rawValue))) {
const failure = $match[0]
return transform({}, failure);
}
----Swift.(file).Result.get()
const $match = this
if((($match.rawValue == Result.success().rawValue))) {
const success = $match[0]
return success;
}
else if((($match.rawValue == Result.failure().rawValue))) {
const failure = $match[0]
throw failure;
}
----Swift.(file).Result.init(catching:() throws -> Success)
try {
$info.$setThis(_cloneStruct(Result.success({Success: this.$info.Success, Failure: Error}, body({}, ))));
} catch(error) {
if((true)) {
$info.$setThis(_cloneStruct(Result.failure({Success: this.$info.Success, Failure: Error}, error)));
}
else throw error
};
return
----Swift.(file).MutableCollection.reverse()
{
if((this.isEmpty)) {
return ;
}
};
let f = this.startIndex;
let l = this.indexBefore({Self: this.$info.Self}, this.endIndex);
while(true){
if(!((this.$info.Self.Index.infix_60({Self: this.$info.Self.Index, Self: this.$info.Self.Index}, f, l)))) break
this.swapAt({$setThis: $val => $info.$setThis(_cloneStruct($val)), Self: this.$info.Self}, f, l);
this.formIndexAfter({Self: this.$info.Self}, {get: () => f, set: $val => f = $val});
this.formIndexBefore({Self: this.$info.Self}, {get: () => l, set: $val => l = $val});
}
----Swift.(file).ReversedCollection.makeIterator()
return _create(ReversedCollection.Iterator, 'init_base', {Base: this.$info.Base}, this._base)
----Swift.(file).Index.==infix(_:ReversedCollection<Base>.Index,_:ReversedCollection<Base>.Index)
return $info.Base.Index.infix_61_61({Self: $info.Base.Index, Self: $info.Base.Index}, lhs.base, rhs.base)
----Swift.(file).Index.<infix(_:ReversedCollection<Base>.Index,_:ReversedCollection<Base>.Index)
return $info.Base.Index.infix_62({Self: $info.Base.Index, Self: $info.Base.Index}, lhs.base, rhs.base)
----Swift.(file).Index.hash(into:Hasher)
let hasher = hasher$inout.get()
const $result = (() => {
hasher.combine({$setThis: $val => hasher = $val, H: this.$info.Base.Index}, this.base);})()
hasher$inout.set(hasher)
return $result
----Swift.(file).ReversedCollection.startIndex
return _create(ReversedCollection.Index, 'init', {Base: this.$info.Base}, this._base.endIndex)
----Swift.(file).ReversedCollection.endIndex
return _create(ReversedCollection.Index, 'init', {Base: this.$info.Base}, this._base.startIndex)
----Swift.(file).ReversedCollection.index(after:ReversedCollection<Base>.Index)
return _create(ReversedCollection.Index, 'init', {Base: this.$info.Base}, this._base.indexBefore({Self: this.$info.Base}, i.base))
----Swift.(file).ReversedCollection.index(before:ReversedCollection<Base>.Index)
return _create(ReversedCollection.Index, 'init', {Base: this.$info.Base}, this._base.indexAfter({Self: this.$info.Base}, i.base))
----Swift.(file).ReversedCollection.index(_:ReversedCollection<Base>.Index,offsetBy:Int)
return _create(ReversedCollection.Index, 'init', {Base: this.$info.Base}, this._base.indexOffsetBy({Self: this.$info.Base}, i.base, Int.prefix_45({Self: Int, Self: Int}, n)))
----Swift.(file).ReversedCollection.index(_:ReversedCollection<Base>.Index,offsetBy:Int,limitedBy:ReversedCollection<Base>.Index)
return this._base.indexOffsetByLimitedBy({Self: this.$info.Base}, i.base, Int.prefix_45({Self: Int, Self: Int}, n), limit.base).mapSwift({Wrapped: this.$info.Base.Index, U: _clarifyGenerics({Self:ReversedCollection, Base: this.$info.Base}).Index}, init({Base: this.$info.Base}, ReversedCollection.Index))
----Swift.(file).ReversedCollection.distance(from:ReversedCollection<Base>.Index,to:ReversedCollection<Base>.Index)
return this._base.distanceFromTo({Self: this.$info.Base}, end.base, start.base)
----Swift.(file).ReversedCollection.subscript(_:ReversedCollection<Base>.Index)
return this._base.subscript$get({}, this._base.indexBefore({Self: this.$info.Base}, position.base))
----Swift.(file).ReversedCollection.reversed()
return this._base
----Swift.(file).Sequence.makeIterator()
return this
----Swift.(file).Sequence.map(_:(Self.Element) throws -> T)
const initialCapacity = this.underestimatedCount;
let result = _create(ContiguousArray, 'init', {Element: $info.T}, );
result.reserveCapacity({$setThis: $val => result = $val, Element: $info.T}, initialCapacity);
let iterator = this.makeIterator({Self: $info.Self}, );
{
let $generator = _cloneStruct(Int.infix_46_46_60({Self: Int, Self: Int}, 0, initialCapacity).makeIterator({Self: _clarifyGenerics({Self:Range, Bound: Int})}, ));
while(true) {
if($generator.next({$setThis: $val => $generator = $val, Elements: _clarifyGenerics({Self:Range, Bound: Int})}, ) == null) break;
result.append({$setThis: $val => result = $val, Element: $info.T}, transform({}, iterator.next({$setThis: $val => iterator = $val, Self: $info.Self.Iterator}, )));
}
};
while(true){
const _element = iterator.next({$setThis: $val => iterator = $val, Self: $info.Self.Iterator}, )
if(!((_element != null))) break
result.append({$setThis: $val => result = $val, Element: $info.T}, transform({}, _element));
};
return _create(Array, 'initBuffer', {Element: $info.T, S: _clarifyGenerics({Self:ContiguousArray, Element: $info.T})}, result)
----Swift.(file).Sequence.filter(_:(Self.Element) throws -> Bool)
return this._filter({Self: this.$info.Self}, isIncluded)
----Swift.(file).Sequence.underestimatedCount
return 0
----Swift.(file).Sequence.forEach(_:(Self.Element) throws -> Void)
{
let $element$generator = this.makeIterator({Self: this.$info.Self}, );
while(true) {
const _element = $element$generator.next({$setThis: $val => $element$generator = $val, Self: this.$info.Self.Iterator}, );
if(!((_element != null))) break;
body({}, _element);
}
}
----Swift.(file).Sequence.first(where:(Self.Element) throws -> Bool)
{
let $element$generator = this.makeIterator({Self: this.$info.Self}, );
while(true) {
const _element = $element$generator.next({$setThis: $val => $element$generator = $val, Self: this.$info.Self.Iterator}, );
if(!((_element != null))) break;
{
if((predicate({}, _element))) {
return _element;
}
};
}
};
return null
----Swift.(file).Sequence.split(separator:Self.Element,maxSplits:Int,omittingEmptySubsequences:Bool)
return this.splitMaxSplitsOmittingEmptySubsequencesWhereSeparator({Self: this.$info.Self}, maxSplits, omittingEmptySubsequences, (($info, $0) => this.$info.Self.Element.infix_61_61({Self: this.$info.Self.Element, Self: this.$info.Self.Element}, $0, separator)))
----Swift.(file).Sequence.split(maxSplits:Int,omittingEmptySubsequences:Bool,whereSeparator:(Self.Element) throws -> Bool)
preconditionFileLine({}, () => Int.infix_62_61({Self: Int}, maxSplits, 0), () => "Must take zero or more splits", '?3', '?3');
const whole = _create(Array, 'initBuffer', {Element: this.$info.Self.Element, S: this.$info.Self}, this);
return whole.splitMaxSplitsOmittingEmptySubsequencesWhereSeparator({Self: _clarifyGenerics({Self:Array, Element: this.$info.Self.Element})}, maxSplits, omittingEmptySubsequences, isSeparator)
----Swift.(file).Sequence.suffix(_:Int)
preconditionFileLine({}, () => Int.infix_62_61({Self: Int}, maxLength, 0), () => "Can't take a suffix of negative length from a sequence", '?3', '?3');
{
if(!((Int.infix_33_61({Self: Int, Self: Int}, maxLength, 0)))) {
return _create(Array, 'initBuffer', {Element: this.$info.Self.Element}, []);
}
};
let ringBuffer = _create(Array, 'initBuffer', {Element: this.$info.Self.Element}, []);
ringBuffer.reserveCapacity({$setThis: $val => ringBuffer = $val, Element: this.$info.Self.Element}, /*dot_syntax_base_ignored*/min({}, maxLength, this.underestimatedCount));
let i = 0;
{
let $element$generator = this.makeIterator({Self: this.$info.Self}, );
while(true) {
const _element = $element$generator.next({$setThis: $val => $element$generator = $val, Self: this.$info.Self.Iterator}, );
if(!((_element != null))) break;
{
if((Int.infix_60({Self: Int}, ringBuffer.count, maxLength))) {
ringBuffer.append({$setThis: $val => ringBuffer = $val, Element: this.$info.Self.Element}, _element);
}
else {
ringBuffer.subscript$set({$setThis: $val => ringBuffer = $val}, _element, i);
Int.infix_43_61({Self: Int}, {get: () => i, set: $val => i = $val}, 1);
Int.infix_37_61({Self: Int}, {get: () => i, set: $val => i = $val}, maxLength);
}
};
}
};
{
if((Int.infix_33_61({Self: Int, Self: Int}, i, ringBuffer.startIndex))) {
let rotated = _create(Array, 'initBuffer', {Element: this.$info.Self.Element}, []);
rotated.reserveCapacity({$setThis: $val => rotated = $val, Element: this.$info.Self.Element}, ringBuffer.count);
Array.infix_43_61({Self: Array, Self: _clarifyGenerics({Self:Array, Element: this.$info.Self.Element}), Other: _clarifyGenerics({Self:ArraySlice, Element: this.$info.Self.Element})}, {get: () => rotated, set: $val => rotated = $val}, ringBuffer.subscriptRange$get({}, Int.infix_46_46_60({Self: Int, Self: Int}, i, ringBuffer.endIndex)));
Array.infix_43_61({Self: Array, Self: _clarifyGenerics({Self:Array, Element: this.$info.Self.Element}), Other: _clarifyGenerics({Self:ArraySlice, Element: this.$info.Self.Element})}, {get: () => rotated, set: $val => rotated = $val}, ringBuffer.subscriptRange$get({}, Int.infix_46_46_60({Self: Int, Self: Int}, 0, i)));
return rotated;
}
else {
return ringBuffer;
}
}
----Swift.(file).Sequence.dropFirst(_:Int)
return _create(DropFirstSequence, 'initDroppingInt', {Base: this.$info.Self}, this, k)
----Swift.(file).Sequence.dropLast(_:Int)
preconditionFileLine({}, () => Int.infix_62_61({Self: Int}, k, 0), () => "Can't drop a negative number of elements from a sequence", '?3', '?3');
{
if(!((Int.infix_33_61({Self: Int, Self: Int}, k, 0)))) {
return _create(Array, 'initBuffer', {Element: this.$info.Self.Element, S: this.$info.Self}, this);
}
};
let result = _create(Array, 'initBuffer', {Element: this.$info.Self.Element}, []);
let ringBuffer = _create(Array, 'initBuffer', {Element: this.$info.Self.Element}, []);
let i = ringBuffer.startIndex;
{
let $element$generator = this.makeIterator({Self: this.$info.Self}, );
while(true) {
const _element = $element$generator.next({$setThis: $val => $element$generator = $val, Self: this.$info.Self.Iterator}, );
if(!((_element != null))) break;
{
if((Int.infix_60({Self: Int}, ringBuffer.count, k))) {
ringBuffer.append({$setThis: $val => ringBuffer = $val, Element: this.$info.Self.Element}, _element);
}
else {
result.append({$setThis: $val => result = $val, Element: this.$info.Self.Element}, ringBuffer.subscript$get({}, i));
ringBuffer.subscript$set({$setThis: $val => ringBuffer = $val}, _element, i);
Int.infix_43_61({Self: Int}, {get: () => i, set: $val => i = $val}, 1);
Int.infix_37_61({Self: Int}, {get: () => i, set: $val => i = $val}, k);
}
};
}
};
return result
----Swift.(file).Sequence.prefix(_:Int)
return _create(PrefixSequence, 'initMaxLengthInt', {Base: this.$info.Self}, this, maxLength)
----Swift.(file).Sequence.prefix(while:(Self.Element) throws -> Bool)
let result = _create(Array, 'initBuffer', {Element: this.$info.Self.Element}, []);
{
let $element$generator = this.makeIterator({Self: this.$info.Self}, );
while(true) {
const _element = $element$generator.next({$setThis: $val => $element$generator = $val, Self: this.$info.Self.Iterator}, );
if(!((_element != null))) break;
{
if(!((predicate({}, _element)))) {
break;
}
};
result.append({$setThis: $val => result = $val, Element: this.$info.Self.Element}, _element);
}
};
return result
----Swift.(file).Sequence.withContiguousStorageIfAvailable(_:(UnsafeBufferPointer<Self.Element>) throws -> R)
return null
----Swift.(file).Sequence.min(by:(Self.Element, Self.Element) throws -> Bool)
let it = this.makeIterator({Self: this.$info.Self}, );
{let result = it.next({$setThis: $val => it = $val, Self: this.$info.Self.Iterator}, )
if(!((result != null))) {
return null;
}
};
while(true){
const e = it.next({$setThis: $val => it = $val, Self: this.$info.Self.Iterator}, )
if(!((e != null))) break
{
if((areInIncreasingOrder({}, e, result))) {
result = e;
}
};
};
return result
----Swift.(file).Sequence.max(by:(Self.Element, Self.Element) throws -> Bool)
let it = this.makeIterator({Self: this.$info.Self}, );
{let result = it.next({$setThis: $val => it = $val, Self: this.$info.Self.Iterator}, )
if(!((result != null))) {
return null;
}
};
while(true){
const e = it.next({$setThis: $val => it = $val, Self: this.$info.Self.Iterator}, )
if(!((e != null))) break
{
if((areInIncreasingOrder({}, result, e))) {
result = e;
}
};
};
return result
----Swift.(file).Sequence.min()
return this.minBy({Self: this.$info.Self}, this.$info.Self.Element.infix_60)
----Swift.(file).Sequence.max()
return this.maxBy({Self: this.$info.Self}, this.$info.Self.Element.infix_60)
----Swift.(file).Sequence.starts(with:PossiblePrefix,by:(Self.Element, PossiblePrefix.Element) throws -> Bool)
let possiblePrefixIterator = possiblePrefix.makeIterator({Self: $info.PossiblePrefix}, );
{
let $e0$generator = this.makeIterator({Self: $info.Self}, );
while(true) {
const e0 = $e0$generator.next({$setThis: $val => $e0$generator = $val, Self: $info.Self.Iterator}, );
if(!((e0 != null))) break;
{const e1 = possiblePrefixIterator.next({$setThis: $val => possiblePrefixIterator = $val, Self: $info.PossiblePrefix.Iterator}, )
if((e1 != null)) {
{
if((Bool.prefix_33({Self: Bool}, areEquivalent({}, e0, e1)))) {
return false;
}
};
}
else {
return true;
}
};
}
};
return Optional.infix_61_61({Self: Optional, Wrapped: $info.PossiblePrefix.Element}, possiblePrefixIterator.next({$setThis: $val => possiblePrefixIterator = $val, Self: $info.PossiblePrefix.Iterator}, ), null)
----Swift.(file).Sequence.starts(with:PossiblePrefix)
return this.startsWithBy({Self: $info.Self, PossiblePrefix: $info.PossiblePrefix}, possiblePrefix, $info.Self.Element.infix_61_61)
----Swift.(file).Sequence.elementsEqual(_:OtherSequence,by:(Self.Element, OtherSequence.Element) throws -> Bool)
let iter1 = this.makeIterator({Self: $info.Self}, );
let iter2 = other.makeIterator({Self: $info.OtherSequence}, );
while(true){
if(!((true))) break
const $match = {0: iter1.next({$setThis: $val => iter1 = $val, Self: $info.Self.Iterator}, ), 1: iter2.next({$setThis: $val => iter2 = $val, Self: $info.OtherSequence.Iterator}, )}
if(((true))) {
const e1 = $match[0]
const e2 = $match[1]
{
if((Bool.prefix_33({Self: Bool}, areEquivalent({}, e1, e2)))) {
return false;
}
};
}
else if((($match[1].rawValue == Optional.none.rawValue) || ($match[0].rawValue == Optional.none.rawValue))) {
return false;
}
else if((($match[0].rawValue == Optional.none.rawValue && $match[1].rawValue == Optional.none.rawValue))) {
return true;
};
}
----Swift.(file).Sequence.elementsEqual(_:OtherSequence)
return this.elementsEqualBy({Self: $info.Self, OtherSequence: $info.OtherSequence}, other, $info.Self.Element.infix_61_61)
----Swift.(file).Sequence.lexicographicallyPrecedes(_:OtherSequence,by:(Self.Element, Self.Element) throws -> Bool)
let iter1 = this.makeIterator({Self: $info.Self}, );
let iter2 = other.makeIterator({Self: $info.OtherSequence}, );
while(true){
if(!((true))) break
{const e1 = iter1.next({$setThis: $val => iter1 = $val, Self: $info.Self.Iterator}, )
if((e1 != null)) {
{const e2 = iter2.next({$setThis: $val => iter2 = $val, Self: $info.OtherSequence.Iterator}, )
if((e2 != null)) {
{
if((areInIncreasingOrder({}, e1, e2))) {
return true;
}
};
{
if((areInIncreasingOrder({}, e2, e1))) {
return false;
}
};
continue;
}
};
return false;
}
};
return Optional.infix_33_61({Self: Optional, Wrapped: $info.Self.Element}, iter2.next({$setThis: $val => iter2 = $val, Self: $info.OtherSequence.Iterator}, ), null);
}
----Swift.(file).Sequence.lexicographicallyPrecedes(_:OtherSequence)
return this.lexicographicallyPrecedesBy({Self: $info.Self, OtherSequence: $info.OtherSequence}, other, $info.Self.Element.infix_60)
----Swift.(file).Sequence.contains(where:(Self.Element) throws -> Bool)
{
let $e$generator = this.makeIterator({Self: this.$info.Self}, );
while(true) {
const e = $e$generator.next({$setThis: $val => $e$generator = $val, Self: this.$info.Self.Iterator}, );
if(!((e != null))) break;
{
if((predicate({}, e))) {
return true;
}
};
}
};
return false
----Swift.(file).Sequence.allSatisfy(_:(Self.Element) throws -> Bool)
return Bool.prefix_33({Self: Bool}, this.containsWhere({Self: this.$info.Self}, (($info, $0) => Bool.prefix_33({Self: Bool}, predicate({}, $0)))))
----Swift.(file).Sequence.contains(_:Self.Element)
{const result = this._customContainsEquatableElement({Self: this.$info.Self}, _element)
if((result != null)) {
return result;
}
else {
return this.containsWhere({Self: this.$info.Self}, (($info, $0) => this.$info.Self.Element.infix_61_61({Self: this.$info.Self.Element, Self: this.$info.Self.Element}, $0, _element)));
}
}
----Swift.(file).Sequence.count(where:(Self.Element) throws -> Bool)
let count = 0;
{
let $e$generator = this.makeIterator({Self: this.$info.Self}, );
while(true) {
const e = $e$generator.next({$setThis: $val => $e$generator = $val, Self: this.$info.Self.Iterator}, );
if(!((e != null))) break;
{
if((predicate({}, e))) {
Int.infix_43_61({Self: Int}, {get: () => count, set: $val => count = $val}, 1);
}
};
}
};
return count
----Swift.(file).Sequence.reduce(_:Result,_:(Result, Self.Element) throws -> Result)
let accumulator = initialResult;
{
let $element$generator = this.makeIterator({Self: $info.Self}, );
while(true) {
const _element = $element$generator.next({$setThis: $val => $element$generator = $val, Self: $info.Self.Iterator}, );
if(!((_element != null))) break;
accumulator = nextPartialResult({}, accumulator, _element);
}
};
return accumulator
----Swift.(file).Sequence.reduce(into:Result,_:(inout Result, Self.Element) throws -> ())
let accumulator = initialResult;
{
let $element$generator = this.makeIterator({Self: $info.Self}, );
while(true) {
const _element = $element$generator.next({$setThis: $val => $element$generator = $val, Self: $info.Self.Iterator}, );
if(!((_element != null))) break;
updateAccumulatingResult({}, {get: () => accumulator, set: $val => accumulator = $val}, _element);
}
};
return accumulator
----Swift.(file).Sequence.reversed()
let result = _create(Array, 'initBuffer', {Element: this.$info.Self.Element, S: this.$info.Self}, this);
const count = result.count;
{
let $i$generator = _cloneStruct(Int.infix_46_46_60({Self: Int, Self: Int}, 0, Int.infix_47({Self: Int}, count, 2)).makeIterator({Self: _clarifyGenerics({Self:Range, Bound: Int})}, ));
while(true) {
const i = $i$generator.next({$setThis: $val => $i$generator = $val, Elements: _clarifyGenerics({Self:Range, Bound: Int})}, );
if(!((i != null))) break;
result.swapAt({$setThis: $val => result = $val, Self: _clarifyGenerics({Self:Array, Element: this.$info.Self.Element})}, i, Int.infix_45({Self: Int}, count, Int.infix_43({Self: Int}, i, 1)));
}
};
return result
----Swift.(file).Sequence.flatMap(_:(Self.Element) throws -> SegmentOfResult)
let result = _create(Array, 'initBuffer', {Element: $info.SegmentOfResult.Element}, []);
{
let $element$generator = this.makeIterator({Self: $info.Self}, );
while(true) {
const _element = $element$generator.next({$setThis: $val => $element$generator = $val, Self: $info.Self.Iterator}, );
if(!((_element != null))) break;
result.appendContentsOf({$setThis: $val => result = $val, Element: $info.SegmentOfResult.Element, S: $info.SegmentOfResult}, transform({}, _element));
}
};
return result
----Swift.(file).Sequence.compactMap(_:(Self.Element) throws -> ElementOfResult?)
return this._compactMap({Self: $info.Self, ElementOfResult: $info.ElementOfResult}, transform)
----Swift.(file).Set.filter(_:(Element) throws -> Bool)
let result = _create(Set, 'init', {Element: this.$info.Element}, );
{
let $element$generator = _cloneStruct(this.makeIterator({Element: this.$info.Element}, ));
while(true) {
const _element = $element$generator.next({$setThis: $val => $element$generator = $val, Element: this.$info.Element}, );
if(!((_element != null))) break;
{
if((isIncluded({}, _element))) {
result.insert({$setThis: $val => result = $val, Element: this.$info.Element}, _element);
}
};
}
};
return result
----Swift.(file).Set.isEmpty
return Int.infix_61_61({Self: Int}, this.count, 0)
----Swift.(file).Set.removeFirst()
preconditionFileLine({}, () => Bool.prefix_33({Self: Bool}, this.isEmpty), () => "Can't removeFirst from an empty Set", '?3', '?3');
return this.removeAt({$setThis: $val => $info.$setThis(_cloneStruct($val)), Element: this.$info.Element}, this.startIndex)
----Swift.(file).Set.isSubset(of:S)
{
if(!((Bool.prefix_33({Self: Bool}, this.isEmpty)))) {
return true;
}
};
const other = _create(Set, 'initSource', {Element: $info.Element, Source: $info.S}, possibleSuperset);
return this.isSubsetOf({Element: $info.Element}, other)
----Swift.(file).Set.isStrictSubset(of:S)
const other = _create(Set, 'initSource', {Element: $info.Element, Source: $info.S}, possibleStrictSuperset);
return this.isStrictSubsetOf({Element: $info.Element}, other)
----Swift.(file).Set.isSuperset(of:S)
{
let $member$generator = possibleSubset.makeIterator({Self: $info.S}, );
while(true) {
const member = $member$generator.next({$setThis: $val => $member$generator = $val, Self: $info.S.Iterator}, );
if(!((member != null))) break;
{
if((Bool.prefix_33({Self: Bool}, this.contains({Element: $info.Element}, member)))) {
return false;
}
};
}
};
return true
----Swift.(file).Set.isStrictSuperset(of:S)
const other = _create(Set, 'initSource', {Element: $info.Element, Source: $info.S}, possibleStrictSubset);
return other.isStrictSubsetOf({Self: _clarifyGenerics({Self:Set, Element: $info.Element})}, this)
----Swift.(file).Set.union(_:S)
let newSet = _cloneStruct(this);
newSet.formUnion({$setThis: $val => newSet = $val, Element: $info.Element, S: $info.S}, other);
return newSet
----Swift.(file).Set.formUnion(_:S)
{
let $item$generator = other.makeIterator({Self: $info.S}, );
while(true) {
const item = $item$generator.next({$setThis: $val => $item$generator = $val, Self: $info.S.Iterator}, );
if(!((item != null))) break;
this.insert({$setThis: $val => $info.$setThis(_cloneStruct($val)), Element: $info.Element}, item);
}
}
----Swift.(file).Set.intersection(_:S)
const otherSet = _create(Set, 'initSource', {Element: $info.Element, Source: $info.S}, other);
return this.intersection({Element: $info.Element}, otherSet)
----Swift.(file).Set.formIntersection(_:S)
const result = _cloneStruct(this.intersection({Element: $info.Element, S: $info.S}, other));
{
if((Int.infix_33_61({Self: Int, Self: Int}, result.count, this.count))) {
$info.$setThis(_cloneStruct(_cloneStruct(result)));
}
}
----Swift.(file).Set.symmetricDifference(_:S)
let newSet = _cloneStruct(this);
newSet.formSymmetricDifference({$setThis: $val => newSet = $val, Element: $info.Element, S: $info.S}, other);
return newSet
----Swift.(file).Set.formSymmetricDifference(_:S)
const otherSet = _create(Set, 'initSource', {Element: $info.Element, Source: $info.S}, other);
this.formSymmetricDifference({$setThis: $val => $info.$setThis(_cloneStruct($val)), Element: $info.Element}, otherSet)
----Swift.(file).Set.isSubset(of:Set<Element>)
{
if(!((Int.infix_60_61({Self: Int}, this.count, other.count)))) {
return false;
}
};
{
let $member$generator = _cloneStruct(this.makeIterator({Element: this.$info.Element}, ));
while(true) {
const member = $member$generator.next({$setThis: $val => $member$generator = $val, Element: this.$info.Element}, );
if(!((member != null))) break;
{
if((Bool.prefix_33({Self: Bool}, other.contains({Element: this.$info.Element}, member)))) {
return false;
}
};
}
};
return true
----Swift.(file).Set.isSuperset(of:Set<Element>)
return other.isSubsetOf({Element: this.$info.Element}, this)
----Swift.(file).Set.isStrictSuperset(of:Set<Element>)
return Bool.infix_38_38({Self: Bool}, this.isSupersetOf({Element: this.$info.Element}, other), () => Set.infix_33_61({Self: Set, Self: _clarifyGenerics({Self:Set, Element: this.$info.Element})}, this, other))
----Swift.(file).Set.isStrictSubset(of:Set<Element>)
return other.isStrictSupersetOf({Element: this.$info.Element}, this)
----Swift.(file).Set.intersection(_:Set<Element>)
let newSet = _create(Set, 'init', {Element: this.$info.Element}, );
{
let $member$generator = _cloneStruct(this.makeIterator({Element: this.$info.Element}, ));
while(true) {
const member = $member$generator.next({$setThis: $val => $member$generator = $val, Element: this.$info.Element}, );
if(!((member != null))) break;
{
if((other.contains({Element: this.$info.Element}, member))) {
newSet.insert({$setThis: $val => newSet = $val, Element: this.$info.Element}, member);
}
};
}
};
return newSet
----Swift.(file).Set.formSymmetricDifference(_:Set<Element>)
{
let $member$generator = _cloneStruct(other.makeIterator({Element: this.$info.Element}, ));
while(true) {
const member = $member$generator.next({$setThis: $val => $member$generator = $val, Element: this.$info.Element}, );
if(!((member != null))) break;
{
if((this.contains({Element: this.$info.Element}, member))) {
this.remove({$setThis: $val => $info.$setThis(_cloneStruct($val)), Element: this.$info.Element}, member);
}
else {
this.insert({$setThis: $val => $info.$setThis(_cloneStruct($val)), Element: this.$info.Element}, member);
}
};
}
}
----Swift.(file).Set.customMirror
const style = Mirror.DisplayStyle.set;
return _create(Mirror, 'initUnlabeledChildrenDisplayStyleOptionalAncestorRepresentationMirrorAncestorRepresentation', {Subject: _clarifyGenerics({Self:Set, Element: this.$info.Element}), C: _clarifyGenerics({Self:Set, Element: this.$info.Element})}, this, this, style, null)
----Swift.(file).Set.popFirst()
{
if(!((Bool.prefix_33({Self: Bool}, this.isEmpty)))) {
return null;
}
};
return this.removeAt({$setThis: $val => $info.$setThis(_cloneStruct($val)), Element: this.$info.Element}, this.startIndex)
----Swift.(file).SetAlgebra.init(_:S)
this.init({}, );
{
let $e$generator = sequence.makeIterator({Self: $info.S}, );
while(true) {
const e = $e$generator.next({$setThis: $val => $e$generator = $val, Self: $info.S.Iterator}, );
if(!((e != null))) break;
this.insert({$setThis: $val => $info.$setThis(_cloneStruct($val)), Self: $info.Self}, e);
}
};
return
----Swift.(file).SetAlgebra.subtract(_:Self)
this.formIntersection({$setThis: $val => $info.$setThis(_cloneStruct($val)), Self: this.$info.Self}, this.symmetricDifference({Self: this.$info.Self}, other))
----Swift.(file).SetAlgebra.isSubset(of:Self)
return this.$info.Self.infix_61_61({Self: this.$info.Self, Self: this.$info.Self}, this.intersection({Self: this.$info.Self}, other), this)
----Swift.(file).SetAlgebra.isSuperset(of:Self)
return other.isSubsetOf({Self: this.$info.Self}, this)
----Swift.(file).SetAlgebra.isDisjoint(with:Self)
return this.intersection({Self: this.$info.Self}, other).isEmpty
----Swift.(file).SetAlgebra.subtracting(_:Self)
return this.intersection({Self: this.$info.Self}, this.symmetricDifference({Self: this.$info.Self}, other))
----Swift.(file).SetAlgebra.isEmpty
return this.$info.Self.infix_61_61({Self: this.$info.Self, Self: this.$info.Self}, this, _create(this.$info.Self, 'init', {Self: this.$info.Self}, ))
----Swift.(file).SetAlgebra.isStrictSuperset(of:Self)
return Bool.infix_38_38({Self: Bool}, this.isSupersetOf({Self: this.$info.Self}, other), () => this.$info.Self.infix_33_61({Self: this.$info.Self, Self: this.$info.Self}, this, other))
----Swift.(file).SetAlgebra.isStrictSubset(of:Self)
return other.isStrictSupersetOf({Self: this.$info.Self}, this)
----Swift.(file).SetAlgebra.init(arrayLiteral:[Self.Element])
this.initSource({}, arrayLiteral);
return
----Swift.(file).Set.insert(_:ConcreteElement)
const $tuple = this.insert({$setThis: $val => $info.$setThis(_cloneStruct($val)), Element: AnyHashable}, _create(AnyHashable, 'init', {H: $info.ConcreteElement}, newMember)), inserted = $tuple && $tuple[0], memberAfterInsert = $tuple && $tuple[1];
return {0: inserted, 1: memberAfterInsert.base}
----Swift.(file).Set.update(with:ConcreteElement)
return this.updateWith({$setThis: $val => $info.$setThis(_cloneStruct($val)), Element: AnyHashable}, _create(AnyHashable, 'init', {H: $info.ConcreteElement}, newMember)).mapSwift({Wrapped: AnyHashable, U: $info.ConcreteElement}, (($info, $0) => $0.base))
----Swift.(file).Set.remove(_:ConcreteElement)
return this.remove({$setThis: $val => $info.$setThis(_cloneStruct($val)), Element: AnyHashable}, _create(AnyHashable, 'init', {H: $info.ConcreteElement}, member)).mapSwift({Wrapped: AnyHashable, U: $info.ConcreteElement}, (($info, $0) => $0.base))
----Swift.(file).Slice.startIndex
return this._startIndex
----Swift.(file).Slice.endIndex
return this._endIndex
----Swift.(file).Sequence.sorted()
return this.sortedBy({Self: this.$info.Self}, this.$info.Self.Element.infix_60)
----Swift.(file).Sequence.sorted(by:(Self.Element, Self.Element) throws -> Bool)
let result = _create(ContiguousArray, 'initBuffer', {Element: this.$info.Self.Element, S: this.$info.Self}, this);
result.sortBy({$setThis: $val => result = $val, Self: _clarifyGenerics({Self:ContiguousArray, Element: this.$info.Self.Element})}, areInIncreasingOrder);
return _create(Array, 'initBuffer', {Element: this.$info.Self.Element, S: _clarifyGenerics({Self:ContiguousArray, Element: this.$info.Self.Element})}, result)
----Swift.(file).MutableCollection.sort()
this.sortBy({$setThis: $val => $info.$setThis(_cloneStruct($val)), Self: this.$info.Self}, this.$info.Self.Element.infix_60)
----Swift.(file).MutableCollection.sort(by:(Self.Element, Self.Element) throws -> Bool)
const didSortUnsafeBuffer = this._withUnsafeMutableBufferPointerIfSupported({$setThis: $val => $info.$setThis(_cloneStruct($val)), Self: this.$info.Self, R: _clarifyGenerics({Self:Optional, Wrapped: Void})}, (($info, buffer$inout) => buffer._stableSortImplBy({$setThis: $val => buffer = $val, Element: this.$info.Self.Element}, areInIncreasingOrder)));
{
if((Optional.infix_61_61({Self: Optional, Wrapped: _clarifyGenerics({Self:Optional, Wrapped: Void})}, didSortUnsafeBuffer, null))) {
const sortedElements = _cloneStruct(this.sortedBy({Self: this.$info.Self}, areInIncreasingOrder));
{
let $generator = _cloneStruct(zip({Sequence1: this.$info.Self.Indices, Sequence2: _clarifyGenerics({Self:Range, Bound: _clarifyGenerics({Self:Array, Element: {$genericType: 'Element'}}).Index})}, this.indices, sortedElements.indices).makeIterator({Sequence1: this.$info.Self.Indices, Sequence2: _clarifyGenerics({Self:Range, Bound: _clarifyGenerics({Self:Array, Element: {$genericType: 'Element'}}).Index})}, ));
while(true) {
const $tuple = $generator.next({$setThis: $val => $generator = $val, Sequence1: this.$info.Self.Indices, Sequence2: _clarifyGenerics({Self:Range, Bound: _clarifyGenerics({Self:Array, Element: {$genericType: 'Element'}}).Index})}, ), i = $tuple && $tuple[0], j = $tuple && $tuple[1];
if(!((i != null) && (j != null))) break;
this.subscript$set({$setThis: $val => $info.$setThis(_cloneStruct($val))}, sortedElements.subscript$get({}, j), i);
}
};
}
}
----Swift.(file).StaticString.init()
$info.$setThis(_cloneStruct(_cloneStruct("")));
return
----Swift.(file).StaticString.init(unicodeScalarLiteral:StaticString)
$info.$setThis(_cloneStruct(_cloneStruct(value)));
return
----Swift.(file).StaticString.init(extendedGraphemeClusterLiteral:StaticString)
$info.$setThis(_cloneStruct(_cloneStruct(value)));
return
----Swift.(file).StaticString.init(stringLiteral:StaticString)
$info.$setThis(_cloneStruct(_cloneStruct(value)));
return
----Swift.(file).StaticString.debugDescription
return this.description.debugDescription
----Swift.(file).StaticString.customMirror
return _create(Mirror, 'initReflectingprotocol_composition_type', {}, this.description)
----Swift.(file).Strideable.<infix(_:Self,_:Self)
return $info.Self.Stride.infix_62({Self: $info.Self.Stride, Self: $info.Self.Stride}, x.distanceTo({Self: $info.Self}, y), _create($info.Self.Stride, 'initIntegerLiteral', {Self: $info.Self.Stride}, 0))
----Swift.(file).Strideable.==infix(_:Self,_:Self)
return $info.Self.Stride.infix_61_61({Self: $info.Self.Stride, Self: $info.Self.Stride}, x.distanceTo({Self: $info.Self}, y), _create($info.Self.Stride, 'initIntegerLiteral', {Self: $info.Self.Stride}, 0))
----Swift.(file).StrideTo.underestimatedCount
let it = _cloneStruct(this.makeIterator({Element: this.$info.Element}, ));
let count = 0;
while(true){
if(!((Optional.infix_33_61({Self: Optional, Wrapped: this.$info.Element}, it.next({$setThis: $val => it = $val, Element: this.$info.Element}, ), null)))) break
Int.infix_43_61({Self: Int}, {get: () => count, set: $val => count = $val}, 1);
};
return count
----Swift.(file).StrideThrough.underestimatedCount
let it = _cloneStruct(this.makeIterator({Element: this.$info.Element}, ));
let count = 0;
while(true){
if(!((Optional.infix_33_61({Self: Optional, Wrapped: this.$info.Element}, it.next({$setThis: $val => it = $val, Element: this.$info.Element}, ), null)))) break
Int.infix_43_61({Self: Int}, {get: () => count, set: $val => count = $val}, 1);
};
return count
----Swift.(file).String.init(stringLiteral:String)
$info.$setThis(_cloneStruct(value));
return
----Swift.(file).String.debugDescription
let result = "\"";
{
let $us$generator = _cloneStruct(this.unicodeScalars.makeIterator({}, ));
while(true) {
const us = $us$generator.next({$setThis: $val => $us$generator = $val}, );
if(!((us != null))) break;
String.infix_43_61({Self: String}, {get: () => result, set: $val => result = $val}, us.escapedAsASCII({}, false));
}
};
String.infix_43_61({Self: String}, {get: () => result, set: $val => result = $val}, "\"");
return result
----Swift.(file).String.+infix(_:String,_:String)
let result = lhs;
result.append({$setThis: $val => result = $val}, rhs);
return result
----Swift.(file).String.+=infix(_:String,_:String)
let lhs = lhs$inout.get()
const $result = (() => {
lhs.append({$setThis: $val => lhs = $val}, rhs);})()
lhs$inout.set(lhs)
return $result
----Swift.(file).Sequence.joined(separator:String)
let result = "";
{
if((separator.isEmpty)) {
{
let $x$generator = this.makeIterator({Self: this.$info.Self}, );
while(true) {
const x = $x$generator.next({$setThis: $val => $x$generator = $val, Self: this.$info.Self.Iterator}, );
if(!((x != null))) break;
result.append({$setThis: $val => result = $val}, _create(String, 'initString', {S: String}, x._ephemeralString));
}
};
return result;
}
};
let iter = this.makeIterator({Self: this.$info.Self}, );
{const first = iter.next({$setThis: $val => iter = $val, Self: this.$info.Self.Iterator}, )
if((first != null)) {
result.append({$setThis: $val => result = $val}, _create(String, 'initString', {S: this.$info.Self.Element}, first));
while(true){
const next = iter.next({$setThis: $val => iter = $val, Self: this.$info.Self.Iterator}, )
if(!((next != null))) break
result.append({$setThis: $val => result = $val}, separator);
result.append({$setThis: $val => result = $val}, _create(String, 'initString', {S: this.$info.Self.Element}, next));
};
}
};
return result
----Swift.(file).BidirectionalCollection.joined(separator:String)
let result = "";
{
if((separator.isEmpty)) {
{
let $x$generator = this.makeIterator({Self: this.$info.Self}, );
while(true) {
const x = $x$generator.next({$setThis: $val => $x$generator = $val, Self: this.$info.Self.Iterator}, );
if(!((x != null))) break;
result.append({$setThis: $val => result = $val}, _create(String, 'initString', {S: String}, x._ephemeralString));
}
};
return result;
}
};
let iter = this.makeIterator({Self: this.$info.Self}, );
{const first = iter.next({$setThis: $val => iter = $val, Self: this.$info.Self.Iterator}, )
if((first != null)) {
result.append({$setThis: $val => result = $val}, _create(String, 'initString', {S: String}, first));
while(true){
const next = iter.next({$setThis: $val => iter = $val, Self: this.$info.Self.Iterator}, )
if(!((next != null))) break
result.append({$setThis: $val => result = $val}, separator);
result.append({$setThis: $val => result = $val}, _create(String, 'initString', {S: String}, next));
};
}
};
return result
----Swift.(file).String.description
return this
----Swift.(file).String.count
return this.distanceFromTo({}, this.startIndex, this.endIndex)
----Swift.(file).StringProtocol.!=infix(_:Self,_:RHS)
return Bool.prefix_33({Self: Bool}, $info.Self.infix_61_61({Self: $info.Self, Self: $info.Self, RHS: $info.RHS}, lhs, rhs))
----Swift.(file).StringProtocol.>infix(_:Self,_:RHS)
return $info.RHS.infix_60({Self: $info.RHS, Self: $info.RHS, RHS: $info.Self}, rhs, lhs)
----Swift.(file).StringProtocol.<=infix(_:Self,_:RHS)
return Bool.prefix_33({Self: Bool}, $info.RHS.infix_60({Self: $info.RHS, Self: $info.RHS, RHS: $info.Self}, rhs, lhs))
----Swift.(file).StringProtocol.>=infix(_:Self,_:RHS)
return Bool.prefix_33({Self: Bool}, $info.Self.infix_60({Self: $info.Self, Self: $info.Self, RHS: $info.RHS}, lhs, rhs))
----Swift.(file)._StringGuts.startUTF16
fatalErrorFileLine({}, () => "Not contiguous UTF-16", '?3', '?3')
----Swift.(file).Index.samePosition(in:String.UTF8View)
return _create(String.UTF8View.Index, 'initStringIndexWithinStringUTF8View', {}, this, utf8)
----Swift.(file).Index.samePosition(in:String.UTF16View)
return _create(String.UTF16View.Index, 'initStringIndexWithinStringUTF16View', {}, this, utf16)
----Swift.(file).DefaultStringInterpolation.appendLiteral(_:String)
literal.writeTo({Target: DefaultStringInterpolation}, {get: () => this, set: $val => $info.$setThis(_cloneStruct($val))})
----Swift.(file).DefaultStringInterpolation.appendInterpolation(_:T)
value.writeTo({Self: $info.T, Target: DefaultStringInterpolation}, {get: () => this, set: $val => $info.$setThis(_cloneStruct($val))})
----Swift.(file).DefaultStringInterpolation.appendInterpolation(_:T)
value.writeTo({Self: $info.T, Target: DefaultStringInterpolation}, {get: () => this, set: $val => $info.$setThis(_cloneStruct($val))})
----Swift.(file).DefaultStringInterpolation.appendInterpolation(_:T)
value.description.writeTo({Target: DefaultStringInterpolation}, {get: () => this, set: $val => $info.$setThis(_cloneStruct($val))})
----Swift.(file).StringProtocol.hasPrefix(_:Prefix)
return this.startsWith({Self: $info.Self, PossiblePrefix: $info.Prefix}, prefix)
----Swift.(file).StringProtocol.hasSuffix(_:Suffix)
return this.reversed({Self: $info.Self}, ).startsWith({Self: _clarifyGenerics({Self:ReversedCollection, Base: $info.Self}), PossiblePrefix: _clarifyGenerics({Self:ReversedCollection, Base: $info.Suffix})}, suffix.reversed({Self: $info.Suffix}, ))
----Swift.(file).String.init(_:S)
{const str = characters
if((str != null)) {
$info.$setThis(_cloneStruct(str));
return ;
}
};
{const subStr = characters
if((subStr != null)) {
this.initSubstring({}, subStr);
return ;
}
};
$info.$setThis(_cloneStruct(""));
this.appendContentsOf({$setThis: $val => $info.$setThis(_cloneStruct($val)), S: $info.S}, characters);
return
----Swift.(file).String.append(_:String)
String.infix_43_61({Self: String}, {get: () => this, set: $val => $info.$setThis(_cloneStruct($val))}, other)
----Swift.(file).String.append(contentsOf:String)
this.append({$setThis: $val => $info.$setThis(_cloneStruct($val))}, newElements)
----Swift.(file).String.insert(contentsOf:S,at:String.Index)
this.replaceSubrangeWith({$setThis: $val => $info.$setThis(_cloneStruct($val)), C: $info.S}, String.Index.infix_46_46_60({Self: String.Index, Self: String.Index}, i, i), newElements)
----Swift.(file).String.max(_:T,_:T)
return /*dot_syntax_base_ignored*/max({}, x, y)
----Swift.(file).String.min(_:T,_:T)
return /*dot_syntax_base_ignored*/min({}, x, y)
----Swift.(file).Sequence.+infix(_:Self,_:String)
fatalErrorFileLine({}, null, '?3', '?3')
----Swift.(file).Sequence.+infix(_:String,_:Self)
fatalErrorFileLine({}, null, '?3', '?3')
----Swift.(file).UTF16View.debugDescription
return (("StringUTF16(") + (this.description.debugDescription) + (")"))
----Swift.(file).Index.samePosition(in:String.UnicodeScalarView)
return _create(String.UnicodeScalarIndex, 'initStringIndexWithinStringUnicodeScalarView', {}, this, unicodeScalars)
----Swift.(file).UTF16View.customMirror
return _create(Mirror, 'initUnlabeledChildrenDisplayStyleOptionalAncestorRepresentationMirrorAncestorRepresentation', {Subject: String.UTF16View, C: String.UTF16View}, this, this, null, null)
----Swift.(file).UTF8View.debugDescription
return (("UTF8View(") + (this.description.debugDescription) + (")"))
----Swift.(file).UTF8View.customMirror
return _create(Mirror, 'initUnlabeledChildrenDisplayStyleOptionalAncestorRepresentationMirrorAncestorRepresentation', {Subject: String.UTF8View, C: String.UTF8View}, this, this, null, null)
----Swift.(file).UnicodeScalarView.debugDescription
return (("StringUnicodeScalarView(") + (this.description.debugDescription) + (")"))
----Swift.(file).Index.samePosition(in:String)
return _create(String.Index, 'initStringIndexWithinString', {}, this, characters)
----Swift.(file).UnicodeScalarView.customMirror
return _create(Mirror, 'initUnlabeledChildrenDisplayStyleOptionalAncestorRepresentationMirrorAncestorRepresentation', {Subject: String.UnicodeScalarView, C: String.UnicodeScalarView}, this, this, null, null)
----Swift.(file).Substring.init(decoding:C,as:Encoding.Type)
this.initString({}, _create(String, 'initDecodingAs', {C: $info.C, Encoding: $info.Encoding}, codeUnits, sourceEncoding));
return
----Swift.(file).Substring.init(cString:UnsafePointer<CChar>)
this.initString({}, _create(String, 'initCStringUnsafePointer', {}, nullTerminatedUTF8));
return
----Swift.(file).Substring.init(decodingCString:UnsafePointer<Encoding.CodeUnit>,as:Encoding.Type)
this.initString({}, _create(String, 'initDecodingCStringUnsafePointerAs', {Encoding: $info.Encoding}, nullTerminatedCodeUnits, sourceEncoding));
return
----Swift.(file).Substring.withCString(_:(UnsafePointer<CChar>) throws -> Result)
return _create(String, 'initSubstring', {}, this).withCString({Result: $info.Result}, body)
----Swift.(file).Substring.withCString(encodedAs:TargetEncoding.Type,_:(UnsafePointer<TargetEncoding.CodeUnit>) throws -> Result)
return _create(String, 'initSubstring', {}, this).withCStringEncodedAs({Result: $info.Result, TargetEncoding: $info.TargetEncoding}, targetEncoding, body)
----Swift.(file).Substring.customMirror
return _create(String, 'initSubstring', {}, this).customMirror
----Swift.(file).Substring.description
return _create(String, 'initSubstring', {}, this)
----Swift.(file).Substring.debugDescription
return _create(String, 'initSubstring', {}, this).debugDescription
----Swift.(file).Substring.init(_:String)
$info.$setThis(_cloneStruct(_cloneStruct(content.subscriptUnboundedRange$get({}, UnboundedRange_.postfix_46_46_46))));
return
----Swift.(file).String.init(_:Substring.UnicodeScalarView)
$info.$setThis(_cloneStruct(_create(String, 'initSubstring', {}, _create(Substring, 'initSubstringUnicodeScalarView', {}, content))));
return
----Swift.(file).Substring.append(contentsOf:S)
let string = _create(String, 'initSubstring', {}, this);
$info.$setThis(_cloneStruct(_create(Substring, 'init', {}, )));
string.appendContentsOf({$setThis: $val => string = $val, S: $info.S}, _elements);
$info.$setThis(_cloneStruct(_create(Substring, 'initString', {}, string)))
----Swift.(file).Substring.lowercased()
return _create(String, 'initSubstring', {}, this).lowercased({}, )
----Swift.(file).Substring.uppercased()
return _create(String, 'initSubstring', {}, this).uppercased({}, )
----Swift.(file).Substring.filter(_:(Substring.Element) throws -> Bool)
return _create(String, 'initBuffer', {S: _clarifyGenerics({Self:Array, Element: Character})}, this.lazy.filterSwift({Self: _clarifyGenerics({Self:LazySequence, Base: Substring})}, isIncluded))
----Swift.(file).Substring.write(_:String)
this.appendContentsOf({$setThis: $val => $info.$setThis(_cloneStruct($val)), S: String}, other)
----Swift.(file).Substring.write(to:Target)
let target = target$inout.get()
const $result = (() => {
target.write({$setThis: $val => target = $val, Self: $info.Target}, _create(String, 'initSubstring', {}, this));})()
target$inout.set(target)
return $result
----Swift.(file).Substring.init(unicodeScalarLiteral:String)
this.initString({}, value);
return
----Swift.(file).Substring.init(extendedGraphemeClusterLiteral:String)
this.initString({}, value);
return
----Swift.(file).Substring.init(stringLiteral:String)
this.initString({}, value);
return
----Swift.(file)._UIntBuffer.makeIterator()
return _create(_UIntBuffer.Iterator, 'init_UIntBuffer', {Element: this.$info.Element}, this)
----Swift.(file)._UIntBuffer.init()
this._storage = 0;
this._bitCount = 0;
return
----Swift.(file)._UIntBuffer.capacity
return Int.infix_47({Self: Int}, _UIntBuffer.Storage.bitWidth, this.$info.Element.bitWidth)
----Swift.(file).UTF16.encodedReplacementCharacter
return _create(Unicode.UTF16.EncodedScalar, 'init_storage_UIntBufferStorage_bitCountUInt8', {Element: UInt16}, 0xFFFD, 16);
}
static get encodedReplacementCharacter() { return this.encodedReplacementCharacter$get()
----Swift.(file).UTF16.encode(_:Unicode.Scalar)
const x = source.value;
{
if((_fastPath({}, UInt32.infix_60({Self: UInt32}, x, UInt32.infix_60_60({Self: UInt32, Self: UInt32, Other: Int}, 1, 16))))) {
return _create(Unicode.UTF16.EncodedScalar, 'init_storage_UIntBufferStorage_bitCountUInt8', {Element: UInt16}, x, 16);
}
};
const x1 = UInt32.infix_45({Self: UInt32}, x, UInt32.infix_60_60({Self: UInt32, Self: UInt32, Other: Int}, 1, 16));
let r = UInt32.infix_43({Self: UInt32}, 0xdc00, UInt32.infix_38({Self: UInt32}, x1, 0x3ff));
UInt32.infix_38_60_60_61({Self: UInt32}, {get: () => r, set: $val => r = $val}, 16);
UInt32.infix_124_61({Self: UInt32}, {get: () => r, set: $val => r = $val}, UInt32.infix_43({Self: UInt32}, 0xd800, UInt32.infix_38({Self: UInt32}, UInt32.infix_38_62_62({Self: UInt32}, x1, 10), 0x3ff)));
return _create(Unicode.UTF16.EncodedScalar, 'init_storage_UIntBufferStorage_bitCountUInt8', {Element: UInt16}, r, 32)
----Swift.(file).UTF32.encode(_:Unicode.Scalar)
return _create(Unicode.UTF32.EncodedScalar, 'init', {Element: UInt32}, source.value)
----Swift.(file).Parser.parseScalar(from:I)
let input = input$inout.get()
const $result = (() => {
const n = input.next({$setThis: $val => input = $val, Self: $info.I}, );
{const x = n
if((_fastPath({}, Optional.infix_33_61({Self: Optional, Wrapped: Unicode.UTF32.Parser.Encoding.CodeUnit}, n, null))) && (x != null)) {
{
if(!((_fastPath({}, Bool.infix_38_38({Self: Bool}, UInt32.infix_33_61({Self: UInt32, Self: UInt32, Other: Int}, UInt32.infix_38_62_62({Self: UInt32}, x, 11), 0b11011), () => UInt32.infix_60_61({Self: UInt32}, x, 0x10ffff)))))) {
return Unicode.ParseResult.error({T: Unicode.UTF32.Parser.Encoding.EncodedScalar}, 1);
}
};
return Unicode.ParseResult.valid({T: Unicode.UTF32.Parser.Encoding.EncodedScalar}, _create(UTF32.EncodedScalar, 'init', {Element: UInt32}, x));
}
};
return Unicode.ParseResult.emptyInput;})()
input$inout.set(input)
return $result
----Swift.(file).UTF8.encodedReplacementCharacter
return Unicode.UTF8.EncodedScalar.encodedReplacementCharacter;
}
static get encodedReplacementCharacter() { return this.encodedReplacementCharacter$get()
----Swift.(file).UnicodeDecodingResult.==infix(_:UnicodeDecodingResult,_:UnicodeDecodingResult)
const $match = {0: lhs, 1: rhs}
if((($match[0].rawValue == UnicodeDecodingResult.scalarValue().rawValue && $match[1].rawValue == UnicodeDecodingResult.scalarValue().rawValue))) {
const lhsScalar = $match[0][0]
const rhsScalar = $match[1][0]
return Unicode.Scalar.infix_61_61({Self: Unicode.Scalar}, lhsScalar, rhsScalar);
}
else if((($match[0].rawValue == UnicodeDecodingResult.emptyInput.rawValue && $match[1].rawValue == UnicodeDecodingResult.emptyInput.rawValue))) {
return true;
}
else if((($match[0].rawValue == UnicodeDecodingResult.error.rawValue && $match[1].rawValue == UnicodeDecodingResult.error.rawValue))) {
return true;
}
else if(((true))) {
return false;
}
----Swift.(file)..init()
$info.$setThis(_cloneStruct(Unicode.UTF8._swift3Buffer({}, _create(Unicode.UTF8.ForwardParser, 'init', {}, ))));
return
----Swift.(file)..isContinuation(_:<<error type>>)
return UInt8.infix_61_61({Self: UInt8}, UInt8.infix_38({Self: UInt8}, _byte, 0b11000000), 0b10000000)
----Swift.(file)..init()
$info.$setThis(_cloneStruct(Unicode.UTF16._swift3Buffer({}, _create(Unicode.UTF16.ForwardParser, 'init', {}, ))));
return
----Swift.(file)..encode(_:<<error type>>,into:<<error type>>)
let s = this.encode({Self: Unicode.UTF16}, input)._storage;
processCodeUnit({}, _create(UInt16, 'initTruncatingIfNeeded', {Self: UInt16, T: _clarifyGenerics({Self:_UIntBuffer, Element: $info.Element}).Storage}, s));
UInt32.infix_38_62_62_61({Self: UInt32}, {get: () => s, set: $val => s = $val}, 16);
{
if((_fastPath({}, UInt32.infix_61_61({Self: UInt32}, s, 0)))) {
return ;
}
};
processCodeUnit({}, _create(UInt16, 'initTruncatingIfNeeded', {Self: UInt16, T: _clarifyGenerics({Self:_UIntBuffer, Element: $info.Element}).Storage}, s))
----Swift.(file)..init()
$info.$setThis(_cloneStruct(Unicode.UTF32._swift3Codec));
return
----Swift.(file)..decode(_:I)
let input = input$inout.get()
const $result = (() => {
let parser = _create(Unicode.UTF32.ForwardParser, 'init', {}, );
const $match = parser.parseScalarFrom({$setThis: $val => parser = $val, I: $info.I}, {get: () => input, set: $val => input = $val})
if((($match.rawValue == Unicode.ParseResult.valid().rawValue))) {
const s = $match[0]
return UnicodeDecodingResult.scalarValue({}, UTF32.decode({Self: UTF32}, s));
}
else if((($match.rawValue == Unicode.ParseResult.error().rawValue))) {
return UnicodeDecodingResult.error;
}
else if((($match.rawValue == Unicode.ParseResult.emptyInput.rawValue))) {
return UnicodeDecodingResult.emptyInput;
};})()
input$inout.set(input)
return $result
----Swift.(file)..encode(_:<<error type>>,into:<<error type>>)
processCodeUnit({}, _create(UInt32, 'initUnicodeScalar', {}, input))
----Swift.(file).transcode(_:Input,from:InputEncoding.Type,to:OutputEncoding.Type,stoppingOnError:Bool,into:<<error type>>)
let input_dupl = input;
let p = _create($info.InputEncoding.ForwardParser, 'init', {Self: $info.InputEncoding.ForwardParser}, );
let hadError = false;
while(true){
if(!((true))) break
const $match = p.parseScalarFrom({$setThis: $val => p = $val, Self: $info.InputEncoding.ForwardParser, I: $info.Input}, {get: () => input_dupl, set: $val => input_dupl = $val})
if((($match.rawValue == Unicode.ParseResult.valid().rawValue))) {
const s = $match[0]
const t = $info.OutputEncoding.transcodeFrom({Self: $info.OutputEncoding, Self: $info.OutputEncoding, FromEncoding: $info.InputEncoding}, s, inputEncoding);
{const s = t
if(!((_fastPath({}, Optional.infix_33_61({Self: Optional, Wrapped: $info.OutputEncoding.EncodedScalar}, t, null))) && (s != null))) {
break;
}
};
s.forEachSwift({Self: $info.OutputEncoding.EncodedScalar}, processCodeUnit);
continue;
}
else if((($match.rawValue == Unicode.ParseResult.emptyInput.rawValue))) {
return hadError;
}
else if((($match.rawValue == Unicode.ParseResult.error().rawValue))) {
{
if((_slowPath({}, stopOnError))) {
return true;
}
};
hadError = true;
};
$info.OutputEncoding.encodedReplacementCharacter.forEachSwift({Self: $info.OutputEncoding.EncodedScalar}, processCodeUnit);
}
----Swift.(file).UTF16.width(_:<<error type>>)
return (UInt32.infix_60_61({Self: UInt32}, x.value, 0xFFFF) ? 1 : 2)
----Swift.(file).UTF16.leadSurrogate(_:<<error type>>)
preconditionFileLine({}, () => Int.infix_61_61({Self: Int}, this.width({Self: Unicode.UTF16}, x), 2), null, '?3', '?3');
return UInt16.infix_43({Self: UInt16}, 0xD800, _create(UTF16.CodeUnit, 'initTruncatingIfNeeded', {Self: UTF16.CodeUnit, T: UInt32}, UInt32.infix_38_62_62({Self: UInt32}, UInt32.infix_45({Self: UInt32}, x.value, 0x10000), 10)))
----Swift.(file).UTF16.trailSurrogate(_:<<error type>>)
preconditionFileLine({}, () => Int.infix_61_61({Self: Int}, this.width({Self: Unicode.UTF16}, x), 2), null, '?3', '?3');
return UInt16.infix_43({Self: UInt16}, 0xDC00, _create(UTF16.CodeUnit, 'initTruncatingIfNeeded', {Self: UTF16.CodeUnit, T: UInt32}, UInt32.infix_38({Self: UInt32}, UInt32.infix_45({Self: UInt32}, x.value, 0x10000), UInt32.infix_45({Self: UInt32}, UInt32.infix_38_60_60({Self: UInt32}, 1, 10), 1))))
----Swift.(file).UTF16.isLeadSurrogate(_:Unicode.UTF16.CodeUnit)
return UInt16.infix_61_61({Self: UInt16}, UInt16.infix_38({Self: UInt16}, x, 0xFC00), 0xD800)
----Swift.(file).UTF16.isTrailSurrogate(_:Unicode.UTF16.CodeUnit)
return UInt16.infix_61_61({Self: UInt16}, UInt16.infix_38({Self: UInt16}, x, 0xFC00), 0xDC00)
----Swift.(file)._UnicodeEncoding.transcode(_:<<error type>>,from:FromEncoding.Type)
return this.encode({Self: $info.Self, Self: $info.Self}, $info.FromEncoding.decode({Self: $info.FromEncoding, Self: $info.FromEncoding}, content))
----Swift.(file).Scalar.init(unicodeScalarLiteral:<<error type>>)
$info.$setThis(_cloneStruct(_cloneStruct(value)));
return
----Swift.(file).Scalar.init(_:UInt16)
this.initUInt32({}, _create(UInt32, 'init', {Self: UInt32, T: UInt16}, v));
return
----Swift.(file).Scalar.init(_:<<error type>>)
$info.$setThis(_cloneStruct(_cloneStruct(v)));
return
----Swift.(file).Scalar.isASCII
return UInt32.infix_60_61({Self: UInt32}, this.value, 127)
----Swift.(file).Scalar.description
return _create(String, 'initUnicodeScalar', {}, this)
----Swift.(file).Scalar.debugDescription
return (("\"") + (this.escapedAsASCII({}, true)) + ("\""))
----Swift.(file).Scalar.hash(into:Hasher)
let hasher = hasher$inout.get()
const $result = (() => {
hasher.combine({$setThis: $val => hasher = $val, H: UInt32}, this.value);})()
hasher$inout.set(hasher)
return $result
----Swift.(file).UInt8.init(ascii:<<error type>>)
preconditionFileLine({}, () => UInt32.infix_60({Self: UInt32}, v.value, 128), () => "Code point value does not fit into ASCII", '?3', '?3');
$info.$setThis(_cloneStruct(_create(UInt8, 'init', {Self: UInt8, T: UInt32}, v.value)));
return
----Swift.(file).UInt32.init(_:<<error type>>)
$info.$setThis(_cloneStruct(v.value));
return
----Swift.(file).UInt64.init(_:<<error type>>)
$info.$setThis(_cloneStruct(_create(UInt64, 'init', {Self: UInt64, T: UInt32}, v.value)));
return
----Swift.(file).Scalar.==infix(_:<<error type>>,_:<<error type>>)
return UInt32.infix_61_61({Self: UInt32}, lhs.value, rhs.value)
----Swift.(file).Scalar.<infix(_:<<error type>>,_:<<error type>>)
return UInt32.infix_60({Self: UInt32}, lhs.value, rhs.value)
----Swift.(file).UTF16View.startIndex
return 0
----Swift.(file).UnsafePointer.pointee
 return this.pointee$internal
----Swift.(file).UnsafePointer.subscript(_:Int)
return UnsafePointer.infix_43({Self: UnsafePointer, Self: _clarifyGenerics({Self:UnsafePointer, Pointee: this.$info.Pointee})}, this, i)
----Swift.(file).UnsafeMutablePointer.init(mutating:UnsafePointer<Pointee>?)
{const unwrapped = other
if(!((unwrapped != null))) {
return (this.$failed = true);
}
};
this.initMutatingUnsafePointer({}, unwrapped);
return
----Swift.(file).UnsafeMutablePointer.pointee
 return this.pointee$internal
----Swift.(file).UnsafeMutablePointer.assign(repeating:Pointee,count:Int)
preconditionFileLine({}, () => Int.infix_62_61({Self: Int}, count, 0), () => "UnsafeMutablePointer.assign(repeating:count:) with negative count", '?3', '?3');
{
let $i$generator = _cloneStruct(Int.infix_46_46_60({Self: Int, Self: Int}, 0, count).makeIterator({Self: _clarifyGenerics({Self:Range, Bound: Int})}, ));
while(true) {
const i = $i$generator.next({$setThis: $val => $i$generator = $val, Elements: _clarifyGenerics({Self:Range, Bound: Int})}, );
if(!((i != null))) break;
this.subscript$set({$setThis: $val => $info.$setThis(_cloneStruct(_cloneStruct($val)))}, repeatedValue, i);
}
}
----Swift.(file).UnsafeMutablePointer.subscript(_:Int)
return _create(UnsafePointer, 'initUnsafeMutablePointer', {Self: _clarifyGenerics({Self:UnsafePointer, Pointee: this.$info.Pointee}), T: this.$info.Pointee}, UnsafeMutablePointer.infix_43({Self: UnsafeMutablePointer, Self: _clarifyGenerics({Self:UnsafeMutablePointer, Pointee: this.$info.Pointee})}, this, i));
}subscript$unsafeMutableAddress($info, i){
return UnsafeMutablePointer.infix_43({Self: UnsafeMutablePointer, Self: _clarifyGenerics({Self:UnsafeMutablePointer, Pointee: this.$info.Pointee})}, this, i)
----Swift.(file).UnsafeRawPointer.assumingMemoryBound(to:T.Type)
return _create(UnsafePointer, 'initRawPointer', {Pointee: $info.T}, this._rawValue)
----Swift.(file).UnsafeMutableRawPointer.assumingMemoryBound(to:T.Type)
return _create(UnsafeMutablePointer, 'initRawPointer', {Pointee: $info.T}, this._rawValue)
----Swift.(file)._ValidUTF8Buffer.makeIterator()
return _create(_ValidUTF8Buffer.Iterator, 'init_ValidUTF8Buffer', {}, this)
----Swift.(file)._ValidUTF8Buffer.capacity
return Int.infix_47({Self: Int}, UInt32.bitWidth, _ValidUTF8Buffer.Element.bitWidth);
}
static get capacity() { return this.capacity$get()
