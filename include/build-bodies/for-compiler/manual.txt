----Swift.(file).String.count
return this.length
----Swift.(file).print(_:[Any],separator:String,terminator:String)
console.log.apply(null, #A0)
----Swift.(file).Dictionary.subscript(_:Dictionary<Key, Value>.Index)
if(this.has(#AA)) return Optional.some({}, this.get(#AA))
return Optional.none
----Swift.(file).Dictionary.subscript(_:Key)
if(this.has(#AA)) return Optional.some({}, this.get(#AA))
return Optional.none
----Swift.(file).Dictionary.subscript(_:Key)#ASS
if(#A0.rawValue === 'none') this.delete(#A1)
else this.set(#A1, _cloneStruct(#A0[0]))
----Swift.(file).Dictionary.count
return this.size
----Swift.(file).Dictionary.makeIterator()
//TODO use _create for Array
//TODO change SwiftIterator because now only Dictionary is using it to use js Map.iterator (much faster)
//TODO preferably move to Swift and use the proper Iterator (then remove SwiftIterator.js too)
return new SwiftIterator((current) => _injectIntoOptional(Array.from(this)[current]))
----Swift.(file).Array.count
return this.length
----Swift.(file).Array.insert(_:Element,at:Int)
this.splice(#A1, 0, _cloneStruct(#A0))
----Swift.(file).Array.remove(at:Int)
return this.splice(#AA, 1)[0]
----Swift.(file).Set.insert(_:Element)
this.add(_cloneStruct(#AA))
----Swift.(file).Set.count
return this.size
----Swift.(file).Sequence.enumerated()
//TODO use _create for Array; preferably move to Swift
return this.map((v, i) => [i, v])
----Swift.(file).Range.lowerBound
return this.lowerBound$internal
----Swift.(file).Range.upperBound
return this.upperBound$internal
----Swift.(file).ClosedRange.lowerBound
return this.lowerBound$internal
----Swift.(file).ClosedRange.upperBound
return this.upperBound$internal
----Swift.(file).Array.init()
return []
----Swift.(file).Dictionary.init()
return new Map()
----Swift.(file).Set.init()
return new Set()
----Swift.(file).Set.init(_:Source)
return new Set(#AA)
----Swift.(file).Array.init()
return []
----Swift.(file).Int.init(_:Double)
return #AA | 0
----Swift.(file).BinaryInteger./infix(_:Self,_:Self)
return (#A0 / #A1) | 0
----Swift.(file).BinaryInteger./=infix(_:Self,_:Self)
lhs$inout.set((lhs$inout.get() / rhs) | 0)
----Swift.(file).Int8.<<infix(_:Int8,_:Int8)
let binaryRepr = lhs.toString(2)
let result = 0
for(let i = 0; i < binaryRepr.length; i++) {
let j = i - rhs
if(binaryRepr[j] !== '1') continue
result += j === 0 ? -128 : Math.pow(2, 7 - j)
}
return result
----Swift.(file).UInt8.<<infix(_:UInt8,_:UInt8)
let binaryRepr = lhs.toString(2)
let result = 0
for(let i = 0; i < binaryRepr.length; i++) {
let j = i - rhs
if(binaryRepr[j] !== '1') continue
result += Math.pow(2, 7 - j)
}
return result
----Swift.(file).ObjectIdentifier.init(_:AnyObject)
this._value = #AA
----Swift.(file).ObjectIdentifier.==infix(_:ObjectIdentifier,_:ObjectIdentifier)
return #A0._value === #A1._value
----Darwin.(file).arc4random_uniform(_:UInt32)
return (Math.random() * #AA) | 0
----Darwin.(file).arc4random()
return arc4random_uniform(null, 4294967296)
----Swift.(file).ExpressibleByIntegerLiteral.init(integerLiteral:Self)
return value
----Swift.(file).Array.init(_:S)
return s
----Swift.(file).Range.init(uncheckedBounds:(lower: Bound, upper: Bound))
this.lowerBound$internal = #AA[0]
this.upperBound$internal = #AA[1]
----Swift.(file).ClosedRange.init(uncheckedBounds:(lower: Bound, upper: Bound))
this.lowerBound$internal = #AA[0]
this.upperBound$internal = #AA[1]
----Swift.(file).SignedNumeric.negate()
$info.$setThis(-this)
----Swift.(file).String.append(_:Character)
$info.$setThis(this + c)
----Swift.(file).String.startIndex
//TODO change once we know what String.Index is about
return 0
----Swift.(file).String.endIndex
return this.length
----Swift.(file).String.index(after:String.Index)
return i + 1
----Swift.(file).MutableCollection.sort(by:(Self.Element, Self.Element) throws -> Bool)
//TODO move to swift
return this.sort((a, b) => areInIncreasingOrder(null, a, b) ? -1 : 1)
----Swift.(file).String.init(_:S)
return String(other)
----Swift.(file).Double.infinity
return Infinity
----XCTest.(file).XCTestCase.init()
var proto = Object.keys(Object.getPrototypeOf(this))
for(const testFunction of proto) {
if(typeof this[testFunction] !== 'function' || XCTestCase.prototype[testFunction]/*is inherited*/ || testFunction.endsWith('$get') || testFunction.endsWith('$set') || testFunction.endsWith('$filePrivate')) continue
this.init$vars()
if(this.setUp) this.setUp()
this[testFunction]()
if(this.tearDown) this.tearDown()
}
----closing dashes needed for the last definition to be processed