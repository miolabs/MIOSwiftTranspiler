

----Swift.(file).ASCII.encodedReplacementCharacter
extension Unicode.ASCII : Unicode.Encoding  {
  public static var encodedReplacementCharacter : EncodedScalar {
    return EncodedScalar(0x1a) // U+001A SUBSTITUTE; best we can do for ASCII
  }
}

----Swift.(file).ASCII.decode(_:Unicode.ASCII.EncodedScalar)
extension Unicode.ASCII : Unicode.Encoding  {
  public static func decode(_ source: EncodedScalar) -> Unicode.Scalar {
    return Unicode.Scalar(_unchecked: UInt32(
        source.first._unsafelyUnwrappedUnchecked))
  }
}

----Swift.(file).ASCII.encode(_:Unicode.Scalar)
extension Unicode.ASCII : Unicode.Encoding  {
  public static func encode(
    _ source: Unicode.Scalar
  ) -> EncodedScalar? {
    guard source.value < (1&<<7) else { return nil }
    return EncodedScalar(UInt8(truncatingIfNeeded: source.value))
  }
}

----Swift.(file).ASCII.transcode(_:FromEncoding.EncodedScalar,from:FromEncoding.Type)
extension Unicode.ASCII : Unicode.Encoding  {
  public static func transcode<FromEncoding : Unicode.Encoding>(
    _ content: FromEncoding.EncodedScalar, from _: FromEncoding.Type
  ) -> EncodedScalar? {
    if _fastPath(FromEncoding.self == UTF16.self) {
      let c = _identityCast(content, to: UTF16.EncodedScalar.self)
      guard (c._storage & 0xFF80 == 0) else { return nil }
      return EncodedScalar(CodeUnit(c._storage & 0x7f))
    }
    else if _fastPath(FromEncoding.self == UTF8.self) {
      let c = _identityCast(content, to: UTF8.EncodedScalar.self)
      let first = c.first.unsafelyUnwrapped
      guard (first < 0x80) else { return nil }
      return EncodedScalar(CodeUnit(first))
    }
    return encode(FromEncoding.decode(content))
  }
}

----Swift.(file).Parser.parseScalar(from:I)
extension Unicode.ASCII.Parser : Unicode.Parser  {
  public mutating func parseScalar<I : IteratorProtocol>(
    from input: inout I
  ) -> Unicode.ParseResult<Encoding.EncodedScalar>
  where I.Element == Encoding.CodeUnit {
    let n = input.next()
    if _fastPath(n != nil), let x = n {
      guard _fastPath(Int8(truncatingIfNeeded: x) >= 0)
      else { return .error(length: 1) }
      return .valid(Unicode.ASCII.EncodedScalar(x))
    }
    return .emptyInput
  }
}

----Swift.(file).min(_:T,_:T)
public func min<T : Comparable>(_ x: T, _ y: T) -> T {
  // In case `x == y` we pick `x`.
  // This preserves any pre-existing order in case `T` has identity,
  // which is important for e.g. the stability of sorting algorithms.
  // `(min(x, y), max(x, y))` should return `(x, y)` in case `x == y`.
  return y < x ? y : x
}

----Swift.(file).min(_:T,_:T,_:T,_:[T])
public func min<T : Comparable>(_ x: T, _ y: T, _ z: T, _ rest: T...) -> T {
  var minValue = min(min(x, y), z)
  // In case `value == minValue`, we pick `minValue`. See min(_:_:).
  for value in rest where value < minValue {
    minValue = value
  }
  return minValue
}

----Swift.(file).max(_:T,_:T)
public func max<T : Comparable>(_ x: T, _ y: T) -> T {
  // In case `x == y`, we pick `y`. See min(_:_:).
  return y >= x ? y : x
}

----Swift.(file).max(_:T,_:T,_:T,_:[T])
public func max<T : Comparable>(_ x: T, _ y: T, _ z: T, _ rest: T...) -> T {
  var maxValue = max(max(x, y), z)
  // In case `value == maxValue`, we pick `value`. See min(_:_:).
  for value in rest where value >= maxValue {
    maxValue = value
  }
  return maxValue
}

----Swift.(file).Iterator.next()
extension EnumeratedSequence.Iterator: IteratorProtocol, Sequence  {
  public mutating func next() -> Element? {
    guard let b = _base.next() else { return nil }
    let result = (offset: _count, element: b)
    _count += 1 
    return result
  }
}

----Swift.(file).EnumeratedSequence.makeIterator()
extension EnumeratedSequence: Sequence  {
  public __consuming func makeIterator() -> Iterator {
    return Iterator(_base: _base.makeIterator())
  }
}

----Swift.(file).AnyHashable.init(_:H)
extension AnyHashable {
  public init<H : Hashable>(_ base: H) {
    if let custom =
      (base as? _HasCustomAnyHashableRepresentation)?._toCustomAnyHashable() {
      self = custom
      return
    }

    self.init(_box: _ConcreteHashableBox(false)) // Dummy value
    _makeAnyHashableUpcastingToHashableBaseType(
      base,
      storingResultInto: &self)
  }
}

----Swift.(file).AnyHashable.base
extension AnyHashable {
  public var base: Any {
    return _box._base
  }
}

----Swift.(file).AnyHashable.==infix(_:AnyHashable,_:AnyHashable)
extension AnyHashable : Equatable  {
  public static func == (lhs: AnyHashable, rhs: AnyHashable) -> Bool {
    return lhs._box._canonicalBox._isEqual(to: rhs._box._canonicalBox) ?? false
  }
}

----Swift.(file).AnyHashable.hashValue
extension AnyHashable : Hashable  {
  public var hashValue: Int {
    return _box._canonicalBox._hashValue
  }
}

----Swift.(file).AnyHashable.hash(into:Hasher)
extension AnyHashable : Hashable  {
  public func hash(into hasher: inout Hasher) {
    _box._canonicalBox._hash(into: &hasher)
  }
}

----Swift.(file).AnyHashable.description
extension AnyHashable : CustomStringConvertible  {
  public var description: String {
    return String(describing: base)
  }
}

----Swift.(file).AnyHashable.debugDescription
extension AnyHashable : CustomDebugStringConvertible  {
  public var debugDescription: String {
    return "AnyHashable(" + String(reflecting: base) + ")"
  }
}

----Swift.(file).AnyHashable.customMirror
extension AnyHashable : CustomReflectable  {
  public var customMirror: Mirror {
    return Mirror(
      self,
      children: ["value": base])
  }
}

----Swift.(file).Array.capacity
extension Array: _ArrayProtocol  {
  public var capacity: Int {
    return _getCapacity()
  }
}

----Swift.(file).Array.startIndex
extension Array: RandomAccessCollection, MutableCollection  {
  public var startIndex: Int {
    return 0
  }
}

----Swift.(file).Array.endIndex
extension Array: RandomAccessCollection, MutableCollection  {
  public var endIndex: Int {
    @inlinable
    get {
      return _getCount()
    }
  }
}

----Swift.(file).Array.index(after:Int)
extension Array: RandomAccessCollection, MutableCollection  {
  public func index(after i: Int) -> Int {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    return i + 1
  }
}

----Swift.(file).Array.formIndex(after:Int)
extension Array: RandomAccessCollection, MutableCollection  {
  public func formIndex(after i: inout Int) {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    i += 1
  }
}

----Swift.(file).Array.index(before:Int)
extension Array: RandomAccessCollection, MutableCollection  {
  public func index(before i: Int) -> Int {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    return i - 1
  }
}

----Swift.(file).Array.formIndex(before:Int)
extension Array: RandomAccessCollection, MutableCollection  {
  public func formIndex(before i: inout Int) {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    i -= 1
  }
}

----Swift.(file).Array.index(_:Int,offsetBy:Int)
extension Array: RandomAccessCollection, MutableCollection  {
  public func index(_ i: Int, offsetBy distance: Int) -> Int {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    return i + distance
  }
}

----Swift.(file).Array.index(_:Int,offsetBy:Int,limitedBy:Int)
extension Array: RandomAccessCollection, MutableCollection  {
  public func index(
    _ i: Int, offsetBy distance: Int, limitedBy limit: Int
  ) -> Int? {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    let l = limit - i
    if distance > 0 ? l >= 0 && l < distance : l <= 0 && distance < l {
      return nil
    }
    return i + distance
  }
}

----Swift.(file).Array.distance(from:Int,to:Int)
extension Array: RandomAccessCollection, MutableCollection  {
  public func distance(from start: Int, to end: Int) -> Int {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    return end - start
  }
}

----Swift.(file).Array.subscript(_:Int)
extension Array: RandomAccessCollection, MutableCollection  {
  public subscript(index: Int) -> Element {
    get {
      // This call may be hoisted or eliminated by the optimizer.  If
      // there is an inout violation, this value may be stale so needs to be
      // checked again below.
      let wasNativeTypeChecked = _hoistableIsNativeTypeChecked()

      // Make sure the index is in range and wasNativeTypeChecked is
      // still valid.
      let token = _checkSubscript(
        index, wasNativeTypeChecked: wasNativeTypeChecked)

      return _getElement(
        index, wasNativeTypeChecked: wasNativeTypeChecked,
        matchingSubscriptCheck: token)
    }
    _modify {
      _makeMutableAndUnique() // makes the array native, too
      _checkSubscript_native(index)
      let address = _buffer.subscriptBaseAddress + index
      yield &address.pointee
    }
  }
}

----Swift.(file).Array.subscript(_:Range<Int>)
extension Array: RandomAccessCollection, MutableCollection  {
  public subscript(bounds: Range<Int>) -> ArraySlice<Element> {
    get {
      _checkIndex(bounds.lowerBound)
      _checkIndex(bounds.upperBound)
      return ArraySlice(_buffer: _buffer[bounds])
    }
    set(rhs) {
      _checkIndex(bounds.lowerBound)
      _checkIndex(bounds.upperBound)
      // If the replacement buffer has same identity, and the ranges match,
      // then this was a pinned in-place modification, nothing further needed.
      if self[bounds]._buffer.identity != rhs._buffer.identity
      || bounds != rhs.startIndex..<rhs.endIndex {
        self.replaceSubrange(bounds, with: rhs)
      }
    }
  }
}

----Swift.(file).Array.count
extension Array: RandomAccessCollection, MutableCollection  {
  public var count: Int {
    return _getCount()
  }
}

----Swift.(file).Array.init(arrayLiteral:[Element])
extension Array: ExpressibleByArrayLiteral  {
  public init(arrayLiteral elements: Element...) {
    self = elements
  }
}

----Swift.(file).Array.init()
extension Array: RangeReplaceableCollection  {
  public init() {
    _buffer = _Buffer()
  }
}

----Swift.(file).Array.init(repeating:Element,count:Int)
extension Array: RangeReplaceableCollection  {
  public init(repeating repeatedValue: Element, count: Int) {
    var p: UnsafeMutablePointer<Element>
    (self, p) = Array._allocateUninitialized(count)
    for _ in 0..<count {
      p.initialize(to: repeatedValue)
      p += 1
    }
  }
}

----Swift.(file).Array.reserveCapacity(_:Int)
extension Array: RangeReplaceableCollection  {
  public mutating func reserveCapacity(_ minimumCapacity: Int) {
    if _buffer.requestUniqueMutableBackingBuffer(
      minimumCapacity: minimumCapacity) == nil {

      let newBuffer = _ContiguousArrayBuffer<Element>(
        _uninitializedCount: count, minimumCapacity: minimumCapacity)

      _buffer._copyContents(
        subRange: _buffer.indices,
        initializing: newBuffer.firstElementAddress)
      _buffer = _Buffer(
        _buffer: newBuffer, shiftedToStartIndex: _buffer.startIndex)
    }
    _internalInvariant(capacity >= minimumCapacity)
  }
}

----Swift.(file).Array.append(_:Element)
extension Array: RangeReplaceableCollection  {
  public mutating func append(_ newElement: __owned Element) {
    _makeUniqueAndReserveCapacityIfNotUnique()
    let oldCount = _getCount()
    _reserveCapacityAssumingUniqueBuffer(oldCount: oldCount)
    _appendElementAssumeUniqueAndCapacity(oldCount, newElement: newElement)
  }
}

----Swift.(file).Array.append(contentsOf:S)
extension Array: RangeReplaceableCollection  {
  public mutating func append<S: Sequence>(contentsOf newElements: __owned S)
    where S.Element == Element {

    let newElementsCount = newElements.underestimatedCount
    reserveCapacityForAppend(newElementsCount: newElementsCount)

    let oldCount = self.count
    let startNewElements = _buffer.firstElementAddress + oldCount
    let buf = UnsafeMutableBufferPointer(
                start: startNewElements, 
                count: self.capacity - oldCount)

    let (remainder,writtenUpTo) = buf.initialize(from: newElements)
    
    // trap on underflow from the sequence's underestimate:
    let writtenCount = buf.distance(from: buf.startIndex, to: writtenUpTo)
    precondition(newElementsCount <= writtenCount, 
      "newElements.underestimatedCount was an overestimate")
    // can't check for overflow as sequences can underestimate

    _buffer.count += writtenCount

    if writtenUpTo == buf.endIndex {
      // there may be elements that didn't fit in the existing buffer,
      // append them in slow sequence-only mode
      _buffer._arrayAppendSequence(IteratorSequence(remainder))
    }
  }
}

----Swift.(file).Array.remove(at:Int)
extension Array: RangeReplaceableCollection  {
  public mutating func remove(at index: Int) -> Element {
    precondition(index < endIndex, "Index out of range")
    precondition(index >= startIndex, "Index out of range")
    _makeUniqueAndReserveCapacityIfNotUnique()
    let newCount = _getCount() - 1
    let pointer = (_buffer.firstElementAddress + index)
    let result = pointer.move()
    pointer.moveInitialize(from: pointer + 1, count: newCount - index)
    _buffer.count = newCount
    return result
  }
}

----Swift.(file).Array.insert(_:Element,at:Int)
extension Array: RangeReplaceableCollection  {
  public mutating func insert(_ newElement: __owned Element, at i: Int) {
    _checkIndex(i)
    self.replaceSubrange(i..<i, with: CollectionOfOne(newElement))
  }
}

----Swift.(file).Array.removeAll(keepingCapacity:Bool)
extension Array: RangeReplaceableCollection  {
  public mutating func removeAll(keepingCapacity keepCapacity: Bool = false) {
    if !keepCapacity {
      _buffer = _Buffer()
    }
    else {
      self.replaceSubrange(indices, with: EmptyCollection())
    }
  }
}

----Swift.(file).Array.withContiguousMutableStorageIfAvailable(_:(inout UnsafeMutableBufferPointer<Element>) throws -> R)
extension Array: RangeReplaceableCollection  {
  public mutating func withContiguousMutableStorageIfAvailable<R>(
    _ body: (inout UnsafeMutableBufferPointer<Element>) throws -> R
  ) rethrows -> R? {
    return try withUnsafeMutableBufferPointer {
      (bufferPointer) -> R in
      return try body(&bufferPointer)
    }
  }
}

----Swift.(file).Array.withContiguousStorageIfAvailable(_:(UnsafeBufferPointer<Element>) throws -> R)
extension Array: RangeReplaceableCollection  {
  public func withContiguousStorageIfAvailable<R>(
    _ body: (UnsafeBufferPointer<Element>) throws -> R
  ) rethrows -> R? {
    return try withUnsafeBufferPointer {
      (bufferPointer) -> R in
      return try body(bufferPointer)
    }
  }
}

----Swift.(file).Array.+infix(_:Array<Element>,_:Array<Element>)
extension Array  {
  public static func + (lhs: Array, rhs: Array) -> Array {
    var lhs = lhs
    lhs.append(contentsOf: rhs)
    return lhs
  }
}

----Swift.(file).Array.+=infix(_:Array<Element>,_:Array<Element>)
extension Array  {
  public static func += (lhs: inout Array, rhs: Array) {
    lhs.append(contentsOf: rhs)
  }
}

----Swift.(file).Array.customMirror
extension Array: CustomReflectable  {
  public var customMirror: Mirror {
    return Mirror(
      self,
      unlabeledChildren: self,
      displayStyle: .collection)
  }
}

----Swift.(file).Array.description
extension Array: CustomStringConvertible, CustomDebugStringConvertible  {
  public var description: String {
    return _makeCollectionDescription()
  }
}

----Swift.(file).Array.debugDescription
extension Array: CustomStringConvertible, CustomDebugStringConvertible  {
  public var debugDescription: String {
    // Always show sugared representation for Arrays.
    return _makeCollectionDescription()
  }
}

----Swift.(file).Array.init(_unsafeUninitializedCapacity:Int,initializingWith:(inout UnsafeMutableBufferPointer<Element>, inout Int) throws -> Void)
extension Array  {
  public init(
    _unsafeUninitializedCapacity: Int,
    initializingWith initializer: (
      _ buffer: inout UnsafeMutableBufferPointer<Element>,
      _ initializedCount: inout Int) throws -> Void
  ) rethrows {
    var firstElementAddress: UnsafeMutablePointer<Element>
    (self, firstElementAddress) =
      Array._allocateUninitialized(_unsafeUninitializedCapacity)
    
    var initializedCount = 0
    defer {
      // Update self.count even if initializer throws an error.
      precondition(
        initializedCount <= _unsafeUninitializedCapacity,
        "Initialized count set to greater than specified capacity."
      )
      self._buffer.count = initializedCount
    }
    var buffer = UnsafeMutableBufferPointer<Element>(
      start: firstElementAddress, count: _unsafeUninitializedCapacity)
    try initializer(&buffer, &initializedCount)
  }
}

----Swift.(file).Array.withUnsafeBufferPointer(_:(UnsafeBufferPointer<Element>) throws -> R)
extension Array  {
  public func withUnsafeBufferPointer<R>(
    _ body: (UnsafeBufferPointer<Element>) throws -> R
  ) rethrows -> R {
    return try _buffer.withUnsafeBufferPointer(body)
  }
}

----Swift.(file).Array.withUnsafeMutableBufferPointer(_:(inout UnsafeMutableBufferPointer<Element>) throws -> R)
extension Array  {
  public mutating func withUnsafeMutableBufferPointer<R>(
    _ body: (inout UnsafeMutableBufferPointer<Element>) throws -> R
  ) rethrows -> R {
    let count = self.count
    // Ensure unique storage
    _buffer._outlinedMakeUniqueBuffer(bufferCount: count)

    // Ensure that body can't invalidate the storage or its bounds by
    // moving self into a temporary working array.
    // NOTE: The stack promotion optimization that keys of the
    // "array.withUnsafeMutableBufferPointer" semantics annotation relies on the
    // array buffer not being able to escape in the closure. It can do this
    // because we swap the array buffer in self with an empty buffer here. Any
    // escape via the address of self in the closure will therefore escape the
    // empty array.

    var work = Array()
    (work, self) = (self, work)

    // Create an UnsafeBufferPointer over work that we can pass to body
    let pointer = work._buffer.firstElementAddress
    var inoutBufferPointer = UnsafeMutableBufferPointer(
      start: pointer, count: count)

    // Put the working array back before returning.
    defer {
      precondition(
        inoutBufferPointer.baseAddress == pointer &&
        inoutBufferPointer.count == count,
        "Array withUnsafeMutableBufferPointer: replacing the buffer is not allowed")

      (work, self) = (self, work)
    }

    // Invoke the body.
    return try body(&inoutBufferPointer)
  }
}

----Swift.(file).Array.replaceSubrange(_:Range<Int>,with:C)
extension Array  {
  public mutating func replaceSubrange<C>(
    _ subrange: Range<Int>,
    with newElements: __owned C
  ) where C: Collection, C.Element == Element {
    precondition(subrange.lowerBound >= self._buffer.startIndex,
      "Array replace: subrange start is negative")

    precondition(subrange.upperBound <= _buffer.endIndex,
      "Array replace: subrange extends past the end")

    let oldCount = _buffer.count
    let eraseCount = subrange.count
    let insertCount = newElements.count
    let growth = insertCount - eraseCount

    if _buffer.requestUniqueMutableBackingBuffer(
      minimumCapacity: oldCount + growth) != nil {

      _buffer.replaceSubrange(
        subrange, with: insertCount, elementsOf: newElements)
    } else {
      _buffer._arrayOutOfPlaceReplace(subrange, with: newElements, count: insertCount)
    }
  }
}

----Swift.(file).Array.==infix(_:Array<Element>,_:Array<Element>)
extension Array: Equatable where Element: Equatable  {
  public static func ==(lhs: Array<Element>, rhs: Array<Element>) -> Bool {
    let lhsCount = lhs.count
    if lhsCount != rhs.count {
      return false
    }

    // Test referential equality.
    if lhsCount == 0 || lhs._buffer.identity == rhs._buffer.identity {
      return true
    }


    _internalInvariant(lhs.startIndex == 0 && rhs.startIndex == 0)
    _internalInvariant(lhs.endIndex == lhsCount && rhs.endIndex == lhsCount)

    // We know that lhs.count == rhs.count, compare element wise.
    for idx in 0..<lhsCount {
      if lhs[idx] != rhs[idx] {
        return false
      }
    }

    return true
  }
}

----Swift.(file).Array.hash(into:Hasher)
extension Array: Hashable where Element: Hashable  {
  public func hash(into hasher: inout Hasher) {
    hasher.combine(count) // discriminator
    for element in self {
      hasher.combine(element)
    }
  }
}

----Swift.(file).Array.withUnsafeMutableBytes(_:(UnsafeMutableRawBufferPointer) throws -> R)
extension Array  {
  public mutating func withUnsafeMutableBytes<R>(
    _ body: (UnsafeMutableRawBufferPointer) throws -> R
  ) rethrows -> R {
    return try self.withUnsafeMutableBufferPointer {
      return try body(UnsafeMutableRawBufferPointer($0))
    }
  }
}

----Swift.(file).Array.withUnsafeBytes(_:(UnsafeRawBufferPointer) throws -> R)
extension Array  {
  public func withUnsafeBytes<R>(
    _ body: (UnsafeRawBufferPointer) throws -> R
  ) rethrows -> R {
    return try self.withUnsafeBufferPointer {
      try body(UnsafeRawBufferPointer($0))
    }
  }
}

----Swift.(file).Array.init(_immutableCocoaArray:AnyObject)
extension Array  {
  public init(_immutableCocoaArray: AnyObject) {
    self = _bridgeCocoaArray(_immutableCocoaArray)
  }
}

----Swift.(file).ArraySlice.capacity
extension ArraySlice: _ArrayProtocol  {
  public var capacity: Int {
    return _getCapacity()
  }
}

----Swift.(file).ArraySlice.startIndex
extension ArraySlice: RandomAccessCollection, MutableCollection  {
  public var startIndex: Int {
    return _buffer.startIndex
  }
}

----Swift.(file).ArraySlice.endIndex
extension ArraySlice: RandomAccessCollection, MutableCollection  {
  public var endIndex: Int {
    return _buffer.endIndex
  }
}

----Swift.(file).ArraySlice.index(after:Int)
extension ArraySlice: RandomAccessCollection, MutableCollection  {
  public func index(after i: Int) -> Int {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    return i + 1
  }
}

----Swift.(file).ArraySlice.formIndex(after:Int)
extension ArraySlice: RandomAccessCollection, MutableCollection  {
  public func formIndex(after i: inout Int) {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    i += 1
  }
}

----Swift.(file).ArraySlice.index(before:Int)
extension ArraySlice: RandomAccessCollection, MutableCollection  {
  public func index(before i: Int) -> Int {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    return i - 1
  }
}

----Swift.(file).ArraySlice.formIndex(before:Int)
extension ArraySlice: RandomAccessCollection, MutableCollection  {
  public func formIndex(before i: inout Int) {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    i -= 1
  }
}

----Swift.(file).ArraySlice.index(_:Int,offsetBy:Int)
extension ArraySlice: RandomAccessCollection, MutableCollection  {
  public func index(_ i: Int, offsetBy distance: Int) -> Int {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    return i + distance
  }
}

----Swift.(file).ArraySlice.index(_:Int,offsetBy:Int,limitedBy:Int)
extension ArraySlice: RandomAccessCollection, MutableCollection  {
  public func index(
    _ i: Int, offsetBy distance: Int, limitedBy limit: Int
  ) -> Int? {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    let l = limit - i
    if distance > 0 ? l >= 0 && l < distance : l <= 0 && distance < l {
      return nil
    }
    return i + distance
  }
}

----Swift.(file).ArraySlice.distance(from:Int,to:Int)
extension ArraySlice: RandomAccessCollection, MutableCollection  {
  public func distance(from start: Int, to end: Int) -> Int {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    return end - start
  }
}

----Swift.(file).ArraySlice.subscript(_:Int)
extension ArraySlice: RandomAccessCollection, MutableCollection  {
  public subscript(index: Int) -> Element {
    get {
      // This call may be hoisted or eliminated by the optimizer.  If
      // there is an inout violation, this value may be stale so needs to be
      // checked again below.
      let wasNativeTypeChecked = _hoistableIsNativeTypeChecked()

      // Make sure the index is in range and wasNativeTypeChecked is
      // still valid.
      let token = _checkSubscript(
        index, wasNativeTypeChecked: wasNativeTypeChecked)

      return _getElement(
        index, wasNativeTypeChecked: wasNativeTypeChecked,
        matchingSubscriptCheck: token)
    }
    _modify {
      _makeMutableAndUnique() // makes the array native, too
      _checkSubscript_native(index)
      let address = _buffer.subscriptBaseAddress + index
      yield &address.pointee
    }
  }
}

----Swift.(file).ArraySlice.subscript(_:Range<Int>)
extension ArraySlice: RandomAccessCollection, MutableCollection  {
  public subscript(bounds: Range<Int>) -> ArraySlice<Element> {
    get {
      _checkIndex(bounds.lowerBound)
      _checkIndex(bounds.upperBound)
      return ArraySlice(_buffer: _buffer[bounds])
    }
    set(rhs) {
      _checkIndex(bounds.lowerBound)
      _checkIndex(bounds.upperBound)
      // If the replacement buffer has same identity, and the ranges match,
      // then this was a pinned in-place modification, nothing further needed.
      if self[bounds]._buffer.identity != rhs._buffer.identity
      || bounds != rhs.startIndex..<rhs.endIndex {
        self.replaceSubrange(bounds, with: rhs)
      }
    }
  }
}

----Swift.(file).ArraySlice.count
extension ArraySlice: RandomAccessCollection, MutableCollection  {
  public var count: Int {
    return _getCount()
  }
}

----Swift.(file).ArraySlice.init(arrayLiteral:[Element])
extension ArraySlice: ExpressibleByArrayLiteral  {
  public init(arrayLiteral elements: Element...) {
    self.init(_buffer: ContiguousArray(elements)._buffer)
  }
}

----Swift.(file).ArraySlice.init()
extension ArraySlice: RangeReplaceableCollection  {
  public init() {
    _buffer = _Buffer()
  }
}

----Swift.(file).ArraySlice.init(repeating:Element,count:Int)
extension ArraySlice: RangeReplaceableCollection  {
  public init(repeating repeatedValue: Element, count: Int) {
    var p: UnsafeMutablePointer<Element>
    (self, p) = ArraySlice._allocateUninitialized(count)
    for _ in 0..<count {
      p.initialize(to: repeatedValue)
      p += 1
    }
  }
}

----Swift.(file).ArraySlice.reserveCapacity(_:Int)
extension ArraySlice: RangeReplaceableCollection  {
  public mutating func reserveCapacity(_ minimumCapacity: Int) {
    if _buffer.requestUniqueMutableBackingBuffer(
      minimumCapacity: minimumCapacity) == nil {

      let newBuffer = _ContiguousArrayBuffer<Element>(
        _uninitializedCount: count, minimumCapacity: minimumCapacity)

      _buffer._copyContents(
        subRange: _buffer.indices,
        initializing: newBuffer.firstElementAddress)
      _buffer = _Buffer(
        _buffer: newBuffer, shiftedToStartIndex: _buffer.startIndex)
    }
    _internalInvariant(capacity >= minimumCapacity)
  }
}

----Swift.(file).ArraySlice.append(_:Element)
extension ArraySlice: RangeReplaceableCollection  {
  public mutating func append(_ newElement: __owned Element) {
    _makeUniqueAndReserveCapacityIfNotUnique()
    let oldCount = _getCount()
    _reserveCapacityAssumingUniqueBuffer(oldCount: oldCount)
    _appendElementAssumeUniqueAndCapacity(oldCount, newElement: newElement)
  }
}

----Swift.(file).ArraySlice.append(contentsOf:S)
extension ArraySlice: RangeReplaceableCollection  {
  public mutating func append<S: Sequence>(contentsOf newElements: __owned S)
    where S.Element == Element {

    let newElementsCount = newElements.underestimatedCount
    reserveCapacityForAppend(newElementsCount: newElementsCount)

    let oldCount = self.count
    let startNewElements = _buffer.firstElementAddress + oldCount
    let buf = UnsafeMutableBufferPointer(
                start: startNewElements, 
                count: self.capacity - oldCount)

    let (remainder,writtenUpTo) = buf.initialize(from: newElements)
    
    // trap on underflow from the sequence's underestimate:
    let writtenCount = buf.distance(from: buf.startIndex, to: writtenUpTo)
    precondition(newElementsCount <= writtenCount, 
      "newElements.underestimatedCount was an overestimate")
    // can't check for overflow as sequences can underestimate

    _buffer.count += writtenCount

    if writtenUpTo == buf.endIndex {
      // there may be elements that didn't fit in the existing buffer,
      // append them in slow sequence-only mode
      _buffer._arrayAppendSequence(IteratorSequence(remainder))
    }
  }
}

----Swift.(file).ArraySlice.remove(at:Int)
extension ArraySlice: RangeReplaceableCollection  {
  public mutating func remove(at index: Int) -> Element {
    let result = self[index]
    self.replaceSubrange(index..<(index + 1), with: EmptyCollection())
    return result
  }
}

----Swift.(file).ArraySlice.insert(_:Element,at:Int)
extension ArraySlice: RangeReplaceableCollection  {
  public mutating func insert(_ newElement: __owned Element, at i: Int) {
    _checkIndex(i)
    self.replaceSubrange(i..<i, with: CollectionOfOne(newElement))
  }
}

----Swift.(file).ArraySlice.removeAll(keepingCapacity:Bool)
extension ArraySlice: RangeReplaceableCollection  {
  public mutating func removeAll(keepingCapacity keepCapacity: Bool = false) {
    if !keepCapacity {
      _buffer = _Buffer()
    }
    else {
      self.replaceSubrange(indices, with: EmptyCollection())
    }
  }
}

----Swift.(file).ArraySlice.withContiguousMutableStorageIfAvailable(_:(inout UnsafeMutableBufferPointer<Element>) throws -> R)
extension ArraySlice: RangeReplaceableCollection  {
  public mutating func withContiguousMutableStorageIfAvailable<R>(
    _ body: (inout UnsafeMutableBufferPointer<Element>) throws -> R
  ) rethrows -> R? {
    return try withUnsafeMutableBufferPointer {
      (bufferPointer) -> R in
      return try body(&bufferPointer)
    }
  }
}

----Swift.(file).ArraySlice.withContiguousStorageIfAvailable(_:(UnsafeBufferPointer<Element>) throws -> R)
extension ArraySlice: RangeReplaceableCollection  {
  public func withContiguousStorageIfAvailable<R>(
    _ body: (UnsafeBufferPointer<Element>) throws -> R
  ) rethrows -> R? {
    return try withUnsafeBufferPointer {
      (bufferPointer) -> R in
      return try body(bufferPointer)
    }
  }
}

----Swift.(file).ArraySlice.customMirror
extension ArraySlice: CustomReflectable  {
  public var customMirror: Mirror {
    return Mirror(
      self,
      unlabeledChildren: self,
      displayStyle: .collection)
  }
}

----Swift.(file).ArraySlice.description
extension ArraySlice: CustomStringConvertible, CustomDebugStringConvertible  {
  public var description: String {
    return _makeCollectionDescription()
  }
}

----Swift.(file).ArraySlice.debugDescription
extension ArraySlice: CustomStringConvertible, CustomDebugStringConvertible  {
  public var debugDescription: String {
    return _makeCollectionDescription(withTypeName: "ArraySlice")
  }
}

----Swift.(file).ArraySlice.withUnsafeBufferPointer(_:(UnsafeBufferPointer<Element>) throws -> R)
extension ArraySlice  {
  public func withUnsafeBufferPointer<R>(
    _ body: (UnsafeBufferPointer<Element>) throws -> R
  ) rethrows -> R {
    return try _buffer.withUnsafeBufferPointer(body)
  }
}

----Swift.(file).ArraySlice.withUnsafeMutableBufferPointer(_:(inout UnsafeMutableBufferPointer<Element>) throws -> R)
extension ArraySlice  {
  public mutating func withUnsafeMutableBufferPointer<R>(
    _ body: (inout UnsafeMutableBufferPointer<Element>) throws -> R
  ) rethrows -> R {
    let count = self.count
    // Ensure unique storage
    _buffer._outlinedMakeUniqueBuffer(bufferCount: count)

    // Ensure that body can't invalidate the storage or its bounds by
    // moving self into a temporary working array.
    // NOTE: The stack promotion optimization that keys of the
    // "array.withUnsafeMutableBufferPointer" semantics annotation relies on the
    // array buffer not being able to escape in the closure. It can do this
    // because we swap the array buffer in self with an empty buffer here. Any
    // escape via the address of self in the closure will therefore escape the
    // empty array.

    var work = ArraySlice()
    (work, self) = (self, work)

    // Create an UnsafeBufferPointer over work that we can pass to body
    let pointer = work._buffer.firstElementAddress
    var inoutBufferPointer = UnsafeMutableBufferPointer(
      start: pointer, count: count)

    // Put the working array back before returning.
    defer {
      precondition(
        inoutBufferPointer.baseAddress == pointer &&
        inoutBufferPointer.count == count,
        "ArraySlice withUnsafeMutableBufferPointer: replacing the buffer is not allowed")

      (work, self) = (self, work)
    }

    // Invoke the body.
    return try body(&inoutBufferPointer)
  }
}

----Swift.(file).ArraySlice.replaceSubrange(_:Range<Int>,with:C)
extension ArraySlice  {
  public mutating func replaceSubrange<C>(
    _ subrange: Range<Int>,
    with newElements: __owned C
  ) where C: Collection, C.Element == Element {
    precondition(subrange.lowerBound >= _buffer.startIndex,
      "ArraySlice replace: subrange start is before the startIndex")

    precondition(subrange.upperBound <= _buffer.endIndex,
      "ArraySlice replace: subrange extends past the end")

    let oldCount = _buffer.count
    let eraseCount = subrange.count
    let insertCount = newElements.count
    let growth = insertCount - eraseCount

    if _buffer.requestUniqueMutableBackingBuffer(
      minimumCapacity: oldCount + growth) != nil {

      _buffer.replaceSubrange(
        subrange, with: insertCount, elementsOf: newElements)
    } else {
      _buffer._arrayOutOfPlaceReplace(subrange, with: newElements, count: insertCount)
    }
  }
}

----Swift.(file).ArraySlice.==infix(_:ArraySlice<Element>,_:ArraySlice<Element>)
extension ArraySlice: Equatable where Element: Equatable  {
  public static func ==(lhs: ArraySlice<Element>, rhs: ArraySlice<Element>) -> Bool {
    let lhsCount = lhs.count
    if lhsCount != rhs.count {
      return false
    }

    // Test referential equality.
    if lhsCount == 0 || lhs._buffer.identity == rhs._buffer.identity {
      return true
    }


    var streamLHS = lhs.makeIterator()
    var streamRHS = rhs.makeIterator()

    var nextLHS = streamLHS.next()
    while nextLHS != nil {
      let nextRHS = streamRHS.next()
      if nextLHS != nextRHS {
        return false
      }
      nextLHS = streamLHS.next()
    }


    return true
  }
}

----Swift.(file).ArraySlice.hash(into:Hasher)
extension ArraySlice: Hashable where Element: Hashable  {
  public func hash(into hasher: inout Hasher) {
    hasher.combine(count) // discriminator
    for element in self {
      hasher.combine(element)
    }
  }
}

----Swift.(file).ArraySlice.withUnsafeMutableBytes(_:(UnsafeMutableRawBufferPointer) throws -> R)
extension ArraySlice  {
  public mutating func withUnsafeMutableBytes<R>(
    _ body: (UnsafeMutableRawBufferPointer) throws -> R
  ) rethrows -> R {
    return try self.withUnsafeMutableBufferPointer {
      return try body(UnsafeMutableRawBufferPointer($0))
    }
  }
}

----Swift.(file).ArraySlice.withUnsafeBytes(_:(UnsafeRawBufferPointer) throws -> R)
extension ArraySlice  {
  public func withUnsafeBytes<R>(
    _ body: (UnsafeRawBufferPointer) throws -> R
  ) rethrows -> R {
    return try self.withUnsafeBufferPointer {
      try body(UnsafeRawBufferPointer($0))
    }
  }
}

----Swift.(file).ArraySlice.init(_startIndex:Int)
extension ArraySlice  {
  init(_startIndex: Int) {
    self.init(
      _buffer: _Buffer(
        _buffer: ContiguousArray()._buffer,
        shiftedToStartIndex: _startIndex))
  }
}

----Swift.(file)._ArrayProtocol.filter(_:(Self.Element) throws -> Bool)
extension _ArrayProtocol  {
  public __consuming func filter(
    _ isIncluded: (Element) throws -> Bool
  ) rethrows -> [Element] {
    return try _filter(isIncluded)
  }
}

----Swift.(file).assert(_:() -> Bool,_:() -> String,file:StaticString,line:UInt)
public func assert(
  _ condition: @autoclosure () -> Bool,
  _ message: @autoclosure () -> String = String(),
  file: StaticString = #file, line: UInt = #line
) {
  // Only assert in debug mode.
  if _isDebugAssertConfiguration() {
    if !_branchHint(condition(), expected: true) {
      _assertionFailure("Assertion failed", message(), file: file, line: line,
        flags: _fatalErrorFlags())
    }
  }
}

----Swift.(file).precondition(_:() -> Bool,_:() -> String,file:StaticString,line:UInt)
public func precondition(
  _ condition: @autoclosure () -> Bool,
  _ message: @autoclosure () -> String = String(),
  file: StaticString = #file, line: UInt = #line
) {
  // Only check in debug and release mode. In release mode just trap.
  if _isDebugAssertConfiguration() {
    if !_branchHint(condition(), expected: true) {
      _assertionFailure("Precondition failed", message(), file: file, line: line,
        flags: _fatalErrorFlags())
    }
  } else if _isReleaseAssertConfiguration() {
    let error = !condition()
    Builtin.condfail(error._value)
  }
}

----Swift.(file).assertionFailure(_:() -> String,file:StaticString,line:UInt)
public func assertionFailure(
  _ message: @autoclosure () -> String = String(),
  file: StaticString = #file, line: UInt = #line
) {
  if _isDebugAssertConfiguration() {
    _assertionFailure("Fatal error", message(), file: file, line: line,
      flags: _fatalErrorFlags())
  }
  else if _isFastAssertConfiguration() {
    _conditionallyUnreachable()
  }
}

----Swift.(file).preconditionFailure(_:() -> String,file:StaticString,line:UInt)
public func preconditionFailure(
  _ message: @autoclosure () -> String = String(),
  file: StaticString = #file, line: UInt = #line
) -> Never {
  // Only check in debug and release mode.  In release mode just trap.
  if _isDebugAssertConfiguration() {
    _assertionFailure("Fatal error", message(), file: file, line: line,
      flags: _fatalErrorFlags())
  } else if _isReleaseAssertConfiguration() {
    Builtin.int_trap()
  }
  _conditionallyUnreachable()
}

----Swift.(file).fatalError(_:() -> String,file:StaticString,line:UInt)
public func fatalError(
  _ message: @autoclosure () -> String = String(),
  file: StaticString = #file, line: UInt = #line
) -> Never {
  _assertionFailure("Fatal error", message(), file: file, line: line,
    flags: _fatalErrorFlags())
}

----Swift.(file).BidirectionalCollection.indices
extension BidirectionalCollection {
  override var indices: Indices { get }
}

----Swift.(file).BidirectionalCollection.subscript(_:Range<Self.Index>)
extension BidirectionalCollection {
  override subscript(bounds: Range<Index>) -> SubSequence { get }
}

----Swift.(file).BidirectionalCollection.subscript(_:Self.Index)
extension BidirectionalCollection {
  override subscript(position: Index) -> Element { get }
}

----Swift.(file).BidirectionalCollection.startIndex
extension BidirectionalCollection {
  override var startIndex: Index { get }
}

----Swift.(file).BidirectionalCollection.endIndex
extension BidirectionalCollection {
  override var endIndex: Index { get }
}

----Swift.(file).BidirectionalCollection.formIndex(before:Self.Index)
extension BidirectionalCollection  {
  public func formIndex(before i: inout Index) {
    i = index(before: i)
  }
}

----Swift.(file).BidirectionalCollection.index(_:Self.Index,offsetBy:Int)
extension BidirectionalCollection  {
  public func index(_ i: Index, offsetBy distance: Int) -> Index {
    return _index(i, offsetBy: distance)
  }
}

----Swift.(file).BidirectionalCollection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)
extension BidirectionalCollection  {
  public func index(
    _ i: Index, offsetBy distance: Int, limitedBy limit: Index
  ) -> Index? {
    return _index(i, offsetBy: distance, limitedBy: limit)
  }
}

----Swift.(file).BidirectionalCollection.distance(from:Self.Index,to:Self.Index)
extension BidirectionalCollection  {
  public func distance(from start: Index, to end: Index) -> Int {
    return _distance(from: start, to: end)
  }
}

----Swift.(file).BidirectionalCollection.popLast()
extension BidirectionalCollection where SubSequence == Self  {
  public mutating func popLast() -> Element? {
    guard !isEmpty else { return nil }
    let element = last!
    self = self[startIndex..<index(before: endIndex)]
    return element
  }
}

----Swift.(file).BidirectionalCollection.removeLast()
extension BidirectionalCollection where SubSequence == Self  {
  public mutating func removeLast() -> Element {
    let element = last!
    self = self[startIndex..<index(before: endIndex)]
    return element
  }
}

----Swift.(file).BidirectionalCollection.removeLast(_:Int)
extension BidirectionalCollection where SubSequence == Self  {
  public mutating func removeLast(_ k: Int) {
    if k == 0 { return }
    precondition(k >= 0, "Number of elements to remove should be non-negative")
    precondition(count >= k,
      "Can't remove more items from a collection than it contains")
    self = self[startIndex..<index(endIndex, offsetBy: -k)]
  }
}

----Swift.(file).BidirectionalCollection.dropLast(_:Int)
extension BidirectionalCollection  {
  public __consuming func dropLast(_ k: Int) -> SubSequence {
    precondition(
      k >= 0, "Can't drop a negative number of elements from a collection")
    let end = index(
      endIndex,
      offsetBy: -k,
      limitedBy: startIndex) ?? startIndex
    return self[startIndex..<end]
  }
}

----Swift.(file).BidirectionalCollection.suffix(_:Int)
extension BidirectionalCollection  {
  public __consuming func suffix(_ maxLength: Int) -> SubSequence {
    precondition(
      maxLength >= 0,
      "Can't take a suffix of negative length from a collection")
    let start = index(
      endIndex,
      offsetBy: -maxLength,
      limitedBy: startIndex) ?? startIndex
    return self[start..<endIndex]
  }
}

----Swift.(file).Bool.init()
extension Bool {
  public init() {
    let zero: Int8 = 0
    self._value = Builtin.trunc_Int8_Int1(zero._value)
  }
}

----Swift.(file).Bool.init(_:Bool)
extension Bool {
  public init(_ value: Bool) {
    self = value
  }
}

----Swift.(file).Bool.random(using:T)
extension Bool {
  public static func random<T: RandomNumberGenerator>(
    using generator: inout T
  ) -> Bool {
    return (generator.next() >> 17) & 1 == 0
  }
}

----Swift.(file).Bool.random()
extension Bool {
  public static func random() -> Bool {
    var g = SystemRandomNumberGenerator()
    return Bool.random(using: &g)
  }
}

----Swift.(file).Bool.init(_builtinBooleanLiteral:<<error type>>)
extension Bool : _ExpressibleByBuiltinBooleanLiteral, ExpressibleByBooleanLiteral  {
  public init(_builtinBooleanLiteral value: Builtin.Int1) {
    self._value = value
  }
}

----Swift.(file).Bool.init(booleanLiteral:Bool)
extension Bool : _ExpressibleByBuiltinBooleanLiteral, ExpressibleByBooleanLiteral  {
  public init(booleanLiteral value: Bool) {
    self = value
  }
}

----Swift.(file).Bool.description
extension Bool : CustomStringConvertible  {
  public var description: String {
    return self ? "true" : "false"
  }
}

----Swift.(file).Bool.==infix(_:Bool,_:Bool)
extension Bool: Equatable  {
  public static func == (lhs: Bool, rhs: Bool) -> Bool {
    return Bool(Builtin.cmp_eq_Int1(lhs._value, rhs._value))
  }
}

----Swift.(file).Bool.hash(into:Hasher)
extension Bool: Hashable  {
  public func hash(into hasher: inout Hasher) {
    hasher.combine((self ? 1 : 0) as UInt8)
  }
}

----Swift.(file).Bool.!prefix(_:Bool)
extension Bool  {
  public static prefix func ! (a: Bool) -> Bool {
    return Bool(Builtin.xor_Int1(a._value, true._value))
  }
}

----Swift.(file).Bool.&&infix(_:Bool,_:() throws -> Bool)
extension Bool  {
  public static func && (lhs: Bool, rhs: @autoclosure () throws -> Bool) rethrows
      -> Bool {
    return lhs ? try rhs() : false
  }
}

----Swift.(file).Bool.||infix(_:Bool,_:() throws -> Bool)
extension Bool  {
  public static func || (lhs: Bool, rhs: @autoclosure () throws -> Bool) rethrows
      -> Bool {
    return lhs ? true : try rhs()
  }
}

----Swift.(file).Bool.toggle()
extension Bool  {
  public mutating func toggle() {
    self = !self
  }
}

----Swift.(file).AutoreleasingUnsafeMutablePointer.init(_:<<error type>>)
extension AutoreleasingUnsafeMutablePointer {
  init(_ _rawValue: Builtin.RawPointer) {
    self._rawValue = _rawValue
  }
}

----Swift.(file).AutoreleasingUnsafeMutablePointer.pointee
extension AutoreleasingUnsafeMutablePointer {
  public var pointee: Pointee {
    @_transparent _read {
      // We can do a strong load normally.
      yield UnsafePointer(self).pointee
    }
    /// Set the value the pointer points to, copying over the previous value.
    ///
    /// AutoreleasingUnsafeMutablePointers are assumed to reference a
    /// value with __autoreleasing ownership semantics, like 'NSFoo**'
    /// in ARC. This autoreleases the argument before trivially
    /// storing it to the referenced memory.
    @_transparent nonmutating set {
      // Autorelease the object reference.
      typealias OptionalAnyObject = AnyObject?
      let newAnyObject = unsafeBitCast(newValue, to: OptionalAnyObject.self)
      Builtin.retain(newAnyObject)
      Builtin.autorelease(newAnyObject)
      // Trivially assign it as an OpaquePointer; the pointer references an
      // autoreleasing slot, so retains/releases of the original value are
      // unneeded.
      typealias OptionalUnmanaged = Unmanaged<AnyObject>?
      UnsafeMutablePointer<Pointee>(_rawValue).withMemoryRebound(
        to: OptionalUnmanaged.self, capacity: 1) {
        if let newAnyObject = newAnyObject {
          $0.pointee = Unmanaged.passUnretained(newAnyObject)
        }
        else {
          $0.pointee = nil
        }
      }
    }
  }
}

----Swift.(file).AutoreleasingUnsafeMutablePointer.subscript(_:Int)
extension AutoreleasingUnsafeMutablePointer {
  public subscript(i: Int) -> Pointee {
    @_transparent
    _read {
      // We can do a strong load normally.
      yield ((UnsafePointer<Pointee>(self) + i).pointee)
    }
  }
}

----Swift.(file).UnsafeMutableRawPointer.init(_:AutoreleasingUnsafeMutablePointer<T>?)
extension UnsafeMutableRawPointer  {
  public init?<T>(_ other: AutoreleasingUnsafeMutablePointer<T>?) {
    guard let unwrapped = other else { return nil }
    self.init(unwrapped)
  }
}

----Swift.(file).UnsafeRawPointer.init(_:AutoreleasingUnsafeMutablePointer<T>?)
extension UnsafeRawPointer  {
  public init?<T>(_ other: AutoreleasingUnsafeMutablePointer<T>?) {
    guard let unwrapped = other else { return nil }
    self.init(unwrapped)
  }
}

----Swift.(file).unsafeBitCast(_:T,to:U.Type)
public func unsafeBitCast<T, U>(_ x: T, to type: U.Type) -> U {
  precondition(MemoryLayout<T>.size == MemoryLayout<U>.size,
    "Can't unsafeBitCast between types of different sizes")
  return Builtin.reinterpretCast(x)
}

----Swift.(file).==infix(_:Any.Type?,_:Any.Type?)
public func == (t0: Any.Type?, t1: Any.Type?) -> Bool {
  switch (t0, t1) {
  case (.none, .none): return true
  case let (.some(ty0), .some(ty1)):
    return Bool(Builtin.is_same_metatype(ty0, ty1))
  default: return false
  }
}

----Swift.(file).!=infix(_:Any.Type?,_:Any.Type?)
public func != (t0: Any.Type?, t1: Any.Type?) -> Bool {
  return !(t0 == t1)
}

----Swift.(file).unsafeDowncast(_:AnyObject,to:T.Type)
public func unsafeDowncast<T : AnyObject>(_ x: AnyObject, to type: T.Type) -> T {
  precondition(x is T, "invalid unsafeDowncast")
  return Builtin.castReference(x)
}

----Swift.(file).ManagedBufferPointer.init(_nativeObject:<<error type>>)
extension ManagedBufferPointer  {
  public init(_nativeObject buffer: Builtin.NativeObject) {
    self._nativeBuffer = buffer
  }
}

----Swift.(file).type(of:T)
public func type<T, Metatype>(of value: T) -> Metatype {
  // This implementation is never used, since calls to `Swift.type(of:)` are
  // resolved as a special case by the type checker.
  Builtin.staticReport(_trueAfterDiagnostics(), true._value,
    ("internal consistency error: 'type(of:)' operation failed to resolve"
     as StaticString).utf8Start._rawValue)
  Builtin.unreachable()
}

----Swift.(file).withoutActuallyEscaping(_:ClosureType,do:(ClosureType) throws -> ResultType)
public func withoutActuallyEscaping<ClosureType, ResultType>(
  _ closure: ClosureType,
  do body: (_ escapingClosure: ClosureType) throws -> ResultType
) rethrows -> ResultType {
  // This implementation is never used, since calls to
  // `Swift.withoutActuallyEscaping(_:do:)` are resolved as a special case by
  // the type checker.
  Builtin.staticReport(_trueAfterDiagnostics(), true._value,
    ("internal consistency error: 'withoutActuallyEscaping(_:do:)' operation failed to resolve"
     as StaticString).utf8Start._rawValue)
  Builtin.unreachable()
}

----Swift.(file).String.init(cString:UnsafePointer<CChar>)
extension String  {
  public init(cString: UnsafePointer<CChar>) {
    let len = UTF8._nullCodeUnitOffset(in: cString)
    self = String._fromUTF8Repairing(
      UnsafeBufferPointer(start: cString._asUInt8, count: len)).0
  }
}

----Swift.(file).String.init(cString:UnsafePointer<UInt8>)
extension String  {
  public init(cString: UnsafePointer<UInt8>) {
    let len = UTF8._nullCodeUnitOffset(in: cString)
    self = String._fromUTF8Repairing(
      UnsafeBufferPointer(start: cString, count: len)).0
  }
}

----Swift.(file).String.decodeCString(_:UnsafePointer<Encoding.CodeUnit>?,as:Encoding.Type,repairingInvalidCodeUnits:Bool)
extension String  {
  public static func decodeCString<Encoding : _UnicodeEncoding>(
    _ cString: UnsafePointer<Encoding.CodeUnit>?,
    as encoding: Encoding.Type,
    repairingInvalidCodeUnits isRepairing: Bool = true
  ) -> (result: String, repairsMade: Bool)? {
    guard let cPtr = cString else { return nil }

    if _fastPath(encoding == Unicode.UTF8.self) {
      let ptr = UnsafeRawPointer(cPtr).assumingMemoryBound(to: UInt8.self)
      let len = UTF8._nullCodeUnitOffset(in: ptr)
      let codeUnits = UnsafeBufferPointer(start: ptr, count: len)
      if isRepairing {
        return String._fromUTF8Repairing(codeUnits)
      } else {
        guard let str = String._tryFromUTF8(codeUnits) else { return nil }
        return (str, false)
      }
    }

    var end = cPtr
    while end.pointee != 0 { end += 1 }
    let len = end - cPtr
    let codeUnits = UnsafeBufferPointer(start: cPtr, count: len)
    return String._fromCodeUnits(
      codeUnits, encoding: encoding, repair: isRepairing)
  }
}

----Swift.(file).OpaquePointer.init(_:UnsafePointer<T>?)
extension OpaquePointer {
  public init?<T>(_ from: UnsafePointer<T>?) {
    guard let unwrapped = from else { return nil }
    self.init(unwrapped)
  }
}

----Swift.(file).OpaquePointer.init(_:UnsafeMutablePointer<T>?)
extension OpaquePointer {
  public init?<T>(_ from: UnsafeMutablePointer<T>?) {
    guard let unwrapped = from else { return nil }
    self.init(unwrapped)
  }
}

----Swift.(file).OpaquePointer.==infix(_:OpaquePointer,_:OpaquePointer)
extension OpaquePointer: Equatable  {
  public static func == (lhs: OpaquePointer, rhs: OpaquePointer) -> Bool {
    return Bool(Builtin.cmp_eq_RawPointer(lhs._rawValue, rhs._rawValue))
  }
}

----Swift.(file).OpaquePointer.hash(into:Hasher)
extension OpaquePointer: Hashable  {
  public func hash(into hasher: inout Hasher) {
    hasher.combine(Int(Builtin.ptrtoint_Word(_rawValue)))
  }
}

----Swift.(file).OpaquePointer.debugDescription
extension OpaquePointer : CustomDebugStringConvertible  {
  public var debugDescription: String {
    return _rawPointerToString(_rawValue)
  }
}

----Swift.(file).Int.init(bitPattern:OpaquePointer?)
extension Int  {
  public init(bitPattern pointer: OpaquePointer?) {
    self.init(bitPattern: UnsafeRawPointer(pointer))
  }
}

----Swift.(file).UInt.init(bitPattern:OpaquePointer?)
extension UInt  {
  public init(bitPattern pointer: OpaquePointer?) {
    self.init(bitPattern: UnsafeRawPointer(pointer))
  }
}

----Swift.(file).CVaListPointer.init(_fromUnsafeMutablePointer:UnsafeMutableRawPointer)
extension CVaListPointer {
  init(_fromUnsafeMutablePointer from: UnsafeMutableRawPointer) {
    _value = from
  }
}

----Swift.(file).CVaListPointer.debugDescription
extension CVaListPointer : CustomDebugStringConvertible  {
  public var debugDescription: String {
    return _value.debugDescription
  }
}

----Swift.(file).Character.unicodeScalars
extension Character  {
  public var unicodeScalars: UnicodeScalarView {
    return _str.unicodeScalars
  }
}

----Swift.(file).Character.init(_:Unicode.Scalar)
extension Character :
  _ExpressibleByBuiltinExtendedGraphemeClusterLiteral,
  ExpressibleByExtendedGraphemeClusterLiteral
 {
  public init(_ content: Unicode.Scalar) {
    self.init(unchecked: String(content))
  }
}

----Swift.(file).Character.init(_builtinUnicodeScalarLiteral:<<error type>>)
extension Character :
  _ExpressibleByBuiltinExtendedGraphemeClusterLiteral,
  ExpressibleByExtendedGraphemeClusterLiteral
 {
  public init(_builtinUnicodeScalarLiteral value: Builtin.Int32) {
    self.init(Unicode.Scalar(_builtinUnicodeScalarLiteral: value))
  }
}

----Swift.(file).Character.init(_builtinExtendedGraphemeClusterLiteral:<<error type>>,utf8CodeUnitCount:<<error type>>,isASCII:<<error type>>)
extension Character :
  _ExpressibleByBuiltinExtendedGraphemeClusterLiteral,
  ExpressibleByExtendedGraphemeClusterLiteral
 {
  public init(
    _builtinExtendedGraphemeClusterLiteral start: Builtin.RawPointer,
    utf8CodeUnitCount: Builtin.Word,
    isASCII: Builtin.Int1
  ) {
    self.init(unchecked: String(
      _builtinExtendedGraphemeClusterLiteral: start,
      utf8CodeUnitCount: utf8CodeUnitCount,
      isASCII: isASCII))
  }
}

----Swift.(file).Character.init(extendedGraphemeClusterLiteral:Character)
extension Character :
  _ExpressibleByBuiltinExtendedGraphemeClusterLiteral,
  ExpressibleByExtendedGraphemeClusterLiteral
 {
  public init(extendedGraphemeClusterLiteral value: Character) {
    self.init(unchecked: value._str)
  }
}

----Swift.(file).Character.init(_:String)
extension Character :
  _ExpressibleByBuiltinExtendedGraphemeClusterLiteral,
  ExpressibleByExtendedGraphemeClusterLiteral
 {
  public init(_ s: String) {
    precondition(!s.isEmpty,
      "Can't form a Character from an empty String")
    precondition(s.index(after: s.startIndex) == s.endIndex,
      "Can't form a Character from a String containing more than one extended grapheme cluster")
    self.init(unchecked: s)
  }
}

----Swift.(file).Character.description
extension Character : CustomStringConvertible  {
 public var description: String {
   return _str
 }
}

----Swift.(file).Character.debugDescription
extension Character : CustomDebugStringConvertible  {
 public var debugDescription: String {
   return _str.debugDescription
 }
}

----Swift.(file).String.init(_:Character)
extension String  {
  public init(_ c: Character) {
    self.init(c._str._guts)
  }
}

----Swift.(file).Character.==infix(_:Character,_:Character)
extension Character : Equatable  {
  public static func == (lhs: Character, rhs: Character) -> Bool {
    return lhs._str == rhs._str
  }
}

----Swift.(file).Character.<infix(_:Character,_:Character)
extension Character : Comparable  {
  public static func < (lhs: Character, rhs: Character) -> Bool {
    return lhs._str < rhs._str
  }
}

----Swift.(file).Character.hash(into:Hasher)
extension Character: Hashable  {
  public func hash(into hasher: inout Hasher) {
    _str.hash(into: &hasher)
  }
}

----Swift.(file).Character.isASCII
extension Character  {
  public var isASCII: Bool {
    return asciiValue != nil
  }
}

----Swift.(file).Character.asciiValue
extension Character  {
  public var asciiValue: UInt8? {
    if _slowPath(self == "\r\n") { return 0x000A /* LINE FEED (LF) */ }
    if _slowPath(!_isSingleScalar || _firstScalar.value >= 0x80) { return nil }
    return UInt8(_firstScalar.value)
  }
}

----Swift.(file).Character.isWhitespace
extension Character  {
  public var isWhitespace: Bool {
    return _firstScalar.properties.isWhitespace
  }
}

----Swift.(file).Character.isNewline
extension Character  {
  public var isNewline: Bool {
    switch _firstScalar.value {
      case 0x000A...0x000D /* LF ... CR */: return true
      case 0x0085 /* NEXT LINE (NEL) */: return true
      case 0x2028 /* LINE SEPARATOR */: return true
      case 0x2029 /* PARAGRAPH SEPARATOR */: return true
      default: return false
    }
  }
}

----Swift.(file).Character.isNumber
extension Character  {
  public var isNumber: Bool {
    return _firstScalar.properties.numericType != nil
  }
}

----Swift.(file).Character.isWholeNumber
extension Character  {
  public var isWholeNumber: Bool {
    return wholeNumberValue != nil
  }
}

----Swift.(file).Character.wholeNumberValue
extension Character  {
  public var wholeNumberValue: Int? {
    guard _isSingleScalar else { return nil }
    guard let value = _firstScalar.properties.numericValue else { return nil }
    return Int(exactly: value)
  }
}

----Swift.(file).Character.isHexDigit
extension Character  {
  public var isHexDigit: Bool {
    return hexDigitValue != nil
  }
}

----Swift.(file).Character.hexDigitValue
extension Character  {
  public var hexDigitValue: Int? {
    guard _isSingleScalar else { return nil }
    let value = _firstScalar.value
    switch value {
      // DIGIT ZERO..DIGIT NINE
      case 0x0030...0x0039: return Int(value &- 0x0030)
      // LATIN CAPITAL LETTER A..LATIN CAPITAL LETTER F
      case 0x0041...0x0046: return Int((value &+ 10) &- 0x0041)
      // LATIN SMALL LETTER A..LATIN SMALL LETTER F
      case 0x0061...0x0066: return Int((value &+ 10) &- 0x0061)
      // FULLWIDTH DIGIT ZERO..FULLWIDTH DIGIT NINE
      case 0xFF10...0xFF19: return Int(value &- 0xFF10)
      // FULLWIDTH LATIN CAPITAL LETTER A..FULLWIDTH LATIN CAPITAL LETTER F
      case 0xFF21...0xFF26: return Int((value &+ 10) &- 0xFF21)
      // FULLWIDTH LATIN SMALL LETTER A..FULLWIDTH LATIN SMALL LETTER F
      case 0xFF41...0xFF46: return Int((value &+ 10) &- 0xFF41)

      default: return nil
    }
  }
}

----Swift.(file).Character.isLetter
extension Character  {
  public var isLetter: Bool {
    return _firstScalar.properties.isAlphabetic
  }
}

----Swift.(file).Character.uppercased()
extension Character  {
  public func uppercased() -> String { return String(self).uppercased() }
}

----Swift.(file).Character.lowercased()
extension Character  {
  public func lowercased() -> String { return String(self).lowercased() }
}

----Swift.(file).Character.isUppercase
extension Character  {
  public var isUppercase: Bool {
    if _fastPath(_isSingleScalar && _firstScalar.properties.isUppercase) {
      return true
    }
    return _isUppercased && isCased
  }
}

----Swift.(file).Character.isLowercase
extension Character  {
  public var isLowercase: Bool {
    if _fastPath(_isSingleScalar && _firstScalar.properties.isLowercase) {
      return true
    }
    return _isLowercased && isCased
  }
}

----Swift.(file).Character.isCased
extension Character  {
  public var isCased: Bool {
    if _fastPath(_isSingleScalar && _firstScalar.properties.isCased) {
      return true
    }
    return !_isUppercased || !_isLowercased
  }
}

----Swift.(file).Character.isSymbol
extension Character  {
  public var isSymbol: Bool {
    return _firstScalar.properties.generalCategory._isSymbol
  }
}

----Swift.(file).Character.isMathSymbol
extension Character  {
  public var isMathSymbol: Bool {
    return _firstScalar.properties.isMath
  }
}

----Swift.(file).Character.isCurrencySymbol
extension Character  {
  public var isCurrencySymbol: Bool {
    return _firstScalar.properties.generalCategory == .currencySymbol
  }
}

----Swift.(file).Character.isPunctuation
extension Character  {
  public var isPunctuation: Bool {
    return _firstScalar.properties.generalCategory._isPunctuation
  }
}

----Swift.(file).ClosedRange.init(uncheckedBounds:(lower: Bound, upper: Bound))
extension ClosedRange {
  public init(uncheckedBounds bounds: (lower: Bound, upper: Bound)) {
    self.lowerBound = bounds.lower
    self.upperBound = bounds.upper
  }
}

----Swift.(file).ClosedRange.isEmpty
extension ClosedRange  {
  public var isEmpty: Bool {
    return false
  }
}

----Swift.(file).ClosedRange.relative(to:C)
extension ClosedRange: RangeExpression  {
  public func relative<C: Collection>(to collection: C) -> Range<Bound>
  where C.Index == Bound {
    return Range(
      uncheckedBounds: (
        lower: lowerBound, upper: collection.index(after: self.upperBound)))
  }
}

----Swift.(file).ClosedRange.contains(_:Bound)
extension ClosedRange: RangeExpression  {
  public func contains(_ element: Bound) -> Bool {
    return element >= self.lowerBound && element <= self.upperBound
  }
}

----Swift.(file).Index.==infix(_:ClosedRange<Bound>.Index,_:ClosedRange<Bound>.Index)
extension ClosedRange.Index : Comparable  {
  public static func == (
    lhs: ClosedRange<Bound>.Index,
    rhs: ClosedRange<Bound>.Index
  ) -> Bool {
    switch (lhs, rhs) {
    case (.inRange(let l), .inRange(let r)):
      return l == r
    case (.pastEnd, .pastEnd):
      return true
    default:
      return false
    }
  }
}

----Swift.(file).Index.<infix(_:ClosedRange<Bound>.Index,_:ClosedRange<Bound>.Index)
extension ClosedRange.Index : Comparable  {
  public static func < (
    lhs: ClosedRange<Bound>.Index,
    rhs: ClosedRange<Bound>.Index
  ) -> Bool {
    switch (lhs, rhs) {
    case (.inRange(let l), .inRange(let r)):
      return l < r
    case (.inRange, .pastEnd):
      return true
    default:
      return false
    }
  }
}

----Swift.(file).Index.hash(into:Hasher)
extension ClosedRange.Index: Hashable
where Bound: Strideable, Bound.Stride: SignedInteger, Bound: Hashable  {
  public func hash(into hasher: inout Hasher) {
    switch self {
    case .inRange(let value):
      hasher.combine(0 as Int8)
      hasher.combine(value)
    case .pastEnd:
      hasher.combine(1 as Int8)
    }
  }
}

----Swift.(file).ClosedRange.startIndex
extension ClosedRange: Collection, BidirectionalCollection, RandomAccessCollection
where Bound : Strideable, Bound.Stride : SignedInteger
 {
  public var startIndex: Index {
    return .inRange(lowerBound)
  }
}

----Swift.(file).ClosedRange.endIndex
extension ClosedRange: Collection, BidirectionalCollection, RandomAccessCollection
where Bound : Strideable, Bound.Stride : SignedInteger
 {
  public var endIndex: Index {
    return .pastEnd
  }
}

----Swift.(file).ClosedRange.index(after:ClosedRange<Bound>.Index)
extension ClosedRange: Collection, BidirectionalCollection, RandomAccessCollection
where Bound : Strideable, Bound.Stride : SignedInteger
 {
  public func index(after i: Index) -> Index {
    switch i {
    case .inRange(let x):
      return x == upperBound
        ? .pastEnd
        : .inRange(x.advanced(by: 1))
    case .pastEnd: 
      preconditionFailure("Incrementing past end index")
    }
  }
}

----Swift.(file).ClosedRange.index(before:ClosedRange<Bound>.Index)
extension ClosedRange: Collection, BidirectionalCollection, RandomAccessCollection
where Bound : Strideable, Bound.Stride : SignedInteger
 {
  public func index(before i: Index) -> Index {
    switch i {
    case .inRange(let x):
      precondition(x > lowerBound, "Incrementing past start index")
      return .inRange(x.advanced(by: -1))
    case .pastEnd: 
      precondition(upperBound >= lowerBound, "Incrementing past start index")
      return .inRange(upperBound)
    }
  }
}

----Swift.(file).ClosedRange.index(_:ClosedRange<Bound>.Index,offsetBy:Int)
extension ClosedRange: Collection, BidirectionalCollection, RandomAccessCollection
where Bound : Strideable, Bound.Stride : SignedInteger
 {
  public func index(_ i: Index, offsetBy distance: Int) -> Index {
    switch i {
    case .inRange(let x):
      let d = x.distance(to: upperBound)
      if distance <= d {
        let newPosition = x.advanced(by: numericCast(distance))
        precondition(newPosition >= lowerBound,
          "Advancing past start index")
        return .inRange(newPosition)
      }
      if d - -1 == distance { return .pastEnd }
      preconditionFailure("Advancing past end index")
    case .pastEnd:
      if distance == 0 {
        return i
      } 
      if distance < 0 {
        return index(.inRange(upperBound), offsetBy: numericCast(distance + 1))
      }
      preconditionFailure("Advancing past end index")
    }
  }
}

----Swift.(file).ClosedRange.distance(from:ClosedRange<Bound>.Index,to:ClosedRange<Bound>.Index)
extension ClosedRange: Collection, BidirectionalCollection, RandomAccessCollection
where Bound : Strideable, Bound.Stride : SignedInteger
 {
  public func distance(from start: Index, to end: Index) -> Int {
    switch (start, end) {
    case let (.inRange(left), .inRange(right)):
      // in range <--> in range
      return numericCast(left.distance(to: right))
    case let (.inRange(left), .pastEnd):
      // in range --> end
      return numericCast(1 + left.distance(to: upperBound))
    case let (.pastEnd, .inRange(right)):
      // in range <-- end
      return numericCast(upperBound.distance(to: right) - 1)
    case (.pastEnd, .pastEnd):
      // end <--> end
      return 0
    }
  }
}

----Swift.(file).ClosedRange.subscript(_:ClosedRange<Bound>.Index)
extension ClosedRange: Collection, BidirectionalCollection, RandomAccessCollection
where Bound : Strideable, Bound.Stride : SignedInteger
 {
  public subscript(position: Index) -> Bound {
    // FIXME: swift-3-indexing-model: range checks and tests.
    switch position {
    case .inRange(let x): return x
    case .pastEnd: preconditionFailure("Index out of range")
    }
  }
}

----Swift.(file).ClosedRange.subscript(_:Range<ClosedRange<Bound>.Index>)
extension ClosedRange: Collection, BidirectionalCollection, RandomAccessCollection
where Bound : Strideable, Bound.Stride : SignedInteger
 {
  public subscript(bounds: Range<Index>)
    -> Slice<ClosedRange<Bound>> {
    return Slice(base: self, bounds: bounds)
  }
}

----Swift.(file).Comparable....infix(_:Self,_:Self)
extension Comparable  {
  public static func ... (minimum: Self, maximum: Self) -> ClosedRange<Self> {
    precondition(
      minimum <= maximum, "Can't form Range with upperBound < lowerBound")
    return ClosedRange(uncheckedBounds: (lower: minimum, upper: maximum))
  }
}

----Swift.(file).ClosedRange.==infix(_:ClosedRange<Bound>,_:ClosedRange<Bound>)
extension ClosedRange: Equatable  {
  public static func == (
    lhs: ClosedRange<Bound>, rhs: ClosedRange<Bound>
  ) -> Bool {
    return lhs.lowerBound == rhs.lowerBound && lhs.upperBound == rhs.upperBound
  }
}

----Swift.(file).ClosedRange.hash(into:Hasher)
extension ClosedRange: Hashable where Bound: Hashable  {
  public func hash(into hasher: inout Hasher) {
    hasher.combine(lowerBound)
    hasher.combine(upperBound)
  }
}

----Swift.(file).ClosedRange.description
extension ClosedRange : CustomStringConvertible  {
  public var description: String {
    return "\(lowerBound)...\(upperBound)"
  }
}

----Swift.(file).ClosedRange.debugDescription
extension ClosedRange : CustomDebugStringConvertible  {
  public var debugDescription: String {
    return "ClosedRange(\(String(reflecting: lowerBound))"
    + "...\(String(reflecting: upperBound)))"
  }
}

----Swift.(file).ClosedRange.customMirror
extension ClosedRange : CustomReflectable  {
  public var customMirror: Mirror {
    return Mirror(
      self, children: ["lowerBound": lowerBound, "upperBound": upperBound])
  }
}

----Swift.(file).ClosedRange.clamped(to:ClosedRange<Bound>)
extension ClosedRange  {
  public func clamped(to limits: ClosedRange) -> ClosedRange {
    let lower =         
      limits.lowerBound > self.lowerBound ? limits.lowerBound
          : limits.upperBound < self.lowerBound ? limits.upperBound
          : self.lowerBound
    let upper =
      limits.upperBound < self.upperBound ? limits.upperBound
          : limits.lowerBound > self.upperBound ? limits.lowerBound
          : self.upperBound
    return ClosedRange(uncheckedBounds: (lower: lower, upper: upper))
  }
}

----Swift.(file).ClosedRange.init(_:Range<Bound>)
extension ClosedRange where Bound: Strideable, Bound.Stride : SignedInteger  {
  public init(_ other: Range<Bound>) {
    precondition(!other.isEmpty, "Can't form an empty closed range")
    let upperBound = other.upperBound.advanced(by: -1)
    self.init(uncheckedBounds: (lower: other.lowerBound, upper: upperBound))
  }
}

----Swift.(file).ClosedRange.overlaps(_:ClosedRange<Bound>)
extension ClosedRange  {
  public func overlaps(_ other: ClosedRange<Bound>) -> Bool {
    return self.contains(other.lowerBound) || other.contains(lowerBound)
  }
}

----Swift.(file).ClosedRange.overlaps(_:Range<Bound>)
extension ClosedRange  {
  public func overlaps(_ other: Range<Bound>) -> Bool {
    return other.overlaps(self)
  }
}

----Swift.(file).IndexingIterator.init(_elements:Elements)
extension IndexingIterator {
  init(_elements: Elements) {
    self._elements = _elements
    self._position = _elements.startIndex
  }
}

----Swift.(file).IndexingIterator.init(_elements:Elements,_position:Elements.Index)
extension IndexingIterator {
  init(_elements: Elements, _position: Elements.Index) {
    self._elements = _elements
    self._position = _position
  }
}

----Swift.(file).IndexingIterator.next()
extension IndexingIterator: IteratorProtocol, Sequence  {
  public mutating func next() -> Elements.Element? {
    if _position == _elements.endIndex { return nil }
    let element = _elements[_position]
    _elements.formIndex(after: &_position)
    return element
  }
}

----Swift.(file).Collection.startIndex
extension Collection {
  var startIndex: Index { get }
}

----Swift.(file).Collection.endIndex
extension Collection {
  var endIndex: Index { get }
}

----Swift.(file).Collection.subscript(_:Self.Index)
extension Collection {
  subscript(position: Index) -> Element { get }
}

----Swift.(file).Collection.subscript(_:Range<Self.Index>)
extension Collection {
  subscript(bounds: Range<Index>) -> SubSequence { get }
}

----Swift.(file).Collection.indices
extension Collection {
  var indices: Indices { get }
}

----Swift.(file).Collection.isEmpty
extension Collection {
  var isEmpty: Bool { get }
}

----Swift.(file).Collection.count
extension Collection {
  var count: Int { get }
}

----Swift.(file).Collection.formIndex(after:Self.Index)
extension Collection  {
  public func formIndex(after i: inout Index) {
    i = index(after: i)
  }
}

----Swift.(file).Collection.index(_:Self.Index,offsetBy:Int)
extension Collection  {
  public func index(_ i: Index, offsetBy distance: Int) -> Index {
    return self._advanceForward(i, by: distance)
  }
}

----Swift.(file).Collection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)
extension Collection  {
  public func index(
    _ i: Index, offsetBy distance: Int, limitedBy limit: Index
  ) -> Index? {
    return self._advanceForward(i, by: distance, limitedBy: limit)
  }
}

----Swift.(file).Collection.formIndex(_:Self.Index,offsetBy:Int)
extension Collection  {
  public func formIndex(_ i: inout Index, offsetBy distance: Int) {
    i = index(i, offsetBy: distance)
  }
}

----Swift.(file).Collection.formIndex(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)
extension Collection  {
  public func formIndex(
    _ i: inout Index, offsetBy distance: Int, limitedBy limit: Index
  ) -> Bool {
    if let advancedIndex = index(i, offsetBy: distance, limitedBy: limit) {
      i = advancedIndex
      return true
    }
    i = limit
    return false
  }
}

----Swift.(file).Collection.distance(from:Self.Index,to:Self.Index)
extension Collection  {
  public func distance(from start: Index, to end: Index) -> Int {
    precondition(start <= end,
      "Only BidirectionalCollections can have end come before start")

    var start = start
    var count = 0
    while start != end {
      count = count + 1
      formIndex(after: &start)
    }
    return count
  }
}

----Swift.(file).Collection.randomElement(using:T)
extension Collection  {
  public func randomElement<T: RandomNumberGenerator>(
    using generator: inout T
  ) -> Element? {
    guard !isEmpty else { return nil }
    let random = Int.random(in: 0 ..< count, using: &generator)
    let idx = index(startIndex, offsetBy: random)
    return self[idx]
  }
}

----Swift.(file).Collection.randomElement()
extension Collection  {
  public func randomElement() -> Element? {
    var g = SystemRandomNumberGenerator()
    return randomElement(using: &g)
  }
}

----Swift.(file).Collection.makeIterator()
extension Collection where Iterator == IndexingIterator<Self>  {
  public __consuming func makeIterator() -> IndexingIterator<Self> {
    return IndexingIterator(_elements: self)
  }
}

----Swift.(file).Collection.subscript(_:Range<Self.Index>)
extension Collection where SubSequence == Slice<Self>  {
  public subscript(bounds: Range<Index>) -> Slice<Self> {
    _failEarlyRangeCheck(bounds, bounds: startIndex..<endIndex)
    return Slice(base: self, bounds: bounds)
  }
}

----Swift.(file).Collection.popFirst()
extension Collection where SubSequence == Self  {
  public mutating func popFirst() -> Element? {
    // TODO: swift-3-indexing-model - review the following
    guard !isEmpty else { return nil }
    let element = first!
    self = self[index(after: startIndex)..<endIndex]
    return element
  }
}

----Swift.(file).Collection.isEmpty
extension Collection  {
  public var isEmpty: Bool {
    return startIndex == endIndex
  }
}

----Swift.(file).Collection.first
extension Collection  {
  public var first: Element? {
    let start = startIndex
    if start != endIndex { return self[start] }
    else { return nil }
  }
}

----Swift.(file).Collection.underestimatedCount
extension Collection  {
  public var underestimatedCount: Int {
    // TODO: swift-3-indexing-model - review the following
    return count
  }
}

----Swift.(file).Collection.count
extension Collection  {
  public var count: Int {
    return distance(from: startIndex, to: endIndex)
  }
}

----Swift.(file).Collection.map(_:(Self.Element) throws -> T)
extension Collection  {
  public func map<T>(
    _ transform: (Element) throws -> T
  ) rethrows -> [T] {
    // TODO: swift-3-indexing-model - review the following
    let n = self.count
    if n == 0 {
      return []
    }

    var result = ContiguousArray<T>()
    result.reserveCapacity(n)

    var i = self.startIndex

    for _ in 0..<n {
      result.append(try transform(self[i]))
      formIndex(after: &i)
    }

    _expectEnd(of: self, is: i)
    return Array(result)
  }
}

----Swift.(file).Collection.dropFirst(_:Int)
extension Collection  {
  public __consuming func dropFirst(_ k: Int = 1) -> SubSequence {
    if(k == nil) k = 1
    precondition(k >= 0, "Can't drop a negative number of elements from a collection")
    let start = index(startIndex, offsetBy: k, limitedBy: endIndex) ?? endIndex
    return self[start..<endIndex]
  }
}

----Swift.(file).Collection.dropLast(_:Int)
extension Collection  {
  public __consuming func dropLast(_ k: Int = 1) -> SubSequence {
    precondition(
      k >= 0, "Can't drop a negative number of elements from a collection")
    let amount = Swift.max(0, count - k)
    let end = index(startIndex,
      offsetBy: amount, limitedBy: endIndex) ?? endIndex
    return self[startIndex..<end]
  }
}

----Swift.(file).Collection.drop(while:(Self.Element) throws -> Bool)
extension Collection  {
  public __consuming func drop(
    while predicate: (Element) throws -> Bool
  ) rethrows -> SubSequence {
    var start = startIndex
    while try start != endIndex && predicate(self[start]) {
      formIndex(after: &start)
    } 
    return self[start..<endIndex]
  }
}

----Swift.(file).Collection.prefix(_:Int)
extension Collection  {
  public __consuming func prefix(_ maxLength: Int) -> SubSequence {
    precondition(
      maxLength >= 0,
      "Can't take a prefix of negative length from a collection")
    let end = index(startIndex,
      offsetBy: maxLength, limitedBy: endIndex) ?? endIndex
    return self[startIndex..<end]
  }
}

----Swift.(file).Collection.prefix(while:(Self.Element) throws -> Bool)
extension Collection  {
  public __consuming func prefix(
    while predicate: (Element) throws -> Bool
  ) rethrows -> SubSequence {
    var end = startIndex
    while try end != endIndex && predicate(self[end]) {
      formIndex(after: &end)
    }
    return self[startIndex..<end]
  }
}

----Swift.(file).Collection.suffix(_:Int)
extension Collection  {
  public __consuming func suffix(_ maxLength: Int) -> SubSequence {
    precondition(
      maxLength >= 0,
      "Can't take a suffix of negative length from a collection")
    let amount = Swift.max(0, count - maxLength)
    let start = index(startIndex,
      offsetBy: amount, limitedBy: endIndex) ?? endIndex
    return self[start..<endIndex]
  }
}

----Swift.(file).Collection.prefix(upTo:Self.Index)
extension Collection  {
  public __consuming func prefix(upTo end: Index) -> SubSequence {
    return self[startIndex..<end]
  }
}

----Swift.(file).Collection.suffix(from:Self.Index)
extension Collection  {
  public __consuming func suffix(from start: Index) -> SubSequence {
    return self[start..<endIndex]
  }
}

----Swift.(file).Collection.prefix(through:Self.Index)
extension Collection  {
  public __consuming func prefix(through position: Index) -> SubSequence {
    return prefix(upTo: index(after: position))
  }
}

----Swift.(file).Collection.split(maxSplits:Int,omittingEmptySubsequences:Bool,whereSeparator:(Self.Element) throws -> Bool)
extension Collection  {
  public __consuming func split(
    maxSplits: Int = Int.max,
    omittingEmptySubsequences: Bool = true,
    whereSeparator isSeparator: (Element) throws -> Bool
  ) rethrows -> [SubSequence] {
    // TODO: swift-3-indexing-model - review the following
    precondition(maxSplits >= 0, "Must take zero or more splits")

    var result: [SubSequence] = []
    var subSequenceStart: Index = startIndex

    func appendSubsequence(end: Index) -> Bool {
      if subSequenceStart == end && omittingEmptySubsequences {
        return false
      }
      result.append(self[subSequenceStart..<end])
      return true
    }

    if maxSplits == 0 || isEmpty {
      _ = appendSubsequence(end: endIndex)
      return result
    }

    var subSequenceEnd = subSequenceStart
    let cachedEndIndex = endIndex
    while subSequenceEnd != cachedEndIndex {
      if try isSeparator(self[subSequenceEnd]) {
        let didAppend = appendSubsequence(end: subSequenceEnd)
        formIndex(after: &subSequenceEnd)
        subSequenceStart = subSequenceEnd
        if didAppend && result.count == maxSplits {
          break
        }
        continue
      }
      formIndex(after: &subSequenceEnd)
    }

    if subSequenceStart != cachedEndIndex || !omittingEmptySubsequences {
      result.append(self[subSequenceStart..<cachedEndIndex])
    }

    return result
  }
}

----Swift.(file).Collection.split(separator:Self.Element,maxSplits:Int,omittingEmptySubsequences:Bool)
extension Collection where Element : Equatable  {
  public __consuming func split(
    separator: Element,
    maxSplits: Int = Int.max,
    omittingEmptySubsequences: Bool = true
  ) -> [SubSequence] {
    // TODO: swift-3-indexing-model - review the following
    return split(
      maxSplits: maxSplits,
      omittingEmptySubsequences: omittingEmptySubsequences,
      whereSeparator: { $0 == separator })
  }
}

----Swift.(file).Collection.removeFirst()
extension Collection where SubSequence == Self  {
  public mutating func removeFirst() -> Element {
    // TODO: swift-3-indexing-model - review the following
    precondition(!isEmpty, "Can't remove items from an empty collection")
    let element = first!
    self = self[index(after: startIndex)..<endIndex]
    return element
  }
}

----Swift.(file).Collection.removeFirst(_:Int)
extension Collection where SubSequence == Self  {
  public mutating func removeFirst(_ k: Int) {
    if k == 0 { return }
    precondition(k >= 0, "Number of elements to remove should be non-negative")
    precondition(count >= k,
      "Can't remove more items from a collection than it contains")
    self = self[index(startIndex, offsetBy: k)..<endIndex]
  }
}

----Swift.(file).BidirectionalCollection.last
extension BidirectionalCollection  {
  public var last: Element? {
    return isEmpty ? nil : self[index(before: endIndex)]
  }
}

----Swift.(file).Collection.firstIndex(of:Self.Element)
extension Collection where Element : Equatable  {
  public func firstIndex(of element: Element) -> Index? {
    if let result = _customIndexOfEquatableElement(element) {
      return result
    }

    var i = self.startIndex
    while i != self.endIndex {
      if self[i] == element {
        return i
      }
      self.formIndex(after: &i)
    }
    return nil
  }
}

----Swift.(file).Collection.firstIndex(where:(Self.Element) throws -> Bool)
extension Collection  {
  public func firstIndex(
    where predicate: (Element) throws -> Bool
  ) rethrows -> Index? {
    var i = self.startIndex
    while i != self.endIndex {
      if try predicate(self[i]) {
        return i
      }
      self.formIndex(after: &i)
    }
    return nil
  }
}

----Swift.(file).BidirectionalCollection.last(where:(Self.Element) throws -> Bool)
extension BidirectionalCollection  {
  public func last(
    where predicate: (Element) throws -> Bool
  ) rethrows -> Element? {
    return try lastIndex(where: predicate).map { self[$0] }
  }
}

----Swift.(file).BidirectionalCollection.lastIndex(where:(Self.Element) throws -> Bool)
extension BidirectionalCollection  {
  public func lastIndex(
    where predicate: (Element) throws -> Bool
  ) rethrows -> Index? {
    var i = endIndex
    while i != startIndex {
      formIndex(before: &i)
      if try predicate(self[i]) {
        return i
      }
    }
    return nil
  }
}

----Swift.(file).BidirectionalCollection.lastIndex(of:Self.Element)
extension BidirectionalCollection where Element : Equatable  {
  public func lastIndex(of element: Element) -> Index? {
    if let result = _customLastIndexOfEquatableElement(element) {
      return result
    }
    return lastIndex(where: { $0 == element })
  }
}

----Swift.(file).MutableCollection.partition(by:(Self.Element) throws -> Bool)
extension MutableCollection  {
  public mutating func partition(
    by belongsInSecondPartition: (Element) throws -> Bool
  ) rethrows -> Index {
    return try _halfStablePartition(isSuffixElement: belongsInSecondPartition)
  }
}

----Swift.(file).MutableCollection.partition(by:(Self.Element) throws -> Bool)
extension MutableCollection where Self : BidirectionalCollection  {
  public mutating func partition(
    by belongsInSecondPartition: (Element) throws -> Bool
  ) rethrows -> Index {
    let maybeOffset = try _withUnsafeMutableBufferPointerIfSupported {
      (bufferPointer) -> Int in
      let unsafeBufferPivot = try bufferPointer._partitionImpl(
        by: belongsInSecondPartition)
      return unsafeBufferPivot - bufferPointer.startIndex
    }
    if let offset = maybeOffset {
      return index(startIndex, offsetBy: offset)
    } else {
      return try _partitionImpl(by: belongsInSecondPartition)
    }
  }
}

----Swift.(file).Sequence.shuffled(using:T)
extension Sequence  {
  public func shuffled<T: RandomNumberGenerator>(
    using generator: inout T
  ) -> [Element] {
    var result = ContiguousArray(self)
    result.shuffle(using: &generator)
    return Array(result)
  }
}

----Swift.(file).Sequence.shuffled()
extension Sequence  {
  public func shuffled() -> [Element] {
    var g = SystemRandomNumberGenerator()
    return shuffled(using: &g)
  }
}

----Swift.(file).MutableCollection.shuffle(using:T)
extension MutableCollection where Self : RandomAccessCollection  {
  public mutating func shuffle<T: RandomNumberGenerator>(
    using generator: inout T
  ) {
    guard count > 1 else { return }
    var amount = count
    var currentIndex = startIndex
    while amount > 1 {
      let random = Int.random(in: 0 ..< amount, using: &generator)
      amount -= 1
      swapAt(
        currentIndex,
        index(currentIndex, offsetBy: random)
      )
      formIndex(after: &currentIndex)
    }
  }
}

----Swift.(file).MutableCollection.shuffle()
extension MutableCollection where Self : RandomAccessCollection  {
  public mutating func shuffle() {
    var g = SystemRandomNumberGenerator()
    shuffle(using: &g)
  }
}

----Swift.(file).CollectionOfOne.init(_:Element)
extension CollectionOfOne {
  public init(_ element: Element) {
    self._element = element
  }
}

----Swift.(file).Iterator.next()
extension CollectionOfOne.Iterator: IteratorProtocol  {
  public mutating func next() -> Element? {
    let result = _elements
    _elements = nil
    return result
  }
}

----Swift.(file).CollectionOfOne.startIndex
extension CollectionOfOne: RandomAccessCollection, MutableCollection  {
  public var startIndex: Index {
    return 0
  }
}

----Swift.(file).CollectionOfOne.endIndex
extension CollectionOfOne: RandomAccessCollection, MutableCollection  {
  public var endIndex: Index {
    return 1
  }
}

----Swift.(file).CollectionOfOne.index(after:CollectionOfOne<Element>.Index)
extension CollectionOfOne: RandomAccessCollection, MutableCollection  {
  public func index(after i: Index) -> Index {
    precondition(i == startIndex)
    return 1
  }
}

----Swift.(file).CollectionOfOne.index(before:CollectionOfOne<Element>.Index)
extension CollectionOfOne: RandomAccessCollection, MutableCollection  {
  public func index(before i: Index) -> Index {
    precondition(i == endIndex)
    return 0
  }
}

----Swift.(file).CollectionOfOne.makeIterator()
extension CollectionOfOne: RandomAccessCollection, MutableCollection  {
  public __consuming func makeIterator() -> Iterator {
    return Iterator(_elements: _element)
  }
}

----Swift.(file).CollectionOfOne.subscript(_:Int)
extension CollectionOfOne: RandomAccessCollection, MutableCollection  {
  public subscript(position: Int) -> Element {
    get {
      precondition(position == 0, "Index out of range")
      return _element
    }
    _modify {
      precondition(position == 0, "Index out of range")
      yield &_element
    }
  }
}

----Swift.(file).CollectionOfOne.subscript(_:Range<Int>)
extension CollectionOfOne: RandomAccessCollection, MutableCollection  {
  public subscript(bounds: Range<Int>) -> SubSequence {
    get {
      _failEarlyRangeCheck(bounds, bounds: 0..<1)
      return Slice(base: self, bounds: bounds)
    }
    set {
      _failEarlyRangeCheck(bounds, bounds: 0..<1)
      let n = newValue.count
      precondition(bounds.count == n, "CollectionOfOne can't be resized")
      if n == 1 { self = newValue.base }
    }
  }
}

----Swift.(file).CollectionOfOne.count
extension CollectionOfOne: RandomAccessCollection, MutableCollection  {
  public var count: Int {
    return 1
  }
}

----Swift.(file).CollectionOfOne.debugDescription
extension CollectionOfOne : CustomDebugStringConvertible  {
  public var debugDescription: String {
    return "CollectionOfOne(\(String(reflecting: _element)))"
  }
}

----Swift.(file).CollectionOfOne.customMirror
extension CollectionOfOne : CustomReflectable  {
  public var customMirror: Mirror {
    return Mirror(self, children: ["element": _element])
  }
}

----Swift.(file).Comparable.>infix(_:Self,_:Self)
extension Comparable  {
  public static func > (lhs: Self, rhs: Self) -> Bool {
    return rhs < lhs
  }
}

----Swift.(file).Comparable.<=infix(_:Self,_:Self)
extension Comparable  {
  public static func <= (lhs: Self, rhs: Self) -> Bool {
    return !(rhs < lhs)
  }
}

----Swift.(file).Comparable.>=infix(_:Self,_:Self)
extension Comparable  {
  public static func >= (lhs: Self, rhs: Self) -> Bool {
    return !(lhs < rhs)
  }
}

----Swift.(file).RawRepresentable.rawValue
extension RawRepresentable {
  var rawValue: RawValue { get }
}

----Swift.(file).==infix(_:T,_:T)
public func == <T : RawRepresentable>(lhs: T, rhs: T) -> Bool
  where T.RawValue : Equatable {
  return lhs.rawValue == rhs.rawValue
}

----Swift.(file).!=infix(_:T,_:T)
public func != <T : RawRepresentable>(lhs: T, rhs: T) -> Bool
  where T.RawValue : Equatable {
  return lhs.rawValue != rhs.rawValue
}

----Swift.(file).!=infix(_:T,_:T)
public func != <T : Equatable>(lhs: T, rhs: T) -> Bool
  where T : RawRepresentable, T.RawValue : Equatable {
  return lhs.rawValue != rhs.rawValue
}

----Swift.(file).RawRepresentable.hashValue
extension RawRepresentable where RawValue: Hashable, Self: Hashable  {
  public var hashValue: Int {
    return rawValue.hashValue
  }
}

----Swift.(file).RawRepresentable.hash(into:Hasher)
extension RawRepresentable where RawValue: Hashable, Self: Hashable  {
  public func hash(into hasher: inout Hasher) {
    hasher.combine(rawValue)
  }
}

----Swift.(file).CaseIterable.allCases
extension CaseIterable {
  static var allCases: AllCases { get }
}

----Swift.(file).ExpressibleByExtendedGraphemeClusterLiteral.init(unicodeScalarLiteral:Self.ExtendedGraphemeClusterLiteralType)
extension ExpressibleByExtendedGraphemeClusterLiteral
  where ExtendedGraphemeClusterLiteralType == UnicodeScalarLiteralType  {
  public init(unicodeScalarLiteral value: ExtendedGraphemeClusterLiteralType) {
    self.init(extendedGraphemeClusterLiteral: value)
  }
}

----Swift.(file).ExpressibleByStringLiteral.init(extendedGraphemeClusterLiteral:Self.StringLiteralType)
extension ExpressibleByStringLiteral
  where StringLiteralType == ExtendedGraphemeClusterLiteralType  {
  public init(extendedGraphemeClusterLiteral value: StringLiteralType) {
    self.init(stringLiteral: value)
  }
}

----Swift.(file).ExpressibleByStringInterpolation.init(stringInterpolation:DefaultStringInterpolation)
extension ExpressibleByStringInterpolation
  where StringInterpolation == DefaultStringInterpolation  {
  public init(stringInterpolation: DefaultStringInterpolation) {
    self.init(stringLiteral: stringInterpolation.make())
  }
}

----Swift.(file).ContiguousArray.capacity
extension ContiguousArray: _ArrayProtocol  {
  public var capacity: Int {
    return _getCapacity()
  }
}

----Swift.(file).ContiguousArray.startIndex
extension ContiguousArray: RandomAccessCollection, MutableCollection  {
  public var startIndex: Int {
    return 0
  }
}

----Swift.(file).ContiguousArray.endIndex
extension ContiguousArray: RandomAccessCollection, MutableCollection  {
  public var endIndex: Int {
    @inlinable
    get {
      return _getCount()
    }
  }
}

----Swift.(file).ContiguousArray.index(after:Int)
extension ContiguousArray: RandomAccessCollection, MutableCollection  {
  public func index(after i: Int) -> Int {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    return i + 1
  }
}

----Swift.(file).ContiguousArray.formIndex(after:Int)
extension ContiguousArray: RandomAccessCollection, MutableCollection  {
  public func formIndex(after i: inout Int) {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    i += 1
  }
}

----Swift.(file).ContiguousArray.index(before:Int)
extension ContiguousArray: RandomAccessCollection, MutableCollection  {
  public func index(before i: Int) -> Int {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    return i - 1
  }
}

----Swift.(file).ContiguousArray.formIndex(before:Int)
extension ContiguousArray: RandomAccessCollection, MutableCollection  {
  public func formIndex(before i: inout Int) {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    i -= 1
  }
}

----Swift.(file).ContiguousArray.index(_:Int,offsetBy:Int)
extension ContiguousArray: RandomAccessCollection, MutableCollection  {
  public func index(_ i: Int, offsetBy distance: Int) -> Int {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    return i + distance
  }
}

----Swift.(file).ContiguousArray.index(_:Int,offsetBy:Int,limitedBy:Int)
extension ContiguousArray: RandomAccessCollection, MutableCollection  {
  public func index(
    _ i: Int, offsetBy distance: Int, limitedBy limit: Int
  ) -> Int? {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    let l = limit - i
    if distance > 0 ? l >= 0 && l < distance : l <= 0 && distance < l {
      return nil
    }
    return i + distance
  }
}

----Swift.(file).ContiguousArray.distance(from:Int,to:Int)
extension ContiguousArray: RandomAccessCollection, MutableCollection  {
  public func distance(from start: Int, to end: Int) -> Int {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    return end - start
  }
}

----Swift.(file).ContiguousArray.subscript(_:Int)
extension ContiguousArray: RandomAccessCollection, MutableCollection  {
  public subscript(index: Int) -> Element {
    get {
      _checkSubscript_native(index)
      return _buffer.getElement(index)
    }
    _modify {
      _makeMutableAndUnique()
      _checkSubscript_native(index)
      let address = _buffer.subscriptBaseAddress + index
      yield &address.pointee
    }
  }
}

----Swift.(file).ContiguousArray.subscript(_:Range<Int>)
extension ContiguousArray: RandomAccessCollection, MutableCollection  {
  public subscript(bounds: Range<Int>) -> ArraySlice<Element> {
    get {
      _checkIndex(bounds.lowerBound)
      _checkIndex(bounds.upperBound)
      return ArraySlice(_buffer: _buffer[bounds])
    }
    set(rhs) {
      _checkIndex(bounds.lowerBound)
      _checkIndex(bounds.upperBound)
      // If the replacement buffer has same identity, and the ranges match,
      // then this was a pinned in-place modification, nothing further needed.
      if self[bounds]._buffer.identity != rhs._buffer.identity
      || bounds != rhs.startIndex..<rhs.endIndex {
        self.replaceSubrange(bounds, with: rhs)
      }
    }
  }
}

----Swift.(file).ContiguousArray.count
extension ContiguousArray: RandomAccessCollection, MutableCollection  {
  public var count: Int {
    return _getCount()
  }
}

----Swift.(file).ContiguousArray.init(arrayLiteral:[Element])
extension ContiguousArray: ExpressibleByArrayLiteral  {
  public init(arrayLiteral elements: Element...) {
    self.init(_buffer: ContiguousArray(elements)._buffer)
  }
}

----Swift.(file).ContiguousArray.init()
extension ContiguousArray: RangeReplaceableCollection  {
  public init() {
    _buffer = _Buffer()
  }
}

----Swift.(file).ContiguousArray.init(repeating:Element,count:Int)
extension ContiguousArray: RangeReplaceableCollection  {
  public init(repeating repeatedValue: Element, count: Int) {
    var p: UnsafeMutablePointer<Element>
    (self, p) = ContiguousArray._allocateUninitialized(count)
    for _ in 0..<count {
      p.initialize(to: repeatedValue)
      p += 1
    }
  }
}

----Swift.(file).ContiguousArray.reserveCapacity(_:Int)
extension ContiguousArray: RangeReplaceableCollection  {
  public mutating func reserveCapacity(_ minimumCapacity: Int) {
    if _buffer.requestUniqueMutableBackingBuffer(
      minimumCapacity: minimumCapacity) == nil {

      let newBuffer = _ContiguousArrayBuffer<Element>(
        _uninitializedCount: count, minimumCapacity: minimumCapacity)

      _buffer._copyContents(
        subRange: _buffer.indices,
        initializing: newBuffer.firstElementAddress)
      _buffer = _Buffer(
        _buffer: newBuffer, shiftedToStartIndex: _buffer.startIndex)
    }
    _internalInvariant(capacity >= minimumCapacity)
  }
}

----Swift.(file).ContiguousArray.append(_:Element)
extension ContiguousArray: RangeReplaceableCollection  {
  public mutating func append(_ newElement: __owned Element) {
    _makeUniqueAndReserveCapacityIfNotUnique()
    let oldCount = _getCount()
    _reserveCapacityAssumingUniqueBuffer(oldCount: oldCount)
    _appendElementAssumeUniqueAndCapacity(oldCount, newElement: newElement)
  }
}

----Swift.(file).ContiguousArray.append(contentsOf:S)
extension ContiguousArray: RangeReplaceableCollection  {
  public mutating func append<S: Sequence>(contentsOf newElements: __owned S)
    where S.Element == Element {

    let newElementsCount = newElements.underestimatedCount
    reserveCapacityForAppend(newElementsCount: newElementsCount)

    let oldCount = self.count
    let startNewElements = _buffer.firstElementAddress + oldCount
    let buf = UnsafeMutableBufferPointer(
                start: startNewElements, 
                count: self.capacity - oldCount)

    let (remainder,writtenUpTo) = buf.initialize(from: newElements)
    
    // trap on underflow from the sequence's underestimate:
    let writtenCount = buf.distance(from: buf.startIndex, to: writtenUpTo)
    precondition(newElementsCount <= writtenCount, 
      "newElements.underestimatedCount was an overestimate")
    // can't check for overflow as sequences can underestimate

    _buffer.count += writtenCount

    if writtenUpTo == buf.endIndex {
      // there may be elements that didn't fit in the existing buffer,
      // append them in slow sequence-only mode
      _buffer._arrayAppendSequence(IteratorSequence(remainder))
    }
  }
}

----Swift.(file).ContiguousArray.remove(at:Int)
extension ContiguousArray: RangeReplaceableCollection  {
  public mutating func remove(at index: Int) -> Element {
    precondition(index < endIndex, "Index out of range")
    precondition(index >= startIndex, "Index out of range")
    _makeUniqueAndReserveCapacityIfNotUnique()
    let newCount = _getCount() - 1
    let pointer = (_buffer.firstElementAddress + index)
    let result = pointer.move()
    pointer.moveInitialize(from: pointer + 1, count: newCount - index)
    _buffer.count = newCount
    return result
  }
}

----Swift.(file).ContiguousArray.insert(_:Element,at:Int)
extension ContiguousArray: RangeReplaceableCollection  {
  public mutating func insert(_ newElement: __owned Element, at i: Int) {
    _checkIndex(i)
    self.replaceSubrange(i..<i, with: CollectionOfOne(newElement))
  }
}

----Swift.(file).ContiguousArray.removeAll(keepingCapacity:Bool)
extension ContiguousArray: RangeReplaceableCollection  {
  public mutating func removeAll(keepingCapacity keepCapacity: Bool = false) {
    if !keepCapacity {
      _buffer = _Buffer()
    }
    else {
      self.replaceSubrange(indices, with: EmptyCollection())
    }
  }
}

----Swift.(file).ContiguousArray.withContiguousMutableStorageIfAvailable(_:(inout UnsafeMutableBufferPointer<Element>) throws -> R)
extension ContiguousArray: RangeReplaceableCollection  {
  public mutating func withContiguousMutableStorageIfAvailable<R>(
    _ body: (inout UnsafeMutableBufferPointer<Element>) throws -> R
  ) rethrows -> R? {
    return try withUnsafeMutableBufferPointer {
      (bufferPointer) -> R in
      return try body(&bufferPointer)
    }
  }
}

----Swift.(file).ContiguousArray.withContiguousStorageIfAvailable(_:(UnsafeBufferPointer<Element>) throws -> R)
extension ContiguousArray: RangeReplaceableCollection  {
  public func withContiguousStorageIfAvailable<R>(
    _ body: (UnsafeBufferPointer<Element>) throws -> R
  ) rethrows -> R? {
    return try withUnsafeBufferPointer {
      (bufferPointer) -> R in
      return try body(bufferPointer)
    }
  }
}

----Swift.(file).ContiguousArray.customMirror
extension ContiguousArray: CustomReflectable  {
  public var customMirror: Mirror {
    return Mirror(
      self,
      unlabeledChildren: self,
      displayStyle: .collection)
  }
}

----Swift.(file).ContiguousArray.description
extension ContiguousArray: CustomStringConvertible, CustomDebugStringConvertible  {
  public var description: String {
    return _makeCollectionDescription()
  }
}

----Swift.(file).ContiguousArray.debugDescription
extension ContiguousArray: CustomStringConvertible, CustomDebugStringConvertible  {
  public var debugDescription: String {
    return _makeCollectionDescription(withTypeName: "ContiguousArray")
  }
}

----Swift.(file).ContiguousArray.withUnsafeBufferPointer(_:(UnsafeBufferPointer<Element>) throws -> R)
extension ContiguousArray  {
  public func withUnsafeBufferPointer<R>(
    _ body: (UnsafeBufferPointer<Element>) throws -> R
  ) rethrows -> R {
    return try _buffer.withUnsafeBufferPointer(body)
  }
}

----Swift.(file).ContiguousArray.withUnsafeMutableBufferPointer(_:(inout UnsafeMutableBufferPointer<Element>) throws -> R)
extension ContiguousArray  {
  public mutating func withUnsafeMutableBufferPointer<R>(
    _ body: (inout UnsafeMutableBufferPointer<Element>) throws -> R
  ) rethrows -> R {
    let count = self.count
    // Ensure unique storage
    _buffer._outlinedMakeUniqueBuffer(bufferCount: count)

    // Ensure that body can't invalidate the storage or its bounds by
    // moving self into a temporary working array.
    // NOTE: The stack promotion optimization that keys of the
    // "array.withUnsafeMutableBufferPointer" semantics annotation relies on the
    // array buffer not being able to escape in the closure. It can do this
    // because we swap the array buffer in self with an empty buffer here. Any
    // escape via the address of self in the closure will therefore escape the
    // empty array.

    var work = ContiguousArray()
    (work, self) = (self, work)

    // Create an UnsafeBufferPointer over work that we can pass to body
    let pointer = work._buffer.firstElementAddress
    var inoutBufferPointer = UnsafeMutableBufferPointer(
      start: pointer, count: count)

    // Put the working array back before returning.
    defer {
      precondition(
        inoutBufferPointer.baseAddress == pointer &&
        inoutBufferPointer.count == count,
        "ContiguousArray withUnsafeMutableBufferPointer: replacing the buffer is not allowed")

      (work, self) = (self, work)
    }

    // Invoke the body.
    return try body(&inoutBufferPointer)
  }
}

----Swift.(file).ContiguousArray.replaceSubrange(_:Range<Int>,with:C)
extension ContiguousArray  {
  public mutating func replaceSubrange<C>(
    _ subrange: Range<Int>,
    with newElements: __owned C
  ) where C: Collection, C.Element == Element {
    precondition(subrange.lowerBound >= self._buffer.startIndex,
      "ContiguousArray replace: subrange start is negative")

    precondition(subrange.upperBound <= _buffer.endIndex,
      "ContiguousArray replace: subrange extends past the end")

    let oldCount = _buffer.count
    let eraseCount = subrange.count
    let insertCount = newElements.count
    let growth = insertCount - eraseCount

    if _buffer.requestUniqueMutableBackingBuffer(
      minimumCapacity: oldCount + growth) != nil {

      _buffer.replaceSubrange(
        subrange, with: insertCount, elementsOf: newElements)
    } else {
      _buffer._arrayOutOfPlaceReplace(subrange, with: newElements, count: insertCount)
    }
  }
}

----Swift.(file).ContiguousArray.==infix(_:ContiguousArray<Element>,_:ContiguousArray<Element>)
extension ContiguousArray: Equatable where Element: Equatable  {
  public static func ==(lhs: ContiguousArray<Element>, rhs: ContiguousArray<Element>) -> Bool {
    let lhsCount = lhs.count
    if lhsCount != rhs.count {
      return false
    }

    // Test referential equality.
    if lhsCount == 0 || lhs._buffer.identity == rhs._buffer.identity {
      return true
    }


    _internalInvariant(lhs.startIndex == 0 && rhs.startIndex == 0)
    _internalInvariant(lhs.endIndex == lhsCount && rhs.endIndex == lhsCount)

    // We know that lhs.count == rhs.count, compare element wise.
    for idx in 0..<lhsCount {
      if lhs[idx] != rhs[idx] {
        return false
      }
    }

    return true
  }
}

----Swift.(file).ContiguousArray.hash(into:Hasher)
extension ContiguousArray: Hashable where Element: Hashable  {
  public func hash(into hasher: inout Hasher) {
    hasher.combine(count) // discriminator
    for element in self {
      hasher.combine(element)
    }
  }
}

----Swift.(file).ContiguousArray.withUnsafeMutableBytes(_:(UnsafeMutableRawBufferPointer) throws -> R)
extension ContiguousArray  {
  public mutating func withUnsafeMutableBytes<R>(
    _ body: (UnsafeMutableRawBufferPointer) throws -> R
  ) rethrows -> R {
    return try self.withUnsafeMutableBufferPointer {
      return try body(UnsafeMutableRawBufferPointer($0))
    }
  }
}

----Swift.(file).ContiguousArray.withUnsafeBytes(_:(UnsafeRawBufferPointer) throws -> R)
extension ContiguousArray  {
  public func withUnsafeBytes<R>(
    _ body: (UnsafeRawBufferPointer) throws -> R
  ) rethrows -> R {
    return try self.withUnsafeBufferPointer {
      try body(UnsafeRawBufferPointer($0))
    }
  }
}

----Swift.(file).Dictionary.init()
extension Dictionary {
  public init() {
    self.init(_native: _NativeDictionary())
  }
}

----Swift.(file).Dictionary.init(minimumCapacity:Int)
extension Dictionary {
  init(minimumCapacity: Int) {
    _variant = _Variant(native: _NativeDictionary(capacity: minimumCapacity))
  }
}

----Swift.(file).Dictionary.init(uniqueKeysWithValues:S)
extension Dictionary {
  public init<S: Sequence>(
    uniqueKeysWithValues keysAndValues: __owned S
  ) where S.Element == (Key, Value) {
    if let d = keysAndValues as? Dictionary<Key, Value> {
      self = d
      return
    }
    var native = _NativeDictionary<Key, Value>(
      capacity: keysAndValues.underestimatedCount)
    // '_MergeError.keyCollision' is caught and handled with an appropriate
    // error message one level down, inside native.merge(_:...). We throw an
    // error instead of calling fatalError() directly because we want the
    // message to include the duplicate key, and the closure only has access to
    // the conflicting values.
    try! native.merge(
      keysAndValues,
      isUnique: true,
      uniquingKeysWith: { _, _ in throw _MergeError.keyCollision })
    self.init(_native: native)
  }
}

----Swift.(file).Dictionary.init(_:S,uniquingKeysWith:(Value, Value) throws -> Value)
extension Dictionary {
  public init<S: Sequence>(
    _ keysAndValues: __owned S,
    uniquingKeysWith combine: (Value, Value) throws -> Value
  ) rethrows where S.Element == (Key, Value) {
    var native = _NativeDictionary<Key, Value>(
      capacity: keysAndValues.underestimatedCount)
    try native.merge(keysAndValues, isUnique: true, uniquingKeysWith: combine)
    self.init(_native: native)
  }
}

----Swift.(file).Dictionary.init(grouping:S,by:(S.Element) throws -> Key)
extension Dictionary {
  public init<S: Sequence>(
    grouping values: __owned S,
    by keyForValue: (S.Element) throws -> Key
  ) rethrows where Value == [S.Element] {
    try self.init(_native: _NativeDictionary(grouping: values, by: keyForValue))
  }
}

----Swift.(file).Dictionary.makeIterator()
extension Dictionary: Sequence  {
  public __consuming func makeIterator() -> Iterator {
    return _variant.makeIterator()
  }
}

----Swift.(file).Dictionary.filter(_:(Dictionary<Key, Value>.Element) throws -> Bool)
extension Dictionary  {
  public __consuming func filter(
    _ isIncluded: (Element) throws -> Bool
  ) rethrows -> [Key: Value] {
    // FIXME(performance): Try building a bitset of elements to keep, so that we
    // eliminate rehashings during insertion.
    var result = _NativeDictionary<Key, Value>()
    for element in self {
      if try isIncluded(element) {
        result.insertNew(key: element.key, value: element.value)
      }
    }
    return Dictionary(_native: result)
  }
}

----Swift.(file).Dictionary.startIndex
extension Dictionary: Collection  {
  public var startIndex: Index {
    return _variant.startIndex
  }
}

----Swift.(file).Dictionary.endIndex
extension Dictionary: Collection  {
  public var endIndex: Index {
    return _variant.endIndex
  }
}

----Swift.(file).Dictionary.index(after:Dictionary<Key, Value>.Index)
extension Dictionary: Collection  {
  public func index(after i: Index) -> Index {
    return _variant.index(after: i)
  }
}

----Swift.(file).Dictionary.formIndex(after:Dictionary<Key, Value>.Index)
extension Dictionary: Collection  {
  public func formIndex(after i: inout Index) {
    _variant.formIndex(after: &i)
  }
}

----Swift.(file).Dictionary.index(forKey:Key)
extension Dictionary: Collection  {
  public func index(forKey key: Key) -> Index? {
    // Complexity: amortized O(1) for native dictionary, O(*n*) when wrapping an
    // NSDictionary.
    return _variant.index(forKey: key)
  }
}

----Swift.(file).Dictionary.subscript(_:Key)
extension Dictionary: Collection  {
  public subscript(position: Index) -> Element {
    return _variant.lookup(position)
  }
}

----Swift.(file).Dictionary.count
extension Dictionary: Collection  {
  public var count: Int {
    return _variant.count
  }
}

----Swift.(file).Dictionary.isEmpty
extension Dictionary: Collection  {
  public var isEmpty: Bool {
    return count == 0
  }
}

----Swift.(file).Dictionary.subscript(_:Key)
extension Dictionary  {
  public subscript(key: Key) -> Value? {
    get {
      return _variant.lookup(key)
    }
    set(newValue) {
      if let x = newValue {
        _variant.setValue(x, forKey: key)
      } else {
        removeValue(forKey: key)
      }
    }
    _modify {
      defer { _fixLifetime(self) }
      yield &_variant[key]
    }
  }
}

----Swift.(file).Dictionary.subscript(_:Key,default:() -> Value)
extension Dictionary  {
  public subscript(
    key: Key, default defaultValue: @autoclosure () -> Value
  ) -> Value {
    @inline(__always)
    get {
      return _variant.lookup(key) ?? defaultValue()
    }
    @inline(__always)
    _modify {
      let (bucket, found) = _variant.mutatingFind(key)
      let native = _variant.asNative
      if !found {
        let value = defaultValue()
        native._insert(at: bucket, key: key, value: value)
      }
      let address = native._values + bucket.offset
      defer { _fixLifetime(self) }
      yield &address.pointee
    }
  }
}

----Swift.(file).Dictionary.mapValues(_:(Value) throws -> T)
extension Dictionary  {
  public func mapValues<T>(
    _ transform: (Value) throws -> T
  ) rethrows -> Dictionary<Key, T> {
    return try Dictionary<Key, T>(_native: _variant.mapValues(transform))
  }
}

----Swift.(file).Dictionary.compactMapValues(_:(Value) throws -> T?)
extension Dictionary  {
  public func compactMapValues<T>(
    _ transform: (Value) throws -> T?
  ) rethrows -> Dictionary<Key, T> {
    let result: _NativeDictionary<Key, T> =
      try self.reduce(into: _NativeDictionary<Key, T>()) { (result, element) in
      if let value = try transform(element.value) {
        result.insertNew(key: element.key, value: value)
      }
    }
    return Dictionary<Key, T>(_native: result)
  }
}

----Swift.(file).Dictionary.updateValue(_:Value,forKey:Key)
extension Dictionary  {
  public mutating func updateValue(
    _ value: __owned Value,
    forKey key: Key
  ) -> Value? {
    return _variant.updateValue(value, forKey: key)
  }
}

----Swift.(file).Dictionary.merge(_:S,uniquingKeysWith:(Value, Value) throws -> Value)
extension Dictionary  {
  public mutating func merge<S: Sequence>(
    _ other: __owned S,
    uniquingKeysWith combine: (Value, Value) throws -> Value
  ) rethrows where S.Element == (Key, Value) {
    try _variant.merge(other, uniquingKeysWith: combine)
  }
}

----Swift.(file).Dictionary.merge(_:[Key : Value],uniquingKeysWith:(Value, Value) throws -> Value)
extension Dictionary  {
  public mutating func merge(
    _ other: __owned [Key: Value],
    uniquingKeysWith combine: (Value, Value) throws -> Value
  ) rethrows {
    try _variant.merge(
      other.lazy.map { ($0, $1) }, uniquingKeysWith: combine)
  }
}

----Swift.(file).Dictionary.merging(_:S,uniquingKeysWith:(Value, Value) throws -> Value)
extension Dictionary  {
  public __consuming func merging<S: Sequence>(
    _ other: __owned S,
    uniquingKeysWith combine: (Value, Value) throws -> Value
  ) rethrows -> [Key: Value] where S.Element == (Key, Value) {
    var result = self
    try result._variant.merge(other, uniquingKeysWith: combine)
    return result
  }
}

----Swift.(file).Dictionary.merging(_:[Key : Value],uniquingKeysWith:(Value, Value) throws -> Value)
extension Dictionary  {
  public __consuming func merging(
    _ other: __owned [Key: Value],
    uniquingKeysWith combine: (Value, Value) throws -> Value
  ) rethrows -> [Key: Value] {
    var result = self
    try result.merge(other, uniquingKeysWith: combine)
    return result
  }
}

----Swift.(file).Dictionary.remove(at:Dictionary<Key, Value>.Index)
extension Dictionary  {
  public mutating func remove(at index: Index) -> Element {
    return _variant.remove(at: index)
  }
}

----Swift.(file).Dictionary.removeValue(forKey:Key)
extension Dictionary  {
  public mutating func removeValue(forKey key: Key) -> Value? {
    return _variant.removeValue(forKey: key)
  }
}

----Swift.(file).Dictionary.removeAll(keepingCapacity:Bool)
extension Dictionary  {
  public mutating func removeAll(keepingCapacity keepCapacity: Bool = false) {
    // The 'will not decrease' part in the documentation comment is worded very
    // carefully.  The capacity can increase if we replace Cocoa dictionary with
    // native dictionary.
    _variant.removeAll(keepingCapacity: keepCapacity)
  }
}

----Swift.(file).Dictionary.keys
extension Dictionary  {
  public var keys: Keys {
    // FIXME(accessors): Provide a _read
    get {
      return Keys(_dictionary: self)
    }
  }
}

----Swift.(file).Dictionary.values
extension Dictionary  {
  public var values: Values {
    // FIXME(accessors): Provide a _read
    get {
      return Values(_dictionary: self)
    }
    _modify {
      var values = Values(_variant: _Variant(dummy: ()))
      swap(&values._variant, &_variant)
      defer { self._variant = values._variant }
      yield &values
    }
  }
}

----Swift.(file).Dictionary.hash(into:Hasher)
extension Dictionary: Hashable where Value: Hashable  {
  public func hash(into hasher: inout Hasher) {
    var commutativeHash = 0
    for (k, v) in self {
      // Note that we use a copy of our own hasher here. This makes hash values
      // dependent on its state, eliminating static collision patterns.
      var elementHasher = hasher
      elementHasher.combine(k)
      elementHasher.combine(v)
      commutativeHash ^= elementHasher._finalize()
    }
    hasher.combine(commutativeHash)
  }
}

----Swift.(file).Dictionary.description
extension Dictionary: CustomStringConvertible, CustomDebugStringConvertible  {
  public var description: String {
    return _makeKeyValuePairDescription()
  }
}

----Swift.(file).Dictionary.debugDescription
extension Dictionary: CustomStringConvertible, CustomDebugStringConvertible  {
  public var debugDescription: String {
    return _makeKeyValuePairDescription()
  }
}

----Swift.(file).Dictionary.customMirror
extension Dictionary: CustomReflectable  {
  public var customMirror: Mirror {
    let style = Mirror.DisplayStyle.dictionary
    return Mirror(self, unlabeledChildren: self, displayStyle: style)
  }
}

----Swift.(file).Dictionary.popFirst()
extension Dictionary  {
  public mutating func popFirst() -> Element? {
    guard !isEmpty else { return nil }
    return remove(at: startIndex)
  }
}

----Swift.(file).Dictionary.capacity
extension Dictionary  {
  public var capacity: Int {
    return _variant.capacity
  }
}

----Swift.(file).Dictionary.reserveCapacity(_:Int)
extension Dictionary  {
  mutating func reserveCapacity(_ minimumCapacity: Int) {
    _variant.reserveCapacity(minimumCapacity)
    _internalInvariant(self.capacity >= minimumCapacity)
  }
}

----Swift.(file).Dictionary.init(_unsafeUninitializedCapacity:Int,allowingDuplicates:Bool,initializingWith:(UnsafeMutableBufferPointer<Key>, UnsafeMutableBufferPointer<Value>, inout Int) -> Void)
extension Dictionary  {
  init(
    _unsafeUninitializedCapacity capacity: Int,
    allowingDuplicates: Bool,
    initializingWith initializer: (
      _ keys: UnsafeMutableBufferPointer<Key>,
      _ values: UnsafeMutableBufferPointer<Value>,
      _ initializedCount: inout Int
    ) -> Void
  ) {
    self.init(_native: _NativeDictionary(
        _unsafeUninitializedCapacity: capacity,
        allowingDuplicates: allowingDuplicates,
        initializingWith: initializer))
  }
}

----Swift.(file).Iterator.next()
extension LazyDropWhileSequence.Iterator: IteratorProtocol  {
  public mutating func next() -> Element? {
    // Once the predicate has failed for the first time, the base iterator
    // can be used for the rest of the elements.
    if _predicateHasFailed {
      return _base.next()
    }

    // Retrieve and discard elements from the base iterator until one fails
    // the predicate.
    while let nextElement = _base.next() {
      if !_predicate(nextElement) {
        _predicateHasFailed = true
        return nextElement
      }
    }
    return nil
  }
}

----Swift.(file).LazyDropWhileSequence.makeIterator()
extension LazyDropWhileSequence: Sequence  {
  public __consuming func makeIterator() -> Iterator {
    return Iterator(_base: _base.makeIterator(), predicate: _predicate)
  }
}

----Swift.(file).LazySequenceProtocol.drop(while:(Self.Elements.Element) -> Bool)
extension LazySequenceProtocol  {
  public __consuming func drop(
    while predicate: @escaping (Elements.Element) -> Bool
  ) -> LazyDropWhileSequence<Self.Elements> {
    return LazyDropWhileSequence(_base: self.elements, predicate: predicate)
  }
}

----Swift.(file).LazyDropWhileSequence.startIndex
extension LazyDropWhileCollection: Collection  {
  public var startIndex: Index {
    var index = _base.startIndex
    while index != _base.endIndex && _predicate(_base[index]) {
      _base.formIndex(after: &index)
    }
    return index
  }
}

----Swift.(file).LazyDropWhileSequence.endIndex
extension LazyDropWhileCollection: Collection  {
  public var endIndex: Index {
    return _base.endIndex
  }
}

----Swift.(file).LazyDropWhileSequence.index(after:LazyDropWhileSequence<Base>.Index)
extension LazyDropWhileCollection: Collection  {
  public func index(after i: Index) -> Index {
    precondition(i < _base.endIndex, "Can't advance past endIndex")
    return _base.index(after: i)
  }
}

----Swift.(file).LazyDropWhileSequence.subscript(_:LazyDropWhileSequence<Base>.Index)
extension LazyDropWhileCollection: Collection  {
  public subscript(position: Index) -> Element {
    return _base[position]
  }
}

----Swift.(file).LazyDropWhileSequence.index(before:LazyDropWhileSequence<Base>.Index)
extension LazyDropWhileCollection: BidirectionalCollection 
where Base: BidirectionalCollection  {
  public func index(before i: Index) -> Index {
    precondition(i > startIndex, "Can't move before startIndex")
    return _base.index(before: i)
  }
}

----Swift.(file).dump(_:T,to:TargetStream,name:String?,indent:Int,maxDepth:Int,maxItems:Int)
public func dump<T, TargetStream : TextOutputStream>(
  _ value: T,
  to target: inout TargetStream,
  name: String? = nil,
  indent: Int = 0,
  maxDepth: Int = .max,
  maxItems: Int = .max
) -> T {
  var maxItemCounter = maxItems
  var visitedItems = [ObjectIdentifier : Int]()
  target._lock()
  defer { target._unlock() }
  _dump_unlocked(
    value,
    to: &target,
    name: name,
    indent: indent,
    maxDepth: maxDepth,
    maxItemCounter: &maxItemCounter,
    visitedItems: &visitedItems)
  return value
}

----Swift.(file).dump(_:T,name:String?,indent:Int,maxDepth:Int,maxItems:Int)
public func dump<T>(
  _ value: T,
  name: String? = nil,
  indent: Int = 0,
  maxDepth: Int = .max,
  maxItems: Int = .max
) -> T {
  var stdoutStream = _Stdout()
  return dump(
    value,
    to: &stdoutStream,
    name: name,
    indent: indent,
    maxDepth: maxDepth,
    maxItems: maxItems)
}

----Swift.(file).EmptyCollection.init()
extension EmptyCollection {
  public init() {}
}

----Swift.(file).Iterator.next()
extension EmptyCollection.Iterator: IteratorProtocol, Sequence  {
  public mutating func next() -> Element? {
    return nil
  }
}

----Swift.(file).EmptyCollection.makeIterator()
extension EmptyCollection: Sequence  {
  public func makeIterator() -> Iterator {
    return Iterator()
  }
}

----Swift.(file).EmptyCollection.startIndex
extension EmptyCollection: RandomAccessCollection, MutableCollection  {
  public var startIndex: Index {
    return 0
  }
}

----Swift.(file).EmptyCollection.endIndex
extension EmptyCollection: RandomAccessCollection, MutableCollection  {
  public var endIndex: Index {
    return 0
  }
}

----Swift.(file).EmptyCollection.index(after:EmptyCollection<Element>.Index)
extension EmptyCollection: RandomAccessCollection, MutableCollection  {
  public func index(after i: Index) -> Index {
    preconditionFailure("EmptyCollection can't advance indices")
  }
}

----Swift.(file).EmptyCollection.index(before:EmptyCollection<Element>.Index)
extension EmptyCollection: RandomAccessCollection, MutableCollection  {
  public func index(before i: Index) -> Index {
    preconditionFailure("EmptyCollection can't advance indices")
  }
}

----Swift.(file).EmptyCollection.subscript(_:EmptyCollection<Element>.Index)
extension EmptyCollection: RandomAccessCollection, MutableCollection  {
  public subscript(position: Index) -> Element {
    get {
      preconditionFailure("Index out of range")
    }
    set {
      preconditionFailure("Index out of range")
    }
  }
}

----Swift.(file).EmptyCollection.subscript(_:Range<EmptyCollection<Element>.Index>)
extension EmptyCollection: RandomAccessCollection, MutableCollection  {
  public subscript(bounds: Range<Index>) -> SubSequence {
    get {
      precondition(bounds.lowerBound == 0 && bounds.upperBound == 0,
        "Index out of range")
      return self
    }
    set {
      precondition(bounds.lowerBound == 0 && bounds.upperBound == 0,
        "Index out of range")
    }
  }
}

----Swift.(file).EmptyCollection.count
extension EmptyCollection: RandomAccessCollection, MutableCollection  {
  public var count: Int {
    return 0
  }
}

----Swift.(file).EmptyCollection.index(_:EmptyCollection<Element>.Index,offsetBy:Int)
extension EmptyCollection: RandomAccessCollection, MutableCollection  {
  public func index(_ i: Index, offsetBy n: Int) -> Index {
    precondition(i == startIndex && n == 0, "Index out of range")
    return i
  }
}

----Swift.(file).EmptyCollection.index(_:EmptyCollection<Element>.Index,offsetBy:Int,limitedBy:EmptyCollection<Element>.Index)
extension EmptyCollection: RandomAccessCollection, MutableCollection  {
  public func index(
    _ i: Index, offsetBy n: Int, limitedBy limit: Index
  ) -> Index? {
    precondition(i == startIndex && limit == startIndex,
      "Index out of range")
    return n == 0 ? i : nil
  }
}

----Swift.(file).EmptyCollection.distance(from:EmptyCollection<Element>.Index,to:EmptyCollection<Element>.Index)
extension EmptyCollection: RandomAccessCollection, MutableCollection  {
  public func distance(from start: Index, to end: Index) -> Int {
    precondition(start == 0, "From must be startIndex (or endIndex)")
    precondition(end == 0, "To must be endIndex (or startIndex)")
    return 0
  }
}

----Swift.(file).EmptyCollection.==infix(_:EmptyCollection<Element>,_:EmptyCollection<Element>)
extension EmptyCollection : Equatable  {
  public static func == (
    lhs: EmptyCollection<Element>, rhs: EmptyCollection<Element>
  ) -> Bool {
    return true
  }
}

----Swift.(file).Equatable.!=infix(_:Self,_:Self)
extension Equatable  {
  public static func != (lhs: Self, rhs: Self) -> Bool {
    return !(lhs == rhs)
  }
}

----Swift.(file).===infix(_:AnyObject?,_:AnyObject?)
public func === (lhs: AnyObject?, rhs: AnyObject?) -> Bool {
  switch (lhs, rhs) {
  case let (l?, r?):
    return ObjectIdentifier(l) == ObjectIdentifier(r)
  case (nil, nil):
    return true
  default:
    return false
  }
}

----Swift.(file).!==infix(_:AnyObject?,_:AnyObject?)
public func !== (lhs: AnyObject?, rhs: AnyObject?) -> Bool {
  return !(lhs === rhs)
}

----Swift.(file).LazyFilterSequence.init(_base:Base,_:(Base.Element) -> Bool)
extension LazyFilterSequence {
  init(_base base: Base, _ isIncluded: @escaping (Base.Element) -> Bool) {
    self._base = base
    self._predicate = isIncluded
  }
}

----Swift.(file).Iterator.next()
extension LazyFilterSequence.Iterator: IteratorProtocol, Sequence  {
  public mutating func next() -> Element? {
    while let n = _base.next() {
      if _predicate(n) {
        return n
      }
    }
    return nil
  }
}

----Swift.(file).LazyFilterSequence.makeIterator()
extension LazyFilterSequence: Sequence  {
  public __consuming func makeIterator() -> Iterator {
    return Iterator(_base: _base.makeIterator(), _predicate)
  }
}

----Swift.(file).LazyFilterSequence.underestimatedCount
extension LazyFilterCollection: Collection  {
  public var underestimatedCount: Int { return 0 }
}

----Swift.(file).LazyFilterSequence.startIndex
extension LazyFilterCollection: Collection  {
  public var startIndex: Index {
    var index = _base.startIndex
    while index != _base.endIndex && !_predicate(_base[index]) {
      _base.formIndex(after: &index)
    }
    return index
  }
}

----Swift.(file).LazyFilterSequence.endIndex
extension LazyFilterCollection: Collection  {
  public var endIndex: Index {
    return _base.endIndex
  }
}

----Swift.(file).LazyFilterSequence.index(after:LazyFilterSequence<Base>.Index)
extension LazyFilterCollection: Collection  {
  public func index(after i: Index) -> Index {
    var i = i
    formIndex(after: &i)
    return i
  }
}

----Swift.(file).LazyFilterSequence.formIndex(after:LazyFilterSequence<Base>.Index)
extension LazyFilterCollection: Collection  {
  public func formIndex(after i: inout Index) {
    // TODO: swift-3-indexing-model: _failEarlyRangeCheck i?
    var index = i
    precondition(index != _base.endIndex, "Can't advance past endIndex")
    repeat {
      _base.formIndex(after: &index)
    } while index != _base.endIndex && !_predicate(_base[index])
    i = index
  }
}

----Swift.(file).LazyFilterSequence.distance(from:LazyFilterSequence<Base>.Index,to:LazyFilterSequence<Base>.Index)
extension LazyFilterCollection: Collection  {
  public func distance(from start: Index, to end: Index) -> Int {
    // The following line makes sure that distance(from:to:) is invoked on the
    // _base at least once, to trigger a precondition in forward only
    // collections.
    _ = _base.distance(from: start, to: end)
    var _start: Index
    let _end: Index
    let step: Int
    if start > end {
      _start = end
      _end = start
      step = -1
    }
    else {
      _start = start
      _end = end
      step = 1
    }
    var count = 0
    while _start != _end {
      count += step
      formIndex(after: &_start)
    }
    return count
  }
}

----Swift.(file).LazyFilterSequence.index(_:LazyFilterSequence<Base>.Index,offsetBy:Int)
extension LazyFilterCollection: Collection  {
  public func index(_ i: Index, offsetBy n: Int) -> Index {
    var i = i
    let step = n.signum()
    // The following line makes sure that index(_:offsetBy:) is invoked on the
    // _base at least once, to trigger a precondition in forward only
    // collections.
    _ensureBidirectional(step: step)
    for _ in 0 ..< abs(numericCast(n)) {
      _advanceIndex(&i, step: step)
    }
    return i
  }
}

----Swift.(file).LazyFilterSequence.formIndex(_:LazyFilterSequence<Base>.Index,offsetBy:Int)
extension LazyFilterCollection: Collection  {
  public func formIndex(_ i: inout Index, offsetBy n: Int) {
    i = index(i, offsetBy: n)
  }
}

----Swift.(file).LazyFilterSequence.index(_:LazyFilterSequence<Base>.Index,offsetBy:Int,limitedBy:LazyFilterSequence<Base>.Index)
extension LazyFilterCollection: Collection  {
  public func index(
    _ i: Index, offsetBy n: Int, limitedBy limit: Index
  ) -> Index? {
    var i = i
    let step = n.signum()
    // The following line makes sure that index(_:offsetBy:limitedBy:) is
    // invoked on the _base at least once, to trigger a precondition in
    // forward only collections.
    _ensureBidirectional(step: step)
    for _ in 0 ..< abs(numericCast(n)) {
      if i == limit {
        return nil
      }
      _advanceIndex(&i, step: step)
    }
    return i
  }
}

----Swift.(file).LazyFilterSequence.formIndex(_:LazyFilterSequence<Base>.Index,offsetBy:Int,limitedBy:LazyFilterSequence<Base>.Index)
extension LazyFilterCollection: Collection  {
  public func formIndex(
    _ i: inout Index, offsetBy n: Int, limitedBy limit: Index
  ) -> Bool {
    if let advancedIndex = index(i, offsetBy: n, limitedBy: limit) {
      i = advancedIndex
      return true
    }
    i = limit
    return false
  }
}

----Swift.(file).LazyFilterSequence.subscript(_:LazyFilterSequence<Base>.Index)
extension LazyFilterCollection: Collection  {
  public subscript(position: Index) -> Element {
    return _base[position]
  }
}

----Swift.(file).LazyFilterSequence.subscript(_:Range<LazyFilterSequence<Base>.Index>)
extension LazyFilterCollection: Collection  {
  public subscript(bounds: Range<Index>) -> SubSequence {
    return SubSequence(_base: _base[bounds], _predicate)
  }
}

----Swift.(file).LazyFilterSequence.index(before:LazyFilterSequence<Base>.Index)
extension LazyFilterCollection : BidirectionalCollection
  where Base : BidirectionalCollection  {
  public func index(before i: Index) -> Index {
    var i = i
    formIndex(before: &i)
    return i
  }
}

----Swift.(file).LazyFilterSequence.formIndex(before:LazyFilterSequence<Base>.Index)
extension LazyFilterCollection : BidirectionalCollection
  where Base : BidirectionalCollection  {
  public func formIndex(before i: inout Index) {
    // TODO: swift-3-indexing-model: _failEarlyRangeCheck i?
    var index = i
    precondition(index != _base.startIndex, "Can't retreat before startIndex")
    repeat {
      _base.formIndex(before: &index)
    } while !_predicate(_base[index])
    i = index
  }
}

----Swift.(file).LazySequenceProtocol.filter(_:(Self.Elements.Element) -> Bool)
extension LazySequenceProtocol  {
  public __consuming func filter(
    _ isIncluded: @escaping (Elements.Element) -> Bool
  ) -> LazyFilterSequence<Self.Elements> {
    return LazyFilterSequence(_base: self.elements, isIncluded)
  }
}

----Swift.(file).LazyFilterSequence.filter(_:(LazyFilterSequence<Base>.Element) -> Bool)
extension LazyFilterSequence  {
  public __consuming func filter(
    _ isIncluded: @escaping (Element) -> Bool
  ) -> LazyFilterSequence<Base> {
    return LazyFilterSequence(_base: _base) {
      isIncluded($0) && self._predicate($0)
    }
  }
}

----Swift.(file).LazySequenceProtocol.flatMap(_:(Self.Elements.Element) -> SegmentOfResult)
extension LazySequenceProtocol  {
  public func flatMap<SegmentOfResult>(
    _ transform: @escaping (Elements.Element) -> SegmentOfResult
  ) -> LazySequence<
    FlattenSequence<LazyMapSequence<Elements, SegmentOfResult>>> {
    return self.map(transform).joined()
  }
}

----Swift.(file).LazySequenceProtocol.compactMap(_:(Self.Elements.Element) -> ElementOfResult?)
extension LazySequenceProtocol  {
  public func compactMap<ElementOfResult>(
    _ transform: @escaping (Elements.Element) -> ElementOfResult?
  ) -> LazyMapSequence<
    LazyFilterSequence<
      LazyMapSequence<Elements, ElementOfResult?>>,
    ElementOfResult
  > {
    return self.map(transform).filter { $0 != nil }.map { $0! }
  }
}

----Swift.(file).Iterator.next()
extension FlattenSequence.Iterator: IteratorProtocol  {
  public mutating func next() -> Element? {
    repeat {
      if _fastPath(_inner != nil) {
        let ret = _inner!.next()
        if _fastPath(ret != nil) {
          return ret
        }
      }
      let s = _base.next()
      if _slowPath(s == nil) {
        return nil
      }
      _inner = s!.makeIterator()
    }
    while true
  }
}

----Swift.(file).FlattenSequence.makeIterator()
extension FlattenSequence: Sequence  {
  public __consuming func makeIterator() -> Iterator {
    return Iterator(_base: _base.makeIterator())
  }
}

----Swift.(file).Sequence.joined()
extension Sequence where Element : Sequence  {
  public __consuming func joined() -> FlattenSequence<Self> {
    return FlattenSequence(_base: self)
  }
}

----Swift.(file).LazySequenceProtocol.joined()
extension LazySequenceProtocol where Element : Sequence  {
  public __consuming func joined() -> LazySequence<FlattenSequence<Elements>> {
    return FlattenSequence(_base: elements).lazy
  }
}

----Swift.(file).Index.==infix(_:FlattenCollection<Base>.Index,_:FlattenCollection<Base>.Index)
extension FlattenSequence.Index : Equatable where Base: Collection, Base.Element: Collection  {
  public static func == (
    lhs: FlattenCollection<Base>.Index,
    rhs: FlattenCollection<Base>.Index
  ) -> Bool {
    return lhs._outer == rhs._outer && lhs._inner == rhs._inner
  }
}

----Swift.(file).Index.<infix(_:FlattenCollection<Base>.Index,_:FlattenCollection<Base>.Index)
extension FlattenSequence.Index : Comparable where Base: Collection, Base.Element: Collection  {
  public static func < (
    lhs: FlattenCollection<Base>.Index,
    rhs: FlattenCollection<Base>.Index
  ) -> Bool {
    // FIXME: swift-3-indexing-model: tests.
    if lhs._outer != rhs._outer {
      return lhs._outer < rhs._outer
    }

    if let lhsInner = lhs._inner, let rhsInner = rhs._inner {
      return lhsInner < rhsInner
    }

    // When combined, the two conditions above guarantee that both
    // `_outer` indices are `_base.endIndex` and both `_inner` indices
    // are `nil`, since `_inner` is `nil` iff `_outer == base.endIndex`.
    precondition(lhs._inner == nil && rhs._inner == nil)

    return false
  }
}

----Swift.(file).Index.hash(into:Hasher)
extension FlattenSequence.Index : Hashable
  where Base: Collection, Base.Element: Collection, Base.Index : Hashable, Base.Element.Index : Hashable  {
  public func hash(into hasher: inout Hasher) {
    hasher.combine(_outer)
    hasher.combine(_inner)
  }
}

----Swift.(file).FlattenSequence.startIndex
extension FlattenCollection: Collection  {
  public var startIndex: Index {
    let end = _base.endIndex
    var outer = _base.startIndex
    while outer != end {
      let innerCollection = _base[outer]
      if !innerCollection.isEmpty {
        return Index(outer, innerCollection.startIndex)
      }
      _base.formIndex(after: &outer)
    }

    return endIndex
  }
}

----Swift.(file).FlattenSequence.endIndex
extension FlattenCollection: Collection  {
  public var endIndex: Index {
    return Index(_base.endIndex, nil)
  }
}

----Swift.(file).FlattenSequence.index(after:FlattenSequence<Base>.Index)
extension FlattenCollection: Collection  {
  public func index(after i: Index) -> Index {
    return _index(after: i)
  }
}

----Swift.(file).FlattenSequence.formIndex(after:FlattenSequence<Base>.Index)
extension FlattenCollection: Collection  {
  public func formIndex(after i: inout Index) {
    i = index(after: i)
  }
}

----Swift.(file).FlattenSequence.distance(from:FlattenSequence<Base>.Index,to:FlattenSequence<Base>.Index)
extension FlattenCollection: Collection  {
  public func distance(from start: Index, to end: Index) -> Int {
    // The following check makes sure that distance(from:to:) is invoked on the
    // _base at least once, to trigger a precondition in forward only
    // collections.
    if end < start {
      _ = _base.distance(from: _base.endIndex, to: _base.startIndex)
    }
    var _start: Index
    let _end: Index
    let step: Int
    if start > end {
      _start = end
      _end = start
      step = -1
    }
    else {
      _start = start
      _end = end
      step = 1
    }
    var count = 0
    while _start != _end {
      count += step
      formIndex(after: &_start)
    }
    return count
  }
}

----Swift.(file).FlattenSequence.index(_:FlattenSequence<Base>.Index,offsetBy:Int)
extension FlattenCollection: Collection  {
  public func index(_ i: Index, offsetBy n: Int) -> Index {
    var i = i
    let step = n.signum()
    _ensureBidirectional(step: step)
    for _ in 0 ..< abs(n) {
      _advanceIndex(&i, step: step)
    }
    return i
  }
}

----Swift.(file).FlattenSequence.formIndex(_:FlattenSequence<Base>.Index,offsetBy:Int)
extension FlattenCollection: Collection  {
  public func formIndex(_ i: inout Index, offsetBy n: Int) {
    i = index(i, offsetBy: n)
  }
}

----Swift.(file).FlattenSequence.index(_:FlattenSequence<Base>.Index,offsetBy:Int,limitedBy:FlattenSequence<Base>.Index)
extension FlattenCollection: Collection  {
  public func index(
    _ i: Index, offsetBy n: Int, limitedBy limit: Index
  ) -> Index? {
    var i = i
    let step = n.signum()
    // The following line makes sure that index(_:offsetBy:limitedBy:) is
    // invoked on the _base at least once, to trigger a precondition in
    // forward only collections.
    _ensureBidirectional(step: step)
    for _ in 0 ..< abs(n) {
      if i == limit {
        return nil
      }
      _advanceIndex(&i, step: step)
    }
    return i
  }
}

----Swift.(file).FlattenSequence.formIndex(_:FlattenSequence<Base>.Index,offsetBy:Int,limitedBy:FlattenSequence<Base>.Index)
extension FlattenCollection: Collection  {
  public func formIndex(
    _ i: inout Index, offsetBy n: Int, limitedBy limit: Index
  ) -> Bool {
    if let advancedIndex = index(i, offsetBy: n, limitedBy: limit) {
      i = advancedIndex
      return true
    }
    i = limit
    return false
  }
}

----Swift.(file).FlattenSequence.subscript(_:FlattenSequence<Base>.Index)
extension FlattenCollection: Collection  {
  public subscript(position: Index) -> Base.Element.Element {
    return _base[position._outer][position._inner!]
  }
}

----Swift.(file).FlattenSequence.subscript(_:Range<FlattenSequence<Base>.Index>)
extension FlattenCollection: Collection  {
  public subscript(bounds: Range<Index>) -> SubSequence {
    return Slice(base: self, bounds: bounds)
  }
}

----Swift.(file).FlattenSequence.index(before:FlattenSequence<Base>.Index)
extension FlattenCollection : BidirectionalCollection
  where Base : BidirectionalCollection, Base.Element : BidirectionalCollection  {
  public func index(before i: Index) -> Index {
    return _index(before: i)
  }
}

----Swift.(file).FlattenSequence.formIndex(before:FlattenSequence<Base>.Index)
extension FlattenCollection : BidirectionalCollection
  where Base : BidirectionalCollection, Base.Element : BidirectionalCollection  {
  public func formIndex(before i: inout Index) {
    i = index(before: i)
  }
}

----Swift.(file).FloatingPoint.radix
extension FloatingPoint {
  static var radix: Int { get }
}

----Swift.(file).FloatingPoint.nan
extension FloatingPoint {
  static var nan: Self { get }
}

----Swift.(file).FloatingPoint.signalingNaN
extension FloatingPoint {
  static var signalingNaN: Self { get }
}

----Swift.(file).FloatingPoint.infinity
extension FloatingPoint {
  static var infinity: Self { get }
}

----Swift.(file).FloatingPoint.greatestFiniteMagnitude
extension FloatingPoint {
  static var greatestFiniteMagnitude: Self { get }
}

----Swift.(file).FloatingPoint.pi
extension FloatingPoint {
  static var pi: Self { get }
}

----Swift.(file).FloatingPoint.ulp
extension FloatingPoint {
  var ulp: Self { get }
}

----Swift.(file).FloatingPoint.ulpOfOne
extension FloatingPoint {
  static var ulpOfOne: Self { get }
}

----Swift.(file).FloatingPoint.leastNormalMagnitude
extension FloatingPoint {
  static var leastNormalMagnitude: Self { get }
}

----Swift.(file).FloatingPoint.leastNonzeroMagnitude
extension FloatingPoint {
  static var leastNonzeroMagnitude: Self { get }
}

----Swift.(file).FloatingPoint.sign
extension FloatingPoint {
  var sign: FloatingPointSign { get }
}

----Swift.(file).FloatingPoint.exponent
extension FloatingPoint {
  var exponent: Exponent { get }
}

----Swift.(file).FloatingPoint.significand
extension FloatingPoint {
  var significand: Self { get }
}

----Swift.(file).FloatingPoint.nextUp
extension FloatingPoint {
  var nextUp: Self { get }
}

----Swift.(file).FloatingPoint.nextDown
extension FloatingPoint {
  var nextDown: Self { get }
}

----Swift.(file).FloatingPoint.isNormal
extension FloatingPoint {
  var isNormal: Bool { get }
}

----Swift.(file).FloatingPoint.isZero
extension FloatingPoint {
  var isZero: Bool { get }
}

----Swift.(file).FloatingPoint.isSubnormal
extension FloatingPoint {
  var isSubnormal: Bool { get }
}

----Swift.(file).FloatingPoint.isInfinite
extension FloatingPoint {
  var isInfinite: Bool { get }
}

----Swift.(file).FloatingPoint.isSignalingNaN
extension FloatingPoint {
  var isSignalingNaN: Bool { get }
}

----Swift.(file).FloatingPoint.floatingPointClass
extension FloatingPoint {
  var floatingPointClass: FloatingPointClassification { get }
}

----Swift.(file).FloatingPoint.isCanonical
extension FloatingPoint {
  var isCanonical: Bool { get }
}

----Swift.(file).FloatingPointSign.rawValue
extension FloatingPointSign {
  public var rawValue: Int {
    switch self {
    case .plus: return 0
    case .minus: return 1
    }
  }
}

----Swift.(file).FloatingPointSign.==infix(_:FloatingPointSign,_:FloatingPointSign)
extension FloatingPointSign {
  public static func ==(a: FloatingPointSign, b: FloatingPointSign) -> Bool {
    return a.rawValue == b.rawValue
  }
}

----Swift.(file).FloatingPointSign.hashValue
extension FloatingPointSign {
  public var hashValue: Int { return rawValue.hashValue }
}

----Swift.(file).FloatingPointSign.hash(into:Hasher)
extension FloatingPointSign {
  public func hash(into hasher: inout Hasher) {
    hasher.combine(rawValue)
  }
}

----Swift.(file).FloatingPoint.==infix(_:Self,_:Self)
extension FloatingPoint  {
  public static func == (lhs: Self, rhs: Self) -> Bool {
    return lhs.isEqual(to: rhs)
  }
}

----Swift.(file).FloatingPoint.<infix(_:Self,_:Self)
extension FloatingPoint  {
  public static func < (lhs: Self, rhs: Self) -> Bool {
    return lhs.isLess(than: rhs)
  }
}

----Swift.(file).FloatingPoint.<=infix(_:Self,_:Self)
extension FloatingPoint  {
  public static func <= (lhs: Self, rhs: Self) -> Bool {
    return lhs.isLessThanOrEqualTo(rhs)
  }
}

----Swift.(file).FloatingPoint.>infix(_:Self,_:Self)
extension FloatingPoint  {
  public static func > (lhs: Self, rhs: Self) -> Bool {
    return rhs.isLess(than: lhs)
  }
}

----Swift.(file).FloatingPoint.>=infix(_:Self,_:Self)
extension FloatingPoint  {
  public static func >= (lhs: Self, rhs: Self) -> Bool {
    return rhs.isLessThanOrEqualTo(lhs)
  }
}

----Swift.(file).BinaryFloatingPoint.exponentBitCount
extension BinaryFloatingPoint {
  static var exponentBitCount: Int { get }
}

----Swift.(file).BinaryFloatingPoint.significandBitCount
extension BinaryFloatingPoint {
  static var significandBitCount: Int { get }
}

----Swift.(file).BinaryFloatingPoint.exponentBitPattern
extension BinaryFloatingPoint {
  var exponentBitPattern: RawExponent { get }
}

----Swift.(file).BinaryFloatingPoint.significandBitPattern
extension BinaryFloatingPoint {
  var significandBitPattern: RawSignificand { get }
}

----Swift.(file).BinaryFloatingPoint.binade
extension BinaryFloatingPoint {
  var binade: Self { get }
}

----Swift.(file).BinaryFloatingPoint.significandWidth
extension BinaryFloatingPoint {
  var significandWidth: Int { get }
}

----Swift.(file).FloatingPoint.ulpOfOne
extension FloatingPoint  {
  public static var ulpOfOne: Self {
    return (1 as Self).ulp
  }
}

----Swift.(file).FloatingPoint.rounded(_:FloatingPointRoundingRule)
extension FloatingPoint  {
  public func rounded(_ rule: FloatingPointRoundingRule) -> Self {
    var lhs = self
    lhs.round(rule)
    return lhs
  }
}

----Swift.(file).FloatingPoint.rounded()
extension FloatingPoint  {
  public func rounded() -> Self {
    return rounded(.toNearestOrAwayFromZero)
  }
}

----Swift.(file).FloatingPoint.round()
extension FloatingPoint  {
  public mutating func round() {
    round(.toNearestOrAwayFromZero)
  }
}

----Swift.(file).FloatingPoint.nextDown
extension FloatingPoint  {
  public var nextDown: Self {
    @inline(__always)
    get {
      return -(-self).nextUp
    }
  }
}

----Swift.(file).FloatingPoint.truncatingRemainder(dividingBy:Self)
extension FloatingPoint  {
  public func truncatingRemainder(dividingBy other: Self) -> Self {
    var lhs = self
    lhs.formTruncatingRemainder(dividingBy: other)
    return lhs
  }
}

----Swift.(file).FloatingPoint.remainder(dividingBy:Self)
extension FloatingPoint  {
  public func remainder(dividingBy other: Self) -> Self {
    var lhs = self
    lhs.formRemainder(dividingBy: other)
    return lhs
  }
}

----Swift.(file).FloatingPoint.squareRoot()
extension FloatingPoint  {
  public func squareRoot( ) -> Self {
    var lhs = self
    lhs.formSquareRoot( )
    return lhs
  }
}

----Swift.(file).FloatingPoint.addingProduct(_:Self,_:Self)
extension FloatingPoint  {
  public func addingProduct(_ lhs: Self, _ rhs: Self) -> Self {
    var addend = self
    addend.addProduct(lhs, rhs)
    return addend
  }
}

----Swift.(file).FloatingPoint.minimum(_:Self,_:Self)
extension FloatingPoint  {
  public static func minimum(_ x: Self, _ y: Self) -> Self {
    if x.isSignalingNaN || y.isSignalingNaN {
      //  Produce a quiet NaN matching platform arithmetic behavior.
      return x + y
    }
    if x <= y || y.isNaN { return x }
    return y
  }
}

----Swift.(file).FloatingPoint.maximum(_:Self,_:Self)
extension FloatingPoint  {
  public static func maximum(_ x: Self, _ y: Self) -> Self {
    if x.isSignalingNaN || y.isSignalingNaN {
      //  Produce a quiet NaN matching platform arithmetic behavior.
      return x + y
    }
    if x > y || y.isNaN { return x }
    return y
  }
}

----Swift.(file).FloatingPoint.minimumMagnitude(_:Self,_:Self)
extension FloatingPoint  {
  public static func minimumMagnitude(_ x: Self, _ y: Self) -> Self {
    if x.isSignalingNaN || y.isSignalingNaN {
      //  Produce a quiet NaN matching platform arithmetic behavior.
      return x + y
    }
    if x.magnitude <= y.magnitude || y.isNaN { return x }
    return y
  }
}

----Swift.(file).FloatingPoint.maximumMagnitude(_:Self,_:Self)
extension FloatingPoint  {
  public static func maximumMagnitude(_ x: Self, _ y: Self) -> Self {
    if x.isSignalingNaN || y.isSignalingNaN {
      //  Produce a quiet NaN matching platform arithmetic behavior.
      return x + y
    }
    if x.magnitude > y.magnitude || y.isNaN { return x }
    return y
  }
}

----Swift.(file).FloatingPoint.floatingPointClass
extension FloatingPoint  {
  public var floatingPointClass: FloatingPointClassification {
    if isSignalingNaN { return .signalingNaN }
    if isNaN { return .quietNaN }
    if isInfinite { return sign == .minus ? .negativeInfinity : .positiveInfinity }
    if isNormal { return sign == .minus ? .negativeNormal : .positiveNormal }
    if isSubnormal { return sign == .minus ? .negativeSubnormal : .positiveSubnormal }
    return sign == .minus ? .negativeZero : .positiveZero
  }
}

----Swift.(file).BinaryFloatingPoint.radix
extension BinaryFloatingPoint  {
  public static var radix: Int { return 2 }
}

----Swift.(file).BinaryFloatingPoint.init(signOf:Self,magnitudeOf:Self)
extension BinaryFloatingPoint  {
  public init(signOf: Self, magnitudeOf: Self) {
    self.init(sign: signOf.sign,
      exponentBitPattern: magnitudeOf.exponentBitPattern,
      significandBitPattern: magnitudeOf.significandBitPattern)
  }
}

----Swift.(file).BinaryFloatingPoint.isTotallyOrdered(belowOrEqualTo:Self)
extension BinaryFloatingPoint  {
  public func isTotallyOrdered(belowOrEqualTo other: Self) -> Bool {
    // Quick return when possible.
    if self < other { return true }
    if other > self { return false }
    // Self and other are either equal or unordered.
    // Every negative-signed value (even NaN) is less than every positive-
    // signed value, so if the signs do not match, we simply return the
    // sign bit of self.
    if sign != other.sign { return sign == .minus }
    // Sign bits match; look at exponents.
    if exponentBitPattern > other.exponentBitPattern { return sign == .minus }
    if exponentBitPattern < other.exponentBitPattern { return sign == .plus }
    // Signs and exponents match, look at significands.
    if significandBitPattern > other.significandBitPattern {
      return sign == .minus
    }
    if significandBitPattern < other.significandBitPattern {
      return sign == .plus
    }
    //  Sign, exponent, and significand all match.
    return true
  }
}

----Swift.(file).BinaryFloatingPoint.random(in:Range<Self>,using:T)
extension BinaryFloatingPoint where Self.RawSignificand : FixedWidthInteger  {
  public static func random<T: RandomNumberGenerator>(
    in range: Range<Self>,
    using generator: inout T
  ) -> Self {
    precondition(
      !range.isEmpty,
      "Can't get random value with an empty range"
    )
    let delta = range.upperBound - range.lowerBound
    //  TODO: this still isn't quite right, because the computation of delta
    //  can overflow (e.g. if .upperBound = .maximumFiniteMagnitude and
    //  .lowerBound = -.upperBound); this should be re-written with an
    //  algorithm that handles that case correctly, but this precondition
    //  is an acceptable short-term fix.
    precondition(
      delta.isFinite,
      "There is no uniform distribution on an infinite range"
    )
    let rand: Self.RawSignificand
    if Self.RawSignificand.bitWidth == Self.significandBitCount + 1 {
      rand = generator.next()
    } else {
      let significandCount = Self.significandBitCount + 1
      let maxSignificand: Self.RawSignificand = 1 << significandCount
      // Rather than use .next(upperBound:), which has to work with arbitrary
      // upper bounds, and therefore does extra work to avoid bias, we can take
      // a shortcut because we know that maxSignificand is a power of two.
      rand = generator.next() & (maxSignificand - 1)
    }
    let unitRandom = Self.init(rand) * (Self.ulpOfOne / 2)
    let randFloat = delta * unitRandom + range.lowerBound
    if randFloat == range.upperBound {
      return Self.random(in: range, using: &generator)
    }
    return randFloat
  }
}

----Swift.(file).BinaryFloatingPoint.random(in:Range<Self>)
extension BinaryFloatingPoint where Self.RawSignificand : FixedWidthInteger  {
  public static func random(in range: Range<Self>) -> Self {
    var g = SystemRandomNumberGenerator()
    return Self.random(in: range, using: &g)
  }
}

----Swift.(file).BinaryFloatingPoint.random(in:ClosedRange<Self>,using:T)
extension BinaryFloatingPoint where Self.RawSignificand : FixedWidthInteger  {
  public static func random<T: RandomNumberGenerator>(
    in range: ClosedRange<Self>,
    using generator: inout T
  ) -> Self {
    precondition(
      !range.isEmpty,
      "Can't get random value with an empty range"
    )
    let delta = range.upperBound - range.lowerBound
    //  TODO: this still isn't quite right, because the computation of delta
    //  can overflow (e.g. if .upperBound = .maximumFiniteMagnitude and
    //  .lowerBound = -.upperBound); this should be re-written with an
    //  algorithm that handles that case correctly, but this precondition
    //  is an acceptable short-term fix.
    precondition(
      delta.isFinite,
      "There is no uniform distribution on an infinite range"
    )
    let rand: Self.RawSignificand
    if Self.RawSignificand.bitWidth == Self.significandBitCount + 1 {
      rand = generator.next()
      let tmp: UInt8 = generator.next() & 1
      if rand == Self.RawSignificand.max && tmp == 1 {
        return range.upperBound
      }
    } else {
      let significandCount = Self.significandBitCount + 1
      let maxSignificand: Self.RawSignificand = 1 << significandCount
      rand = generator.next(upperBound: maxSignificand + 1)
      if rand == maxSignificand {
        return range.upperBound
      }
    }
    let unitRandom = Self.init(rand) * (Self.ulpOfOne / 2)
    let randFloat = delta * unitRandom + range.lowerBound
    return randFloat
  }
}

----Swift.(file).BinaryFloatingPoint.random(in:ClosedRange<Self>)
extension BinaryFloatingPoint where Self.RawSignificand : FixedWidthInteger  {
  public static func random(in range: ClosedRange<Self>) -> Self {
    var g = SystemRandomNumberGenerator()
    return Self.random(in: range, using: &g)
  }
}

----Swift.(file).Hashable.hashValue
extension Hashable {
  var hashValue: Int { get }
}

----Swift.(file).Hasher.init()
extension Hasher {
  public init() {
    self._core = _Core()
  }
}

----Swift.(file).Hasher.combine(_:H)
extension Hasher {
  public mutating func combine<H: Hashable>(_ value: H) {
    value.hash(into: &self)
  }
}

----Swift.(file).Hasher.combine(bytes:UnsafeRawBufferPointer)
extension Hasher {
  public mutating func combine(bytes: UnsafeRawBufferPointer) {
    _core.combine(bytes: bytes)
  }
}

----Swift.(file).Hasher.finalize()
extension Hasher {
  public __consuming func finalize() -> Int {
    var core = _core
    return Int(truncatingIfNeeded: core.finalize())
  }
}

----Swift.(file).DefaultIndices.startIndex
extension DefaultIndices: Collection  {
  public var startIndex: Index {
    return _startIndex
  }
}

----Swift.(file).DefaultIndices.endIndex
extension DefaultIndices: Collection  {
  public var endIndex: Index {
    return _endIndex
  }
}

----Swift.(file).DefaultIndices.subscript(_:DefaultIndices<Elements>.Index)
extension DefaultIndices: Collection  {
  public subscript(i: Index) -> Elements.Index {
    // FIXME: swift-3-indexing-model: range check.
    return i
  }
}

----Swift.(file).DefaultIndices.subscript(_:Range<DefaultIndices<Elements>.Index>)
extension DefaultIndices: Collection  {
  public subscript(bounds: Range<Index>) -> DefaultIndices<Elements> {
    // FIXME: swift-3-indexing-model: range check.
    return DefaultIndices(
      _elements: _elements,
      startIndex: bounds.lowerBound,
      endIndex: bounds.upperBound)
  }
}

----Swift.(file).DefaultIndices.index(after:DefaultIndices<Elements>.Index)
extension DefaultIndices: Collection  {
  public func index(after i: Index) -> Index {
    // FIXME: swift-3-indexing-model: range check.
    return _elements.index(after: i)
  }
}

----Swift.(file).DefaultIndices.formIndex(after:DefaultIndices<Elements>.Index)
extension DefaultIndices: Collection  {
  public func formIndex(after i: inout Index) {
    // FIXME: swift-3-indexing-model: range check.
    _elements.formIndex(after: &i)
  }
}

----Swift.(file).DefaultIndices.indices
extension DefaultIndices: Collection  {
  public var indices: Indices {
    return self
  }
}

----Swift.(file).DefaultIndices.index(before:DefaultIndices<Elements>.Index)
extension DefaultIndices: BidirectionalCollection
where Elements: BidirectionalCollection  {
  public func index(before i: Index) -> Index {
    // FIXME: swift-3-indexing-model: range check.
    return _elements.index(before: i)
  }
}

----Swift.(file).DefaultIndices.formIndex(before:DefaultIndices<Elements>.Index)
extension DefaultIndices: BidirectionalCollection
where Elements: BidirectionalCollection  {
  public func formIndex(before i: inout Index) {
    // FIXME: swift-3-indexing-model: range check.
    _elements.formIndex(before: &i)
  }
}

----Swift.(file).Collection.indices
extension Collection where Indices == DefaultIndices<Self>  {
  public var indices: DefaultIndices<Self> {
    return DefaultIndices(
      _elements: self,
      startIndex: self.startIndex,
      endIndex: self.endIndex)
  }
}

----Swift.(file).readLine(strippingNewline:Bool)
public func readLine(strippingNewline: Bool = true) -> String? {
  var linePtrVar: UnsafeMutablePointer<UInt8>?
  var readBytes = swift_stdlib_readLine_stdin(&linePtrVar)
  if readBytes == -1 {
    return nil
  }
  _internalInvariant(readBytes >= 0,
    "unexpected return value from swift_stdlib_readLine_stdin")
  if readBytes == 0 {
    return ""
  }

  let linePtr = linePtrVar!
  if strippingNewline {
    // FIXME: Unicode conformance.  To fix this, we need to reimplement the
    // code we call above to get a line, since it will only stop on LF.
    //
    // <rdar://problem/20013999> Recognize Unicode newlines in readLine()
    //
    // Recognize only LF and CR+LF combinations for now.
    let cr = UInt8(ascii: "\r")
    let lf = UInt8(ascii: "\n")
    if readBytes == 1 && linePtr[0] == lf {
      return ""
    }
    if readBytes >= 2 {
      switch (linePtr[readBytes - 2], linePtr[readBytes - 1]) {
      case (cr, lf):
        readBytes -= 2
        break
      case (_, lf):
        readBytes -= 1
        break
      default:
        ()
      }
    }
  }
  let result = String._fromUTF8Repairing(
    UnsafeBufferPointer(start: linePtr, count: readBytes)).0
  _swift_stdlib_free(linePtr)
  return result
}

----Swift.(file).FixedWidthInteger.init(_:S,radix:Int)
extension FixedWidthInteger  {
  public init?<S : StringProtocol>(_ text: S, radix: Int = 10) {
    precondition(2...36 ~= radix, "Radix not in range 2...36")

    if let str = text as? String, str._guts.isFastUTF8 {
      guard let ret = str._guts.withFastUTF8 ({ utf8 -> Self? in
        var iter = utf8.makeIterator()
        return _parseASCII(codeUnits: &iter, radix: Self(radix))
      }) else {
        return nil
      }
      self = ret
      return
    }

    // TODO(String performance): We can provide fast paths for common radices,
    // native UTF-8 storage, etc.

    var iter = text.utf8.makeIterator()
    guard let ret = Self._parseASCIISlowPath(
      codeUnits: &iter, radix: Self(radix)
    ) else { return nil }

    self = ret
  }
}

----Swift.(file).FixedWidthInteger.init(_:String)
extension FixedWidthInteger  {
  public init?(_ description: String) {
    self.init(description, radix: 10)
  }
}

----Swift.(file).ExpressibleByIntegerLiteral.init(integerLiteral:Self)
extension ExpressibleByIntegerLiteral
  where Self : _ExpressibleByBuiltinIntegerLiteral  {
  public init(integerLiteral value: Self) {
    self = value
  }
}

----Swift.(file).AdditiveArithmetic.zero
extension AdditiveArithmetic {
  static var zero: Self { get }
}

----Swift.(file).AdditiveArithmetic.zero
public extension AdditiveArithmetic where Self : ExpressibleByIntegerLiteral  {
  static var zero: Self {
    return 0
  }
}

----Swift.(file).Numeric.magnitude
extension Numeric {
  var magnitude: Magnitude { get }
}

----Swift.(file).SignedNumeric.-prefix(_:Self)
extension SignedNumeric  {
  public static prefix func - (_ operand: Self) -> Self {
    var result = operand
    result.negate()
    return result
  }
}

----Swift.(file).SignedNumeric.negate()
extension SignedNumeric  {
  public mutating func negate() {
    self = 0 - self
  }
}

----Swift.(file).abs(_:T)
public func abs<T : SignedNumeric & Comparable>(_ x: T) -> T {
  if T.self == T.Magnitude.self {
    return unsafeBitCast(x.magnitude, to: T.self)
  }

  return x < (0 as T) ? -x : x
}

----Swift.(file).AdditiveArithmetic.+prefix(_:Self)
extension AdditiveArithmetic  {
  public static prefix func + (x: Self) -> Self {
    return x
  }
}

----Swift.(file).BinaryInteger.isSigned
extension BinaryInteger {
  static var isSigned: Bool { get }
}

----Swift.(file).BinaryInteger.words
extension BinaryInteger {
  var words: Words { get }
}

----Swift.(file).BinaryInteger.bitWidth
extension BinaryInteger {
  var bitWidth: Int { get }
}

----Swift.(file).BinaryInteger.trailingZeroBitCount
extension BinaryInteger {
  var trailingZeroBitCount: Int { get }
}

----Swift.(file).BinaryInteger.init()
extension BinaryInteger  {
  public init() {
    self = 0
  }
}

----Swift.(file).BinaryInteger.signum()
extension BinaryInteger  {
  public func signum() -> Self {
    return (self > (0 as Self) ? 1 : 0) - (self < (0 as Self) ? 1 : 0)
  }
}

----Swift.(file).BinaryInteger.quotientAndRemainder(dividingBy:Self)
extension BinaryInteger  {
  public func quotientAndRemainder(dividingBy rhs: Self)
    -> (quotient: Self, remainder: Self) {
    return (self / rhs, self % rhs)
  }
}

----Swift.(file).BinaryInteger.isMultiple(of:Self)
extension BinaryInteger  {
  public func isMultiple(of other: Self) -> Bool {
    // Nothing but zero is a multiple of zero.
    if other == 0 { return self == 0 }
    // Do the test in terms of magnitude, which guarantees there are no other
    // edge cases. If we write this as `self % other` instead, it could trap
    // for types that are not symmetric around zero.
    return self.magnitude % other.magnitude == 0
  }
}

----Swift.(file).BinaryInteger.&infix(_:Self,_:Self)
extension BinaryInteger  {
  public static func & (lhs: Self, rhs: Self) -> Self {
    var lhs = lhs
    lhs &= rhs
    return lhs
  }
}

----Swift.(file).BinaryInteger.|infix(_:Self,_:Self)
extension BinaryInteger  {
  public static func | (lhs: Self, rhs: Self) -> Self {
    var lhs = lhs
    lhs |= rhs
    return lhs
  }
}

----Swift.(file).BinaryInteger.^infix(_:Self,_:Self)
extension BinaryInteger  {
  public static func ^ (lhs: Self, rhs: Self) -> Self {
    var lhs = lhs
    lhs ^= rhs
    return lhs
  }
}

----Swift.(file).BinaryInteger.>>infix(_:Self,_:RHS)
extension BinaryInteger  {
  public static func >> <RHS: BinaryInteger>(lhs: Self, rhs: RHS) -> Self {
    var r = lhs
    r >>= rhs
    return r
  }
}

----Swift.(file).BinaryInteger.<<infix(_:Self,_:RHS)
extension BinaryInteger  {
  public static func << <RHS: BinaryInteger>(lhs: Self, rhs: RHS) -> Self {
    var r = lhs
    r <<= rhs
    return r
  }
}

----Swift.(file).BinaryInteger.description
extension BinaryInteger  {
  public var description: String {
    return _description(radix: 10, uppercase: false)
  }
}

----Swift.(file).BinaryInteger.distance(to:Self)
extension BinaryInteger  {
  public func distance(to other: Self) -> Int {
    if !Self.isSigned {
      if self > other {
        if let result = Int(exactly: self - other) {
          return -result
        }
      } else {
        if let result = Int(exactly: other - self) {
          return result
        }
      }
    } else {
      let isNegative = self < (0 as Self)
      if isNegative == (other < (0 as Self)) {
        if let result = Int(exactly: other - self) {
          return result
        }
      } else {
        if let result = Int(exactly: self.magnitude + other.magnitude) {
          return isNegative ? result : -result
        }
      }
    }
    preconditionFailure("Distance is not representable in Int")
  }
}

----Swift.(file).BinaryInteger.advanced(by:Int)
extension BinaryInteger  {
  public func advanced(by n: Int) -> Self {
    if !Self.isSigned {
      return n < (0 as Int)
        ? self - Self(-n)
        : self + Self(n)
    }
    if (self < (0 as Self)) == (n < (0 as Self)) {
      return self + Self(n)
    }
    return self.magnitude < n.magnitude
      ? Self(Int(self) + n)
      : self + Self(n)
  }
}

----Swift.(file).BinaryInteger.==infix(_:Self,_:Other)
extension BinaryInteger  {
  public static func == <
    Other : BinaryInteger
  >(lhs: Self, rhs: Other) -> Bool {
    let lhsNegative = Self.isSigned && lhs < (0 as Self)
    let rhsNegative = Other.isSigned && rhs < (0 as Other)

    if lhsNegative != rhsNegative { return false }

    // Here we know the values are of the same sign.
    //
    // There are a few possible scenarios from here:
    //
    // 1. Both values are negative
    //  - If one value is strictly wider than the other, then it is safe to
    //    convert to the wider type.
    //  - If the values are of the same width, it does not matter which type we
    //    choose to convert to as the values are already negative, and thus
    //    include the sign bit if two's complement representation already.
    // 2. Both values are non-negative
    //  - If one value is strictly wider than the other, then it is safe to
    //    convert to the wider type.
    //  - If the values are of the same width, than signedness matters, as not
    //    unsigned types are 'wider' in a sense they don't need to 'waste' the
    //    sign bit. Therefore it is safe to convert to the unsigned type.

    if lhs.bitWidth < rhs.bitWidth {
      return Other(truncatingIfNeeded: lhs) == rhs
    }
    if lhs.bitWidth > rhs.bitWidth {
      return lhs == Self(truncatingIfNeeded: rhs)
    }

    if Self.isSigned {
      return Other(truncatingIfNeeded: lhs) == rhs
    }
    return lhs == Self(truncatingIfNeeded: rhs)
  }
}

----Swift.(file).BinaryInteger.!=infix(_:Self,_:Other)
extension BinaryInteger  {
  public static func != <
    Other : BinaryInteger
  >(lhs: Self, rhs: Other) -> Bool {
    return !(lhs == rhs)
  }
}

----Swift.(file).BinaryInteger.<infix(_:Self,_:Other)
extension BinaryInteger  {
  public static func < <Other : BinaryInteger>(lhs: Self, rhs: Other) -> Bool {
    let lhsNegative = Self.isSigned && lhs < (0 as Self)
    let rhsNegative = Other.isSigned && rhs < (0 as Other)
    if lhsNegative != rhsNegative { return lhsNegative }

    if lhs == (0 as Self) && rhs == (0 as Other) { return false }

    // if we get here, lhs and rhs have the same sign. If they're negative,
    // then Self and Other are both signed types, and one of them can represent
    // values of the other type. Otherwise, lhs and rhs are positive, and one
    // of Self, Other may be signed and the other unsigned.

    let rhsAsSelf = Self(truncatingIfNeeded: rhs)
    let rhsAsSelfNegative = rhsAsSelf < (0 as Self)


    // Can we round-trip rhs through Other?
    if Other(truncatingIfNeeded: rhsAsSelf) == rhs &&
      // This additional check covers the `Int8.max < (128 as UInt8)` case.
      // Since the types are of the same width, init(truncatingIfNeeded:)
      // will result in a simple bitcast, so that rhsAsSelf would be -128, and
      // `lhs < rhsAsSelf` will return false.
      // We basically guard against that bitcast by requiring rhs and rhsAsSelf
      // to be the same sign.
      rhsNegative == rhsAsSelfNegative {
      return lhs < rhsAsSelf
    }

    return Other(truncatingIfNeeded: lhs) < rhs
  }
}

----Swift.(file).BinaryInteger.<=infix(_:Self,_:Other)
extension BinaryInteger  {
  public static func <= <Other : BinaryInteger>(lhs: Self, rhs: Other) -> Bool {
    return !(rhs < lhs)
  }
}

----Swift.(file).BinaryInteger.>=infix(_:Self,_:Other)
extension BinaryInteger  {
  public static func >= <Other : BinaryInteger>(lhs: Self, rhs: Other) -> Bool {
    return !(lhs < rhs)
  }
}

----Swift.(file).BinaryInteger.>infix(_:Self,_:Other)
extension BinaryInteger  {
  public static func > <Other : BinaryInteger>(lhs: Self, rhs: Other) -> Bool {
    return rhs < lhs
  }
}

----Swift.(file).BinaryInteger.!=infix(_:Self,_:Self)
extension BinaryInteger  {
  public static func != (lhs: Self, rhs: Self) -> Bool {
    return !(lhs == rhs)
  }
}

----Swift.(file).BinaryInteger.<=infix(_:Self,_:Self)
extension BinaryInteger  {
  public static func <= (lhs: Self, rhs: Self) -> Bool {
    return !(rhs < lhs)
  }
}

----Swift.(file).BinaryInteger.>=infix(_:Self,_:Self)
extension BinaryInteger  {
  public static func >= (lhs: Self, rhs: Self) -> Bool {
    return !(lhs < rhs)
  }
}

----Swift.(file).BinaryInteger.>infix(_:Self,_:Self)
extension BinaryInteger  {
  public static func > (lhs: Self, rhs: Self) -> Bool {
    return rhs < lhs
  }
}

----Swift.(file).FixedWidthInteger.bitWidth
extension FixedWidthInteger {
  static var bitWidth: Int { get }
}

----Swift.(file).FixedWidthInteger.max
extension FixedWidthInteger {
  static var max: Self { get }
}

----Swift.(file).FixedWidthInteger.min
extension FixedWidthInteger {
  static var min: Self { get }
}

----Swift.(file).FixedWidthInteger.nonzeroBitCount
extension FixedWidthInteger {
  var nonzeroBitCount: Int { get }
}

----Swift.(file).FixedWidthInteger.leadingZeroBitCount
extension FixedWidthInteger {
  var leadingZeroBitCount: Int { get }
}

----Swift.(file).FixedWidthInteger.bigEndian
extension FixedWidthInteger {
  var bigEndian: Self { get }
}

----Swift.(file).FixedWidthInteger.littleEndian
extension FixedWidthInteger {
  var littleEndian: Self { get }
}

----Swift.(file).FixedWidthInteger.byteSwapped
extension FixedWidthInteger {
  var byteSwapped: Self { get }
}

----Swift.(file).FixedWidthInteger.bitWidth
extension FixedWidthInteger  {
  public var bitWidth: Int { return Self.bitWidth }
}

----Swift.(file).FixedWidthInteger.init(littleEndian:Self)
extension FixedWidthInteger  {
  public init(littleEndian value: Self) {
#if _endian(little)
    self = value
#else
    self = value.byteSwapped
#endif
  }
}

----Swift.(file).FixedWidthInteger.init(bigEndian:Self)
extension FixedWidthInteger  {
  public init(bigEndian value: Self) {
#if _endian(big)
    self = value
#else
    self = value.byteSwapped
#endif
  }
}

----Swift.(file).FixedWidthInteger.littleEndian
extension FixedWidthInteger  {
  public var littleEndian: Self {
#if _endian(little)
    return self
#else
    return byteSwapped
#endif
  }
}

----Swift.(file).FixedWidthInteger.bigEndian
extension FixedWidthInteger  {
  public var bigEndian: Self {
#if _endian(big)
    return self
#else
    return byteSwapped
#endif
  }
}

----Swift.(file).FixedWidthInteger.&>>infix(_:Self,_:Self)
extension FixedWidthInteger  {
  public static func &>> (lhs: Self, rhs: Self) -> Self {
    var lhs = lhs
    lhs &>>= rhs
    return lhs
  }
}

----Swift.(file).FixedWidthInteger.&>>infix(_:Self,_:Other)
extension FixedWidthInteger  {
  public static func &>> <
    Other : BinaryInteger
  >(lhs: Self, rhs: Other) -> Self {
    return lhs &>> Self(truncatingIfNeeded: rhs)
  }
}

----Swift.(file).FixedWidthInteger.&>>=infix(_:Self,_:Other)
extension FixedWidthInteger  {
  public static func &>>= <
    Other : BinaryInteger
  >(lhs: inout Self, rhs: Other) {
    lhs = lhs &>> rhs
  }
}

----Swift.(file).FixedWidthInteger.&<<infix(_:Self,_:Self)
extension FixedWidthInteger  {
  public static func &<< (lhs: Self, rhs: Self) -> Self {
    var lhs = lhs
    lhs &<<= rhs
    return lhs
  }
}

----Swift.(file).FixedWidthInteger.&<<infix(_:Self,_:Other)
extension FixedWidthInteger  {
  public static func &<< <
    Other : BinaryInteger
  >(lhs: Self, rhs: Other) -> Self {
    return lhs &<< Self(truncatingIfNeeded: rhs)
  }
}

----Swift.(file).FixedWidthInteger.&<<=infix(_:Self,_:Other)
extension FixedWidthInteger  {
  public static func &<<= <
    Other : BinaryInteger
  >(lhs: inout Self, rhs: Other) {
    lhs = lhs &<< rhs
  }
}

----Swift.(file).FixedWidthInteger.random(in:Range<Self>,using:T)
extension FixedWidthInteger  {
  public static func random<T: RandomNumberGenerator>(
    in range: Range<Self>,
    using generator: inout T
  ) -> Self {
    precondition(
      !range.isEmpty,
      "Can't get random value with an empty range"
    )

    // Compute delta, the distance between the lower and upper bounds. This
    // value may not representable by the type Bound if Bound is signed, but
    // is always representable as Bound.Magnitude.
    let delta = Magnitude(truncatingIfNeeded: range.upperBound &- range.lowerBound)
    // The mathematical result we want is lowerBound plus a random value in
    // 0 ..< delta. We need to be slightly careful about how we do this
    // arithmetic; the Bound type cannot generally represent the random value,
    // so we use a wrapping addition on Bound.Magnitude. This will often
    // overflow, but produces the correct bit pattern for the result when
    // converted back to Bound.
    return Self(truncatingIfNeeded:
      Magnitude(truncatingIfNeeded: range.lowerBound) &+
      generator.next(upperBound: delta)
    )
  }
}

----Swift.(file).FixedWidthInteger.random(in:Range<Self>)
extension FixedWidthInteger  {
  public static func random(in range: Range<Self>) -> Self {
    var g = SystemRandomNumberGenerator()
    return Self.random(in: range, using: &g)
  }
}

----Swift.(file).FixedWidthInteger.random(in:ClosedRange<Self>,using:T)
extension FixedWidthInteger  {
  public static func random<T: RandomNumberGenerator>(
    in range: ClosedRange<Self>,
    using generator: inout T
  ) -> Self {
    precondition(
      !range.isEmpty,
      "Can't get random value with an empty range"
    )

    // Compute delta, the distance between the lower and upper bounds. This
    // value may not representable by the type Bound if Bound is signed, but
    // is always representable as Bound.Magnitude.
    var delta = Magnitude(truncatingIfNeeded: range.upperBound &- range.lowerBound)
    // Subtle edge case: if the range is the whole set of representable values,
    // then adding one to delta to account for a closed range will overflow.
    // If we used &+ instead, the result would be zero, which isn't helpful,
    // so we actually need to handle this case separately.
    if delta == Magnitude.max {
      return Self(truncatingIfNeeded: generator.next() as Magnitude)
    }
    // Need to widen delta to account for the right-endpoint of a closed range.
    delta += 1
    // The mathematical result we want is lowerBound plus a random value in
    // 0 ..< delta. We need to be slightly careful about how we do this
    // arithmetic; the Bound type cannot generally represent the random value,
    // so we use a wrapping addition on Bound.Magnitude. This will often
    // overflow, but produces the correct bit pattern for the result when
    // converted back to Bound.
    return Self(truncatingIfNeeded:
      Magnitude(truncatingIfNeeded: range.lowerBound) &+
      generator.next(upperBound: delta)
    )
  }
}

----Swift.(file).FixedWidthInteger.random(in:ClosedRange<Self>)
extension FixedWidthInteger  {
  public static func random(in range: ClosedRange<Self>) -> Self {
    var g = SystemRandomNumberGenerator()
    return Self.random(in: range, using: &g)
  }
}

----Swift.(file).FixedWidthInteger.~prefix(_:Self)
extension FixedWidthInteger  {
  public static prefix func ~ (x: Self) -> Self {
    return 0 &- x &- 1
  }
}

----Swift.(file).FixedWidthInteger.>>infix(_:Self,_:Other)
extension FixedWidthInteger  {
  public static func >> <
    Other : BinaryInteger
  >(lhs: Self, rhs: Other) -> Self {
    var lhs = lhs
    _nonMaskingRightShiftGeneric(&lhs, rhs)
    return lhs
  }
}

----Swift.(file).FixedWidthInteger.>>=infix(_:Self,_:Other)
extension FixedWidthInteger  {
  public static func >>= <
    Other : BinaryInteger
  >(lhs: inout Self, rhs: Other) {
    _nonMaskingRightShiftGeneric(&lhs, rhs)
  }
}

----Swift.(file).FixedWidthInteger.<<infix(_:Self,_:Other)
extension FixedWidthInteger  {
  public static func << <
    Other : BinaryInteger
  >(lhs: Self, rhs: Other) -> Self {
    var lhs = lhs
    _nonMaskingLeftShiftGeneric(&lhs, rhs)
    return lhs
  }
}

----Swift.(file).FixedWidthInteger.<<=infix(_:Self,_:Other)
extension FixedWidthInteger  {
  public static func <<= <
    Other : BinaryInteger
  >(lhs: inout Self, rhs: Other) {
    _nonMaskingLeftShiftGeneric(&lhs, rhs)
  }
}

----Swift.(file).FixedWidthInteger.init(truncatingIfNeeded:T)
extension FixedWidthInteger  {
  public init<T : BinaryInteger>(truncatingIfNeeded source: T) {
    if Self.bitWidth <= Int.bitWidth {
      self = Self(_truncatingBits: source._lowWord)
    }
    else {
      let neg = source < (0 as T)
      var result: Self = neg ? ~0 : 0
      var shift: Self = 0
      let width = Self(_truncatingBits: Self.bitWidth._lowWord)
      for word in source.words {
        guard shift < width else { break }
        // Masking shift is OK here because we have already ensured
        // that shift < Self.bitWidth. Not masking results in
        // infinite recursion.
        result ^= Self(_truncatingBits: neg ? ~word : word) &<< shift
        shift += Self(_truncatingBits: Int.bitWidth._lowWord)
      }
      self = result
    }
  }
}

----Swift.(file).FixedWidthInteger.&+infix(_:Self,_:Self)
extension FixedWidthInteger  {
  public static func &+ (lhs: Self, rhs: Self) -> Self {
    return lhs.addingReportingOverflow(rhs).partialValue
  }
}

----Swift.(file).FixedWidthInteger.&+=infix(_:Self,_:Self)
extension FixedWidthInteger  {
  public static func &+= (lhs: inout Self, rhs: Self) {
    lhs = lhs &+ rhs
  }
}

----Swift.(file).FixedWidthInteger.&-infix(_:Self,_:Self)
extension FixedWidthInteger  {
  public static func &- (lhs: Self, rhs: Self) -> Self {
    return lhs.subtractingReportingOverflow(rhs).partialValue
  }
}

----Swift.(file).FixedWidthInteger.&-=infix(_:Self,_:Self)
extension FixedWidthInteger  {
  public static func &-= (lhs: inout Self, rhs: Self) {
    lhs = lhs &- rhs
  }
}

----Swift.(file).FixedWidthInteger.&*infix(_:Self,_:Self)
extension FixedWidthInteger  {
  public static func &* (lhs: Self, rhs: Self) -> Self {
    return lhs.multipliedReportingOverflow(by: rhs).partialValue
  }
}

----Swift.(file).FixedWidthInteger.&*=infix(_:Self,_:Self)
extension FixedWidthInteger  {
  public static func &*= (lhs: inout Self, rhs: Self) {
    lhs = lhs &* rhs
  }
}

----Swift.(file).UnsignedInteger.magnitude
extension UnsignedInteger  {
  public var magnitude: Self {
    @inline(__always)
    get { return self }
  }
}

----Swift.(file).UnsignedInteger.isSigned
extension UnsignedInteger  {
  public static var isSigned: Bool {
    @inline(__always)
    get { return false }
  }
}

----Swift.(file).UnsignedInteger.init(_:T)
extension UnsignedInteger where Self : FixedWidthInteger  {
  public init<T : BinaryInteger>(_ source: T) {
    // This check is potentially removable by the optimizer
    if T.isSigned {
      precondition(source >= (0 as T), "Negative value is not representable")
    }
    // This check is potentially removable by the optimizer
    if source.bitWidth >= Self.bitWidth {
      precondition(source <= Self.max,
        "Not enough bits to represent the passed value")
    }
    self.init(truncatingIfNeeded: source)
  }
}

----Swift.(file).UnsignedInteger.init(exactly:T)
extension UnsignedInteger where Self : FixedWidthInteger  {
  public init?<T : BinaryInteger>(exactly source: T) {
    // This check is potentially removable by the optimizer
    if T.isSigned && source < (0 as T) {
      return nil
    }
    // The width check can be eliminated by the optimizer
    if source.bitWidth >= Self.bitWidth &&
       source > Self.max {
      return nil
    }
    self.init(truncatingIfNeeded: source)
  }
}

----Swift.(file).UnsignedInteger.max
extension UnsignedInteger where Self : FixedWidthInteger  {
  public static var max: Self { return ~0 }
}

----Swift.(file).UnsignedInteger.min
extension UnsignedInteger where Self : FixedWidthInteger  {
  public static var min: Self { return 0 }
}

----Swift.(file).SignedInteger.isSigned
extension SignedInteger  {
  public static var isSigned: Bool {
    @inline(__always)
    get { return true }
  }
}

----Swift.(file).SignedInteger.init(_:T)
extension SignedInteger where Self : FixedWidthInteger  {
  public init<T : BinaryInteger>(_ source: T) {
    // This check is potentially removable by the optimizer
    if T.isSigned && source.bitWidth > Self.bitWidth {
      precondition(source >= Self.min,
        "Not enough bits to represent a signed value")
    }
    // This check is potentially removable by the optimizer
    if (source.bitWidth > Self.bitWidth) ||
       (source.bitWidth == Self.bitWidth && !T.isSigned) {
      precondition(source <= Self.max,
        "Not enough bits to represent the passed value")
    }
    self.init(truncatingIfNeeded: source)
  }
}

----Swift.(file).SignedInteger.init(exactly:T)
extension SignedInteger where Self : FixedWidthInteger  {
  public init?<T : BinaryInteger>(exactly source: T) {
    // This check is potentially removable by the optimizer
    if T.isSigned && source.bitWidth > Self.bitWidth && source < Self.min {
      return nil
    }
    // The width check can be eliminated by the optimizer
    if (source.bitWidth > Self.bitWidth ||
        (source.bitWidth == Self.bitWidth && !T.isSigned)) &&
       source > Self.max {
      return nil
    }
    self.init(truncatingIfNeeded: source)
  }
}

----Swift.(file).SignedInteger.max
extension SignedInteger where Self : FixedWidthInteger  {
  public static var max: Self { return ~min }
}

----Swift.(file).SignedInteger.min
extension SignedInteger where Self : FixedWidthInteger  {
  public static var min: Self {
    return (-1 as Self) &<< Self._highBitIndex
  }
}

----Swift.(file).SignedInteger.isMultiple(of:Self)
extension SignedInteger where Self : FixedWidthInteger  {
  public func isMultiple(of other: Self) -> Bool {
    // Nothing but zero is a multiple of zero.
    if other == 0 { return self == 0 }
    // Special case to avoid overflow on .min / -1 for signed types.
    if other == -1 { return true }
    // Having handled those special cases, this is safe.
    return self % other == 0
  }
}

----Swift.(file).numericCast(_:T)
public func numericCast<T : BinaryInteger, U : BinaryInteger>(_ x: T) -> U {
  return U(x)
}

----Swift.(file).FixedWidthInteger.>>infix(_:Self,_:Self)
extension FixedWidthInteger  {
  public static func >>(lhs: Self, rhs: Self) -> Self {
    var lhs = lhs
    _nonMaskingRightShiftGeneric(&lhs, rhs)
    return lhs
  }
}

----Swift.(file).FixedWidthInteger.>>=infix(_:Self,_:Self)
extension FixedWidthInteger  {
  public static func >>=(lhs: inout Self, rhs: Self) {
    _nonMaskingRightShiftGeneric(&lhs, rhs)
  }
}

----Swift.(file).FixedWidthInteger.<<infix(_:Self,_:Self)
extension FixedWidthInteger  {
  public static func <<(lhs: Self, rhs: Self) -> Self {
    var lhs = lhs
    _nonMaskingLeftShiftGeneric(&lhs, rhs)
    return lhs
  }
}

----Swift.(file).FixedWidthInteger.<<=infix(_:Self,_:Self)
extension FixedWidthInteger  {
  public static func <<=(lhs: inout Self, rhs: Self) {
    _nonMaskingLeftShiftGeneric(&lhs, rhs)
  }
}

----Swift.(file).FixedWidthInteger.addWithOverflow(_:Self,_:Self)
extension FixedWidthInteger  {
  public static func addWithOverflow(
    _ lhs: Self, _ rhs: Self
  ) -> (Self, overflow: Bool) {
    let (partialValue, overflow) =
      lhs.addingReportingOverflow( rhs)
    return (partialValue, overflow: overflow)
  }
}

----Swift.(file).FixedWidthInteger.subtractWithOverflow(_:Self,_:Self)
extension FixedWidthInteger  {
  public static func subtractWithOverflow(
    _ lhs: Self, _ rhs: Self
  ) -> (Self, overflow: Bool) {
    let (partialValue, overflow) =
      lhs.subtractingReportingOverflow( rhs)
    return (partialValue, overflow: overflow)
  }
}

----Swift.(file).FixedWidthInteger.multiplyWithOverflow(_:Self,_:Self)
extension FixedWidthInteger  {
  public static func multiplyWithOverflow(
    _ lhs: Self, _ rhs: Self
  ) -> (Self, overflow: Bool) {
    let (partialValue, overflow) =
      lhs.multipliedReportingOverflow(by: rhs)
    return (partialValue, overflow: overflow)
  }
}

----Swift.(file).FixedWidthInteger.divideWithOverflow(_:Self,_:Self)
extension FixedWidthInteger  {
  public static func divideWithOverflow(
    _ lhs: Self, _ rhs: Self
  ) -> (Self, overflow: Bool) {
    let (partialValue, overflow) =
      lhs.dividedReportingOverflow(by: rhs)
    return (partialValue, overflow: overflow)
  }
}

----Swift.(file).FixedWidthInteger.remainderWithOverflow(_:Self,_:Self)
extension FixedWidthInteger  {
  public static func remainderWithOverflow(
    _ lhs: Self, _ rhs: Self
  ) -> (Self, overflow: Bool) {
    let (partialValue, overflow) =
      lhs.remainderReportingOverflow(dividingBy: rhs)
    return (partialValue, overflow: overflow)
  }
}

----Swift.(file).BinaryInteger.addWithOverflow(_:Self,_:Self)
extension BinaryInteger  {
  public static func addWithOverflow(
    _ lhs: Self, _ rhs: Self
  ) -> (Self, overflow: Bool) {
    fatalError("Unavailable")
  }
}

----Swift.(file).BinaryInteger.subtractWithOverflow(_:Self,_:Self)
extension BinaryInteger  {
  public static func subtractWithOverflow(
    _ lhs: Self, _ rhs: Self
  ) -> (Self, overflow: Bool) {
    fatalError("Unavailable")
  }
}

----Swift.(file).BinaryInteger.multiplyWithOverflow(_:Self,_:Self)
extension BinaryInteger  {
  public static func multiplyWithOverflow(
    _ lhs: Self, _ rhs: Self
  ) -> (Self, overflow: Bool) {
    fatalError("Unavailable")
  }
}

----Swift.(file).BinaryInteger.divideWithOverflow(_:Self,_:Self)
extension BinaryInteger  {
  public static func divideWithOverflow(
    _ lhs: Self, _ rhs: Self
  ) -> (Self, overflow: Bool) {
    fatalError("Unavailable")
  }
}

----Swift.(file).BinaryInteger.remainderWithOverflow(_:Self,_:Self)
extension BinaryInteger  {
  public static func remainderWithOverflow(
    _ lhs: Self, _ rhs: Self
  ) -> (Self, overflow: Bool) {
    fatalError("Unavailable")
  }
}

----Swift.(file).SignedInteger.&+infix(_:Self,_:Self)
extension SignedInteger  {
  public static func &+ (lhs: Self, rhs: Self) -> Self {
    return _maskingAdd(lhs, rhs)
  }
}

----Swift.(file).SignedInteger.&-infix(_:Self,_:Self)
extension SignedInteger  {
  public static func &- (lhs: Self, rhs: Self) -> Self {
    return _maskingSubtract(lhs, rhs)
  }
}

----Swift.(file).SignedInteger.&+infix(_:Self,_:Self)
extension SignedInteger where Self : FixedWidthInteger  {
  public static func &+ (lhs: Self, rhs: Self) -> Self {
    return _maskingAdd(lhs, rhs)
  }
}

----Swift.(file).SignedInteger.&-infix(_:Self,_:Self)
extension SignedInteger where Self : FixedWidthInteger  {
  public static func &- (lhs: Self, rhs: Self) -> Self {
    return _maskingSubtract(lhs, rhs)
  }
}

----Swift.(file).Iterator.next()
extension JoinedSequence.Iterator: IteratorProtocol  {
  public mutating func next() -> Element? {
    while true {
      switch _state {
      case .start:
        if let nextSubSequence = _base.next() {
          _inner = nextSubSequence.makeIterator()
          _state = .generatingElements
        } else {
          _state = .end
          return nil
        }

      case .generatingElements:
        let result = _inner!.next()
        if _fastPath(result != nil) {
          return result
        }
        _inner = _base.next()?.makeIterator()
        if _inner == nil {
          _state = .end
          return nil
        }
        if !_separatorData.isEmpty {
          _separator = _separatorData.makeIterator()
          _state = .generatingSeparator
        }

      case .generatingSeparator:
        let result = _separator!.next()
        if _fastPath(result != nil) {
          return result
        }
        _state = .generatingElements

      case .end:
        return nil
      }
    }
  }
}

----Swift.(file).JoinedSequence.makeIterator()
extension JoinedSequence: Sequence  {
  public __consuming func makeIterator() -> Iterator {
    return Iterator(base: _base.makeIterator(), separator: _separator)
  }
}

----Swift.(file).Sequence.joined(separator:Separator)
extension Sequence where Element : Sequence  {
  public __consuming func joined<Separator : Sequence>(
    separator: Separator
  ) -> JoinedSequence<Self>
    where Separator.Element == Element.Element {
    return JoinedSequence(base: self, separator: separator)
  }
}

----Swift.(file).AnyKeyPath.rootType
extension AnyKeyPath {
  public static var rootType: Any.Type {
    return _rootAndValueType.root
  }
}

----Swift.(file).AnyKeyPath.valueType
extension AnyKeyPath {
  public static var valueType: Any.Type {
    return _rootAndValueType.value
  }
}

----Swift.(file).AnyKeyPath.hashValue
extension AnyKeyPath {
  final public var hashValue: Int {
    return _hashValue(for: self)
  }
}

----Swift.(file).AnyKeyPath.hash(into:Hasher)
extension AnyKeyPath {
  final public func hash(into hasher: inout Hasher) {
    ObjectIdentifier(type(of: self)).hash(into: &hasher)
    return withBuffer {
      var buffer = $0
      if buffer.data.isEmpty { return }
      while true {
        let (component, type) = buffer.next()
        hasher.combine(component.value)
        if let type = type {
          hasher.combine(unsafeBitCast(type, to: Int.self))
        } else {
          break
        }
      }
    }
  }
}

----Swift.(file).AnyKeyPath.==infix(_:AnyKeyPath,_:AnyKeyPath)
extension AnyKeyPath {
  public static func ==(a: AnyKeyPath, b: AnyKeyPath) -> Bool {
    // Fast-path identical objects
    if a === b {
      return true
    }
    // Short-circuit differently-typed key paths
    if type(of: a) != type(of: b) {
      return false
    }
    return a.withBuffer {
      var aBuffer = $0
      return b.withBuffer {
        var bBuffer = $0
        
        // Two equivalent key paths should have the same reference prefix
        if aBuffer.hasReferencePrefix != bBuffer.hasReferencePrefix {
          return false
        }
        
        // Identity is equal to identity
        if aBuffer.data.isEmpty {
          return bBuffer.data.isEmpty
        }

        while true {
          let (aComponent, aType) = aBuffer.next()
          let (bComponent, bType) = bBuffer.next()
        
          if aComponent.header.endOfReferencePrefix
              != bComponent.header.endOfReferencePrefix
            || aComponent.value != bComponent.value
            || aType != bType {
            return false
          }
          if aType == nil {
            return true
          }
        }
      }
    }
  }
}

----Swift.(file).KeyPath.deinit()
extension KeyPath {
  deinit {
    withBuffer { $0.destroy() }
  }
}

----Swift.(file)._AppendKeyPath.appending(path:AnyKeyPath)
extension _AppendKeyPath where Self == AnyKeyPath  {
  public func appending(path: AnyKeyPath) -> AnyKeyPath? {
    return _tryToAppendKeyPaths(root: self, leaf: path)
  }
}

----Swift.(file)._AppendKeyPath.appending(path:AnyKeyPath)
extension _AppendKeyPath /* where Self == PartialKeyPath<T> */  {
  public func appending<Root>(path: AnyKeyPath) -> PartialKeyPath<Root>?
  where Self == PartialKeyPath<Root> {
    return _tryToAppendKeyPaths(root: self, leaf: path)
  }
}

----Swift.(file)._AppendKeyPath.appending(path:KeyPath<AppendedRoot, AppendedValue>)
extension _AppendKeyPath /* where Self == PartialKeyPath<T> */  {
  public func appending<Root, AppendedRoot, AppendedValue>(
    path: KeyPath<AppendedRoot, AppendedValue>
  ) -> KeyPath<Root, AppendedValue>?
  where Self == PartialKeyPath<Root> {
    return _tryToAppendKeyPaths(root: self, leaf: path)
  }
}

----Swift.(file)._AppendKeyPath.appending(path:ReferenceWritableKeyPath<AppendedRoot, AppendedValue>)
extension _AppendKeyPath /* where Self == PartialKeyPath<T> */  {
  public func appending<Root, AppendedRoot, AppendedValue>(
    path: ReferenceWritableKeyPath<AppendedRoot, AppendedValue>
  ) -> ReferenceWritableKeyPath<Root, AppendedValue>?
  where Self == PartialKeyPath<Root> {
    return _tryToAppendKeyPaths(root: self, leaf: path)
  }
}

----Swift.(file)._AppendKeyPath.appending(path:KeyPath<Value, AppendedValue>)
extension _AppendKeyPath /* where Self == KeyPath<T,U> */  {
  public func appending<Root, Value, AppendedValue>(
    path: KeyPath<Value, AppendedValue>
  ) -> KeyPath<Root, AppendedValue>
  where Self: KeyPath<Root, Value> {
    return _appendingKeyPaths(root: self, leaf: path)
  }
}

----Swift.(file)._AppendKeyPath.appending(path:ReferenceWritableKeyPath<Value, AppendedValue>)
extension _AppendKeyPath /* where Self == KeyPath<T,U> */  {
  public func appending<Root, Value, AppendedValue>(
    path: ReferenceWritableKeyPath<Value, AppendedValue>
  ) -> ReferenceWritableKeyPath<Root, AppendedValue>
  where Self == KeyPath<Root, Value> {
    return _appendingKeyPaths(root: self, leaf: path)
  }
}

----Swift.(file)._AppendKeyPath.appending(path:WritableKeyPath<Value, AppendedValue>)
extension _AppendKeyPath /* where Self == WritableKeyPath<T,U> */  {
  public func appending<Root, Value, AppendedValue>(
    path: WritableKeyPath<Value, AppendedValue>
  ) -> WritableKeyPath<Root, AppendedValue>
  where Self == WritableKeyPath<Root, Value> {
    return _appendingKeyPaths(root: self, leaf: path)
  }
}

----Swift.(file)._AppendKeyPath.appending(path:ReferenceWritableKeyPath<Value, AppendedValue>)
extension _AppendKeyPath /* where Self == WritableKeyPath<T,U> */  {
  public func appending<Root, Value, AppendedValue>(
    path: ReferenceWritableKeyPath<Value, AppendedValue>
  ) -> ReferenceWritableKeyPath<Root, AppendedValue>
  where Self == WritableKeyPath<Root, Value> {
    return _appendingKeyPaths(root: self, leaf: path)
  }
}

----Swift.(file)._AppendKeyPath.appending(path:WritableKeyPath<Value, AppendedValue>)
extension _AppendKeyPath /* where Self == ReferenceWritableKeyPath<T,U> */  {
  public func appending<Root, Value, AppendedValue>(
    path: WritableKeyPath<Value, AppendedValue>
  ) -> ReferenceWritableKeyPath<Root, AppendedValue>
  where Self == ReferenceWritableKeyPath<Root, Value> {
    return _appendingKeyPaths(root: self, leaf: path)
  }
}

----Swift.(file).KeyValuePairs.init(dictionaryLiteral:[(Key, Value)])
extension KeyValuePairs {
  public init(dictionaryLiteral elements: (Key, Value)...) {
    self._elements = elements
  }
}

----Swift.(file).KeyValuePairs.startIndex
extension KeyValuePairs : RandomAccessCollection  {
  public var startIndex: Index { return 0 }
}

----Swift.(file).KeyValuePairs.endIndex
extension KeyValuePairs : RandomAccessCollection  {
  public var endIndex: Index { return _elements.endIndex }
}

----Swift.(file).KeyValuePairs.subscript(_:KeyValuePairs<Key, Value>.Index)
extension KeyValuePairs : RandomAccessCollection  {
  public subscript(position: Index) -> Element {
    return _elements[position]
  }
}

----Swift.(file).KeyValuePairs.description
extension KeyValuePairs: CustomStringConvertible  {
  public var description: String {
    return _makeKeyValuePairDescription()
  }
}

----Swift.(file).KeyValuePairs.debugDescription
extension KeyValuePairs: CustomDebugStringConvertible  {
  public var debugDescription: String {
    return _makeKeyValuePairDescription()
  }
}

----Swift.(file).LazyCollectionProtocol.lazy
extension LazyCollectionProtocol  {
   public var lazy: LazyCollection<Elements> {		
     return elements.lazy		
   }
}

----Swift.(file).LazyCollectionProtocol.lazy
 extension LazyCollectionProtocol where Elements: LazyCollectionProtocol  {
   public var lazy: Elements {		
     return elements		
   }
}

----Swift.(file).LazySequence.startIndex
extension LazyCollection : Collection  {
  public var startIndex: Index { return _base.startIndex }
}

----Swift.(file).LazySequence.endIndex
extension LazyCollection : Collection  {
  public var endIndex: Index { return _base.endIndex }
}

----Swift.(file).LazySequence.indices
extension LazyCollection : Collection  {
  public var indices: Indices { return _base.indices }
}

----Swift.(file).LazySequence.index(after:LazySequence<Base>.Index)
extension LazyCollection : Collection  {
  public func index(after i: Index) -> Index {
    return _base.index(after: i)
  }
}

----Swift.(file).LazySequence.subscript(_:LazySequence<Base>.Index)
extension LazyCollection : Collection  {
  public subscript(position: Index) -> Element {
    return _base[position]
  }
}

----Swift.(file).LazySequence.isEmpty
extension LazyCollection : Collection  {
  public var isEmpty: Bool {
    return _base.isEmpty
  }
}

----Swift.(file).LazySequence.count
extension LazyCollection : Collection  {
  public var count: Int {
    return _base.count
  }
}

----Swift.(file).LazySequence.index(_:LazySequence<Base>.Index,offsetBy:Int)
extension LazyCollection : Collection  {
  public func index(_ i: Index, offsetBy n: Int) -> Index {
    return _base.index(i, offsetBy: n)
  }
}

----Swift.(file).LazySequence.index(_:LazySequence<Base>.Index,offsetBy:Int,limitedBy:LazySequence<Base>.Index)
extension LazyCollection : Collection  {
  public func index(
    _ i: Index, offsetBy n: Int, limitedBy limit: Index
  ) -> Index? {
    return _base.index(i, offsetBy: n, limitedBy: limit)
  }
}

----Swift.(file).LazySequence.distance(from:LazySequence<Base>.Index,to:LazySequence<Base>.Index)
extension LazyCollection : Collection  {
  public func distance(from start: Index, to end: Index) -> Int {
    return _base.distance(from:start, to: end)
  }
}

----Swift.(file).LazySequence.index(before:LazySequence<Base>.Index)
extension LazyCollection : BidirectionalCollection
  where Base : BidirectionalCollection  {
  public func index(before i: Index) -> Index {
    return _base.index(before: i)
  }
}

----Swift.(file).LazySequenceProtocol.lazy
extension LazySequenceProtocol  {
  public var lazy: LazySequence<Elements> {
    return elements.lazy
  }
}

----Swift.(file).LazySequenceProtocol.lazy
extension LazySequenceProtocol where Elements: LazySequenceProtocol  {
  public var lazy: Elements {
    return elements
  }
}

----Swift.(file).LazySequence.makeIterator()
extension LazySequence: Sequence  {
  public __consuming func makeIterator() -> Iterator {
    return _base.makeIterator()
  }
}

----Swift.(file).LazySequence.underestimatedCount
extension LazySequence: Sequence  {
  public var underestimatedCount: Int {
    return _base.underestimatedCount
  }
}

----Swift.(file).Sequence.lazy
extension Sequence  {
  public var lazy: LazySequence<Self> {
    return LazySequence(_base: self)
  }
}

----Swift.(file).withExtendedLifetime(_:T,_:() throws -> Result)
public func withExtendedLifetime<T, Result>(
  _ x: T, _ body: () throws -> Result
) rethrows -> Result {
  defer { _fixLifetime(x) }
  return try body()
}

----Swift.(file).withExtendedLifetime(_:T,_:(T) throws -> Result)
public func withExtendedLifetime<T, Result>(
  _ x: T, _ body: (T) throws -> Result
) rethrows -> Result {
  defer { _fixLifetime(x) }
  return try body(x)
}

----Swift.(file).withUnsafeMutablePointer(to:T,_:(UnsafeMutablePointer<T>) throws -> Result)
public func withUnsafeMutablePointer<T, Result>(
  to value: inout T,
  _ body: (UnsafeMutablePointer<T>) throws -> Result
) rethrows -> Result
{
  return try body(UnsafeMutablePointer<T>(Builtin.addressof(&value)))
}

----Swift.(file).withUnsafePointer(to:T,_:(UnsafePointer<T>) throws -> Result)
public func withUnsafePointer<T, Result>(
  to value: T,
  _ body: (UnsafePointer<T>) throws -> Result
) rethrows -> Result
{
  return try body(UnsafePointer<T>(Builtin.addressOfBorrow(value)))
}

----Swift.(file).withUnsafePointer(to:T,_:(UnsafePointer<T>) throws -> Result)
public func withUnsafePointer<T, Result>(
  to value: inout T,
  _ body: (UnsafePointer<T>) throws -> Result
) rethrows -> Result
{
  return try body(UnsafePointer<T>(Builtin.addressof(&value)))
}

----Swift.(file).String.withCString(_:(UnsafePointer<Int8>) throws -> Result)
extension String  {
  public func withCString<Result>(
    _ body: (UnsafePointer<Int8>) throws -> Result
  ) rethrows -> Result {
    return try _guts.withCString(body)
  }
}

----Swift.(file).ManagedBuffer.capacity
extension ManagedBuffer  {
  public final var capacity: Int {
    let storageAddr = UnsafeMutableRawPointer(Builtin.bridgeToRawPointer(self))
    let endAddr = storageAddr + _swift_stdlib_malloc_size(storageAddr)
    let realCapacity = endAddr.assumingMemoryBound(to: Element.self) -
      firstElementAddress
    return realCapacity
  }
}

----Swift.(file).ManagedBuffer.withUnsafeMutablePointerToHeader(_:(UnsafeMutablePointer<Header>) throws -> R)
extension ManagedBuffer  {
  public final func withUnsafeMutablePointerToHeader<R>(
    _ body: (UnsafeMutablePointer<Header>) throws -> R
  ) rethrows -> R {
    return try withUnsafeMutablePointers { (v, _) in return try body(v) }
  }
}

----Swift.(file).ManagedBuffer.withUnsafeMutablePointerToElements(_:(UnsafeMutablePointer<Element>) throws -> R)
extension ManagedBuffer  {
  public final func withUnsafeMutablePointerToElements<R>(
    _ body: (UnsafeMutablePointer<Element>) throws -> R
  ) rethrows -> R {
    return try withUnsafeMutablePointers { return try body($1) }
  }
}

----Swift.(file).ManagedBuffer.withUnsafeMutablePointers(_:(UnsafeMutablePointer<Header>, UnsafeMutablePointer<Element>) throws -> R)
extension ManagedBuffer  {
  public final func withUnsafeMutablePointers<R>(
    _ body: (UnsafeMutablePointer<Header>, UnsafeMutablePointer<Element>) throws -> R
  ) rethrows -> R {
    defer { _fixLifetime(self) }
    return try body(headerAddress, firstElementAddress)
  }
}

----Swift.(file).tryReallocateUniquelyReferenced(buffer:Buffer,newMinimumCapacity:Int)
public func tryReallocateUniquelyReferenced<Header, Element, Buffer: ManagedBuffer<Header, Element>>(
  buffer: inout Buffer,
  newMinimumCapacity: Int
) -> Bool {
  precondition(_isBitwiseTakable(Header.self))
  precondition(_isBitwiseTakable(Element.self))
  precondition(isKnownUniquelyReferenced(&buffer))

  let newSizeInBytes = MemoryLayout<Header>.stride
    + newMinimumCapacity * MemoryLayout<Element>.stride

  return withUnsafeMutablePointer(to: &buffer) {
    $0.withMemoryRebound(to: UnsafeMutableRawPointer.self, capacity: 1) {
      if let reallocdObject = _reallocObject($0.pointee, newSizeInBytes) {
        $0.pointee = reallocdObject
        return true
      } else {
        return false
      }
    }
  }
}

----Swift.(file).ManagedBufferPointer.init(bufferClass:AnyClass,minimumCapacity:Int,makingHeaderWith:(AnyObject, (AnyObject) -> Int) throws -> Header)
extension ManagedBufferPointer {
  public init(
    bufferClass: AnyClass,
    minimumCapacity: Int,
    makingHeaderWith factory:
      (_ buffer: AnyObject, _ capacity: (AnyObject) -> Int) throws -> Header
  ) rethrows {
    self = ManagedBufferPointer(
      bufferClass: bufferClass, minimumCapacity: minimumCapacity)

    // initialize the header field
    try withUnsafeMutablePointerToHeader {
      $0.initialize(to: 
        try factory(
          self.buffer,
          {
            ManagedBufferPointer(unsafeBufferObject: $0).capacity
          }))
    }
    // FIXME: workaround for <rdar://problem/18619176>.  If we don't
    // access header somewhere, its addressor gets linked away
    _ = header
  }
}

----Swift.(file).ManagedBufferPointer.init(unsafeBufferObject:AnyObject)
extension ManagedBufferPointer {
  public init(unsafeBufferObject buffer: AnyObject) {
    ManagedBufferPointer._checkValidBufferClass(type(of: buffer))

    self._nativeBuffer = Builtin.unsafeCastToNativeObject(buffer)
  }
}

----Swift.(file).ManagedBufferPointer.header
extension ManagedBufferPointer  {
  public var header: Header {
    _read {
      yield _headerPointer.pointee
    }
    _modify {
      yield &_headerPointer.pointee
    }
  }
}

----Swift.(file).ManagedBufferPointer.buffer
extension ManagedBufferPointer  {
  public var buffer: AnyObject {
    return Builtin.castFromNativeObject(_nativeBuffer)
  }
}

----Swift.(file).ManagedBufferPointer.capacity
extension ManagedBufferPointer  {
  public var capacity: Int {
    return (
      _capacityInBytes &- ManagedBufferPointer._elementOffset
    ) / MemoryLayout<Element>.stride
  }
}

----Swift.(file).ManagedBufferPointer.withUnsafeMutablePointerToHeader(_:(UnsafeMutablePointer<Header>) throws -> R)
extension ManagedBufferPointer  {
  public func withUnsafeMutablePointerToHeader<R>(
    _ body: (UnsafeMutablePointer<Header>) throws -> R
  ) rethrows -> R {
    return try withUnsafeMutablePointers { (v, _) in return try body(v) }
  }
}

----Swift.(file).ManagedBufferPointer.withUnsafeMutablePointerToElements(_:(UnsafeMutablePointer<Element>) throws -> R)
extension ManagedBufferPointer  {
  public func withUnsafeMutablePointerToElements<R>(
    _ body: (UnsafeMutablePointer<Element>) throws -> R
  ) rethrows -> R {
    return try withUnsafeMutablePointers { return try body($1) }
  }
}

----Swift.(file).ManagedBufferPointer.withUnsafeMutablePointers(_:(UnsafeMutablePointer<Header>, UnsafeMutablePointer<Element>) throws -> R)
extension ManagedBufferPointer  {
  public func withUnsafeMutablePointers<R>(
    _ body: (UnsafeMutablePointer<Header>, UnsafeMutablePointer<Element>) throws -> R
  ) rethrows -> R {
    defer { _fixLifetime(_nativeBuffer) }
    return try body(_headerPointer, _elementPointer)
  }
}

----Swift.(file).ManagedBufferPointer.isUniqueReference()
extension ManagedBufferPointer  {
  public mutating func isUniqueReference() -> Bool {
    return _isUnique(&_nativeBuffer)
  }
}

----Swift.(file).ManagedBufferPointer.==infix(_:ManagedBufferPointer<Header, Element>,_:ManagedBufferPointer<Header, Element>)
extension ManagedBufferPointer: Equatable  {
  public static func == (
    lhs: ManagedBufferPointer,
    rhs: ManagedBufferPointer
  ) -> Bool {
    return lhs._address == rhs._address
  }
}

----Swift.(file).isKnownUniquelyReferenced(_:T)
public func isKnownUniquelyReferenced<T : AnyObject>(_ object: inout T) -> Bool
{
  return _isUnique(&object)
}

----Swift.(file).isKnownUniquelyReferenced(_:T?)
public func isKnownUniquelyReferenced<T : AnyObject>(
  _ object: inout T?
) -> Bool {
  return _isUnique(&object)
}

----Swift.(file).Iterator.next()
extension LazyMapSequence.Iterator: IteratorProtocol, Sequence  {
  public mutating func next() -> Element? {
    return _base.next().map(_transform)
  }
}

----Swift.(file).LazyMapSequence.makeIterator()
extension LazyMapSequence: LazySequenceProtocol  {
  public __consuming func makeIterator() -> Iterator {
    return Iterator(_base: _base.makeIterator(), _transform: _transform)
  }
}

----Swift.(file).LazyMapSequence.underestimatedCount
extension LazyMapSequence: LazySequenceProtocol  {
  public var underestimatedCount: Int {
    return _base.underestimatedCount
  }
}

----Swift.(file).LazyMapSequence.startIndex
extension LazyMapCollection: Collection  {
  public var startIndex: Base.Index { return _base.startIndex }
}

----Swift.(file).LazyMapSequence.endIndex
extension LazyMapCollection: Collection  {
  public var endIndex: Base.Index { return _base.endIndex }
}

----Swift.(file).LazyMapSequence.index(after:LazyMapSequence<Base, Element>.Index)
extension LazyMapCollection: Collection  {
  public func index(after i: Index) -> Index { return _base.index(after: i) }
}

----Swift.(file).LazyMapSequence.formIndex(after:LazyMapSequence<Base, Element>.Index)
extension LazyMapCollection: Collection  {
  public func formIndex(after i: inout Index) { _base.formIndex(after: &i) }
}

----Swift.(file).LazyMapSequence.subscript(_:Base.Index)
extension LazyMapCollection: Collection  {
  public subscript(position: Base.Index) -> Element {
    return _transform(_base[position])
  }
}

----Swift.(file).LazyMapSequence.subscript(_:Range<Base.Index>)
extension LazyMapCollection: Collection  {
  public subscript(bounds: Range<Base.Index>) -> SubSequence {
    return SubSequence(_base: _base[bounds], transform: _transform)
  }
}

----Swift.(file).LazyMapSequence.indices
extension LazyMapCollection: Collection  {
  public var indices: Indices {
    return _base.indices
  }
}

----Swift.(file).LazyMapSequence.isEmpty
extension LazyMapCollection: Collection  {
  public var isEmpty: Bool { return _base.isEmpty }
}

----Swift.(file).LazyMapSequence.count
extension LazyMapCollection: Collection  {
  public var count: Int {
    return _base.count
  }
}

----Swift.(file).LazyMapSequence.index(_:LazyMapSequence<Base, Element>.Index,offsetBy:Int)
extension LazyMapCollection: Collection  {
  public func index(_ i: Index, offsetBy n: Int) -> Index {
    return _base.index(i, offsetBy: n)
  }
}

----Swift.(file).LazyMapSequence.index(_:LazyMapSequence<Base, Element>.Index,offsetBy:Int,limitedBy:LazyMapSequence<Base, Element>.Index)
extension LazyMapCollection: Collection  {
  public func index(
    _ i: Index, offsetBy n: Int, limitedBy limit: Index
  ) -> Index? {
    return _base.index(i, offsetBy: n, limitedBy: limit)
  }
}

----Swift.(file).LazyMapSequence.distance(from:LazyMapSequence<Base, Element>.Index,to:LazyMapSequence<Base, Element>.Index)
extension LazyMapCollection: Collection  {
  public func distance(from start: Index, to end: Index) -> Int {
    return _base.distance(from: start, to: end)
  }
}

----Swift.(file).LazyMapSequence.index(before:LazyMapSequence<Base, Element>.Index)
extension LazyMapCollection : BidirectionalCollection
  where Base : BidirectionalCollection  {
  public func index(before i: Index) -> Index { return _base.index(before: i) }
}

----Swift.(file).LazyMapSequence.formIndex(before:LazyMapSequence<Base, Element>.Index)
extension LazyMapCollection : BidirectionalCollection
  where Base : BidirectionalCollection  {
  public func formIndex(before i: inout Index) {
    _base.formIndex(before: &i)
  }
}

----Swift.(file).LazySequenceProtocol.map(_:(Self.Element) -> U)
extension LazySequenceProtocol  {
  public func map<U>(
    _ transform: @escaping (Element) -> U
  ) -> LazyMapSequence<Elements, U> {
    return LazyMapSequence(_base: elements, transform: transform)
  }
}

----Swift.(file).LazyMapSequence.map(_:(Element) -> ElementOfResult)
extension LazyMapSequence  {
  public func map<ElementOfResult>(
    _ transform: @escaping (Element) -> ElementOfResult
  ) -> LazyMapSequence<Base, ElementOfResult> {
    return LazyMapSequence<Base, ElementOfResult>(
      _base: _base,
      transform: { transform(self._transform($0)) })
  }
}

----Swift.(file).LazyMapSequence.map(_:(Element) -> ElementOfResult)
extension LazyMapCollection  {
  public func map<ElementOfResult>(
    _ transform: @escaping (Element) -> ElementOfResult
  ) -> LazyMapCollection<Base, ElementOfResult> {
    return LazyMapCollection<Base, ElementOfResult>(
      _base: _base,
      transform: {transform(self._transform($0))})
  }
}

----Swift.(file).MemoryLayout.size
extension MemoryLayout {
  public static var size: Int {
    return Int(Builtin.sizeof(T.self))
  }
}

----Swift.(file).MemoryLayout.stride
extension MemoryLayout {
  public static var stride: Int {
    return Int(Builtin.strideof(T.self))
  }
}

----Swift.(file).MemoryLayout.alignment
extension MemoryLayout {
  public static var alignment: Int {
    return Int(Builtin.alignof(T.self))
  }
}

----Swift.(file).MemoryLayout.size(ofValue:T)
extension MemoryLayout  {
  public static func size(ofValue value: T) -> Int {
    return MemoryLayout.size
  }
}

----Swift.(file).MemoryLayout.stride(ofValue:T)
extension MemoryLayout  {
  public static func stride(ofValue value: T) -> Int {
    return MemoryLayout.stride
  }
}

----Swift.(file).MemoryLayout.alignment(ofValue:T)
extension MemoryLayout  {
  public static func alignment(ofValue value: T) -> Int {
    return MemoryLayout.alignment
  }
}

----Swift.(file).MemoryLayout.offset(of:PartialKeyPath<T>)
extension MemoryLayout  {
  public static func offset(of key: PartialKeyPath<T>) -> Int? {
    return key._storedInlineOffset
  }
}

----Swift.(file).Range.init(_:Range<Bound>)
extension Range where Bound: Strideable, Bound.Stride : SignedInteger  {
  public init(_ other: Range<Bound>) {
    self = other
  }
}

----Swift.(file).ClosedRange.init(_:ClosedRange<Bound>)
extension ClosedRange where Bound: Strideable, Bound.Stride : SignedInteger  {
  public init(_ other: ClosedRange<Bound>) {
    self = other
  }
}

----Swift.(file).LazySequenceProtocol.flatMap(_:(Self.Elements.Element) -> ElementOfResult?)
extension LazySequenceProtocol  {
  public func flatMap<ElementOfResult>(
    _ transform: @escaping (Elements.Element) -> ElementOfResult?
  ) -> LazyMapSequence<
    LazyFilterSequence<
      LazyMapSequence<Elements, ElementOfResult?>>,
    ElementOfResult
  > {
    return self.compactMap(transform)
  }
}

----Swift.(file).String.characters
extension String  {
  public var characters: String {
    get { return self }
    set { self = newValue }
  }
}

----Swift.(file).String.withMutableCharacters(_:(inout String) -> R)
extension String  {
  public mutating func withMutableCharacters<R>(
    _ body: (inout String) -> R
  ) -> R {
    return body(&self)
  }
}

----Swift.(file).UnicodeScalarView.customPlaygroundQuickLook
extension String.UnicodeScalarView : _CustomPlaygroundQuickLookable  {
  public var customPlaygroundQuickLook: _PlaygroundQuickLook {
    return .text(description)
  }
}

----Swift.(file).UnicodeScalarView.subscript(_:Range<String.UnicodeScalarView.Index>)
extension String.UnicodeScalarView  {
  public subscript(bounds: Range<Index>) -> String.UnicodeScalarView {
    Builtin.unreachable()
  }
}

----Swift.(file).UnicodeScalarView.subscript(_:ClosedRange<String.UnicodeScalarView.Index>)
extension String.UnicodeScalarView  {
  public subscript(bounds: ClosedRange<Index>) -> String.UnicodeScalarView {
    Builtin.unreachable()
  }
}

----Swift.(file).UTF16View.customPlaygroundQuickLook
extension String.UTF16View : _CustomPlaygroundQuickLookable  {
  public var customPlaygroundQuickLook: _PlaygroundQuickLook {
    return .text(description)
  }
}

----Swift.(file).UTF8View.customPlaygroundQuickLook
extension String.UTF8View : _CustomPlaygroundQuickLookable  {
  public var customPlaygroundQuickLook: _PlaygroundQuickLook {
    return .text(description)
  }
}

----Swift.(file).Substring.characters
extension Substring  {
  public var characters: Substring {
    get {
      return self
    }
    set {
      self = newValue
    }
  }
}

----Swift.(file).Substring.withMutableCharacters(_:(inout Substring) -> R)
extension Substring  {
  public mutating func withMutableCharacters<R>(
    _ body: (inout Substring) -> R
  ) -> R {
    return body(&self)
  }
}

----Swift.(file).Substring.subscript(_:ClosedRange<Substring.Index>)
extension Substring  {
  public subscript(bounds: ClosedRange<Index>) -> String {
    Builtin.unreachable()
  }
}

----Swift.(file).Substring.customPlaygroundQuickLook
extension Substring : _CustomPlaygroundQuickLookable  {
  public var customPlaygroundQuickLook: _PlaygroundQuickLook {
    return String(self).customPlaygroundQuickLook
  }
}

----Swift.(file).Collection.index(_:Self.Index,offsetBy:T)
extension Collection  {
  public func index<T: BinaryInteger>(_ i: Index, offsetBy n: T) -> Index {
    return index(i, offsetBy: Int(n))
  }
}

----Swift.(file).Collection.formIndex(_:Self.Index,offsetBy:T)
extension Collection  {
  public func formIndex<T: BinaryInteger>(_ i: inout Index, offsetBy n: T) {
    return formIndex(&i, offsetBy: Int(n))
  }
}

----Swift.(file).Collection.index(_:Self.Index,offsetBy:T,limitedBy:Self.Index)
extension Collection  {
  public func index<T: BinaryInteger>(_ i: Index, offsetBy n: T, limitedBy limit: Index) -> Index? {
    return index(i, offsetBy: Int(n), limitedBy: limit)
  }
}

----Swift.(file).Collection.formIndex(_:Self.Index,offsetBy:T,limitedBy:Self.Index)
extension Collection  {
  public func formIndex<T: BinaryInteger>(_ i: inout Index, offsetBy n: T, limitedBy limit: Index) -> Bool {
    return formIndex(&i, offsetBy: Int(n), limitedBy: limit)
  }
}

----Swift.(file).Collection.distance(from:Self.Index,to:Self.Index)
extension Collection  {
  public func distance<T: BinaryInteger>(from start: Index, to end: Index) -> T {
    return numericCast(distance(from: start, to: end) as Int)
  }
}

----Swift.(file).UnsafeMutablePointer.initialize(to:Pointee,count:Int)
extension UnsafeMutablePointer  {
  public func initialize(to newValue: Pointee, count: Int = 1) { 
    initialize(repeating: newValue, count: count)
  }
}

----Swift.(file).UnsafeMutablePointer.deinitialize()
extension UnsafeMutablePointer  {
  public func deinitialize() -> UnsafeMutableRawPointer {
    return deinitialize(count: 1)
  }
}

----Swift.(file).UnsafeMutablePointer.deallocate(capacity:Int)
extension UnsafeMutablePointer  {
  public func deallocate(capacity _: Int) { 
    self.deallocate()
  }
}

----Swift.(file).UnsafeMutablePointer.initialize(from:C)
extension UnsafeMutablePointer  {
  public func initialize<C : Collection>(from source: C)
    where C.Element == Pointee {
    let buf = UnsafeMutableBufferPointer(start: self, count: numericCast(source.count))
    var (remainders,writtenUpTo) = source._copyContents(initializing: buf)
    // ensure that exactly rhs.count elements were written
    precondition(remainders.next() == nil, "rhs underreported its count")
    precondition(writtenUpTo == buf.endIndex, "rhs overreported its count")
  }
}

----Swift.(file).UnsafeMutableRawPointer.init(_:UnsafeRawPointer)
extension UnsafeMutableRawPointer  {
  public init(_ from : UnsafeRawPointer) { Builtin.unreachable() }
}

----Swift.(file).UnsafeRawPointer.customPlaygroundQuickLook
extension UnsafeRawPointer : _CustomPlaygroundQuickLookable  {
  public var customPlaygroundQuickLook: _PlaygroundQuickLook {
    return .text(summary)
  }
}

----Swift.(file).UnsafeMutableRawPointer.customPlaygroundQuickLook
extension UnsafeMutableRawPointer : _CustomPlaygroundQuickLookable  {
  public var customPlaygroundQuickLook: _PlaygroundQuickLook {
    return .text(summary)
  }
}

----Swift.(file).UnsafePointer.customPlaygroundQuickLook
extension UnsafePointer: _CustomPlaygroundQuickLookable  {
  public var customPlaygroundQuickLook: PlaygroundQuickLook {
    return .text(summary)
  }
}

----Swift.(file).UnsafeMutablePointer.customPlaygroundQuickLook
extension UnsafeMutablePointer: _CustomPlaygroundQuickLookable  {
  public var customPlaygroundQuickLook: PlaygroundQuickLook {
    return .text(summary)
  }
}

----Swift.(file).UnsafeMutableRawPointer.allocate(bytes:Int,alignedTo:Int)
extension UnsafeMutableRawPointer  {
  public static func allocate(
    bytes size: Int, alignedTo alignment: Int
  ) -> UnsafeMutableRawPointer {
    return UnsafeMutableRawPointer.allocate(byteCount: size, alignment: alignment)
  }
}

----Swift.(file).UnsafeMutableRawPointer.deallocate(bytes:Int,alignedTo:Int)
extension UnsafeMutableRawPointer  {
  public func deallocate(bytes _: Int, alignedTo _: Int) { 
    self.deallocate()
  }
}

----Swift.(file).UnsafeMutableRawPointer.copyBytes(from:UnsafeRawPointer,count:Int)
extension UnsafeMutableRawPointer  {
  public func copyBytes(from source: UnsafeRawPointer, count: Int) {
    copyMemory(from: source, byteCount: count)
  }
}

----Swift.(file).UnsafeMutableRawPointer.initializeMemory(as:T.Type,at:Int,count:Int,to:T)
extension UnsafeMutableRawPointer  {
  public func initializeMemory<T>(
    as type: T.Type, at offset: Int = 0, count: Int = 1, to repeatedValue: T
  ) -> UnsafeMutablePointer<T> { 
    return (self + offset * MemoryLayout<T>.stride).initializeMemory(
      as: type, repeating: repeatedValue, count: count)
  }
}

----Swift.(file).UnsafeMutableRawPointer.initializeMemory(as:C.Element.Type,from:C)
extension UnsafeMutableRawPointer  {
  public func initializeMemory<C : Collection>(
    as type: C.Element.Type, from source: C
  ) -> UnsafeMutablePointer<C.Element> {
    // TODO: Optimize where `C` is a `ContiguousArrayBuffer`.
    // Initialize and bind each element of the container.
    var ptr = self
    for element in source {
      ptr.initializeMemory(as: C.Element.self, repeating: element, count: 1)
      ptr += MemoryLayout<C.Element>.stride
    }
    return UnsafeMutablePointer(_rawValue)
  }
}

----Swift.(file).UnsafeMutableRawBufferPointer.allocate(count:Int)
extension UnsafeMutableRawBufferPointer  {
  public static func allocate(count: Int) -> UnsafeMutableRawBufferPointer { 
    return UnsafeMutableRawBufferPointer.allocate(
      byteCount: count, alignment: MemoryLayout<UInt>.alignment)
  }
}

----Swift.(file).UnsafeMutableRawBufferPointer.copyBytes(from:UnsafeRawBufferPointer)
extension UnsafeMutableRawBufferPointer  {
  public func copyBytes(from source: UnsafeRawBufferPointer) {
    copyMemory(from: source)
  }
}

----Swift.(file).Sequence.flatMap(_:(Self.Element) throws -> ElementOfResult?)
extension Sequence  {
  public func flatMap<ElementOfResult>(
    _ transform: (Element) throws -> ElementOfResult?
  ) rethrows -> [ElementOfResult] {
    return try _compactMap(transform)
  }
}

----Swift.(file).Sequence.flatMap(_:(Self.Element) throws -> String)
extension Sequence  {
  public func flatMap(
    _ transform: (Element) throws -> String
  ) rethrows -> [String] {
    return try map(transform)
  }
}

----Swift.(file).Collection.flatMap(_:(Self.Element) throws -> String?)
extension Collection  {
  public func flatMap(
    _ transform: (Element) throws -> String?
  ) rethrows -> [String] {
    return try _compactMap(transform)
  }
}

----Swift.(file).Collection.index(where:(Self.Element) throws -> Bool)
extension Collection  {
  public func index(
    where _predicate: (Element) throws -> Bool
  ) rethrows -> Index? {
    return try firstIndex(where: _predicate)
  }
}

----Swift.(file).Collection.index(of:Self.Element)
extension Collection where Element: Equatable  {
  public func index(of element: Element) -> Index? {
    return firstIndex(of: element)
  }
}

----Swift.(file)._PlaygroundQuickLook.init(reflecting:Any)
extension _PlaygroundQuickLook  {
  public init(reflecting subject: Any) {
    if let customized = subject as? _CustomPlaygroundQuickLookable {
      self = customized.customPlaygroundQuickLook
    }
    else if let customized = subject as? __DefaultCustomPlaygroundQuickLookable {
      self = customized._defaultCustomPlaygroundQuickLook
    }
    else {
      if let q = Mirror.quickLookObject(subject) {
        self = q
      }
      else {
        self = .text(String(reflecting: subject))
      }
    }
  }
}

----Swift.(file).MutableCollection.subscript(_:Self.Index)
extension MutableCollection {
  override subscript(position: Index) -> Element { get set }
}

----Swift.(file).MutableCollection.subscript(_:Range<Self.Index>)
extension MutableCollection {
  override subscript(bounds: Range<Index>) -> SubSequence { get set }
}

----Swift.(file).MutableCollection.withContiguousMutableStorageIfAvailable(_:(inout UnsafeMutableBufferPointer<Self.Element>) throws -> R)
extension MutableCollection  {
  public mutating func withContiguousMutableStorageIfAvailable<R>(
    _ body: (inout UnsafeMutableBufferPointer<Element>) throws -> R
  ) rethrows -> R? {
    return nil
  }
}

----Swift.(file).MutableCollection.subscript(_:Range<Self.Index>)
extension MutableCollection  {
  public subscript(bounds: Range<Index>) -> Slice<Self> {
    get {
      _failEarlyRangeCheck(bounds, bounds: startIndex..<endIndex)
      return Slice(base: self, bounds: bounds)
    }
    set {
      _writeBackMutableSlice(&self, bounds: bounds, slice: newValue)
    }
  }
}

----Swift.(file).MutableCollection.swapAt(_:Self.Index,_:Self.Index)
extension MutableCollection  {
  public mutating func swapAt(_ i: Index, _ j: Index) {
    guard i != j else { return }
    let tmp = self[i]
    self[i] = self[j]
    self[j] = tmp
  }
}

----Swift.(file).swap(_:T,_:T)
public func swap<T>(_ a: inout T, _ b: inout T) {
  // Semantically equivalent to (a, b) = (b, a).
  // Microoptimized to avoid retain/release traffic.
  let p1 = Builtin.addressof(&a)
  let p2 = Builtin.addressof(&b)
  precondition(
    p1 != p2,
    "swapping a location with itself is not supported")

  // Take from P1.
  let tmp: T = Builtin.take(p1)
  // Transfer P2 into P1.
  Builtin.initialize(Builtin.take(p2) as T, p1)
  // Initialize P2.
  Builtin.initialize(tmp, p2)
}

----Swift.(file)._SwiftNewtypeWrapper.hashValue
extension _SwiftNewtypeWrapper where Self: Hashable, Self.RawValue: Hashable  {
  public var hashValue: Int {
    return rawValue.hashValue
  }
}

----Swift.(file)._SwiftNewtypeWrapper.hash(into:Hasher)
extension _SwiftNewtypeWrapper where Self: Hashable, Self.RawValue: Hashable  {
  public func hash(into hasher: inout Hasher) {
    hasher.combine(rawValue)
  }
}

----Swift.(file).ObjectIdentifier.init(_:AnyObject)
extension ObjectIdentifier {
  public init(_ x: AnyObject) {
    self._value = Builtin.bridgeToRawPointer(x)
  }
}

----Swift.(file).ObjectIdentifier.init(_:Any.Type)
extension ObjectIdentifier {
  public init(_ x: Any.Type) {
    self._value = unsafeBitCast(x, to: Builtin.RawPointer.self)
  }
}

----Swift.(file).ObjectIdentifier.debugDescription
extension ObjectIdentifier : CustomDebugStringConvertible  {
  public var debugDescription: String {
    return "ObjectIdentifier(\(_rawPointerToString(_value)))"
  }
}

----Swift.(file).ObjectIdentifier.==infix(_:ObjectIdentifier,_:ObjectIdentifier)
extension ObjectIdentifier: Equatable  {
  public static func == (x: ObjectIdentifier, y: ObjectIdentifier) -> Bool {
    return Bool(Builtin.cmp_eq_RawPointer(x._value, y._value))
  }
}

----Swift.(file).ObjectIdentifier.<infix(_:ObjectIdentifier,_:ObjectIdentifier)
extension ObjectIdentifier: Comparable  {
  public static func < (lhs: ObjectIdentifier, rhs: ObjectIdentifier) -> Bool {
    return UInt(bitPattern: lhs) < UInt(bitPattern: rhs)
  }
}

----Swift.(file).ObjectIdentifier.hash(into:Hasher)
extension ObjectIdentifier: Hashable  {
  public func hash(into hasher: inout Hasher) {
    hasher.combine(Int(Builtin.ptrtoint_Word(_value)))
  }
}

----Swift.(file).UInt.init(bitPattern:ObjectIdentifier)
extension UInt  {
  public init(bitPattern objectID: ObjectIdentifier) {
    self.init(Builtin.ptrtoint_Word(objectID._value))
  }
}

----Swift.(file).Int.init(bitPattern:ObjectIdentifier)
extension Int  {
  public init(bitPattern objectID: ObjectIdentifier) {
    self.init(bitPattern: UInt(bitPattern: objectID))
  }
}

----Swift.(file).OptionSet.union(_:Self)
extension OptionSet  {
  public func union(_ other: Self) -> Self {
    var r: Self = Self(rawValue: self.rawValue)
    r.formUnion(other)
    return r
  }
}

----Swift.(file).OptionSet.intersection(_:Self)
extension OptionSet  {
  public func intersection(_ other: Self) -> Self {
    var r = Self(rawValue: self.rawValue)
    r.formIntersection(other)
    return r
  }
}

----Swift.(file).OptionSet.symmetricDifference(_:Self)
extension OptionSet  {
  public func symmetricDifference(_ other: Self) -> Self {
    var r = Self(rawValue: self.rawValue)
    r.formSymmetricDifference(other)
    return r
  }
}

----Swift.(file).OptionSet.contains(_:Self)
extension OptionSet where Element == Self  {
  public func contains(_ member: Self) -> Bool {
    return self.isSuperset(of: member)
  }
}

----Swift.(file).OptionSet.insert(_:Self.Element)
extension OptionSet where Element == Self  {
  public mutating func insert(
    _ newMember: Element
  ) -> (inserted: Bool, memberAfterInsert: Element) {
    let oldMember = self.intersection(newMember)
    let shouldInsert = oldMember != newMember
    let result = (
      inserted: shouldInsert,
      memberAfterInsert: shouldInsert ? newMember : oldMember)
    if shouldInsert {
      self.formUnion(newMember)
    }
    return result
  }
}

----Swift.(file).OptionSet.remove(_:Self.Element)
extension OptionSet where Element == Self  {
  public mutating func remove(_ member: Element) -> Element? {
    let r = isSuperset(of: member) ? Optional(member) : nil
    self.subtract(member)
    return r
  }
}

----Swift.(file).OptionSet.update(with:Self.Element)
extension OptionSet where Element == Self  {
  public mutating func update(with newMember: Element) -> Element? {
    let r = self.intersection(newMember)
    self.formUnion(newMember)
    return r.isEmpty ? nil : r
  }
}

----Swift.(file).OptionSet.init()
extension OptionSet where RawValue : FixedWidthInteger  {
  public init() {
    self.init(rawValue: 0)
  }
}

----Swift.(file).OptionSet.formUnion(_:Self)
extension OptionSet where RawValue : FixedWidthInteger  {
  public mutating func formUnion(_ other: Self) {
    self = Self(rawValue: self.rawValue | other.rawValue)
  }
}

----Swift.(file).OptionSet.formIntersection(_:Self)
extension OptionSet where RawValue : FixedWidthInteger  {
  public mutating func formIntersection(_ other: Self) {
    self = Self(rawValue: self.rawValue & other.rawValue)
  }
}

----Swift.(file).OptionSet.formSymmetricDifference(_:Self)
extension OptionSet where RawValue : FixedWidthInteger  {
  public mutating func formSymmetricDifference(_ other: Self) {
    self = Self(rawValue: self.rawValue ^ other.rawValue)
  }
}

----Swift.(file).Optional.init(_:Wrapped)
extension Optional {
  public init(_ some: Wrapped) { self = .some(some) }
}

----Swift.(file).Optional.map(_:(Wrapped) throws -> U)
extension Optional {
  public func map<U>(
    _ transform: (Wrapped) throws -> U
  ) rethrows -> U? {
    switch self {
    case .some(let y):
      return .some(try transform(y))
    case .none:
      return .none
    }
  }
}

----Swift.(file).Optional.flatMap(_:(Wrapped) throws -> U?)
extension Optional {
  public func flatMap<U>(
    _ transform: (Wrapped) throws -> U?
  ) rethrows -> U? {
    switch self {
    case .some(let y):
      return try transform(y)
    case .none:
      return .none
    }
  }
}

----Swift.(file).Optional.init(nilLiteral:())
extension Optional {
  public init(nilLiteral: ()) {
    self = .none
  }
}

----Swift.(file).Optional.unsafelyUnwrapped
extension Optional {
  public var unsafelyUnwrapped: Wrapped {
    @inline(__always)
    get {
      if let x = self {
        return x
      }
      preconditionFailure("unsafelyUnwrapped of nil optional")
    }
  }
}

----Swift.(file).Optional.debugDescription
extension Optional : CustomDebugStringConvertible  {
  public var debugDescription: String {
    switch self {
    case .some(let value):
      var result = "Optional("
      debugPrint(value, terminator: "", to: &result)
      result += ")"
      return result
    case .none:
      return "nil"
    }
  }
}

----Swift.(file).Optional.customMirror
extension Optional : CustomReflectable  {
  public var customMirror: Mirror {
    switch self {
    case .some(let value):
      return Mirror(
        self,
        children: [ "some": value ],
        displayStyle: .optional)
    case .none:
      return Mirror(self, children: [:], displayStyle: .optional)
    }
  }
}

----Swift.(file).Optional.==infix(_:Wrapped?,_:Wrapped?)
extension Optional : Equatable where Wrapped : Equatable  {
  public static func ==(lhs: Wrapped?, rhs: Wrapped?) -> Bool {
    switch (lhs, rhs) {
    case let (l?, r?):
      return l == r
    case (nil, nil):
      return true
    default:
      return false
    }
  }
}

----Swift.(file).Optional.hash(into:Hasher)
extension Optional: Hashable where Wrapped: Hashable  {
  public func hash(into hasher: inout Hasher) {
    switch self {
    case .none:
      hasher.combine(0 as UInt8)
    case .some(let wrapped):
      hasher.combine(1 as UInt8)
      hasher.combine(wrapped)
    }
  }
}

----Swift.(file).Optional.~=infix(_:_OptionalNilComparisonType,_:Wrapped?)
extension Optional  {
  public static func ~=(lhs: _OptionalNilComparisonType, rhs: Wrapped?) -> Bool {
    switch rhs {
    case .some:
      return false
    case .none:
      return true
    }
  }
}

----Swift.(file).Optional.==infix(_:Wrapped?,_:_OptionalNilComparisonType)
extension Optional  {
  public static func ==(lhs: Wrapped?, rhs: _OptionalNilComparisonType) -> Bool {
    switch lhs {
    case .some:
      return false
    case .none:
      return true
    }
  }
}

----Swift.(file).Optional.!=infix(_:Wrapped?,_:_OptionalNilComparisonType)
extension Optional  {
  public static func !=(lhs: Wrapped?, rhs: _OptionalNilComparisonType) -> Bool {
    switch lhs {
    case .some:
      return true
    case .none:
      return false
    }
  }
}

----Swift.(file).Optional.==infix(_:_OptionalNilComparisonType,_:Wrapped?)
extension Optional  {
  public static func ==(lhs: _OptionalNilComparisonType, rhs: Wrapped?) -> Bool {
    switch rhs {
    case .some:
      return false
    case .none:
      return true
    }
  }
}

----Swift.(file).Optional.!=infix(_:_OptionalNilComparisonType,_:Wrapped?)
extension Optional  {
  public static func !=(lhs: _OptionalNilComparisonType, rhs: Wrapped?) -> Bool {
    switch rhs {
    case .some:
      return true
    case .none:
      return false
    }
  }
}

----Swift.(file).??infix(_:T?,_:() throws -> T)
public func ?? <T>(optional: T?, defaultValue: @autoclosure () throws -> T)
    rethrows -> T {
  switch optional {
  case .some(let value):
    return value
  case .none:
    return try defaultValue()
  }
}

----Swift.(file).??infix(_:T?,_:() throws -> T?)
public func ?? <T>(optional: T?, defaultValue: @autoclosure () throws -> T?)
    rethrows -> T? {
  switch optional {
  case .some(let value):
    return value
  case .none:
    return try defaultValue()
  }
}

----Swift.(file).CustomStringConvertible.description
extension CustomStringConvertible {
  var description: String { get }
}

----Swift.(file).CustomDebugStringConvertible.debugDescription
extension CustomDebugStringConvertible {
  var debugDescription: String { get }
}

----Swift.(file).String.write(_:String)
extension String : TextOutputStream  {
  public mutating func write(_ other: String) {
    self += other
  }
}

----Swift.(file).String.write(to:Target)
extension String : TextOutputStreamable  {
  public func write<Target : TextOutputStream>(to target: inout Target) {
    target.write(self)
  }
}

----Swift.(file).Character.write(to:Target)
extension Character : TextOutputStreamable  {
  public func write<Target : TextOutputStream>(to target: inout Target) {
    target.write(String(self))
  }
}

----Swift.(file).Scalar.write(to:Target)
extension Unicode.Scalar : TextOutputStreamable  {
  public func write<Target : TextOutputStream>(to target: inout Target) {
    target.write(String(Character(self)))
  }
}

----Swift.(file)._Pointer.init(_:OpaquePointer)
extension _Pointer  {
  public init(_ from : OpaquePointer) {
    self.init(from._rawValue)
  }
}

----Swift.(file)._Pointer.init(_:OpaquePointer?)
extension _Pointer  {
  public init?(_ from : OpaquePointer?) {
    guard let unwrapped = from else { return nil }
    self.init(unwrapped)
  }
}

----Swift.(file)._Pointer.init(bitPattern:Int)
extension _Pointer  {
  public init?(bitPattern: Int) {
    if bitPattern == 0 { return nil }
    self.init(Builtin.inttoptr_Word(bitPattern._builtinWordValue))
  }
}

----Swift.(file)._Pointer.init(bitPattern:UInt)
extension _Pointer  {
  public init?(bitPattern: UInt) {
    if bitPattern == 0 { return nil }
    self.init(Builtin.inttoptr_Word(bitPattern._builtinWordValue))
  }
}

----Swift.(file)._Pointer.init(_:Self)
extension _Pointer  {
  public init(_ other: Self) {
    self.init(other._rawValue)
  }
}

----Swift.(file)._Pointer.init(_:Self?)
extension _Pointer  {
  public init?(_ other: Self?) {
    guard let unwrapped = other else { return nil }
    self.init(unwrapped._rawValue)
  }
}

----Swift.(file)._Pointer.init(_:UnsafeMutablePointer<T>)
extension _Pointer  {
  public init<T>(_ other: UnsafeMutablePointer<T>) {
    self.init(other._rawValue)
  }
}

----Swift.(file)._Pointer.init(_:UnsafeMutablePointer<T>?)
extension _Pointer  {
  public init?<T>(_ other: UnsafeMutablePointer<T>?) {
    guard let unwrapped = other else { return nil }
    self.init(unwrapped)
  }
}

----Swift.(file)._Pointer.==infix(_:Self,_:Self)
extension _Pointer /*: Equatable */  {
  public static func == (lhs: Self, rhs: Self) -> Bool {
    return Bool(Builtin.cmp_eq_RawPointer(lhs._rawValue, rhs._rawValue))
  }
}

----Swift.(file)._Pointer.<infix(_:Self,_:Self)
extension _Pointer /*: Comparable */  {
  public static func < (lhs: Self, rhs: Self) -> Bool {
    return Bool(Builtin.cmp_ult_RawPointer(lhs._rawValue, rhs._rawValue))
  }
}

----Swift.(file)._Pointer.successor()
extension _Pointer /*: Strideable*/  {
  public func successor() -> Self {
    return advanced(by: 1)
  }
}

----Swift.(file)._Pointer.predecessor()
extension _Pointer /*: Strideable*/  {
  public func predecessor() -> Self {
    return advanced(by: -1)
  }
}

----Swift.(file)._Pointer.distance(to:Self)
extension _Pointer /*: Strideable*/  {
  public func distance(to end: Self) -> Int {
    return
      Int(Builtin.sub_Word(Builtin.ptrtoint_Word(end._rawValue),
                           Builtin.ptrtoint_Word(_rawValue)))
      / MemoryLayout<Pointee>.stride
  }
}

----Swift.(file)._Pointer.advanced(by:Int)
extension _Pointer /*: Strideable*/  {
  public func advanced(by n: Int) -> Self {
    return Self(Builtin.gep_Word(
      self._rawValue, n._builtinWordValue, Pointee.self))
  }
}

----Swift.(file)._Pointer.hash(into:Hasher)
extension _Pointer /*: Hashable */  {
  public func hash(into hasher: inout Hasher) {
    hasher.combine(UInt(bitPattern: self))
  }
}

----Swift.(file)._Pointer.debugDescription
extension _Pointer /*: CustomDebugStringConvertible */  {
  public var debugDescription: String {
    return _rawPointerToString(_rawValue)
  }
}

----Swift.(file)._Pointer.customMirror
extension _Pointer /*: CustomReflectable */  {
  public var customMirror: Mirror {
    let ptrValue = UInt64(
      bitPattern: Int64(Int(Builtin.ptrtoint_Word(_rawValue))))
    return Mirror(self, children: ["pointerValue": ptrValue])
  }
}

----Swift.(file).Strideable.+infix(_:Self,_:Self.Stride)
extension Strideable where Self : _Pointer  {
  public static func + (lhs: Self, rhs: Self.Stride) -> Self {
    return lhs.advanced(by: rhs)
  }
}

----Swift.(file).Strideable.+infix(_:Self.Stride,_:Self)
extension Strideable where Self : _Pointer  {
  public static func + (lhs: Self.Stride, rhs: Self) -> Self {
    return rhs.advanced(by: lhs)
  }
}

----Swift.(file).Strideable.-infix(_:Self,_:Self.Stride)
extension Strideable where Self : _Pointer  {
  public static func - (lhs: Self, rhs: Self.Stride) -> Self {
    return lhs.advanced(by: -rhs)
  }
}

----Swift.(file).Strideable.-infix(_:Self,_:Self)
extension Strideable where Self : _Pointer  {
  public static func - (lhs: Self, rhs: Self) -> Self.Stride {
    return rhs.distance(to: lhs)
  }
}

----Swift.(file).Strideable.+=infix(_:Self,_:Self.Stride)
extension Strideable where Self : _Pointer  {
  public static func += (lhs: inout Self, rhs: Self.Stride) {
    lhs = lhs.advanced(by: rhs)
  }
}

----Swift.(file).Strideable.-=infix(_:Self,_:Self.Stride)
extension Strideable where Self : _Pointer  {
  public static func -= (lhs: inout Self, rhs: Self.Stride) {
    lhs = lhs.advanced(by: -rhs)
  }
}

----Swift.(file).Never.<infix(_:Never,_:Never)
extension Never: Comparable  {
  public static func < (lhs: Never, rhs: Never) -> Bool {
  }
}

----Swift.(file).~=infix(_:T,_:T)
public func ~= <T : Equatable>(a: T, b: T) -> Bool {
  return a == b
}

----Swift.(file).Iterator.next()
extension LazyPrefixWhileSequence.Iterator: IteratorProtocol, Sequence  {
  public mutating func next() -> Element? {
    // Return elements from the base iterator until one fails the predicate.
    if !_predicateHasFailed, let nextElement = _base.next() {
      if _predicate(nextElement) {
        return nextElement
      } else {
        _predicateHasFailed = true
      }
    }
    return nil
  }
}

----Swift.(file).LazyPrefixWhileSequence.makeIterator()
extension LazyPrefixWhileSequence: Sequence  {
  public __consuming func makeIterator() -> Iterator {
    return Iterator(_base: _base.makeIterator(), predicate: _predicate)
  }
}

----Swift.(file).LazySequenceProtocol.prefix(while:(Self.Elements.Element) -> Bool)
extension LazySequenceProtocol  {
  public __consuming func prefix(
    while predicate: @escaping (Elements.Element) -> Bool
  ) -> LazyPrefixWhileSequence<Self.Elements> {
    return LazyPrefixWhileSequence(_base: self.elements, predicate: predicate)
  }
}

----Swift.(file).Index.==infix(_:LazyPrefixWhileCollection<Base>.Index,_:LazyPrefixWhileCollection<Base>.Index)
extension LazyPrefixWhileSequence.Index: Comparable where Base: Collection  {
  public static func == (
    lhs: LazyPrefixWhileCollection<Base>.Index, 
    rhs: LazyPrefixWhileCollection<Base>.Index
  ) -> Bool {
    switch (lhs._value, rhs._value) {
    case let (.index(l), .index(r)):
      return l == r
    case (.pastEnd, .pastEnd):
      return true
    case (.pastEnd, .index), (.index, .pastEnd):
      return false
    }
  }
}

----Swift.(file).Index.<infix(_:LazyPrefixWhileCollection<Base>.Index,_:LazyPrefixWhileCollection<Base>.Index)
extension LazyPrefixWhileSequence.Index: Comparable where Base: Collection  {
  public static func < (
    lhs: LazyPrefixWhileCollection<Base>.Index, 
    rhs: LazyPrefixWhileCollection<Base>.Index
  ) -> Bool {
    switch (lhs._value, rhs._value) {
    case let (.index(l), .index(r)):
      return l < r
    case (.index, .pastEnd):
      return true
    case (.pastEnd, _):
      return false
    }
  }
}

----Swift.(file).Index.hash(into:Hasher)
extension LazyPrefixWhileSequence.Index: Hashable where Base.Index: Hashable, Base: Collection  {
  public func hash(into hasher: inout Hasher) {
    switch _value {
    case .index(let value):
      hasher.combine(value)
    case .pastEnd:
      hasher.combine(Int.max)
    }
  }
}

----Swift.(file).LazyPrefixWhileSequence.startIndex
extension LazyPrefixWhileCollection: Collection  {
  public var startIndex: Index {
    return Index(_base.startIndex)
  }
}

----Swift.(file).LazyPrefixWhileSequence.endIndex
extension LazyPrefixWhileCollection: Collection  {
  public var endIndex: Index {
    // If the first element of `_base` satisfies the predicate, there is at
    // least one element in the lazy collection: Use the explicit `.pastEnd` index.
    if let first = _base.first, _predicate(first) {
      return Index(endOf: _base)
    }

    // `_base` is either empty or `_predicate(_base.first!) == false`. In either
    // case, the lazy collection is empty, so `endIndex == startIndex`.
    return startIndex
  }
}

----Swift.(file).LazyPrefixWhileSequence.index(after:LazyPrefixWhileSequence<Base>.Index)
extension LazyPrefixWhileCollection: Collection  {
  public func index(after i: Index) -> Index {
    precondition(i != endIndex, "Can't advance past endIndex")
    guard case .index(let i) = i._value else {
      preconditionFailure("Invalid index passed to index(after:)")
    }
    let nextIndex = _base.index(after: i)
    guard nextIndex != _base.endIndex && _predicate(_base[nextIndex]) else {
      return Index(endOf: _base)
    }
    return Index(nextIndex)
  }
}

----Swift.(file).LazyPrefixWhileSequence.subscript(_:LazyPrefixWhileSequence<Base>.Index)
extension LazyPrefixWhileCollection: Collection  {
  public subscript(position: Index) -> Element {
    switch position._value {
    case .index(let i):
      return _base[i]
    case .pastEnd:
      preconditionFailure("Index out of range")
    }
  }
}

----Swift.(file).LazyPrefixWhileSequence.index(before:LazyPrefixWhileSequence<Base>.Index)
extension LazyPrefixWhileCollection: BidirectionalCollection
where Base: BidirectionalCollection  {
  public func index(before i: Index) -> Index {
    switch i._value {
    case .index(let i):
      precondition(i != _base.startIndex, "Can't move before startIndex")
      return Index(_base.index(before: i))
    case .pastEnd:
      // Look for the position of the last element in a non-empty
      // prefix(while:) collection by searching forward for a predicate
      // failure.

      // Safe to assume that `_base.startIndex != _base.endIndex`; if they
      // were equal, `_base.startIndex` would be used as the `endIndex` of
      // this collection.
      _internalInvariant(!_base.isEmpty)
      var result = _base.startIndex
      while true {
        let next = _base.index(after: result)
        if next == _base.endIndex || !_predicate(_base[next]) {
          break
        }
        result = next
      }
      return Index(result)
    }
  }
}

----Swift.(file).print(_:[Any],separator:String,terminator:String)
public func print(
  _ items: Any...,
  separator: String = " ",
  terminator: String = "\n"
) {
  if let hook = _playgroundPrintHook {
    var output = _TeeStream(left: "", right: _Stdout())
    _print(items, separator: separator, terminator: terminator, to: &output)
    hook(output.left)
  }
  else {
    var output = _Stdout()
    _print(items, separator: separator, terminator: terminator, to: &output)
  }
}

----Swift.(file).debugPrint(_:[Any],separator:String,terminator:String)
public func debugPrint(
  _ items: Any...,
  separator: String = " ",
  terminator: String = "\n"
) {
  if let hook = _playgroundPrintHook {
    var output = _TeeStream(left: "", right: _Stdout())
    _debugPrint(items, separator: separator, terminator: terminator, to: &output)
    hook(output.left)
  }
  else {
    var output = _Stdout()
    _debugPrint(items, separator: separator, terminator: terminator, to: &output)
  }
}

----Swift.(file).print(_:[Any],separator:String,terminator:String,to:Target)
public func print<Target : TextOutputStream>(
  _ items: Any...,
  separator: String = " ",
  terminator: String = "\n",
  to output: inout Target
) {
  _print(items, separator: separator, terminator: terminator, to: &output)
}

----Swift.(file).debugPrint(_:[Any],separator:String,terminator:String,to:Target)
public func debugPrint<Target : TextOutputStream>(
  _ items: Any...,
  separator: String = " ",
  terminator: String = "\n",
  to output: inout Target
) {
  _debugPrint(items, separator: separator, terminator: terminator, to: &output)
}

----Swift.(file).RandomNumberGenerator.next()
extension RandomNumberGenerator  {
  public mutating func next<T: FixedWidthInteger & UnsignedInteger>() -> T {
    return T._random(using: &self)
  }
}

----Swift.(file).RandomNumberGenerator.next(upperBound:T)
extension RandomNumberGenerator  {
  public mutating func next<T: FixedWidthInteger & UnsignedInteger>(
    upperBound: T
  ) -> T {
    precondition(upperBound != 0, "upperBound cannot be zero.")
    let tmp = (T.max % upperBound) + 1
    let range = tmp == upperBound ? 0 : tmp
    var random: T = 0

    repeat {
      random = next()
    } while random < range

    return random % upperBound
  }
}

----Swift.(file).SystemRandomNumberGenerator.init()
extension SystemRandomNumberGenerator {
  public init() { }
}

----Swift.(file).SystemRandomNumberGenerator.next()
extension SystemRandomNumberGenerator {
  public mutating func next() -> UInt64 {
    var random: UInt64 = 0
    swift_stdlib_random(&random, MemoryLayout<UInt64>.size)
    return random
  }
}

----Swift.(file).RandomAccessCollection.indices
extension RandomAccessCollection {
  override var indices: Indices { get }
}

----Swift.(file).RandomAccessCollection.subscript(_:Range<Self.Index>)
extension RandomAccessCollection {
  override subscript(bounds: Range<Index>) -> SubSequence { get }
}

----Swift.(file).RandomAccessCollection.subscript(_:Self.Index)
extension RandomAccessCollection {
  override subscript(position: Index) -> Element { get }
}

----Swift.(file).RandomAccessCollection.startIndex
extension RandomAccessCollection {
  override var startIndex: Index { get }
}

----Swift.(file).RandomAccessCollection.endIndex
extension RandomAccessCollection {
  override var endIndex: Index { get }
}

----Swift.(file).RandomAccessCollection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)
extension RandomAccessCollection  {
  public func index(
    _ i: Index, offsetBy distance: Int, limitedBy limit: Index
  ) -> Index? {
    // FIXME: swift-3-indexing-model: tests.
    let l = self.distance(from: i, to: limit)
    if distance > 0 ? l >= 0 && l < distance : l <= 0 && distance < l {
      return nil
    }
    return index(i, offsetBy: distance)
  }
}

----Swift.(file).RandomAccessCollection.indices
extension RandomAccessCollection
where Index : Strideable, 
      Index.Stride == Int,
      Indices == Range<Index>  {
  public var indices: Range<Index> {
    return startIndex..<endIndex
  }
}

----Swift.(file).RandomAccessCollection.index(after:Self.Index)
extension RandomAccessCollection
where Index : Strideable, 
      Index.Stride == Int,
      Indices == Range<Index>  {
  public func index(after i: Index) -> Index {
    // FIXME: swift-3-indexing-model: tests for the trap.
    _failEarlyRangeCheck(
      i, bounds: Range(uncheckedBounds: (startIndex, endIndex)))
    return i.advanced(by: 1)
  }
}

----Swift.(file).RandomAccessCollection.index(before:Self.Index)
extension RandomAccessCollection
where Index : Strideable, 
      Index.Stride == Int,
      Indices == Range<Index>  {
  public func index(before i: Index) -> Index {
    let result = i.advanced(by: -1)
    // FIXME: swift-3-indexing-model: tests for the trap.
    _failEarlyRangeCheck(
      result, bounds: Range(uncheckedBounds: (startIndex, endIndex)))
    return result
  }
}

----Swift.(file).RandomAccessCollection.index(_:Self.Index,offsetBy:Self.Index.Stride)
extension RandomAccessCollection
where Index : Strideable, 
      Index.Stride == Int,
      Indices == Range<Index>  {
  public func index(_ i: Index, offsetBy distance: Index.Stride) -> Index {
    let result = i.advanced(by: distance)
    // This range check is not precise, tighter bounds exist based on `n`.
    // Unfortunately, we would need to perform index manipulation to
    // compute those bounds, which is probably too slow in the general
    // case.
    // FIXME: swift-3-indexing-model: tests for the trap.
    _failEarlyRangeCheck(
      result, bounds: ClosedRange(uncheckedBounds: (startIndex, endIndex)))
    return result
  }
}

----Swift.(file).RandomAccessCollection.distance(from:Self.Index,to:Self.Index)
extension RandomAccessCollection
where Index : Strideable, 
      Index.Stride == Int,
      Indices == Range<Index>  {
  public func distance(from start: Index, to end: Index) -> Index.Stride {
    // FIXME: swift-3-indexing-model: tests for traps.
    _failEarlyRangeCheck(
      start, bounds: ClosedRange(uncheckedBounds: (startIndex, endIndex)))
    _failEarlyRangeCheck(
      end, bounds: ClosedRange(uncheckedBounds: (startIndex, endIndex)))
    return start.distance(to: end)
  }
}

----Swift.(file).RangeExpression.~=infix(_:Self,_:Self.Bound)
extension RangeExpression  {
  public static func ~= (pattern: Self, value: Bound) -> Bool {
    return pattern.contains(value)
  }
}

----Swift.(file).Range.init(uncheckedBounds:(lower: Bound, upper: Bound))
extension Range {
  public init(uncheckedBounds bounds: (lower: Bound, upper: Bound)) {
    self.lowerBound = bounds.lower
    self.upperBound = bounds.upper
  }
}

----Swift.(file).Range.contains(_:Bound)
extension Range {
  public func contains(_ element: Bound) -> Bool {
    return lowerBound <= element && element < upperBound
  }
}

----Swift.(file).Range.isEmpty
extension Range {
  public var isEmpty: Bool {
    return lowerBound == upperBound
  }
}

----Swift.(file).Range.startIndex
extension Range: Collection, BidirectionalCollection, RandomAccessCollection
where Bound : Strideable, Bound.Stride : SignedInteger
 {
  public var startIndex: Index { return lowerBound }
}

----Swift.(file).Range.endIndex
extension Range: Collection, BidirectionalCollection, RandomAccessCollection
where Bound : Strideable, Bound.Stride : SignedInteger
 {
  public var endIndex: Index { return upperBound }
}

----Swift.(file).Range.index(after:Range<Bound>.Index)
extension Range: Collection, BidirectionalCollection, RandomAccessCollection
where Bound : Strideable, Bound.Stride : SignedInteger
 {
  public func index(after i: Index) -> Index {
    _failEarlyRangeCheck(i, bounds: startIndex..<endIndex)

    return i.advanced(by: 1)
  }
}

----Swift.(file).Range.index(before:Range<Bound>.Index)
extension Range: Collection, BidirectionalCollection, RandomAccessCollection
where Bound : Strideable, Bound.Stride : SignedInteger
 {
  public func index(before i: Index) -> Index {
    precondition(i > lowerBound)
    precondition(i <= upperBound)

    return i.advanced(by: -1)
  }
}

----Swift.(file).Range.index(_:Range<Bound>.Index,offsetBy:Int)
extension Range: Collection, BidirectionalCollection, RandomAccessCollection
where Bound : Strideable, Bound.Stride : SignedInteger
 {
  public func index(_ i: Index, offsetBy n: Int) -> Index {
    let r = i.advanced(by: numericCast(n))
    precondition(r >= lowerBound)
    precondition(r <= upperBound)
    return r
  }
}

----Swift.(file).Range.distance(from:Range<Bound>.Index,to:Range<Bound>.Index)
extension Range: Collection, BidirectionalCollection, RandomAccessCollection
where Bound : Strideable, Bound.Stride : SignedInteger
 {
  public func distance(from start: Index, to end: Index) -> Int {
    return numericCast(start.distance(to: end))
  }
}

----Swift.(file).Range.subscript(_:Range<Range<Bound>.Index>)
extension Range: Collection, BidirectionalCollection, RandomAccessCollection
where Bound : Strideable, Bound.Stride : SignedInteger
 {
  public subscript(bounds: Range<Index>) -> Range<Bound> {
    return bounds
  }
}

----Swift.(file).Range.indices
extension Range: Collection, BidirectionalCollection, RandomAccessCollection
where Bound : Strideable, Bound.Stride : SignedInteger
 {
  public var indices: Indices {
    return self
  }
}

----Swift.(file).Range.subscript(_:Range<Bound>.Index)
extension Range: Collection, BidirectionalCollection, RandomAccessCollection
where Bound : Strideable, Bound.Stride : SignedInteger
 {
  public subscript(position: Index) -> Element {
    // FIXME: swift-3-indexing-model: tests for the range check.
    precondition(self.contains(position), "Index out of range")
    return position
  }
}

----Swift.(file).Range.init(_:ClosedRange<Bound>)
extension Range where Bound: Strideable, Bound.Stride : SignedInteger  {
  public init(_ other: ClosedRange<Bound>) {
    let upperBound = other.upperBound.advanced(by: 1)
    self.init(uncheckedBounds: (lower: other.lowerBound, upper: upperBound))
  }
}

----Swift.(file).Range.relative(to:C)
extension Range: RangeExpression  {
  public func relative<C: Collection>(to collection: C) -> Range<Bound>
  where C.Index == Bound {
    return Range(uncheckedBounds: (lower: lowerBound, upper: upperBound))
  }
}

----Swift.(file).Range.clamped(to:Range<Bound>)
extension Range  {
  public func clamped(to limits: Range) -> Range {
    let lower =         
      limits.lowerBound > self.lowerBound ? limits.lowerBound
          : limits.upperBound < self.lowerBound ? limits.upperBound
          : self.lowerBound
    let upper =
      limits.upperBound < self.upperBound ? limits.upperBound
          : limits.lowerBound > self.upperBound ? limits.lowerBound
          : self.upperBound
    return Range(uncheckedBounds: (lower: lower, upper: upper))
  }
}

----Swift.(file).Range.description
extension Range : CustomStringConvertible  {
  public var description: String {
    return "\(lowerBound)..<\(upperBound)"
  }
}

----Swift.(file).Range.debugDescription
extension Range : CustomDebugStringConvertible  {
  public var debugDescription: String {
    return "Range(\(String(reflecting: lowerBound))"
    + "..<\(String(reflecting: upperBound)))"
  }
}

----Swift.(file).Range.customMirror
extension Range : CustomReflectable  {
  public var customMirror: Mirror {
    return Mirror(
      self, children: ["lowerBound": lowerBound, "upperBound": upperBound])
  }
}

----Swift.(file).Range.==infix(_:Range<Bound>,_:Range<Bound>)
extension Range: Equatable  {
  public static func == (lhs: Range<Bound>, rhs: Range<Bound>) -> Bool {
    return
      lhs.lowerBound == rhs.lowerBound &&
      lhs.upperBound == rhs.upperBound
  }
}

----Swift.(file).Range.hash(into:Hasher)
extension Range: Hashable where Bound: Hashable  {
  public func hash(into hasher: inout Hasher) {
    hasher.combine(lowerBound)
    hasher.combine(upperBound)
  }
}

----Swift.(file).PartialRangeUpTo.init(_:Bound)
extension PartialRangeUpTo {
  public init(_ upperBound: Bound) { self.upperBound = upperBound }
}

----Swift.(file).PartialRangeUpTo.relative(to:C)
extension PartialRangeUpTo: RangeExpression  {
  public func relative<C: Collection>(to collection: C) -> Range<Bound>
  where C.Index == Bound {
    return collection.startIndex..<self.upperBound
  }
}

----Swift.(file).PartialRangeUpTo.contains(_:Bound)
extension PartialRangeUpTo: RangeExpression  {
  public func contains(_ element: Bound) -> Bool {
    return element < upperBound
  }
}

----Swift.(file).PartialRangeThrough.init(_:Bound)
extension PartialRangeThrough {
  public init(_ upperBound: Bound) { self.upperBound = upperBound }
}

----Swift.(file).PartialRangeThrough.relative(to:C)
extension PartialRangeThrough: RangeExpression  {
  public func relative<C: Collection>(to collection: C) -> Range<Bound>
  where C.Index == Bound {
    return collection.startIndex..<collection.index(after: self.upperBound)
  }
}

----Swift.(file).PartialRangeThrough.contains(_:Bound)
extension PartialRangeThrough: RangeExpression  {
  public func contains(_ element: Bound) -> Bool {
    return element <= upperBound
  }
}

----Swift.(file).PartialRangeFrom.init(_:Bound)
extension PartialRangeFrom {
  public init(_ lowerBound: Bound) { self.lowerBound = lowerBound }
}

----Swift.(file).PartialRangeFrom.relative(to:C)
extension PartialRangeFrom: RangeExpression  {
  public func relative<C: Collection>(
    to collection: C
  ) -> Range<Bound> where C.Index == Bound {
    return self.lowerBound..<collection.endIndex
  }
}

----Swift.(file).PartialRangeFrom.contains(_:Bound)
extension PartialRangeFrom: RangeExpression  {
  public func contains(_ element: Bound) -> Bool {
    return lowerBound <= element
  }
}

----Swift.(file).PartialRangeFrom.makeIterator()
extension PartialRangeFrom: Sequence
  where Bound : Strideable, Bound.Stride : SignedInteger
 {
  public __consuming func makeIterator() -> Iterator { 
    return Iterator(_current: lowerBound) 
  }
}

----Swift.(file).Comparable...<infix(_:Self,_:Self)
extension Comparable  {
  public static func ..< (minimum: Self, maximum: Self) -> Range<Self> {
    precondition(minimum <= maximum,
      "Can't form Range with upperBound < lowerBound")
    return Range(uncheckedBounds: (lower: minimum, upper: maximum))
  }
}

----Swift.(file).Comparable...<prefix(_:Self)
extension Comparable  {
  public static prefix func ..< (maximum: Self) -> PartialRangeUpTo<Self> {
    return PartialRangeUpTo(maximum)
  }
}

----Swift.(file).Comparable....prefix(_:Self)
extension Comparable  {
  public static prefix func ... (maximum: Self) -> PartialRangeThrough<Self> {
    return PartialRangeThrough(maximum)
  }
}

----Swift.(file).Comparable....postfix(_:Self)
extension Comparable  {
  public static postfix func ... (minimum: Self) -> PartialRangeFrom<Self> {
    return PartialRangeFrom(minimum)
  }
}

----Swift.(file).UnboundedRange_....postfix(_:UnboundedRange_)
extension UnboundedRange_ {
  public static postfix func ... (_: UnboundedRange_) -> () {
    // This function is uncallable
  }
}

----Swift.(file).Collection.subscript(_:(UnboundedRange_) -> ())
extension Collection  {
  public subscript(x: UnboundedRange) -> SubSequence {
    return self[startIndex...]
  }
}

----Swift.(file).MutableCollection.subscript(_:(UnboundedRange_) -> ())
extension MutableCollection  {
  public subscript(x: UnboundedRange) -> SubSequence {
    get {
      return self[startIndex...]
    }
    set {
      self[startIndex...] = newValue
    }
  }
}

----Swift.(file).Range.overlaps(_:Range<Bound>)
extension Range  {
  public func overlaps(_ other: Range<Bound>) -> Bool {
    return (!other.isEmpty && self.contains(other.lowerBound))
        || (!self.isEmpty && other.contains(self.lowerBound))
  }
}

----Swift.(file).Range.overlaps(_:ClosedRange<Bound>)
extension Range  {
  public func overlaps(_ other: ClosedRange<Bound>) -> Bool {
    return self.contains(other.lowerBound)
        || (!self.isEmpty && other.contains(self.lowerBound))
  }
}

----Swift.(file).RangeReplaceableCollection.subscript(_:Self.Index)
extension RangeReplaceableCollection {
  override subscript(bounds: Index) -> Element { get }
}

----Swift.(file).RangeReplaceableCollection.subscript(_:Range<Self.Index>)
extension RangeReplaceableCollection {
  override subscript(bounds: Range<Index>) -> SubSequence { get }
}

----Swift.(file).RangeReplaceableCollection.init(repeating:Self.Element,count:Int)
extension RangeReplaceableCollection  {
  public init(repeating repeatedValue: Element, count: Int) {
    self.init()
    if count != 0 {
      let elements = Repeated(_repeating: repeatedValue, count: count)
      append(contentsOf: elements)
    }
  }
}

----Swift.(file).RangeReplaceableCollection.init(_:S)
extension RangeReplaceableCollection  {
  public init<S : Sequence>(_ elements: S)
    where S.Element == Element {
    self.init()
    append(contentsOf: elements)
  }
}

----Swift.(file).RangeReplaceableCollection.append(_:Self.Element)
extension RangeReplaceableCollection  {
  public mutating func append(_ newElement: __owned Element) {
    insert(newElement, at: endIndex)
  }
}

----Swift.(file).RangeReplaceableCollection.append(contentsOf:S)
extension RangeReplaceableCollection  {
  public mutating func append<S : Sequence>(contentsOf newElements: __owned S)
    where S.Element == Element {

    let approximateCapacity = self.count +
      numericCast(newElements.underestimatedCount)
    self.reserveCapacity(approximateCapacity)
    for element in newElements {
      append(element)
    }
  }
}

----Swift.(file).RangeReplaceableCollection.insert(_:Self.Element,at:Self.Index)
extension RangeReplaceableCollection  {
  public mutating func insert(
    _ newElement: __owned Element, at i: Index
  ) {
    replaceSubrange(i..<i, with: CollectionOfOne(newElement))
  }
}

----Swift.(file).RangeReplaceableCollection.insert(contentsOf:C,at:Self.Index)
extension RangeReplaceableCollection  {
  public mutating func insert<C : Collection>(
    contentsOf newElements: __owned C, at i: Index
  ) where C.Element == Element {
    replaceSubrange(i..<i, with: newElements)
  }
}

----Swift.(file).RangeReplaceableCollection.remove(at:Self.Index)
extension RangeReplaceableCollection  {
  public mutating func remove(at position: Index) -> Element {
    precondition(!isEmpty, "Can't remove from an empty collection")
    let result: Element = self[position]
    replaceSubrange(position..<index(after: position), with: EmptyCollection())
    return result
  }
}

----Swift.(file).RangeReplaceableCollection.removeSubrange(_:Range<Self.Index>)
extension RangeReplaceableCollection  {
  public mutating func removeSubrange(_ bounds: Range<Index>) {
    replaceSubrange(bounds, with: EmptyCollection())
  }
}

----Swift.(file).RangeReplaceableCollection.removeFirst(_:Int)
extension RangeReplaceableCollection  {
  public mutating func removeFirst(_ k: Int) {
    if k == 0 { return }
    precondition(k >= 0, "Number of elements to remove should be non-negative")
    precondition(count >= k,
      "Can't remove more items from a collection than it has")
    let end = index(startIndex, offsetBy: k)
    removeSubrange(startIndex..<end)
  }
}

----Swift.(file).RangeReplaceableCollection.removeFirst()
extension RangeReplaceableCollection  {
  public mutating func removeFirst() -> Element {
    precondition(!isEmpty,
      "Can't remove first element from an empty collection")
    let firstElement = first!
    removeFirst(1)
    return firstElement
  }
}

----Swift.(file).RangeReplaceableCollection.removeAll(keepingCapacity:Bool)
extension RangeReplaceableCollection  {
  public mutating func removeAll(keepingCapacity keepCapacity: Bool = false) {
    if !keepCapacity {
      self = Self()
    }
    else {
      replaceSubrange(startIndex..<endIndex, with: EmptyCollection())
    }
  }
}

----Swift.(file).RangeReplaceableCollection.reserveCapacity(_:Int)
extension RangeReplaceableCollection  {
  public mutating func reserveCapacity(_ n: Int) {}
}

----Swift.(file).RangeReplaceableCollection.removeFirst()
extension RangeReplaceableCollection where SubSequence == Self  {
  public mutating func removeFirst() -> Element {
    precondition(!isEmpty, "Can't remove items from an empty collection")
    let element = first!
    self = self[index(after: startIndex)..<endIndex]
    return element
  }
}

----Swift.(file).RangeReplaceableCollection.removeFirst(_:Int)
extension RangeReplaceableCollection where SubSequence == Self  {
  public mutating func removeFirst(_ k: Int) {
    if k == 0 { return }
    precondition(k >= 0, "Number of elements to remove should be non-negative")
    precondition(count >= k,
      "Can't remove more items from a collection than it contains")
    self = self[index(startIndex, offsetBy: k)..<endIndex]
  }
}

----Swift.(file).RangeReplaceableCollection.replaceSubrange(_:R,with:C)
extension RangeReplaceableCollection  {
  public mutating func replaceSubrange<C: Collection, R: RangeExpression>(
    _ subrange: R,
    with newElements: __owned C
  ) where C.Element == Element, R.Bound == Index {
    self.replaceSubrange(subrange.relative(to: self), with: newElements)
  }
}

----Swift.(file).RangeReplaceableCollection.removeSubrange(_:R)
extension RangeReplaceableCollection  {
  public mutating func removeSubrange<R: RangeExpression>(
    _ bounds: R
  ) where R.Bound == Index  {
    removeSubrange(bounds.relative(to: self))
  }
}

----Swift.(file).RangeReplaceableCollection.popLast()
extension RangeReplaceableCollection where Self : BidirectionalCollection  {
  public mutating func popLast() -> Element? {
    if isEmpty { return nil }
    // duplicate of removeLast logic below, to avoid redundant precondition
    if let result = _customRemoveLast() { return result }
    return remove(at: index(before: endIndex))
  }
}

----Swift.(file).RangeReplaceableCollection.removeLast()
extension RangeReplaceableCollection where Self : BidirectionalCollection  {
  public mutating func removeLast() -> Element {
    precondition(!isEmpty, "Can't remove last element from an empty collection")
    // NOTE if you change this implementation, change popLast above as well
    // AND change the tie-breaker implementations in the next extension
    if let result = _customRemoveLast() { return result }
    return remove(at: index(before: endIndex))
  }
}

----Swift.(file).RangeReplaceableCollection.removeLast(_:Int)
extension RangeReplaceableCollection where Self : BidirectionalCollection  {
  public mutating func removeLast(_ k: Int) {
    if k == 0 { return }
    precondition(k >= 0, "Number of elements to remove should be non-negative")
    precondition(count >= k,
      "Can't remove more items from a collection than it contains")
    if _customRemoveLast(k) {
      return
    }
    let end = endIndex
    removeSubrange(index(end, offsetBy: -k)..<end)
  }
}

----Swift.(file).RangeReplaceableCollection.popLast()
extension RangeReplaceableCollection
where Self : BidirectionalCollection, SubSequence == Self  {
  public mutating func popLast() -> Element? {
    if isEmpty { return nil }
    // duplicate of removeLast logic below, to avoid redundant precondition
    if let result = _customRemoveLast() { return result }
    return remove(at: index(before: endIndex))
  }
}

----Swift.(file).RangeReplaceableCollection.removeLast()
extension RangeReplaceableCollection
where Self : BidirectionalCollection, SubSequence == Self  {
  public mutating func removeLast() -> Element {
    precondition(!isEmpty, "Can't remove last element from an empty collection")
    // NOTE if you change this implementation, change popLast above as well
    if let result = _customRemoveLast() { return result }
    return remove(at: index(before: endIndex))
  }
}

----Swift.(file).RangeReplaceableCollection.removeLast(_:Int)
extension RangeReplaceableCollection
where Self : BidirectionalCollection, SubSequence == Self  {
  public mutating func removeLast(_ k: Int) {
    if k == 0 { return }
    precondition(k >= 0, "Number of elements to remove should be non-negative")
    precondition(count >= k,
      "Can't remove more items from a collection than it contains")
    if _customRemoveLast(k) {
      return
    }
    let end = endIndex
    removeSubrange(index(end, offsetBy: -k)..<end)
  }
}

----Swift.(file).RangeReplaceableCollection.+infix(_:Self,_:Other)
extension RangeReplaceableCollection  {
  public static func + <
    Other : Sequence
  >(lhs: Self, rhs: Other) -> Self
  where Element == Other.Element {
    var lhs = lhs
    // FIXME: what if lhs is a reference type?  This will mutate it.
    lhs.append(contentsOf: rhs)
    return lhs
  }
}

----Swift.(file).RangeReplaceableCollection.+infix(_:Other,_:Self)
extension RangeReplaceableCollection  {
  public static func + <
    Other : Sequence
  >(lhs: Other, rhs: Self) -> Self
  where Element == Other.Element {
    var result = Self()
    result.reserveCapacity(rhs.count + numericCast(lhs.underestimatedCount))
    result.append(contentsOf: lhs)
    result.append(contentsOf: rhs)
    return result
  }
}

----Swift.(file).RangeReplaceableCollection.+=infix(_:Self,_:Other)
extension RangeReplaceableCollection  {
  public static func += <
    Other : Sequence
  >(lhs: inout Self, rhs: Other)
  where Element == Other.Element {
    lhs.append(contentsOf: rhs)
  }
}

----Swift.(file).RangeReplaceableCollection.+infix(_:Self,_:Other)
extension RangeReplaceableCollection  {
  public static func + <
    Other : RangeReplaceableCollection
  >(lhs: Self, rhs: Other) -> Self
  where Element == Other.Element {
    var lhs = lhs
    // FIXME: what if lhs is a reference type?  This will mutate it.
    lhs.append(contentsOf: rhs)
    return lhs
  }
}

----Swift.(file).RangeReplaceableCollection.filter(_:(Self.Element) throws -> Bool)
extension RangeReplaceableCollection  {
  public __consuming func filter(
    _ isIncluded: (Element) throws -> Bool
  ) rethrows -> Self {
    return try Self(self.lazy.filter(isIncluded))
  }
}

----Swift.(file).RangeReplaceableCollection.removeAll(where:(Self.Element) throws -> Bool)
extension RangeReplaceableCollection where Self: MutableCollection  {
  public mutating func removeAll(
    where shouldBeRemoved: (Element) throws -> Bool
  ) rethrows {
    let suffixStart = try _halfStablePartition(isSuffixElement: shouldBeRemoved)
    removeSubrange(suffixStart...)
  }
}

----Swift.(file).RangeReplaceableCollection.removeAll(where:(Self.Element) throws -> Bool)
extension RangeReplaceableCollection  {
  public mutating func removeAll(
    where shouldBeRemoved: (Element) throws -> Bool
  ) rethrows {
    // FIXME: Switch to using RRC.filter once stdlib is compiled for 4.0
    // self = try filter { try !predicate($0) }
    self = try Self(self.lazy.filter { try !shouldBeRemoved($0) })
  }
}

----Swift.(file).Repeated.startIndex
extension Repeated: RandomAccessCollection  {
  public var startIndex: Index {
    return 0
  }
}

----Swift.(file).Repeated.endIndex
extension Repeated: RandomAccessCollection  {
  public var endIndex: Index {
    return count
  }
}

----Swift.(file).Repeated.subscript(_:Int)
extension Repeated: RandomAccessCollection  {
  public subscript(position: Int) -> Element {
    precondition(position >= 0 && position < count, "Index out of range")
    return repeatedValue
  }
}

----Swift.(file).repeatElement(_:T,count:Int)
public func repeatElement<T>(_ element: T, count n: Int) -> Repeated<T> {
  return Repeated(_repeating: element, count: n)
}

----Swift.(file).Result.map(_:(Success) -> NewSuccess)
extension Result {
  public func map<NewSuccess>(
    _ transform: (Success) -> NewSuccess
  ) -> Result<NewSuccess, Failure> {
    switch self {
    case let .success(success):
      return .success(transform(success))
    case let .failure(failure):
      return .failure(failure)
    }
  }
}

----Swift.(file).Result.mapError(_:(Failure) -> NewFailure)
extension Result {
  public func mapError<NewFailure>(
    _ transform: (Failure) -> NewFailure
  ) -> Result<Success, NewFailure> {
    switch self {
    case let .success(success):
      return .success(success)
    case let .failure(failure):
      return .failure(transform(failure))
    }
  }
}

----Swift.(file).Result.flatMap(_:(Success) -> Result<NewSuccess, Failure>)
extension Result {
  public func flatMap<NewSuccess>(
    _ transform: (Success) -> Result<NewSuccess, Failure>
  ) -> Result<NewSuccess, Failure> {
    switch self {
    case let .success(success):
      return transform(success)
    case let .failure(failure):
      return .failure(failure)
    }
  }
}

----Swift.(file).Result.flatMapError(_:(Failure) -> Result<Success, NewFailure>)
extension Result {
  public func flatMapError<NewFailure>(
    _ transform: (Failure) -> Result<Success, NewFailure>
  ) -> Result<Success, NewFailure> {
    switch self {
    case let .success(success):
      return .success(success)
    case let .failure(failure):
      return transform(failure)
    }
  }
}

----Swift.(file).Result.get()
extension Result {
  public func get() throws -> Success {
    switch self {
    case let .success(success):
      return success
    case let .failure(failure):
      throw failure
    }
  }
}

----Swift.(file).Result.init(catching:() throws -> Success)
extension Result where Failure == Swift.Error  {
  public init(catching body: () throws -> Success) {
    do {
      self = .success(try body())
    } catch {
      self = .failure(error)
    }
  }
}

----Swift.(file).MutableCollection.reverse()
extension MutableCollection where Self: BidirectionalCollection  {
  public mutating func reverse() {
    if isEmpty { return }
    var f = startIndex
    var l = index(before: endIndex)
    while f < l {
      swapAt(f, l)
      formIndex(after: &f)
      formIndex(before: &l)
    }
  }
}

----Swift.(file).Iterator.next()
extension ReversedCollection.Iterator: IteratorProtocol, Sequence  {
  public mutating func next() -> Element? {
    guard _fastPath(_position != _base.startIndex) else { return nil }
    _base.formIndex(before: &_position)
    return _base[_position]
  }
}

----Swift.(file).ReversedCollection.makeIterator()
extension ReversedCollection: Sequence  {
  public __consuming func makeIterator() -> Iterator {
    return Iterator(_base: _base)
  }
}

----Swift.(file).Index.==infix(_:ReversedCollection<Base>.Index,_:ReversedCollection<Base>.Index)
extension ReversedCollection.Index: Comparable  {
  public static func == (
    lhs: ReversedCollection<Base>.Index,
    rhs: ReversedCollection<Base>.Index
  ) -> Bool {
    // Note ReversedIndex has inverted logic compared to base Base.Index
    return lhs.base == rhs.base
  }
}

----Swift.(file).Index.<infix(_:ReversedCollection<Base>.Index,_:ReversedCollection<Base>.Index)
extension ReversedCollection.Index: Comparable  {
  public static func < (
    lhs: ReversedCollection<Base>.Index,
    rhs: ReversedCollection<Base>.Index
  ) -> Bool {
    // Note ReversedIndex has inverted logic compared to base Base.Index
    return lhs.base > rhs.base
  }
}

----Swift.(file).Index.hash(into:Hasher)
extension ReversedCollection.Index: Hashable where Base.Index: Hashable  {
  public func hash(into hasher: inout Hasher) {
    hasher.combine(base)
  }
}

----Swift.(file).ReversedCollection.startIndex
extension ReversedCollection: BidirectionalCollection  {
  public var startIndex: Index {
    return Index(_base.endIndex)
  }
}

----Swift.(file).ReversedCollection.endIndex
extension ReversedCollection: BidirectionalCollection  {
  public var endIndex: Index {
    return Index(_base.startIndex)
  }
}

----Swift.(file).ReversedCollection.index(after:ReversedCollection<Base>.Index)
extension ReversedCollection: BidirectionalCollection  {
  public func index(after i: Index) -> Index {
    return Index(_base.index(before: i.base))
  }
}

----Swift.(file).ReversedCollection.index(before:ReversedCollection<Base>.Index)
extension ReversedCollection: BidirectionalCollection  {
  public func index(before i: Index) -> Index {
    return Index(_base.index(after: i.base))
  }
}

----Swift.(file).ReversedCollection.index(_:ReversedCollection<Base>.Index,offsetBy:Int)
extension ReversedCollection: BidirectionalCollection  {
  public func index(_ i: Index, offsetBy n: Int) -> Index {
    // FIXME: swift-3-indexing-model: `-n` can trap on Int.min.
    return Index(_base.index(i.base, offsetBy: -n))
  }
}

----Swift.(file).ReversedCollection.index(_:ReversedCollection<Base>.Index,offsetBy:Int,limitedBy:ReversedCollection<Base>.Index)
extension ReversedCollection: BidirectionalCollection  {
  public func index(
    _ i: Index, offsetBy n: Int, limitedBy limit: Index
  ) -> Index? {
    // FIXME: swift-3-indexing-model: `-n` can trap on Int.min.
    return _base.index(i.base, offsetBy: -n, limitedBy: limit.base)
                .map(Index.init)
  }
}

----Swift.(file).ReversedCollection.distance(from:ReversedCollection<Base>.Index,to:ReversedCollection<Base>.Index)
extension ReversedCollection: BidirectionalCollection  {
  public func distance(from start: Index, to end: Index) -> Int {
    return _base.distance(from: end.base, to: start.base)
  }
}

----Swift.(file).ReversedCollection.subscript(_:ReversedCollection<Base>.Index)
extension ReversedCollection: BidirectionalCollection  {
  public subscript(position: Index) -> Element {
    return _base[_base.index(before: position.base)]
  }
}

----Swift.(file).ReversedCollection.reversed()
extension ReversedCollection  {
  public __consuming func reversed() -> Base {
    return _base
  }
}

----Swift.(file).BidirectionalCollection.reversed()
extension BidirectionalCollection  {
  public __consuming func reversed() -> ReversedCollection<Self> {
    return ReversedCollection(_base: self)
  }
}

----Swift.(file).Sequence.underestimatedCount
extension Sequence {
  var underestimatedCount: Int { get }
}

----Swift.(file).Sequence.makeIterator()
extension Sequence where Self.Iterator == Self  {
  public __consuming func makeIterator() -> Self {
    return self
  }
}

----Swift.(file).DropFirstSequence.init(_:Base,dropping:Int)
extension DropFirstSequence {
  public init(_ base: Base, dropping limit: Int) {
    precondition(limit >= 0, 
      "Can't drop a negative number of elements from a sequence")
    _base = base
    _limit = limit
  }
}

----Swift.(file).DropFirstSequence.makeIterator()
extension DropFirstSequence: Sequence  {
  public __consuming func makeIterator() -> Iterator {
    var it = _base.makeIterator()
    var dropped = 0
    while dropped < _limit, it.next() != nil { dropped &+= 1 }
    return it
  }
}

----Swift.(file).DropFirstSequence.dropFirst(_:Int)
extension DropFirstSequence: Sequence  {
  public __consuming func dropFirst(_ k: Int) -> DropFirstSequence<Base> {
    // If this is already a _DropFirstSequence, we need to fold in
    // the current drop count and drop limit so no data is lost.
    //
    // i.e. [1,2,3,4].dropFirst(1).dropFirst(1) should be equivalent to
    // [1,2,3,4].dropFirst(2).
    return DropFirstSequence(_base, dropping: _limit + k)
  }
}

----Swift.(file).PrefixSequence.init(_:Base,maxLength:Int)
extension PrefixSequence {
  public init(_ base: Base, maxLength: Int) {
    precondition(maxLength >= 0, "Can't take a prefix of negative length")
    _base = base
    _maxLength = maxLength
  }
}

----Swift.(file).Iterator.next()
extension PrefixSequence.Iterator: IteratorProtocol  {
  public mutating func next() -> Element? {
    if _remaining != 0 {
      _remaining &-= 1
      return _base.next()
    } else {
      return nil
    }
  }
}

----Swift.(file).PrefixSequence.makeIterator()
extension PrefixSequence: Sequence  {
  public __consuming func makeIterator() -> Iterator {
    return Iterator(_base.makeIterator(), maxLength: _maxLength)
  }
}

----Swift.(file).PrefixSequence.prefix(_:Int)
extension PrefixSequence: Sequence  {
  public __consuming func prefix(_ maxLength: Int) -> PrefixSequence<Base> {
    let length = Swift.min(maxLength, self._maxLength)
    return PrefixSequence(_base, maxLength: length)
  }
}

----Swift.(file).Iterator.next()
extension DropWhileSequence.Iterator: IteratorProtocol  {
  public mutating func next() -> Element? {
    guard let next = _nextElement else { return nil }
    _nextElement = _iterator.next()
    return next
  }
}

----Swift.(file).DropWhileSequence.makeIterator()
extension DropWhileSequence: Sequence  {
  public func makeIterator() -> Iterator {
    return Iterator(_iterator, nextElement: _nextElement)
  }
}

----Swift.(file).DropWhileSequence.drop(while:(Base.Element) throws -> Bool)
extension DropWhileSequence: Sequence  {
  public __consuming func drop(
    while predicate: (Element) throws -> Bool
  ) rethrows -> DropWhileSequence<Base> {
    guard let x = _nextElement, try predicate(x) else { return self }
    return try DropWhileSequence(iterator: _iterator, predicate: predicate)
  }
}

----Swift.(file).Sequence.map(_:(Self.Element) throws -> T)
extension Sequence  {
  public func map<T>(
    _ transform: (Element) throws -> T
  ) rethrows -> [T] {
    let initialCapacity = underestimatedCount
    var result = ContiguousArray<T>()
    result.reserveCapacity(initialCapacity)

    var iterator = self.makeIterator()

    // Add elements up to the initial capacity without checking for regrowth.
    for _ in 0..<initialCapacity {
      result.append(try transform(iterator.next()!))
    }
    // Add remaining elements, if any.
    while let element = iterator.next() {
      result.append(try transform(element))
    }
    return Array(result)
  }
}

----Swift.(file).Sequence.filter(_:(Self.Element) throws -> Bool)
extension Sequence  {
  public __consuming func filter(
    _ isIncluded: (Element) throws -> Bool
  ) rethrows -> [Element] {
    return try _filter(isIncluded)
  }
}

----Swift.(file).Sequence.underestimatedCount
extension Sequence  {
  public var underestimatedCount: Int {
    return 0
  }
}

----Swift.(file).Sequence.forEach(_:(Self.Element) throws -> Void)
extension Sequence  {
  public func forEach(
    _ body: (Element) throws -> Void
  ) rethrows {
    for element in self {
      try body(element)
    }
  }
}

----Swift.(file).Sequence.first(where:(Self.Element) throws -> Bool)
extension Sequence  {
  public func first(
    where predicate: (Element) throws -> Bool
  ) rethrows -> Element? {
    for element in self  {
      if try predicate(element) {
        return element
      }
    }
    return nil
  }
}

----Swift.(file).Sequence.split(separator:Self.Element,maxSplits:Int,omittingEmptySubsequences:Bool)
extension Sequence where Element : Equatable  {
  public __consuming func split(
    separator: Element,
    maxSplits: Int = Int.max,
    omittingEmptySubsequences: Bool = true
  ) -> [ArraySlice<Element>] {
    return split(
      maxSplits: maxSplits,
      omittingEmptySubsequences: omittingEmptySubsequences,
      whereSeparator: { $0 == separator })
  }
}

----Swift.(file).Sequence.split(maxSplits:Int,omittingEmptySubsequences:Bool,whereSeparator:(Self.Element) throws -> Bool)
extension Sequence  {
  public __consuming func split(
    maxSplits: Int = Int.max,
    omittingEmptySubsequences: Bool = true,
    whereSeparator isSeparator: (Element) throws -> Bool
  ) rethrows -> [ArraySlice<Element>] {
    precondition(maxSplits >= 0, "Must take zero or more splits")
    let whole = Array(self)
    return try whole.split(
                  maxSplits: maxSplits, 
                  omittingEmptySubsequences: omittingEmptySubsequences, 
                  whereSeparator: isSeparator)
  }
}

----Swift.(file).Sequence.suffix(_:Int)
extension Sequence  {
  public __consuming func suffix(_ maxLength: Int) -> [Element] {
    precondition(maxLength >= 0, "Can't take a suffix of negative length from a sequence")
    guard maxLength != 0 else { return [] }

    // FIXME: <rdar://problem/21885650> Create reusable RingBuffer<T>
    // Put incoming elements into a ring buffer to save space. Once all
    // elements are consumed, reorder the ring buffer into an `Array`
    // and return it. This saves memory for sequences particularly longer
    // than `maxLength`.
    var ringBuffer: [Element] = []
    ringBuffer.reserveCapacity(Swift.min(maxLength, underestimatedCount))

    var i = 0

    for element in self {
      if ringBuffer.count < maxLength {
        ringBuffer.append(element)
      } else {
        ringBuffer[i] = element
        i += 1
        i %= maxLength
      }
    }

    if i != ringBuffer.startIndex {
      var rotated: [Element] = []
      rotated.reserveCapacity(ringBuffer.count)
      rotated += ringBuffer[i..<ringBuffer.endIndex]
      rotated += ringBuffer[0..<i]
      return rotated
    } else {      
      return ringBuffer
    }
  }
}

----Swift.(file).Sequence.dropFirst(_:Int)
extension Sequence  {
  public __consuming func dropFirst(_ k: Int = 1) -> DropFirstSequence<Self> {
    return DropFirstSequence(self, dropping: k)
  }
}

----Swift.(file).Sequence.dropLast(_:Int)
extension Sequence  {
  public __consuming func dropLast(_ k: Int = 1) -> [Element] {
    precondition(k >= 0, "Can't drop a negative number of elements from a sequence")
    guard k != 0 else { return Array(self) }

    // FIXME: <rdar://problem/21885650> Create reusable RingBuffer<T>
    // Put incoming elements from this sequence in a holding tank, a ring buffer
    // of size <= k. If more elements keep coming in, pull them out of the
    // holding tank into the result, an `Array`. This saves
    // `k` * sizeof(Element) of memory, because slices keep the entire
    // memory of an `Array` alive.
    var result: [Element] = []
    var ringBuffer: [Element] = []
    var i = ringBuffer.startIndex

    for element in self {
      if ringBuffer.count < k {
        ringBuffer.append(element)
      } else {
        result.append(ringBuffer[i])
        ringBuffer[i] = element
        i += 1
        i %= k
      }
    }
    return result
  }
}

----Swift.(file).Sequence.drop(while:(Self.Element) throws -> Bool)
extension Sequence  {
  public __consuming func drop(
    while predicate: (Element) throws -> Bool
  ) rethrows -> DropWhileSequence<Self> {
    return try DropWhileSequence(self, predicate: predicate)
  }
}

----Swift.(file).Sequence.prefix(_:Int)
extension Sequence  {
  public __consuming func prefix(_ maxLength: Int) -> PrefixSequence<Self> {
    return PrefixSequence(self, maxLength: maxLength)
  }
}

----Swift.(file).Sequence.prefix(while:(Self.Element) throws -> Bool)
extension Sequence  {
  public __consuming func prefix(
    while predicate: (Element) throws -> Bool
  ) rethrows -> [Element] {
    var result: [Element] = []

    for element in self {
      guard try predicate(element) else {
        break
      }
      result.append(element)
    }
    return result
  }
}

----Swift.(file).Sequence.withContiguousStorageIfAvailable(_:(UnsafeBufferPointer<Self.Element>) throws -> R)
extension Sequence  {
  public func withContiguousStorageIfAvailable<R>(
    _ body: (UnsafeBufferPointer<Element>) throws -> R
  ) rethrows -> R? {
    return nil
  }
}

----Swift.(file).IteratorSequence.init(_:Base)
extension IteratorSequence {
  public init(_ base: Base) {
    _base = base
  }
}

----Swift.(file).IteratorSequence.next()
extension IteratorSequence: IteratorProtocol, Sequence  {
  public mutating func next() -> Base.Element? {
    return _base.next()
  }
}

----Swift.(file).Sequence.enumerated()
extension Sequence  {
  public func enumerated() -> EnumeratedSequence<Self> {
    return EnumeratedSequence(_base: self)
  }
}

----Swift.(file).Sequence.min(by:(Self.Element, Self.Element) throws -> Bool)
extension Sequence  {
  public func min(
    by areInIncreasingOrder: (Element, Element) throws -> Bool
  ) rethrows -> Element? {
    var it = makeIterator()
    guard var result = it.next() else { return nil }
    while let e = it.next() {
      if try areInIncreasingOrder(e, result) { result = e }
    }
    return result
  }
}

----Swift.(file).Sequence.max(by:(Self.Element, Self.Element) throws -> Bool)
extension Sequence  {
  public func max(
    by areInIncreasingOrder: (Element, Element) throws -> Bool
  ) rethrows -> Element? {
    var it = makeIterator()
    guard var result = it.next() else { return nil }
    while let e = it.next() {
      if try areInIncreasingOrder(result, e) { result = e }
    }
    return result
  }
}

----Swift.(file).Sequence.min()
extension Sequence where Element: Comparable  {
  public func min() -> Element? {
    return self.min(by: <)
  }
}

----Swift.(file).Sequence.max()
extension Sequence where Element: Comparable  {
  public func max() -> Element? {
    return self.max(by: <)
  }
}

----Swift.(file).Sequence.starts(with:PossiblePrefix,by:(Self.Element, PossiblePrefix.Element) throws -> Bool)
extension Sequence   {
  public func starts<PossiblePrefix: Sequence>(
    with possiblePrefix: PossiblePrefix,
    by areEquivalent: (Element, PossiblePrefix.Element) throws -> Bool
  ) rethrows -> Bool {
    var possiblePrefixIterator = possiblePrefix.makeIterator()
    for e0 in self {
      if let e1 = possiblePrefixIterator.next() {
        if try !areEquivalent(e0, e1) {
          return false
        }
      }
      else {
        return true
      }
    }
    return possiblePrefixIterator.next() == nil
  }
}

----Swift.(file).Sequence.starts(with:PossiblePrefix)
extension Sequence where Element: Equatable  {
  public func starts<PossiblePrefix: Sequence>(
    with possiblePrefix: PossiblePrefix
  ) -> Bool where PossiblePrefix.Element == Element {
    return self.starts(with: possiblePrefix, by: ==)
  }
}

----Swift.(file).Sequence.elementsEqual(_:OtherSequence,by:(Self.Element, OtherSequence.Element) throws -> Bool)
extension Sequence  {
  public func elementsEqual<OtherSequence: Sequence>(
    _ other: OtherSequence,
    by areEquivalent: (Element, OtherSequence.Element) throws -> Bool
  ) rethrows -> Bool {
    var iter1 = self.makeIterator()
    var iter2 = other.makeIterator()
    while true {
      switch (iter1.next(), iter2.next()) {
      case let (e1?, e2?):
        if try !areEquivalent(e1, e2) {
          return false
        }
      case (_?, nil), (nil, _?): return false
      case (nil, nil):           return true
      }
    }
  }
}

----Swift.(file).Sequence.elementsEqual(_:OtherSequence)
extension Sequence where Element : Equatable  {
  public func elementsEqual<OtherSequence: Sequence>(
    _ other: OtherSequence
  ) -> Bool where OtherSequence.Element == Element {
    return self.elementsEqual(other, by: ==)
  }
}

----Swift.(file).Sequence.lexicographicallyPrecedes(_:OtherSequence,by:(Self.Element, Self.Element) throws -> Bool)
extension Sequence  {
  public func lexicographicallyPrecedes<OtherSequence: Sequence>(
    _ other: OtherSequence,
    by areInIncreasingOrder: (Element, Element) throws -> Bool
  ) rethrows -> Bool 
  where OtherSequence.Element == Element {
    var iter1 = self.makeIterator()
    var iter2 = other.makeIterator()
    while true {
      if let e1 = iter1.next() {
        if let e2 = iter2.next() {
          if try areInIncreasingOrder(e1, e2) {
            return true
          }
          if try areInIncreasingOrder(e2, e1) {
            return false
          }
          continue // Equivalent
        }
        return false
      }

      return iter2.next() != nil
    }
  }
}

----Swift.(file).Sequence.lexicographicallyPrecedes(_:OtherSequence)
extension Sequence where Element : Comparable  {
  public func lexicographicallyPrecedes<OtherSequence: Sequence>(
    _ other: OtherSequence
  ) -> Bool where OtherSequence.Element == Element {
    return self.lexicographicallyPrecedes(other, by: <)
  }
}

----Swift.(file).Sequence.contains(where:(Self.Element) throws -> Bool)
extension Sequence  {
  public func contains(
    where predicate: (Element) throws -> Bool
  ) rethrows -> Bool {
    for e in self {
      if try predicate(e) {
        return true
      }
    }
    return false
  }
}

----Swift.(file).Sequence.allSatisfy(_:(Self.Element) throws -> Bool)
extension Sequence  {
  public func allSatisfy(
    _ predicate: (Element) throws -> Bool
  ) rethrows -> Bool {
    return try !contains { try !predicate($0) }
  }
}

----Swift.(file).Sequence.contains(_:Self.Element)
extension Sequence where Element : Equatable  {
  public func contains(_ element: Element) -> Bool {
    if let result = _customContainsEquatableElement(element) {
      return result
    } else {
      return self.contains { $0 == element }
    }
  }
}

----Swift.(file).Sequence.count(where:(Self.Element) throws -> Bool)
extension Sequence  {
  public func count(
    where predicate: (Element) throws -> Bool
  ) rethrows -> Int {
    var count = 0
    for e in self {
      if try predicate(e) {
        count += 1
      }
    }
    return count
  }
}

----Swift.(file).Sequence.reduce(_:Result,_:(Result, Self.Element) throws -> Result)
extension Sequence  {
  public func reduce<Result>(
    _ initialResult: Result,
    _ nextPartialResult:
      (_ partialResult: Result, Element) throws -> Result
  ) rethrows -> Result {
    var accumulator = initialResult
    for element in self {
      accumulator = try nextPartialResult(accumulator, element)
    }
    return accumulator
  }
}

----Swift.(file).Sequence.reduce(into:Result,_:(inout Result, Self.Element) throws -> ())
extension Sequence  {
  public func reduce<Result>(
    into initialResult: __owned Result,
    _ updateAccumulatingResult:
      (_ partialResult: inout Result, Element) throws -> ()
  ) rethrows -> Result {
    var accumulator = initialResult
    for element in self {
      try updateAccumulatingResult(&accumulator, element)
    }
    return accumulator
  }
}

----Swift.(file).Sequence.reversed()
extension Sequence  {
  public __consuming func reversed() -> [Element] {
    // FIXME(performance): optimize to 1 pass?  But Array(self) can be
    // optimized to a memcpy() sometimes.  Those cases are usually collections,
    // though.
    var result = Array(self)
    let count = result.count
    for i in 0..<count/2 {
      result.swapAt(i, count - ((i + 1) as Int))
    }
    return result
  }
}

----Swift.(file).Sequence.flatMap(_:(Self.Element) throws -> SegmentOfResult)
extension Sequence  {
  public func flatMap<SegmentOfResult : Sequence>(
    _ transform: (Element) throws -> SegmentOfResult
  ) rethrows -> [SegmentOfResult.Element] {
    var result: [SegmentOfResult.Element] = []
    for element in self {
      result.append(contentsOf: try transform(element))
    }
    return result
  }
}

----Swift.(file).Sequence.compactMap(_:(Self.Element) throws -> ElementOfResult?)
extension Sequence  {
  public func compactMap<ElementOfResult>(
    _ transform: (Element) throws -> ElementOfResult?
  ) rethrows -> [ElementOfResult] {
    return try _compactMap(transform)
  }
}

----Swift.(file).Set.init(minimumCapacity:Int)
extension Set {
  init(minimumCapacity: Int) {
    _variant = _Variant(native: _NativeSet(capacity: minimumCapacity))
  }
}

----Swift.(file).Set.init(arrayLiteral:[Element])
extension Set: ExpressibleByArrayLiteral  {
  public init(arrayLiteral elements: Element...) {
    if elements.isEmpty {
      self.init()
      return
    }
    let native = _NativeSet<Element>(capacity: elements.count)
    for element in elements {
      let (bucket, found) = native.find(element)
      if found {
        // FIXME: Shouldn't this trap?
        continue
      }
      native._unsafeInsertNew(element, at: bucket)
    }
    self.init(_native: native)
  }
}

----Swift.(file).Set.makeIterator()
extension Set: Sequence  {
  public __consuming func makeIterator() -> Iterator {
    return _variant.makeIterator()
  }
}

----Swift.(file).Set.contains(_:Element)
extension Set: Sequence  {
  public func contains(_ member: Element) -> Bool {
    return _variant.contains(member)
  }
}

----Swift.(file).Set.filter(_:(Element) throws -> Bool)
extension Set  {
  public __consuming func filter(
    _ isIncluded: (Element) throws -> Bool
  ) rethrows -> Set {
    // FIXME(performance): Eliminate rehashes by using a bitmap.
    var result = Set()
    for element in self {
      if try isIncluded(element) {
        result.insert(element)
      }
    }
    return result
  }
}

----Swift.(file).Set.startIndex
extension Set: Collection  {
  public var startIndex: Index {
    return _variant.startIndex
  }
}

----Swift.(file).Set.endIndex
extension Set: Collection  {
  public var endIndex: Index {
    return _variant.endIndex
  }
}

----Swift.(file).Set.subscript(_:Set<Element>.Index)
extension Set: Collection  {
  public subscript(position: Index) -> Element {
    //FIXME(accessors): Provide a _read
    get {
      return _variant.element(at: position)
    }
  }
}

----Swift.(file).Set.index(after:Set<Element>.Index)
extension Set: Collection  {
  public func index(after i: Index) -> Index {
    return _variant.index(after: i)
  }
}

----Swift.(file).Set.formIndex(after:Set<Element>.Index)
extension Set: Collection  {
  public func formIndex(after i: inout Index) {
    _variant.formIndex(after: &i)
  }
}

----Swift.(file).Set.firstIndex(of:Element)
extension Set: Collection  {
  public func firstIndex(of member: Element) -> Index? {
    return _variant.index(for: member)
  }
}

----Swift.(file).Set.count
extension Set: Collection  {
  public var count: Int {
    return _variant.count
  }
}

----Swift.(file).Set.isEmpty
extension Set: Collection  {
  public var isEmpty: Bool {
    return count == 0
  }
}

----Swift.(file).Set.hash(into:Hasher)
extension Set: Hashable  {
  public func hash(into hasher: inout Hasher) {
    // FIXME(ABI)#177: <rdar://problem/18915294> Cache Set<T> hashValue

    // Generate a seed from a snapshot of the hasher.  This makes members' hash
    // values depend on the state of the hasher, which improves hashing
    // quality. (E.g., it makes it possible to resolve collisions by passing in
    // a different hasher.)
    var copy = hasher
    let seed = copy._finalize()

    var hash = 0
    for member in self {
      hash ^= member._rawHashValue(seed: seed)
    }
    hasher.combine(hash)
  }
}

----Swift.(file).Set.insert(_:Element)
extension Set: SetAlgebra  {
  public mutating func insert(
    _ newMember: __owned Element
  ) -> (inserted: Bool, memberAfterInsert: Element) {
    return _variant.insert(newMember)
  }
}

----Swift.(file).Set.update(with:Element)
extension Set: SetAlgebra  {
  public mutating func update(with newMember: __owned Element) -> Element? {
    return _variant.update(with: newMember)
  }
}

----Swift.(file).Set.remove(_:Element)
extension Set: SetAlgebra  {
  public mutating func remove(_ member: Element) -> Element? {
    return _variant.remove(member)
  }
}

----Swift.(file).Set.remove(at:Set<Element>.Index)
extension Set: SetAlgebra  {
  public mutating func remove(at position: Index) -> Element {
    return _variant.remove(at: position)
  }
}

----Swift.(file).Set.removeAll(keepingCapacity:Bool)
extension Set: SetAlgebra  {
  public mutating func removeAll(keepingCapacity keepCapacity: Bool = false) {
    _variant.removeAll(keepingCapacity: keepCapacity)
  }
}

----Swift.(file).Set.removeFirst()
extension Set: SetAlgebra  {
  public mutating func removeFirst() -> Element {
    precondition(!isEmpty, "Can't removeFirst from an empty Set")
    return remove(at: startIndex)
  }
}

----Swift.(file).Set.init()
extension Set: SetAlgebra  {
  public init() {
    self = Set<Element>(_native: _NativeSet())
  }
}

----Swift.(file).Set.init(_:Source)
extension Set: SetAlgebra  {
  public init<Source: Sequence>(_ sequence: __owned Source)
  where Source.Element == Element {
    self.init(minimumCapacity: sequence.underestimatedCount)
    if let s = sequence as? Set<Element> {
      // If this sequence is actually a native `Set`, then we can quickly
      // adopt its native buffer and let COW handle uniquing only
      // if necessary.
      self._variant = s._variant
    } else {
      for item in sequence {
        insert(item)
      }
    }
  }
}

----Swift.(file).Set.isSubset(of:S)
extension Set: SetAlgebra  {
  public func isSubset<S: Sequence>(of possibleSuperset: S) -> Bool
  where S.Element == Element {
    guard !isEmpty else { return true }
    
    let other = Set(possibleSuperset)
    return isSubset(of: other)
  }
}

----Swift.(file).Set.isStrictSubset(of:S)
extension Set: SetAlgebra  {
  public func isStrictSubset<S: Sequence>(of possibleStrictSuperset: S) -> Bool
  where S.Element == Element {
    // FIXME: code duplication.
    let other = Set(possibleStrictSuperset)
    return isStrictSubset(of: other)
  }
}

----Swift.(file).Set.isSuperset(of:S)
extension Set: SetAlgebra  {
  public func isSuperset<S: Sequence>(of possibleSubset: __owned S) -> Bool
    where S.Element == Element {
    for member in possibleSubset {
      if !contains(member) {
        return false
      }
    }
    return true
  }
}

----Swift.(file).Set.isStrictSuperset(of:S)
extension Set: SetAlgebra  {
  public func isStrictSuperset<S: Sequence>(of possibleStrictSubset: S) -> Bool
  where S.Element == Element {
    let other = Set(possibleStrictSubset)
    return other.isStrictSubset(of: self)
  }
}

----Swift.(file).Set.isDisjoint(with:S)
extension Set: SetAlgebra  {
  public func isDisjoint<S: Sequence>(with other: S) -> Bool
  where S.Element == Element {
    return _isDisjoint(with: other)
  }
}

----Swift.(file).Set.union(_:S)
extension Set: SetAlgebra  {
  public __consuming func union<S: Sequence>(_ other: __owned S) -> Set<Element>
  where S.Element == Element {
    var newSet = self
    newSet.formUnion(other)
    return newSet
  }
}

----Swift.(file).Set.formUnion(_:S)
extension Set: SetAlgebra  {
  public mutating func formUnion<S: Sequence>(_ other: __owned S)
  where S.Element == Element {
    for item in other {
      insert(item)
    }
  }
}

----Swift.(file).Set.subtracting(_:S)
extension Set: SetAlgebra  {
  public __consuming func subtracting<S: Sequence>(_ other: S) -> Set<Element>
  where S.Element == Element {
    return self._subtracting(other)
  }
}

----Swift.(file).Set.subtract(_:S)
extension Set: SetAlgebra  {
  public mutating func subtract<S: Sequence>(_ other: S)
  where S.Element == Element {
    _subtract(other)
  }
}

----Swift.(file).Set.intersection(_:S)
extension Set: SetAlgebra  {
  public __consuming func intersection<S: Sequence>(_ other: S) -> Set<Element>
  where S.Element == Element {
    let otherSet = Set(other)
    return intersection(otherSet)
  }
}

----Swift.(file).Set.formIntersection(_:S)
extension Set: SetAlgebra  {
  public mutating func formIntersection<S: Sequence>(_ other: S)
  where S.Element == Element {
    // Because `intersect` needs to both modify and iterate over
    // the left-hand side, the index may become invalidated during
    // traversal so an intermediate set must be created.
    //
    // FIXME(performance): perform this operation at a lower level
    // to avoid invalidating the index and avoiding a copy.
    let result = self.intersection(other)

    // The result can only have fewer or the same number of elements.
    // If no elements were removed, don't perform a reassignment
    // as this may cause an unnecessary uniquing COW.
    if result.count != count {
      self = result
    }
  }
}

----Swift.(file).Set.symmetricDifference(_:S)
extension Set: SetAlgebra  {
  public __consuming func symmetricDifference<S: Sequence>(
    _ other: __owned S
  ) -> Set<Element>
  where S.Element == Element {
    var newSet = self
    newSet.formSymmetricDifference(other)
    return newSet
  }
}

----Swift.(file).Set.formSymmetricDifference(_:S)
extension Set: SetAlgebra  {
  public mutating func formSymmetricDifference<S: Sequence>(
    _ other: __owned S)
  where S.Element == Element {
    let otherSet = Set(other)
    formSymmetricDifference(otherSet)
  }
}

----Swift.(file).Set.description
extension Set: CustomStringConvertible, CustomDebugStringConvertible  {
  public var description: String {
    return _makeCollectionDescription()
  }
}

----Swift.(file).Set.debugDescription
extension Set: CustomStringConvertible, CustomDebugStringConvertible  {
  public var debugDescription: String {
    return _makeCollectionDescription(withTypeName: "Set")
  }
}

----Swift.(file).Set.subtract(_:Set<Element>)
extension Set  {
  public mutating func subtract(_ other: Set<Element>) {
    _subtract(other)
  }
}

----Swift.(file).Set.isSubset(of:Set<Element>)
extension Set  {
  public func isSubset(of other: Set<Element>) -> Bool {
    guard self.count <= other.count else { return false }
    for member in self {
      if !other.contains(member) {
        return false
      }
    }
    return true
  }
}

----Swift.(file).Set.isSuperset(of:Set<Element>)
extension Set  {
  public func isSuperset(of other: Set<Element>) -> Bool {
    return other.isSubset(of: self)
  }
}

----Swift.(file).Set.isDisjoint(with:Set<Element>)
extension Set  {
  public func isDisjoint(with other: Set<Element>) -> Bool {
    return _isDisjoint(with: other)
  }
}

----Swift.(file).Set.subtracting(_:Set<Element>)
extension Set  {
  public __consuming func subtracting(_ other: Set<Element>) -> Set<Element> {
    return self._subtracting(other)
  }
}

----Swift.(file).Set.isStrictSuperset(of:Set<Element>)
extension Set  {
  public func isStrictSuperset(of other: Set<Element>) -> Bool {
    return self.isSuperset(of: other) && self != other
  }
}

----Swift.(file).Set.isStrictSubset(of:Set<Element>)
extension Set  {
  public func isStrictSubset(of other: Set<Element>) -> Bool {
    return other.isStrictSuperset(of: self)
  }
}

----Swift.(file).Set.intersection(_:Set<Element>)
extension Set  {
  public __consuming func intersection(_ other: Set<Element>) -> Set<Element> {
    var newSet = Set<Element>()
    for member in self {
      if other.contains(member) {
        newSet.insert(member)
      }
    }
    return newSet
  }
}

----Swift.(file).Set.formSymmetricDifference(_:Set<Element>)
extension Set  {
  public mutating func formSymmetricDifference(_ other: __owned Set<Element>) {
    for member in other {
      if contains(member) {
        remove(member)
      } else {
        insert(member)
      }
    }
  }
}

----Swift.(file).Set.customMirror
extension Set: CustomReflectable  {
  public var customMirror: Mirror {
    let style = Mirror.DisplayStyle.`set`
    return Mirror(self, unlabeledChildren: self, displayStyle: style)
  }
}

----Swift.(file).Set.popFirst()
extension Set  {
  public mutating func popFirst() -> Element? {
    guard !isEmpty else { return nil }
    return remove(at: startIndex)
  }
}

----Swift.(file).Set.capacity
extension Set  {
  public var capacity: Int {
    return _variant.capacity
  }
}

----Swift.(file).Set.reserveCapacity(_:Int)
extension Set  {
  mutating func reserveCapacity(_ minimumCapacity: Int) {
    _variant.reserveCapacity(minimumCapacity)
    _internalInvariant(self.capacity >= minimumCapacity)
  }
}

----Swift.(file).SetAlgebra.isEmpty
extension SetAlgebra {
  var isEmpty: Bool { get }
}

----Swift.(file).SetAlgebra.init(_:S)
extension SetAlgebra  {
  public init<S : Sequence>(_ sequence: __owned S)
    where S.Element == Element {
    self.init()
    for e in sequence { insert(e) }
  }
}

----Swift.(file).SetAlgebra.subtract(_:Self)
extension SetAlgebra  {
  public mutating func subtract(_ other: Self) {
    self.formIntersection(self.symmetricDifference(other))
  }
}

----Swift.(file).SetAlgebra.isSubset(of:Self)
extension SetAlgebra  {
  public func isSubset(of other: Self) -> Bool {
    return self.intersection(other) == self
  }
}

----Swift.(file).SetAlgebra.isSuperset(of:Self)
extension SetAlgebra  {
  public func isSuperset(of other: Self) -> Bool {
    return other.isSubset(of: self)
  }
}

----Swift.(file).SetAlgebra.isDisjoint(with:Self)
extension SetAlgebra  {
  public func isDisjoint(with other: Self) -> Bool {
    return self.intersection(other).isEmpty
  }
}

----Swift.(file).SetAlgebra.subtracting(_:Self)
extension SetAlgebra  {
  public func subtracting(_ other: Self) -> Self {
    return self.intersection(self.symmetricDifference(other))
  }
}

----Swift.(file).SetAlgebra.isEmpty
extension SetAlgebra  {
  public var isEmpty: Bool {
    return self == Self()
  }
}

----Swift.(file).SetAlgebra.isStrictSuperset(of:Self)
extension SetAlgebra  {
  public func isStrictSuperset(of other: Self) -> Bool {
    return self.isSuperset(of: other) && self != other
  }
}

----Swift.(file).SetAlgebra.isStrictSubset(of:Self)
extension SetAlgebra  {
  public func isStrictSubset(of other: Self) -> Bool {
    return other.isStrictSuperset(of: self)
  }
}

----Swift.(file).SetAlgebra.init(arrayLiteral:[Self.Element])
extension SetAlgebra where Element == ArrayLiteralElement  {
  public init(arrayLiteral: Element...) {
    self.init(arrayLiteral)
  }
}

----Swift.(file).Set.insert(_:ConcreteElement)
extension Set where Element == AnyHashable  {
  public mutating func insert<ConcreteElement : Hashable>(
    _ newMember: __owned ConcreteElement
  ) -> (inserted: Bool, memberAfterInsert: ConcreteElement) {
    let (inserted, memberAfterInsert) =
      insert(AnyHashable(newMember))
    return (
      inserted: inserted,
      memberAfterInsert: memberAfterInsert.base as! ConcreteElement)
  }
}

----Swift.(file).Set.update(with:ConcreteElement)
extension Set where Element == AnyHashable  {
  public mutating func update<ConcreteElement : Hashable>(
    with newMember: __owned ConcreteElement
  ) -> ConcreteElement? {
    return update(with: AnyHashable(newMember))
      .map { $0.base as! ConcreteElement }
  }
}

----Swift.(file).Set.remove(_:ConcreteElement)
extension Set where Element == AnyHashable  {
  public mutating func remove<ConcreteElement : Hashable>(
    _ member: ConcreteElement
  ) -> ConcreteElement? {
    return remove(AnyHashable(member))
      .map { $0.base as! ConcreteElement }
  }
}

----Swift.(file).Slice.init(base:Base,bounds:Range<Base.Index>)
extension Slice {
  public init(base: Base, bounds: Range<Base.Index>) {
    self._base = base
    self._startIndex = bounds.lowerBound
    self._endIndex = bounds.upperBound
  }
}

----Swift.(file).Slice.base
extension Slice {
  public var base: Base {
    return _base
  }
}

----Swift.(file).Slice.startIndex
extension Slice: Collection  {
  public var startIndex: Index {
    return _startIndex
  }
}

----Swift.(file).Slice.endIndex
extension Slice: Collection  {
  public var endIndex: Index {
    return _endIndex
  }
}

----Swift.(file).Slice.subscript(_:Slice<Base>.Index)
extension Slice: Collection  {
  public subscript(index: Index) -> Base.Element {
    get {
      _failEarlyRangeCheck(index, bounds: startIndex..<endIndex)
      return _base[index]
    }
  }
}

----Swift.(file).Slice.subscript(_:Range<Slice<Base>.Index>)
extension Slice: Collection  {
  public subscript(bounds: Range<Index>) -> Slice<Base> {
    get {
      _failEarlyRangeCheck(bounds, bounds: startIndex..<endIndex)
      return Slice(base: _base, bounds: bounds)
    }
  }
}

----Swift.(file).Slice.indices
extension Slice: Collection  {
  public var indices: Indices { 
    return _base.indices[_startIndex..<_endIndex]
  }
}

----Swift.(file).Slice.index(after:Slice<Base>.Index)
extension Slice: Collection  {
  public func index(after i: Index) -> Index {
    // FIXME: swift-3-indexing-model: range check.
    return _base.index(after: i)
  }
}

----Swift.(file).Slice.formIndex(after:Slice<Base>.Index)
extension Slice: Collection  {
  public func formIndex(after i: inout Index) {
    // FIXME: swift-3-indexing-model: range check.
    _base.formIndex(after: &i)
  }
}

----Swift.(file).Slice.index(_:Slice<Base>.Index,offsetBy:Int)
extension Slice: Collection  {
  public func index(_ i: Index, offsetBy n: Int) -> Index {
    // FIXME: swift-3-indexing-model: range check.
    return _base.index(i, offsetBy: n)
  }
}

----Swift.(file).Slice.index(_:Slice<Base>.Index,offsetBy:Int,limitedBy:Slice<Base>.Index)
extension Slice: Collection  {
  public func index(
    _ i: Index, offsetBy n: Int, limitedBy limit: Index
  ) -> Index? {
    // FIXME: swift-3-indexing-model: range check.
    return _base.index(i, offsetBy: n, limitedBy: limit)
  }
}

----Swift.(file).Slice.distance(from:Slice<Base>.Index,to:Slice<Base>.Index)
extension Slice: Collection  {
  public func distance(from start: Index, to end: Index) -> Int {
    // FIXME: swift-3-indexing-model: range check.
    return _base.distance(from: start, to: end)
  }
}

----Swift.(file).Slice.index(before:Slice<Base>.Index)
extension Slice: BidirectionalCollection where Base: BidirectionalCollection  {
  public func index(before i: Index) -> Index {
    // FIXME: swift-3-indexing-model: range check.
    return _base.index(before: i)
  }
}

----Swift.(file).Slice.formIndex(before:Slice<Base>.Index)
extension Slice: BidirectionalCollection where Base: BidirectionalCollection  {
  public func formIndex(before i: inout Index) {
    // FIXME: swift-3-indexing-model: range check.
    _base.formIndex(before: &i)
  }
}

----Swift.(file).Slice.subscript(_:Slice<Base>.Index)
extension Slice: MutableCollection where Base: MutableCollection  {
  public subscript(index: Index) -> Base.Element {
    get {
      _failEarlyRangeCheck(index, bounds: startIndex..<endIndex)
      return _base[index]
    }
    set {
      _failEarlyRangeCheck(index, bounds: startIndex..<endIndex)
      _base[index] = newValue
      // MutableSlice requires that the underlying collection's subscript
      // setter does not invalidate indices, so our `startIndex` and `endIndex`
      // continue to be valid.
    }
  }
}

----Swift.(file).Slice.subscript(_:Range<Slice<Base>.Index>)
extension Slice: MutableCollection where Base: MutableCollection  {
  public subscript(bounds: Range<Index>) -> Slice<Base> {
    get {
      _failEarlyRangeCheck(bounds, bounds: startIndex..<endIndex)
      return Slice(base: _base, bounds: bounds)
    }
    set {
      _writeBackMutableSlice(&self, bounds: bounds, slice: newValue)
    }
  }
}

----Swift.(file).Slice.init()
extension Slice: RangeReplaceableCollection
  where Base: RangeReplaceableCollection  {
  public init() {
    self._base = Base()
    self._startIndex = _base.startIndex
    self._endIndex = _base.endIndex
  }
}

----Swift.(file).Slice.init(repeating:Base.Element,count:Int)
extension Slice: RangeReplaceableCollection
  where Base: RangeReplaceableCollection  {
  public init(repeating repeatedValue: Base.Element, count: Int) {
    self._base = Base(repeating: repeatedValue, count: count)
    self._startIndex = _base.startIndex
    self._endIndex = _base.endIndex
  }
}

----Swift.(file).Slice.replaceSubrange(_:Range<Slice<Base>.Index>,with:C)
extension Slice: RangeReplaceableCollection
  where Base: RangeReplaceableCollection  {
  public mutating func replaceSubrange<C>(
    _ subRange: Range<Index>, with newElements: C
  ) where C : Collection, C.Element == Base.Element {

    // FIXME: swift-3-indexing-model: range check.
    let sliceOffset =
      _base.distance(from: _base.startIndex, to: _startIndex)
    let newSliceCount =
      _base.distance(from: _startIndex, to: subRange.lowerBound)
      + _base.distance(from: subRange.upperBound, to: _endIndex)
      + (numericCast(newElements.count) as Int)
    _base.replaceSubrange(subRange, with: newElements)
    _startIndex = _base.index(_base.startIndex, offsetBy: sliceOffset)
    _endIndex = _base.index(_startIndex, offsetBy: newSliceCount)
  }
}

----Swift.(file).Slice.insert(_:Base.Element,at:Slice<Base>.Index)
extension Slice: RangeReplaceableCollection
  where Base: RangeReplaceableCollection  {
  public mutating func insert(_ newElement: Base.Element, at i: Index) {
    // FIXME: swift-3-indexing-model: range check.
    let sliceOffset = _base.distance(from: _base.startIndex, to: _startIndex)
    let newSliceCount = count + 1
    _base.insert(newElement, at: i)
    _startIndex = _base.index(_base.startIndex, offsetBy: sliceOffset)
    _endIndex = _base.index(_startIndex, offsetBy: newSliceCount)
  }
}

----Swift.(file).Slice.insert(contentsOf:S,at:Slice<Base>.Index)
extension Slice: RangeReplaceableCollection
  where Base: RangeReplaceableCollection  {
  public mutating func insert<S>(contentsOf newElements: S, at i: Index)
  where S: Collection, S.Element == Base.Element {

    // FIXME: swift-3-indexing-model: range check.
    let sliceOffset = _base.distance(from: _base.startIndex, to: _startIndex)
    let newSliceCount = count + newElements.count
    _base.insert(contentsOf: newElements, at: i)
    _startIndex = _base.index(_base.startIndex, offsetBy: sliceOffset)
    _endIndex = _base.index(_startIndex, offsetBy: newSliceCount)
  }
}

----Swift.(file).Slice.remove(at:Slice<Base>.Index)
extension Slice: RangeReplaceableCollection
  where Base: RangeReplaceableCollection  {
  public mutating func remove(at i: Index) -> Base.Element {
    // FIXME: swift-3-indexing-model: range check.
    let sliceOffset = _base.distance(from: _base.startIndex, to: _startIndex)
    let newSliceCount = count - 1
    let result = _base.remove(at: i)
    _startIndex = _base.index(_base.startIndex, offsetBy: sliceOffset)
    _endIndex = _base.index(_startIndex, offsetBy: newSliceCount)
    return result
  }
}

----Swift.(file).Slice.removeSubrange(_:Range<Slice<Base>.Index>)
extension Slice: RangeReplaceableCollection
  where Base: RangeReplaceableCollection  {
  public mutating func removeSubrange(_ bounds: Range<Index>) {
    // FIXME: swift-3-indexing-model: range check.
    let sliceOffset = _base.distance(from: _base.startIndex, to: _startIndex)
    let newSliceCount =
      count - distance(from: bounds.lowerBound, to: bounds.upperBound)
    _base.removeSubrange(bounds)
    _startIndex = _base.index(_base.startIndex, offsetBy: sliceOffset)
    _endIndex = _base.index(_startIndex, offsetBy: newSliceCount)
  }
}

----Swift.(file).Slice.replaceSubrange(_:Range<Slice<Base>.Index>,with:C)
extension Slice
  where Base: RangeReplaceableCollection, Base: BidirectionalCollection  {
  public mutating func replaceSubrange<C>(
    _ subRange: Range<Index>, with newElements: C
  ) where C : Collection, C.Element == Base.Element {
    // FIXME: swift-3-indexing-model: range check.
    if subRange.lowerBound == _base.startIndex {
      let newSliceCount =
        _base.distance(from: _startIndex, to: subRange.lowerBound)
        + _base.distance(from: subRange.upperBound, to: _endIndex)
        + (numericCast(newElements.count) as Int)
      _base.replaceSubrange(subRange, with: newElements)
      _startIndex = _base.startIndex
      _endIndex = _base.index(_startIndex, offsetBy: newSliceCount)
    } else {
      let shouldUpdateStartIndex = subRange.lowerBound == _startIndex
      let lastValidIndex = _base.index(before: subRange.lowerBound)
      let newEndIndexOffset =
        _base.distance(from: subRange.upperBound, to: _endIndex)
        + (numericCast(newElements.count) as Int) + 1
      _base.replaceSubrange(subRange, with: newElements)
      if shouldUpdateStartIndex {
        _startIndex = _base.index(after: lastValidIndex)
      }
      _endIndex = _base.index(lastValidIndex, offsetBy: newEndIndexOffset)
    }
  }
}

----Swift.(file).Slice.insert(_:Base.Element,at:Slice<Base>.Index)
extension Slice
  where Base: RangeReplaceableCollection, Base: BidirectionalCollection  {
  public mutating func insert(_ newElement: Base.Element, at i: Index) {
    // FIXME: swift-3-indexing-model: range check.
    if i == _base.startIndex {
      let newSliceCount = count + 1
      _base.insert(newElement, at: i)
      _startIndex = _base.startIndex
      _endIndex = _base.index(_startIndex, offsetBy: newSliceCount)
    } else {
      let shouldUpdateStartIndex = i == _startIndex
      let lastValidIndex = _base.index(before: i)
      let newEndIndexOffset = _base.distance(from: i, to: _endIndex) + 2
      _base.insert(newElement, at: i)
      if shouldUpdateStartIndex {
        _startIndex = _base.index(after: lastValidIndex)
      }
      _endIndex = _base.index(lastValidIndex, offsetBy: newEndIndexOffset)
    }
  }
}

----Swift.(file).Slice.insert(contentsOf:S,at:Slice<Base>.Index)
extension Slice
  where Base: RangeReplaceableCollection, Base: BidirectionalCollection  {
  public mutating func insert<S>(contentsOf newElements: S, at i: Index)
  where S : Collection, S.Element == Base.Element {
    // FIXME: swift-3-indexing-model: range check.
    if i == _base.startIndex {
      let newSliceCount = count + numericCast(newElements.count)
      _base.insert(contentsOf: newElements, at: i)
      _startIndex = _base.startIndex
      _endIndex = _base.index(_startIndex, offsetBy: newSliceCount)
    } else {
      let shouldUpdateStartIndex = i == _startIndex
      let lastValidIndex = _base.index(before: i)
      let newEndIndexOffset =
        _base.distance(from: i, to: _endIndex)
        + numericCast(newElements.count) + 1
      _base.insert(contentsOf: newElements, at: i)
      if shouldUpdateStartIndex {
        _startIndex = _base.index(after: lastValidIndex)
      }
      _endIndex = _base.index(lastValidIndex, offsetBy: newEndIndexOffset)
    }
  }
}

----Swift.(file).Slice.remove(at:Slice<Base>.Index)
extension Slice
  where Base: RangeReplaceableCollection, Base: BidirectionalCollection  {
  public mutating func remove(at i: Index) -> Base.Element {
    // FIXME: swift-3-indexing-model: range check.
    if i == _base.startIndex {
      let newSliceCount = count - 1
      let result = _base.remove(at: i)
      _startIndex = _base.startIndex
      _endIndex = _base.index(_startIndex, offsetBy: newSliceCount)
      return result
    } else {
      let shouldUpdateStartIndex = i == _startIndex
      let lastValidIndex = _base.index(before: i)
      let newEndIndexOffset = _base.distance(from: i, to: _endIndex)
      let result = _base.remove(at: i)
      if shouldUpdateStartIndex {
        _startIndex = _base.index(after: lastValidIndex)
      }
      _endIndex = _base.index(lastValidIndex, offsetBy: newEndIndexOffset)
      return result
    }
  }
}

----Swift.(file).Slice.removeSubrange(_:Range<Slice<Base>.Index>)
extension Slice
  where Base: RangeReplaceableCollection, Base: BidirectionalCollection  {
  public mutating func removeSubrange(_ bounds: Range<Index>) {
    // FIXME: swift-3-indexing-model: range check.
    if bounds.lowerBound == _base.startIndex {
      let newSliceCount =
        count - _base.distance(from: bounds.lowerBound, to: bounds.upperBound)
      _base.removeSubrange(bounds)
      _startIndex = _base.startIndex
      _endIndex = _base.index(_startIndex, offsetBy: newSliceCount)
    } else {
      let shouldUpdateStartIndex = bounds.lowerBound == _startIndex
      let lastValidIndex = _base.index(before: bounds.lowerBound)
      let newEndIndexOffset =
          _base.distance(from: bounds.lowerBound, to: _endIndex)
        - _base.distance(from: bounds.lowerBound, to: bounds.upperBound)
        + 1
      _base.removeSubrange(bounds)
      if shouldUpdateStartIndex {
        _startIndex = _base.index(after: lastValidIndex)
      }
      _endIndex = _base.index(lastValidIndex, offsetBy: newEndIndexOffset)
    }
  }
}

----Swift.(file).Sequence.sorted()
extension Sequence where Element: Comparable  {
  public func sorted() -> [Element] {
    return sorted(by: <)
  }
}

----Swift.(file).Sequence.sorted(by:(Self.Element, Self.Element) throws -> Bool)
extension Sequence  {
  public func sorted(
    by areInIncreasingOrder:
      (Element, Element) throws -> Bool
  ) rethrows -> [Element] {
    var result = ContiguousArray(self)
    try result.sort(by: areInIncreasingOrder)
    return Array(result)
  }
}

----Swift.(file).MutableCollection.sort()
extension MutableCollection
where Self: RandomAccessCollection, Element: Comparable  {
  public mutating func sort() {
    sort(by: <)
  }
}

----Swift.(file).MutableCollection.sort(by:(Self.Element, Self.Element) throws -> Bool)
extension MutableCollection where Self: RandomAccessCollection  {
  public mutating func sort(
    by areInIncreasingOrder: (Element, Element) throws -> Bool
  ) rethrows {
    let didSortUnsafeBuffer = try _withUnsafeMutableBufferPointerIfSupported {
      buffer -> Void? in
        try buffer._stableSortImpl(by: areInIncreasingOrder)
    }
    if didSortUnsafeBuffer == nil {
      // Fallback since we can't use an unsafe buffer: sort into an outside
      // array, then copy elements back in.
      let sortedElements = try sorted(by: areInIncreasingOrder)
      for (i, j) in zip(indices, sortedElements.indices) {
        self[i] = sortedElements[j]
      }
    }
  }
}

----Swift.(file).StaticString.utf8Start
extension StaticString {
  public var utf8Start: UnsafePointer<UInt8> {
    precondition(
      hasPointerRepresentation,
      "StaticString should have pointer representation")
    return UnsafePointer(bitPattern: UInt(_startPtrOrData))!
  }
}

----Swift.(file).StaticString.unicodeScalar
extension StaticString {
  public var unicodeScalar: Unicode.Scalar {
    precondition(
      !hasPointerRepresentation,
      "StaticString should have Unicode scalar representation")
    return Unicode.Scalar(UInt32(UInt(_startPtrOrData)))!
  }
}

----Swift.(file).StaticString.utf8CodeUnitCount
extension StaticString {
  public var utf8CodeUnitCount: Int {
    precondition(
      hasPointerRepresentation,
      "StaticString should have pointer representation")
    return Int(_utf8CodeUnitCount)
  }
}

----Swift.(file).StaticString.hasPointerRepresentation
extension StaticString {
  public var hasPointerRepresentation: Bool {
    return (UInt8(_flags) & 0x1) == 0
  }
}

----Swift.(file).StaticString.isASCII
extension StaticString {
  public var isASCII: Bool {
    return (UInt8(_flags) & 0x2) != 0
  }
}

----Swift.(file).StaticString.withUTF8Buffer(_:(UnsafeBufferPointer<UInt8>) -> R)
extension StaticString {
  public func withUTF8Buffer<R>(
    _ body: (UnsafeBufferPointer<UInt8>) -> R) -> R {
    if hasPointerRepresentation {
      return body(UnsafeBufferPointer(
        start: utf8Start, count: utf8CodeUnitCount))
    } else {
      var buffer: UInt64 = 0
      var i = 0
      let sink: (UInt8) -> Void = {
#if _endian(little)
        buffer = buffer | (UInt64($0) << (UInt64(i) * 8))
#else
        buffer = buffer | (UInt64($0) << (UInt64(7-i) * 8))
#endif
        i += 1
      }
      UTF8.encode(unicodeScalar, into: sink)
      return body(UnsafeBufferPointer(
        start: UnsafePointer(Builtin.addressof(&buffer)),
        count: i))
    }
  }
}

----Swift.(file).StaticString.init()
extension StaticString {
  public init() {
    self = ""
  }
}

----Swift.(file).StaticString.init(_builtinUnicodeScalarLiteral:<<error type>>)
extension StaticString {
  public init(_builtinUnicodeScalarLiteral value: Builtin.Int32) {
    self = StaticString(unicodeScalar: value)
  }
}

----Swift.(file).StaticString.init(unicodeScalarLiteral:StaticString)
extension StaticString {
  public init(unicodeScalarLiteral value: StaticString) {
    self = value
  }
}

----Swift.(file).StaticString.init(_builtinExtendedGraphemeClusterLiteral:<<error type>>,utf8CodeUnitCount:<<error type>>,isASCII:<<error type>>)
extension StaticString {
  public init(
    _builtinExtendedGraphemeClusterLiteral start: Builtin.RawPointer,
    utf8CodeUnitCount: Builtin.Word,
    isASCII: Builtin.Int1
  ) {
    self = StaticString(
      _builtinStringLiteral: start,
      utf8CodeUnitCount: utf8CodeUnitCount,
      isASCII: isASCII
    )
  }
}

----Swift.(file).StaticString.init(extendedGraphemeClusterLiteral:StaticString)
extension StaticString {
  public init(extendedGraphemeClusterLiteral value: StaticString) {
    self = value
  }
}

----Swift.(file).StaticString.init(_builtinStringLiteral:<<error type>>,utf8CodeUnitCount:<<error type>>,isASCII:<<error type>>)
extension StaticString {
  public init(
    _builtinStringLiteral start: Builtin.RawPointer,
    utf8CodeUnitCount: Builtin.Word,
    isASCII: Builtin.Int1
  ) {
    self = StaticString(
      _start: start,
      utf8CodeUnitCount: utf8CodeUnitCount,
      isASCII: isASCII)
  }
}

----Swift.(file).StaticString.init(stringLiteral:StaticString)
extension StaticString {
  public init(stringLiteral value: StaticString) {
    self = value
  }
}

----Swift.(file).StaticString.description
extension StaticString {
  public var description: String {
    return withUTF8Buffer { String._uncheckedFromUTF8($0) }
  }
}

----Swift.(file).StaticString.debugDescription
extension StaticString {
  public var debugDescription: String {
    return self.description.debugDescription
  }
}

----Swift.(file).StaticString.customMirror
extension StaticString  {
  public var customMirror: Mirror {
    return Mirror(reflecting: description)
  }
}

----Swift.(file).Strideable.<infix(_:Self,_:Self)
extension Strideable  {
  public static func < (x: Self, y: Self) -> Bool {
    return x.distance(to: y) > 0
  }
}

----Swift.(file).Strideable.==infix(_:Self,_:Self)
extension Strideable  {
  public static func == (x: Self, y: Self) -> Bool {
    return x.distance(to: y) == 0
  }
}

----Swift.(file).StrideToIterator.next()
extension StrideToIterator: IteratorProtocol  {
  public mutating func next() -> Element? {
    let result = _current.value
    if _stride > 0 ? result >= _end : result <= _end {
      return nil
    }
    _current = Element._step(after: _current, from: _start, by: _stride)
    return result
  }
}

----Swift.(file).StrideTo.makeIterator()
extension StrideTo: Sequence  {
  public __consuming func makeIterator() -> StrideToIterator<Element> {
    return StrideToIterator(_start: _start, end: _end, stride: _stride)
  }
}

----Swift.(file).StrideTo.underestimatedCount
extension StrideTo: Sequence  {
  public var underestimatedCount: Int {
    var it = self.makeIterator()
    var count = 0
    while it.next() != nil {
      count += 1
    }
    return count
  }
}

----Swift.(file).StrideTo.customMirror
extension StrideTo: CustomReflectable  {
  public var customMirror: Mirror {
    return Mirror(self, children: ["from": _start, "to": _end, "by": _stride])
  }
}

----Swift.(file).stride(from:T,to:T,by:T.Stride)
public func stride<T>(
  from start: T, to end: T, by stride: T.Stride
) -> StrideTo<T> {
  return StrideTo(_start: start, end: end, stride: stride)
}

----Swift.(file).StrideThroughIterator.next()
extension StrideThroughIterator: IteratorProtocol  {
  public mutating func next() -> Element? {
    let result = _current.value
    if _stride > 0 ? result >= _end : result <= _end {
      // This check is needed because if we just changed the above operators
      // to > and <, respectively, we might advance current past the end
      // and throw it out of bounds (e.g. above Int.max) unnecessarily.
      if result == _end && !_didReturnEnd {
        _didReturnEnd = true
        return result
      }
      return nil
    }
    _current = Element._step(after: _current, from: _start, by: _stride)
    return result
  }
}

----Swift.(file).StrideThrough.makeIterator()
extension StrideThrough: Sequence  {
  public __consuming func makeIterator() -> StrideThroughIterator<Element> {
    return StrideThroughIterator(_start: _start, end: _end, stride: _stride)
  }
}

----Swift.(file).StrideThrough.underestimatedCount
extension StrideThrough: Sequence  {
  public var underestimatedCount: Int {
    var it = self.makeIterator()
    var count = 0
    while it.next() != nil {
      count += 1
    }
    return count
  }
}

----Swift.(file).StrideThrough.customMirror
extension StrideThrough: CustomReflectable  {
  public var customMirror: Mirror {
    return Mirror(self,
      children: ["from": _start, "through": _end, "by": _stride])
  }
}

----Swift.(file).stride(from:T,through:T,by:T.Stride)
public func stride<T>(
  from start: T, through end: T, by stride: T.Stride
) -> StrideThrough<T> {
  return StrideThrough(_start: start, end: end, stride: stride)
}

----Swift.(file).String.init()
extension String {
  public init() { self.init(_StringGuts()) }
}

----Swift.(file).String.withCString(encodedAs:TargetEncoding.Type,_:(UnsafePointer<TargetEncoding.CodeUnit>) throws -> Result)
extension String  {
  public func withCString<Result, TargetEncoding: Unicode.Encoding>(
    encodedAs targetEncoding: TargetEncoding.Type,
    _ body: (UnsafePointer<TargetEncoding.CodeUnit>) throws -> Result
  ) rethrows -> Result {
    if targetEncoding == UTF8.self {
      return try self.withCString {
        (cPtr: UnsafePointer<CChar>) -> Result  in
        _internalInvariant(UInt8.self == TargetEncoding.CodeUnit.self)
        let ptr = UnsafeRawPointer(cPtr).assumingMemoryBound(
          to: TargetEncoding.CodeUnit.self)
        return try body(ptr)
      }
    }
    return try _slowWithCString(encodedAs: targetEncoding, body)
  }
}

----Swift.(file).String.init(_builtinUnicodeScalarLiteral:<<error type>>)
extension String: _ExpressibleByBuiltinUnicodeScalarLiteral  {
  public init(_builtinUnicodeScalarLiteral value: Builtin.Int32) {
    self.init(Unicode.Scalar(_unchecked: UInt32(value)))
  }
}

----Swift.(file).String.init(_:Unicode.Scalar)
extension String: _ExpressibleByBuiltinUnicodeScalarLiteral  {
  public init(_ scalar: Unicode.Scalar) {
    self = scalar.withUTF8CodeUnits { String._uncheckedFromUTF8($0) }
  }
}

----Swift.(file).String.init(_builtinExtendedGraphemeClusterLiteral:<<error type>>,utf8CodeUnitCount:<<error type>>,isASCII:<<error type>>)
extension String: _ExpressibleByBuiltinExtendedGraphemeClusterLiteral  {
  public init(
    _builtinExtendedGraphemeClusterLiteral start: Builtin.RawPointer,
    utf8CodeUnitCount: Builtin.Word,
    isASCII: Builtin.Int1
  ) {
    self.init(
      _builtinStringLiteral: start,
      utf8CodeUnitCount: utf8CodeUnitCount,
      isASCII: isASCII)
  }
}

----Swift.(file).String.init(_builtinStringLiteral:<<error type>>,utf8CodeUnitCount:<<error type>>,isASCII:<<error type>>)
extension String: _ExpressibleByBuiltinStringLiteral  {
  public init(
    _builtinStringLiteral start: Builtin.RawPointer,
    utf8CodeUnitCount: Builtin.Word,
    isASCII: Builtin.Int1
    ) {
    let bufPtr = UnsafeBufferPointer(
      start: UnsafeRawPointer(start).assumingMemoryBound(to: UInt8.self),
      count: Int(utf8CodeUnitCount))
    if let smol = _SmallString(bufPtr) {
      self = String(_StringGuts(smol))
      return
    }
    self.init(_StringGuts(bufPtr, isASCII: Bool(isASCII)))
  }
}

----Swift.(file).String.init(stringLiteral:String)
extension String: ExpressibleByStringLiteral  {
  public init(stringLiteral value: String) {
    self = value
  }
}

----Swift.(file).String.debugDescription
extension String: CustomDebugStringConvertible  {
  public var debugDescription: String {
    var result = "\""
    for us in self.unicodeScalars {
      result += us.escaped(asASCII: false)
    }
    result += "\""
    return result
  }
}

----Swift.(file).String.+infix(_:String,_:String)
extension String  {
  public static func + (lhs: String, rhs: String) -> String {
    var result = lhs
    result.append(rhs)
    return result
  }
}

----Swift.(file).String.+=infix(_:String,_:String)
extension String  {
  public static func += (lhs: inout String, rhs: String) {
    lhs.append(rhs)
  }
}

----Swift.(file).Sequence.joined(separator:String)
extension Sequence where Element: StringProtocol  {
  public func joined(separator: String = "") -> String {
    return _joined(separator: separator)
  }
}

----Swift.(file).BidirectionalCollection.joined(separator:String)
extension BidirectionalCollection where Element == String  {
  public func joined(separator: String = "") -> String {
    return _joined(separator: separator)
  }
}

----Swift.(file).String.lowercased()
extension String  {
  public func lowercased() -> String {
    if _fastPath(_guts.isFastASCII) {
      return _guts.withFastUTF8 { utf8 in
        // TODO(String performance): We can directly call appendInPlace
        var result = String()
        result.reserveCapacity(utf8.count)
        for u8 in utf8 {
          result._guts.append(String(Unicode.Scalar(_lowercaseASCII(u8)))._guts)
        }
        return result
      }
    }

    // TODO(String performance): Try out incremental case-conversion rather than
    // make UTF-16 array beforehand
    let codeUnits = Array(self.utf16).withUnsafeBufferPointer {
      (uChars: UnsafeBufferPointer<UInt16>) -> Array<UInt16> in
      var result = Array<UInt16>(repeating: 0, count: uChars.count)
      let len = result.withUnsafeMutableBufferPointer {
        (output) -> Int in
        var err = __swift_stdlib_U_ZERO_ERROR
        return Int(truncatingIfNeeded:
          __swift_stdlib_u_strToLower(
            output.baseAddress._unsafelyUnwrappedUnchecked,
            Int32(output.count),
            uChars.baseAddress._unsafelyUnwrappedUnchecked,
            Int32(uChars.count),
            "",
            &err))
      }
      if len > uChars.count {
        var err = __swift_stdlib_U_ZERO_ERROR
        result = Array<UInt16>(repeating: 0, count: len)
        result.withUnsafeMutableBufferPointer {
          output -> Void in
          __swift_stdlib_u_strToLower(
            output.baseAddress._unsafelyUnwrappedUnchecked,
            Int32(output.count),
            uChars.baseAddress._unsafelyUnwrappedUnchecked,
            Int32(uChars.count),
            "",
            &err)
        }
      }
      return result
    }
    return codeUnits.withUnsafeBufferPointer { String._uncheckedFromUTF16($0) }
  }
}

----Swift.(file).String.uppercased()
extension String  {
  public func uppercased() -> String {
    if _fastPath(_guts.isFastASCII) {
      return _guts.withFastUTF8 { utf8 in
        // TODO(String performance): code-unit appendInPlace on guts
        var result = String()
        result.reserveCapacity(utf8.count)
        for u8 in utf8 {
          result._guts.append(String(Unicode.Scalar(_uppercaseASCII(u8)))._guts)
        }
        return result
      }
    }

    // TODO(String performance): Try out incremental case-conversion rather than
    // make UTF-16 array beforehand
    let codeUnits = Array(self.utf16).withUnsafeBufferPointer {
      (uChars: UnsafeBufferPointer<UInt16>) -> Array<UInt16> in
      var result = Array<UInt16>(repeating: 0, count: uChars.count)
      let len = result.withUnsafeMutableBufferPointer {
        (output) -> Int in
        var err = __swift_stdlib_U_ZERO_ERROR
        return Int(truncatingIfNeeded:
          __swift_stdlib_u_strToUpper(
            output.baseAddress._unsafelyUnwrappedUnchecked,
            Int32(output.count),
            uChars.baseAddress._unsafelyUnwrappedUnchecked,
            Int32(uChars.count),
            "",
            &err))
      }
      if len > uChars.count {
        var err = __swift_stdlib_U_ZERO_ERROR
        result = Array<UInt16>(repeating: 0, count: len)
        result.withUnsafeMutableBufferPointer {
          output -> Void in
          __swift_stdlib_u_strToUpper(
            output.baseAddress._unsafelyUnwrappedUnchecked,
            Int32(output.count),
            uChars.baseAddress._unsafelyUnwrappedUnchecked,
            Int32(uChars.count),
            "",
            &err)
        }
      }
      return result
    }
    return codeUnits.withUnsafeBufferPointer { String._uncheckedFromUTF16($0) }
  }
}

----Swift.(file).String.description
extension String: CustomStringConvertible  {
  public var description: String { return self }
}

----Swift.(file).String.init(_cocoaString:AnyObject)
extension String  {
  init(_cocoaString: AnyObject) {
    self._guts = _bridgeCocoaString(_cocoaString)
  }
}

----Swift.(file).String.startIndex
extension String: BidirectionalCollection  {
  public var startIndex: Index {
    @inline(__always) get { return _guts.startIndex }
  }
}

----Swift.(file).String.endIndex
extension String: BidirectionalCollection  {
  public var endIndex: Index {
    @inline(__always) get { return _guts.endIndex }
  }
}

----Swift.(file).String.count
extension String: BidirectionalCollection  {
  public var count: Int {
    @inline(__always) get {
      return distance(from: startIndex, to: endIndex)
    }
  }
}

----Swift.(file).String.index(after:String.Index)
extension String: BidirectionalCollection  {
  public func index(after i: Index) -> Index {
    precondition(i < endIndex, "String index is out of bounds")

    // TODO: known-ASCII fast path, single-scalar-grapheme fast path, etc.
    let stride = _characterStride(startingAt: i)
    let nextOffset = i.encodedOffset &+ stride
    let nextStride = _characterStride(
      startingAt: Index(encodedOffset: nextOffset))

    return Index(
      encodedOffset: nextOffset, characterStride: nextStride)
  }
}

----Swift.(file).String.index(before:String.Index)
extension String: BidirectionalCollection  {
  public func index(before i: Index) -> Index {
    precondition(i > startIndex, "String index is out of bounds")

    // TODO: known-ASCII fast path, single-scalar-grapheme fast path, etc.
    let stride = _characterStride(endingAt: i)
    let priorOffset = i.encodedOffset &- stride
    return Index(encodedOffset: priorOffset, characterStride: stride)
  }
}

----Swift.(file).String.index(_:String.Index,offsetBy:String.IndexDistance)
extension String: BidirectionalCollection  {
  public func index(_ i: Index, offsetBy n: IndexDistance) -> Index {
    // TODO: known-ASCII and single-scalar-grapheme fast path, etc.
    return _index(i, offsetBy: n)
  }
}

----Swift.(file).String.index(_:String.Index,offsetBy:String.IndexDistance,limitedBy:String.Index)
extension String: BidirectionalCollection  {
  public func index(
    _ i: Index, offsetBy n: IndexDistance, limitedBy limit: Index
  ) -> Index? {
    // TODO: known-ASCII and single-scalar-grapheme fast path, etc.
    return _index(i, offsetBy: n, limitedBy: limit)
  }
}

----Swift.(file).String.distance(from:String.Index,to:String.Index)
extension String: BidirectionalCollection  {
  public func distance(from start: Index, to end: Index) -> IndexDistance {
    // TODO: known-ASCII and single-scalar-grapheme fast path, etc.
    return _distance(from: start, to: end)
  }
}

----Swift.(file).String.subscript(_:String.Index)
extension String: BidirectionalCollection  {
  public subscript(i: Index) -> Character {
    @inline(__always) get {
      _boundsCheck(i)

      let i = _guts.scalarAlign(i)
      let distance = _characterStride(startingAt: i)
      return _guts.errorCorrectedCharacter(
        startingAt: i.encodedOffset, endingAt: i.encodedOffset &+ distance)
    }
  }
}

----Swift.(file).String.makeIterator()
extension String  {
  public __consuming func makeIterator() -> Iterator {
    return Iterator(_guts)
  }
}

----Swift.(file).StringProtocol.==infix(_:Self,_:RHS)
extension StringProtocol  {
  public static func == <RHS: StringProtocol>(lhs: Self, rhs: RHS) -> Bool {
    return _stringCompare(
      lhs._wholeGuts, lhs._offsetRange,
      rhs._wholeGuts, rhs._offsetRange,
      expecting: .equal)
  }
}

----Swift.(file).StringProtocol.!=infix(_:Self,_:RHS)
extension StringProtocol  {
  public static func != <RHS: StringProtocol>(lhs: Self, rhs: RHS) -> Bool {
    return !(lhs == rhs)
  }
}

----Swift.(file).StringProtocol.<infix(_:Self,_:RHS)
extension StringProtocol  {
  public static func < <RHS: StringProtocol>(lhs: Self, rhs: RHS) -> Bool {
    return _stringCompare(
      lhs._wholeGuts, lhs._offsetRange,
      rhs._wholeGuts, rhs._offsetRange,
      expecting: .less)
  }
}

----Swift.(file).StringProtocol.>infix(_:Self,_:RHS)
extension StringProtocol  {
  public static func > <RHS: StringProtocol>(lhs: Self, rhs: RHS) -> Bool {
    return rhs < lhs
  }
}

----Swift.(file).StringProtocol.<=infix(_:Self,_:RHS)
extension StringProtocol  {
  public static func <= <RHS: StringProtocol>(lhs: Self, rhs: RHS) -> Bool {
    return !(rhs < lhs)
  }
}

----Swift.(file).StringProtocol.>=infix(_:Self,_:RHS)
extension StringProtocol  {
  public static func >= <RHS: StringProtocol>(lhs: Self, rhs: RHS) -> Bool {
    return !(lhs < rhs)
  }
}

----Swift.(file).String.==infix(_:String,_:String)
extension String : Equatable  {
  public static func == (lhs: String, rhs: String) -> Bool {
    return _stringCompare(lhs._guts, rhs._guts, expecting: .equal)
  }
}

----Swift.(file).String.<infix(_:String,_:String)
extension String : Comparable  {
  public static func < (lhs: String, rhs: String) -> Bool {
    return _stringCompare(lhs._guts, rhs._guts, expecting: .less)
  }
}

----Swift.(file)._StringGuts.startASCII
extension _StringGuts  {
  public var startASCII: UnsafeMutablePointer<UInt8> {
    return UnsafeMutablePointer(mutating: _object.fastUTF8.baseAddress!)
  }
}

----Swift.(file)._StringGuts.startUTF16
extension _StringGuts  {
  public var startUTF16: UnsafeMutablePointer<UTF16.CodeUnit> {
    fatalError("Not contiguous UTF-16")
  }
}

----Swift.(file).String.hash(into:Hasher)
extension String : Hashable  {
  public func hash(into hasher: inout Hasher) {
    if _fastPath(self._guts.isNFCFastUTF8) {
      self._guts.withFastUTF8 {
        hasher.combine(bytes: UnsafeRawBufferPointer($0))
      }
      hasher.combine(0xFF as UInt8) // terminator
      return
    }

    _gutsSlice._normalizedHash(into: &hasher)
  }
}

----Swift.(file).StringProtocol.hash(into:Hasher)
extension StringProtocol  {
  public func hash(into hasher: inout Hasher) {
    _gutsSlice._normalizedHash(into: &hasher)
  }
}

----Swift.(file).Index.encodedOffset
extension String.Index  {
  public var encodedOffset: Int {
    @inline(__always) get { return Int(truncatingIfNeeded: _rawBits &>> 16) }
  }
}

----Swift.(file).Index.init(encodedOffset:Int)
extension String.Index  {
  public init(encodedOffset: Int) {
    self.init(encodedOffset: encodedOffset, transcodedOffset: 0)
  }
}

----Swift.(file).Index.==infix(_:<<error type>>,_:<<error type>>)
extension String.Index: Equatable  {
  public static func == (lhs: String.Index, rhs: String.Index) -> Bool {
    return lhs.orderingValue == rhs.orderingValue
  }
}

----Swift.(file).Index.<infix(_:<<error type>>,_:<<error type>>)
extension String.Index: Comparable  {
  public static func < (lhs: String.Index, rhs: String.Index) -> Bool {
    return lhs.orderingValue < rhs.orderingValue
  }
}

----Swift.(file).Index.hash(into:Hasher)
extension String.Index: Hashable  {
  public func hash(into hasher: inout Hasher) {
    hasher.combine(orderingValue)
  }
}

----Swift.(file).Index.samePosition(in:String.UTF8View)
extension String.Index  {
  public func samePosition(
    in utf8: String.UTF8View
    ) -> String.UTF8View.Index? {
    return String.UTF8View.Index(self, within: utf8)
  }
}

----Swift.(file).Index.samePosition(in:String.UTF16View)
extension String.Index  {
  public func samePosition(
    in utf16: String.UTF16View
  ) -> String.UTF16View.Index? {
    return String.UTF16View.Index(self, within: utf16)
  }
}

----Swift.(file).DefaultStringInterpolation.init(literalCapacity:Int,interpolationCount:Int)
extension DefaultStringInterpolation {
  public init(literalCapacity: Int, interpolationCount: Int) {
    let capacityPerInterpolation = 2
    let initialCapacity = literalCapacity +
      interpolationCount * capacityPerInterpolation
    _storage = String(_StringGuts(_initialCapacity: initialCapacity))
  }
}

----Swift.(file).DefaultStringInterpolation.appendLiteral(_:String)
extension DefaultStringInterpolation {
  public mutating func appendLiteral(_ literal: String) {
    literal.write(to: &self)
  }
}

----Swift.(file).DefaultStringInterpolation.appendInterpolation(_:T)
extension DefaultStringInterpolation {
  public mutating func appendInterpolation<T>(_ value: T)
    where T: TextOutputStreamable, T: CustomStringConvertible
  {
    value.write(to: &self)
  }
}

----Swift.(file).DefaultStringInterpolation.appendInterpolation(_:T)
extension DefaultStringInterpolation {
  public mutating func appendInterpolation<T>(_ value: T)
    where T: TextOutputStreamable
  {
    value.write(to: &self)
  }
}

----Swift.(file).DefaultStringInterpolation.appendInterpolation(_:T)
extension DefaultStringInterpolation {
  public mutating func appendInterpolation<T>(_ value: T)
    where T: CustomStringConvertible
  {
    value.description.write(to: &self)
  }
}

----Swift.(file).DefaultStringInterpolation.appendInterpolation(_:T)
extension DefaultStringInterpolation {
  public mutating func appendInterpolation<T>(_ value: T) {
    _print_unlocked(value, &self)
  }
}

----Swift.(file).DefaultStringInterpolation.description
extension DefaultStringInterpolation: CustomStringConvertible  {
  public var description: String {
    return _storage
  }
}

----Swift.(file).DefaultStringInterpolation.write(_:String)
extension DefaultStringInterpolation: TextOutputStream  {
  public mutating func write(_ string: String) {
    _storage.append(string)
  }
}

----Swift.(file).String.init(stringInterpolation:DefaultStringInterpolation)
extension String  {
  public init(stringInterpolation: DefaultStringInterpolation) {
    self = stringInterpolation.make()
  }
}

----Swift.(file).Substring.init(stringInterpolation:DefaultStringInterpolation)
extension Substring  {
  public init(stringInterpolation: DefaultStringInterpolation) {
    self.init(stringInterpolation.make())
  }
}

----Swift.(file).String.init(repeating:String,count:Int)
extension String  {
  public init(repeating repeatedValue: String, count: Int) {
    precondition(count >= 0, "Negative count not allowed")
    guard count > 1 else {
      self = count == 0 ? "" : repeatedValue
      return
    }

    // TODO(String performance): We can directly call appendInPlace
    var result = String()
    result.reserveCapacity(repeatedValue._guts.count &* count)
    for _ in 0..<count {
      result += repeatedValue
    }
    self = result
  }
}

----Swift.(file).String.isEmpty
extension String  {
  public var isEmpty: Bool {
    @inline(__always) get { return _guts.isEmpty }
  }
}

----Swift.(file).StringProtocol.hasPrefix(_:Prefix)
extension StringProtocol  {
  public func hasPrefix<Prefix: StringProtocol>(_ prefix: Prefix) -> Bool {
    return self.starts(with: prefix)
  }
}

----Swift.(file).StringProtocol.hasSuffix(_:Suffix)
extension StringProtocol  {
  public func hasSuffix<Suffix: StringProtocol>(_ suffix: Suffix) -> Bool {
    return self.reversed().starts(with: suffix.reversed())
  }
}

----Swift.(file).String.hasPrefix(_:String)
extension String  {
  public func hasPrefix(_ prefix: String) -> Bool {
    if _fastPath(self._guts.isNFCFastUTF8 && prefix._guts.isNFCFastUTF8) {
      guard prefix._guts.count <= self._guts.count else { return false }
      return prefix._guts.withFastUTF8 { nfcPrefix in
        let prefixEnd = nfcPrefix.count
        return self._guts.withFastUTF8(range: 0..<prefixEnd) { nfcSlicedSelf in
          return _binaryCompare(nfcSlicedSelf, nfcPrefix) == 0
        }
      }
    }

    return starts(with: prefix)
  }
}

----Swift.(file).String.hasSuffix(_:String)
extension String  {
  public func hasSuffix(_ suffix: String) -> Bool {
    if _fastPath(self._guts.isNFCFastUTF8 && suffix._guts.isNFCFastUTF8) {
      guard suffix._guts.count <= self._guts.count else { return false }
      return suffix._guts.withFastUTF8 { nfcSuffix in
        let suffixStart = self._guts.count - nfcSuffix.count
        return self._guts.withFastUTF8(range: suffixStart..<self._guts.count) {
          nfcSlicedSelf in return _binaryCompare(nfcSlicedSelf, nfcSuffix) == 0
        }
      }
    }

    return self.reversed().starts(with: suffix.reversed())
  }
}

----Swift.(file).StringProtocol.utf8
extension StringProtocol {
  var utf8: UTF8View { get }
}

----Swift.(file).StringProtocol.utf16
extension StringProtocol {
  var utf16: UTF16View { get }
}

----Swift.(file).StringProtocol.unicodeScalars
extension StringProtocol {
  var unicodeScalars: UnicodeScalarView { get }
}

----Swift.(file).String.init(repeating:Character,count:Int)
extension String: RangeReplaceableCollection  {
  public init(repeating repeatedValue: Character, count: Int) {
    self.init(repeating: repeatedValue._str, count: count)
  }
}

----Swift.(file).String.init(_:S)
extension String: RangeReplaceableCollection  {
  public init<S : Sequence>(_ characters: S)
  where S.Iterator.Element == Character {
    if let str = characters as? String {
      self = str
      return
    }
    if let subStr = characters as? Substring {
      self.init(subStr)
      return
    }
    self = ""
    self.append(contentsOf: characters)
  }
}

----Swift.(file).String.reserveCapacity(_:Int)
extension String: RangeReplaceableCollection  {
  public mutating func reserveCapacity(_ n: Int) {
    self._guts.reserveCapacity(n)
  }
}

----Swift.(file).String.append(_:String)
extension String: RangeReplaceableCollection  {
  public mutating func append(_ other: String) {
    if self.isEmpty && !_guts.hasNativeStorage {
      self = other
      return
    }
    self._guts.append(other._guts)
  }
}

----Swift.(file).String.append(_:Character)
extension String: RangeReplaceableCollection  {
  public mutating func append(_ c: Character) {
    self.append(c._str)
  }
}

----Swift.(file).String.append(contentsOf:String)
extension String: RangeReplaceableCollection  {
  public mutating func append(contentsOf newElements: String) {
    self.append(newElements)
  }
}

----Swift.(file).String.append(contentsOf:Substring)
extension String: RangeReplaceableCollection  {
  public mutating func append(contentsOf newElements: Substring) {
    self._guts.append(newElements._gutsSlice)
  }
}

----Swift.(file).String.append(contentsOf:S)
extension String: RangeReplaceableCollection  {
  public mutating func append<S : Sequence>(contentsOf newElements: S)
  where S.Iterator.Element == Character {
    if let str = newElements as? String {
      self.append(str)
      return
    }
    if let substr = newElements as? Substring {
      self.append(contentsOf: substr)
      return
    }
    for c in newElements {
      self.append(c._str)
    }
  }
}

----Swift.(file).String.replaceSubrange(_:Range<String.Index>,with:C)
extension String: RangeReplaceableCollection  {
  public mutating func replaceSubrange<C>(
    _ bounds: Range<Index>,
    with newElements: C
  ) where C : Collection, C.Iterator.Element == Character {
    _guts.replaceSubrange(bounds, with: newElements)
  }
}

----Swift.(file).String.insert(_:Character,at:String.Index)
extension String: RangeReplaceableCollection  {
  public mutating func insert(_ newElement: Character, at i: Index) {
    self.replaceSubrange(i..<i, with: newElement._str)
  }
}

----Swift.(file).String.insert(contentsOf:S,at:String.Index)
extension String: RangeReplaceableCollection  {
  public mutating func insert<S : Collection>(
    contentsOf newElements: S, at i: Index
  ) where S.Element == Character {
    self.replaceSubrange(i..<i, with: newElements)
  }
}

----Swift.(file).String.remove(at:String.Index)
extension String: RangeReplaceableCollection  {
  public mutating func remove(at i: Index) -> Character {
    let result = self[i]
    _guts.remove(from: i, to: self.index(after: i))
    return result
  }
}

----Swift.(file).String.removeSubrange(_:Range<String.Index>)
extension String: RangeReplaceableCollection  {
  public mutating func removeSubrange(_ bounds: Range<Index>) {
    _guts.remove(from: bounds.lowerBound, to: bounds.upperBound)
  }
}

----Swift.(file).String.removeAll(keepingCapacity:Bool)
extension String: RangeReplaceableCollection  {
  public mutating func removeAll(keepingCapacity keepCapacity: Bool = false) {
    guard keepCapacity else {
      self = ""
      return
    }
    _guts.clear()
  }
}

----Swift.(file).String.max(_:T,_:T)
extension String  {
  public func max<T : Comparable>(_ x: T, _ y: T) -> T {
    return Swift.max(x,y)
  }
}

----Swift.(file).String.min(_:T,_:T)
extension String  {
  public func min<T : Comparable>(_ x: T, _ y: T) -> T {
    return Swift.min(x,y)
  }
}

----Swift.(file).Sequence.+infix(_:Self,_:String)
extension Sequence where Element == String  {
  public static func + (lhs: Self, rhs: String) -> Never {
    fatalError()
  }
}

----Swift.(file).Sequence.+infix(_:String,_:Self)
extension Sequence where Element == String  {
  public static func + (lhs: String, rhs: Self) -> Never {
    fatalError()
  }
}

----Swift.(file).UTF16View.startIndex
extension String.UTF16View: BidirectionalCollection  {
  public var startIndex: Index {
    @inline(__always) get { return _guts.startIndex }
  }
}

----Swift.(file).UTF16View.endIndex
extension String.UTF16View: BidirectionalCollection  {
  public var endIndex: Index {
    @inline(__always) get { return _guts.endIndex }
  }
}

----Swift.(file).UTF16View.index(after:String.UTF16View.Index)
extension String.UTF16View: BidirectionalCollection  {
  public func index(after i: Index) -> Index {
    if _slowPath(_guts.isForeign) { return _foreignIndex(after: i) }
    if _guts.isASCII { return i.nextEncoded }

    // For a BMP scalar (1-3 UTF-8 code units), advance past it. For a non-BMP
    // scalar, use a transcoded offset first.
    let len = _guts.fastUTF8ScalarLength(startingAt: i.encodedOffset)
    if len == 4 && i.transcodedOffset == 0 {
      return i.nextTranscoded
    }
    return i.strippingTranscoding.encoded(offsetBy: len)
  }
}

----Swift.(file).UTF16View.index(before:String.UTF16View.Index)
extension String.UTF16View: BidirectionalCollection  {
  public func index(before i: Index) -> Index {
    precondition(!i.isZeroPosition)
    if _slowPath(_guts.isForeign) { return _foreignIndex(before: i) }
    if _guts.isASCII { return i.priorEncoded }

    if i.transcodedOffset != 0 {
      _internalInvariant(i.transcodedOffset == 1)
      return i.strippingTranscoding
    }

    let len = _guts.fastUTF8ScalarLength(endingAt: i.encodedOffset)
    if len == 4 {
      // 2 UTF-16 code units comprise this scalar; advance to the beginning and
      // start mid-scalar transcoding
      return i.encoded(offsetBy: -len).nextTranscoded
    }

    // Single UTF-16 code unit
    _internalInvariant((1...3) ~= len)
    return i.encoded(offsetBy: -len)
  }
}

----Swift.(file).UTF16View.index(_:String.UTF16View.Index,offsetBy:Int)
extension String.UTF16View: BidirectionalCollection  {
  public func index(_ i: Index, offsetBy n: Int) -> Index {
    if _slowPath(_guts.isForeign) {
      return _foreignIndex(i, offsetBy: n)
    }

    let lowerOffset = _nativeGetOffset(for: i)
    let result = _nativeGetIndex(for: lowerOffset + n)
    return result
  }
}

----Swift.(file).UTF16View.index(_:String.UTF16View.Index,offsetBy:Int,limitedBy:String.UTF16View.Index)
extension String.UTF16View: BidirectionalCollection  {
  public func index(
    _ i: Index, offsetBy n: Int, limitedBy limit: Index
  ) -> Index? {
    if _slowPath(_guts.isForeign) {
      return _foreignIndex(i, offsetBy: n, limitedBy: limit)
    }

    let iOffset = _nativeGetOffset(for: i)
    let limitOffset = _nativeGetOffset(for: limit)

    // If distance < 0, limit has no effect if it is greater than i.
    if _slowPath(n < 0 && limit <= i && limitOffset > iOffset + n) {
      return nil
    }
    // If distance > 0, limit has no effect if it is less than i.
    if _slowPath(n >= 0 && limit >= i && limitOffset < iOffset + n) {
      return nil
    }

    let result = _nativeGetIndex(for: iOffset + n)
    return result
  }
}

----Swift.(file).UTF16View.distance(from:String.UTF16View.Index,to:String.UTF16View.Index)
extension String.UTF16View: BidirectionalCollection  {
  public func distance(from start: Index, to end: Index) -> Int {
    if _slowPath(_guts.isForeign) {
      return _foreignDistance(from: start, to: end)
    }

    let lower = _nativeGetOffset(for: start)
    let upper = _nativeGetOffset(for: end)
    return upper &- lower
  }
}

----Swift.(file).UTF16View.count
extension String.UTF16View: BidirectionalCollection  {
  public var count: Int {
    if _slowPath(_guts.isForeign) {
      return _foreignCount()
    }
    return _nativeGetOffset(for: endIndex)
  }
}

----Swift.(file).UTF16View.subscript(_:String.UTF16View.Index)
extension String.UTF16View: BidirectionalCollection  {
  public subscript(i: Index) -> UTF16.CodeUnit {
    @inline(__always) get {
      String(_guts)._boundsCheck(i)

      if _fastPath(_guts.isFastUTF8) {
        let scalar = _guts.fastUTF8Scalar(
          startingAt: _guts.scalarAlign(i).encodedOffset)
        if scalar.value <= 0xFFFF {
          return UInt16(truncatingIfNeeded: scalar.value)
        }
        return scalar.utf16[i.transcodedOffset]
      }

      return _foreignSubscript(position: i)
    }
  }
}

----Swift.(file).UTF16View.makeIterator()
extension String.UTF16View  {
  public __consuming func makeIterator() -> Iterator {
    return Iterator(_guts)
  }
}

----Swift.(file).UTF16View.description
extension String.UTF16View: CustomStringConvertible  {
  public var description: String {
    @inline(__always) get { return String(_guts) }
  }
}

----Swift.(file).UTF16View.debugDescription
extension String.UTF16View: CustomDebugStringConvertible  {
  public var debugDescription: String {
    return "StringUTF16(\(self.description.debugDescription))"
  }
}

----Swift.(file).String.utf16
extension String  {
  public var utf16: UTF16View {
    @inline(__always) get { return UTF16View(_guts) }
    @inline(__always) set { self = String(newValue._guts) }
  }
}

----Swift.(file).String.init(_:<<error type>>)
extension String  {
  public init(_ utf16: UTF16View) {
    self.init(utf16._guts)
  }
}

----Swift.(file).Index.samePosition(in:String.UnicodeScalarView)
extension String.UTF16View.Index  {
  public func samePosition(
    in unicodeScalars: String.UnicodeScalarView
  ) -> String.UnicodeScalarIndex? {
    return String.UnicodeScalarIndex(self, within: unicodeScalars)
  }
}

----Swift.(file).UTF16View.customMirror
extension String.UTF16View : CustomReflectable  {
  public var customMirror: Mirror {
    return Mirror(self, unlabeledChildren: self)
  }
}

----Swift.(file).UTF16View.subscript(_:Range<String.UTF16View.Index>)
extension String.UTF16View  {
  public subscript(r: Range<Index>) -> Substring.UTF16View {
    return Substring.UTF16View(self, _bounds: r)
  }
}

----Swift.(file).UTF8View.startIndex
extension String.UTF8View: BidirectionalCollection  {
  public var startIndex: Index {
    @inline(__always) get { return _guts.startIndex }
  }
}

----Swift.(file).UTF8View.endIndex
extension String.UTF8View: BidirectionalCollection  {
  public var endIndex: Index {
    @inline(__always) get { return _guts.endIndex }
  }
}

----Swift.(file).UTF8View.index(after:String.UTF8View.Index)
extension String.UTF8View: BidirectionalCollection  {
  public func index(after i: Index) -> Index {
    if _fastPath(_guts.isFastUTF8) {
      return i.nextEncoded
    }

    return _foreignIndex(after: i)
  }
}

----Swift.(file).UTF8View.index(before:String.UTF8View.Index)
extension String.UTF8View: BidirectionalCollection  {
  public func index(before i: Index) -> Index {
    precondition(!i.isZeroPosition)
    if _fastPath(_guts.isFastUTF8) {
      return i.priorEncoded
    }

    return _foreignIndex(before: i)
  }
}

----Swift.(file).UTF8View.index(_:String.UTF8View.Index,offsetBy:Int)
extension String.UTF8View: BidirectionalCollection  {
  public func index(_ i: Index, offsetBy n: Int) -> Index {
    if _fastPath(_guts.isFastUTF8) {
      precondition(n + i.encodedOffset <= _guts.count)
      return i.encoded(offsetBy: n)
    }

    return _foreignIndex(i, offsetBy: n)
  }
}

----Swift.(file).UTF8View.index(_:String.UTF8View.Index,offsetBy:Int,limitedBy:String.UTF8View.Index)
extension String.UTF8View: BidirectionalCollection  {
  public func index(
    _ i: Index, offsetBy n: Int, limitedBy limit: Index
  ) -> Index? {
    if _fastPath(_guts.isFastUTF8) {
      // Check the limit: ignore limit if it precedes `i` (in the correct
      // direction), otherwise must not be beyond limit (in the correct
      // direction).
      let iOffset = i.encodedOffset
      let result = iOffset + n
      let limitOffset = limit.encodedOffset
      if n >= 0 {
        guard limitOffset < iOffset || result <= limitOffset else { return nil }
      } else {
        guard limitOffset > iOffset || result >= limitOffset else { return nil }
      }
      return Index(encodedOffset: result)
    }

    return _foreignIndex(i, offsetBy: n, limitedBy: limit)
  }
}

----Swift.(file).UTF8View.distance(from:String.UTF8View.Index,to:String.UTF8View.Index)
extension String.UTF8View: BidirectionalCollection  {
  public func distance(from i: Index, to j: Index) -> Int {
    if _fastPath(_guts.isFastUTF8) {
      return j.encodedOffset &- i.encodedOffset
    }
    return _foreignDistance(from: i, to: j)
  }
}

----Swift.(file).UTF8View.subscript(_:String.UTF8View.Index)
extension String.UTF8View: BidirectionalCollection  {
  public subscript(i: Index) -> UTF8.CodeUnit {
    @inline(__always) get {
      String(_guts)._boundsCheck(i)
      if _fastPath(_guts.isFastUTF8) {
        return _guts.withFastUTF8 { utf8 in utf8[_unchecked: i.encodedOffset] }
      }

      return _foreignSubscript(position: i)
    }
  }
}

----Swift.(file).UTF8View.description
extension String.UTF8View: CustomStringConvertible  {
 public var description: String {
   @inline(__always) get { return String(String(_guts)) }
 }
}

----Swift.(file).UTF8View.debugDescription
extension String.UTF8View: CustomDebugStringConvertible  {
 public var debugDescription: String {
   return "UTF8View(\(self.description.debugDescription))"
 }
}

----Swift.(file).String.utf8
extension String  {
  public var utf8: UTF8View {
    @inline(__always) get { return UTF8View(self._guts) }
    set {
      // TODO(String testing): test suite doesn't currenlty exercise this code at
      // all, test it.
      self = String(utf8._guts)
    }
  }
}

----Swift.(file).String.utf8CString
extension String  {
  public var utf8CString: ContiguousArray<CChar> {
    if _fastPath(_guts.isFastUTF8) {
      var result = _guts.withFastCChar { ContiguousArray($0) }
      result.append(0)
      return result
    }

    return _slowUTF8CString()
  }
}

----Swift.(file).String.init(_:<<error type>>)
extension String  {
  public init(_ utf8: UTF8View) {
    self = String(utf8._guts)
  }
}

----Swift.(file).UTF8View.count
extension String.UTF8View  {
  public var count: Int {
    @inline(__always) get {
      if _fastPath(_guts.isFastUTF8) {
        return _guts.count
      }
      return _foreignCount()
    }
  }
}

----Swift.(file).UTF8View.customMirror
extension String.UTF8View : CustomReflectable  {
  public var customMirror: Mirror {
    return Mirror(self, unlabeledChildren: self)
  }
}

----Swift.(file).UTF8View.subscript(_:Range<String.UTF8View.Index>)
extension String.UTF8View  {
  public subscript(r: Range<Index>) -> String.UTF8View.SubSequence {
    return Substring.UTF8View(self, _bounds: r)
  }
}

----Swift.(file).UTF8View.withContiguousStorageIfAvailable(_:(UnsafeBufferPointer<String.UTF8View.Element>) throws -> R)
extension String.UTF8View  {
  public func withContiguousStorageIfAvailable<R>(
    _ body: (UnsafeBufferPointer<Element>) throws -> R
  ) rethrows -> R? {
    guard _guts.isFastUTF8 else { return nil }
    return try _guts.withFastUTF8(body)
  }
}

----Swift.(file).UnicodeScalarView.startIndex
extension String.UnicodeScalarView: BidirectionalCollection  {
  public var startIndex: Index {
    @inline(__always) get { return _guts.startIndex }
  }
}

----Swift.(file).UnicodeScalarView.endIndex
extension String.UnicodeScalarView: BidirectionalCollection  {
  public var endIndex: Index {
    @inline(__always) get { return _guts.endIndex }
  }
}

----Swift.(file).UnicodeScalarView.index(after:String.UnicodeScalarView.Index)
extension String.UnicodeScalarView: BidirectionalCollection  {
  public func index(after i: Index) -> Index {
    _internalInvariant(i < endIndex)
    // TODO(String performance): isASCII fast-path

    if _fastPath(_guts.isFastUTF8) {
      let len = _guts.fastUTF8ScalarLength(startingAt: i.encodedOffset)
      return i.encoded(offsetBy: len)
    }

    return _foreignIndex(after: i)
  }
}

----Swift.(file).UnicodeScalarView.index(before:String.UnicodeScalarView.Index)
extension String.UnicodeScalarView: BidirectionalCollection  {
  public func index(before i: Index) -> Index {
    precondition(i.encodedOffset > 0)
    // TODO(String performance): isASCII fast-path

    if _fastPath(_guts.isFastUTF8) {
      let len = _guts.withFastUTF8 { utf8 -> Int in
        return _utf8ScalarLength(utf8, endingAt: i.encodedOffset)
      }
      _internalInvariant(len <= 4, "invalid UTF8")
      return i.encoded(offsetBy: -len)
    }

    return _foreignIndex(before: i)
  }
}

----Swift.(file).UnicodeScalarView.subscript(_:String.UnicodeScalarView.Index)
extension String.UnicodeScalarView: BidirectionalCollection  {
  public subscript(position: Index) -> Unicode.Scalar {
    @inline(__always) get {
      String(_guts)._boundsCheck(position)
      let i = _guts.scalarAlign(position)
      return _guts.errorCorrectedScalar(startingAt: i.encodedOffset).0
    }
  }
}

----Swift.(file).UnicodeScalarView.makeIterator()
extension String.UnicodeScalarView  {
  public __consuming func makeIterator() -> Iterator {
    return Iterator(_guts)
  }
}

----Swift.(file).UnicodeScalarView.description
extension String.UnicodeScalarView: CustomStringConvertible  {
 public var description: String {
   @inline(__always) get { return String(_guts) }
 }
}

----Swift.(file).UnicodeScalarView.debugDescription
extension String.UnicodeScalarView: CustomDebugStringConvertible  {
 public var debugDescription: String {
   return "StringUnicodeScalarView(\(self.description.debugDescription))"
 }
}

----Swift.(file).String.init(_:<<error type>>)
extension String  {
  public init(_ unicodeScalars: UnicodeScalarView) {
    self.init(unicodeScalars._guts)
  }
}

----Swift.(file).String.unicodeScalars
extension String  {
  public var unicodeScalars: UnicodeScalarView {
    @inline(__always) get { return UnicodeScalarView(_guts) }
    @inline(__always) set { _guts = newValue._guts }
  }
}

----Swift.(file).UnicodeScalarView.init()
extension String.UnicodeScalarView : RangeReplaceableCollection  {
  public init() {
    self.init(_StringGuts())
  }
}

----Swift.(file).UnicodeScalarView.reserveCapacity(_:Int)
extension String.UnicodeScalarView : RangeReplaceableCollection  {
  public mutating func reserveCapacity(_ n: Int) {
    self._guts.reserveCapacity(n)
  }
}

----Swift.(file).UnicodeScalarView.append(_:Unicode.Scalar)
extension String.UnicodeScalarView : RangeReplaceableCollection  {
  public mutating func append(_ c: Unicode.Scalar) {
    self._guts.append(String(c)._guts)
  }
}

----Swift.(file).UnicodeScalarView.append(contentsOf:S)
extension String.UnicodeScalarView : RangeReplaceableCollection  {
  public mutating func append<S : Sequence>(contentsOf newElements: S)
  where S.Element == Unicode.Scalar {
    // TODO(String performance): Skip extra String allocation
    let scalars = String(decoding: newElements.map { $0.value }, as: UTF32.self)
    self = (String(self._guts) + scalars).unicodeScalars
  }
}

----Swift.(file).UnicodeScalarView.replaceSubrange(_:Range<String.UnicodeScalarView.Index>,with:C)
extension String.UnicodeScalarView : RangeReplaceableCollection  {
  public mutating func replaceSubrange<C>(
    _ bounds: Range<Index>,
    with newElements: C
  ) where C : Collection, C.Element == Unicode.Scalar {
    // TODO(String performance): Skip extra String and Array allocation

    let utf8Replacement = newElements.flatMap { String($0).utf8 }
    let replacement = utf8Replacement.withUnsafeBufferPointer {
      return String._uncheckedFromUTF8($0)
    }
    var copy = String(_guts)
    copy.replaceSubrange(bounds, with: replacement)
    self = copy.unicodeScalars
  }
}

----Swift.(file).Index.samePosition(in:String)
extension String.UnicodeScalarIndex  {
  public func samePosition(in characters: String) -> String.Index? {
    return String.Index(self, within: characters)
  }
}

----Swift.(file).UnicodeScalarView.customMirror
extension String.UnicodeScalarView : CustomReflectable  {
  public var customMirror: Mirror {
    return Mirror(self, unlabeledChildren: self)
  }
}

----Swift.(file).UnicodeScalarView.subscript(_:Range<String.UnicodeScalarView.Index>)
extension String.UnicodeScalarView  {
  public subscript(r: Range<Index>) -> String.UnicodeScalarView.SubSequence {
    return String.UnicodeScalarView.SubSequence(self, _bounds: r)
  }
}

----Swift.(file).String.init(_:Substring)
extension String  {
  public init(_ substring: __shared Substring) {
    self = String._fromSubstring(substring)
  }
}

----Swift.(file).Substring.init()
extension Substring {
  public init() {
    self.init(Slice())
  }
}

----Swift.(file).Substring.startIndex
extension Substring: StringProtocol  {
  public var startIndex: Index {
    @inline(__always) get { return _slice.startIndex }
  }
}

----Swift.(file).Substring.endIndex
extension Substring: StringProtocol  {
  public var endIndex: Index {
    @inline(__always) get { return _slice.endIndex }
  }
}

----Swift.(file).Substring.index(after:Substring.Index)
extension Substring: StringProtocol  {
  public func index(after i: Index) -> Index {
    precondition(i < endIndex, "Cannot increment beyond endIndex")
    precondition(i >= startIndex, "Cannot increment an invalid index")
    return _slice.index(after: i)
  }
}

----Swift.(file).Substring.index(before:Substring.Index)
extension Substring: StringProtocol  {
  public func index(before i: Index) -> Index {
    precondition(i <= endIndex, "Cannot decrement an invalid index")
    precondition(i > startIndex, "Cannot decrement beyond startIndex")
    return _slice.index(before: i)
  }
}

----Swift.(file).Substring.index(_:Substring.Index,offsetBy:Int)
extension Substring: StringProtocol  {
  public func index(_ i: Index, offsetBy n: Int) -> Index {
    let result = _slice.index(i, offsetBy: n)
    precondition(
      (_slice._startIndex ... _slice.endIndex).contains(result),
      "Operation results in an invalid index")
    return result
  }
}

----Swift.(file).Substring.index(_:Substring.Index,offsetBy:Int,limitedBy:Substring.Index)
extension Substring: StringProtocol  {
  public func index(
    _ i: Index, offsetBy n: Int, limitedBy limit: Index
  ) -> Index? {
    let result = _slice.index(i, offsetBy: n, limitedBy: limit)
    precondition(result.map {
        (_slice._startIndex ... _slice.endIndex).contains($0)
      } ?? true,
      "Operation results in an invalid index")
    return result
  }
}

----Swift.(file).Substring.distance(from:Substring.Index,to:Substring.Index)
extension Substring: StringProtocol  {
  public func distance(from start: Index, to end: Index) -> Int {
    return _slice.distance(from: start, to: end)
  }
}

----Swift.(file).Substring.subscript(_:Substring.Index)
extension Substring: StringProtocol  {
  public subscript(i: Index) -> Character {
    return _slice[i]
  }
}

----Swift.(file).Substring.replaceSubrange(_:Range<Substring.Index>,with:C)
extension Substring: StringProtocol  {
  public mutating func replaceSubrange<C>(
    _ bounds: Range<Index>,
    with newElements: C
  ) where C : Collection, C.Iterator.Element == Iterator.Element {
    _slice.replaceSubrange(bounds, with: newElements)
  }
}

----Swift.(file).Substring.replaceSubrange(_:Range<Substring.Index>,with:Substring)
extension Substring: StringProtocol  {
  public mutating func replaceSubrange(
    _ bounds: Range<Index>, with newElements: Substring
  ) {
    replaceSubrange(bounds, with: newElements._slice)
  }
}

----Swift.(file).Substring.init(decoding:C,as:Encoding.Type)
extension Substring: StringProtocol  {
  public init<C: Collection, Encoding: _UnicodeEncoding>(
    decoding codeUnits: C, as sourceEncoding: Encoding.Type
  ) where C.Iterator.Element == Encoding.CodeUnit {
    self.init(String(decoding: codeUnits, as: sourceEncoding))
  }
}

----Swift.(file).Substring.init(cString:UnsafePointer<CChar>)
extension Substring: StringProtocol  {
  public init(cString nullTerminatedUTF8: UnsafePointer<CChar>) {
    self.init(String(cString: nullTerminatedUTF8))
  }
}

----Swift.(file).Substring.init(decodingCString:UnsafePointer<Encoding.CodeUnit>,as:Encoding.Type)
extension Substring: StringProtocol  {
  public init<Encoding: _UnicodeEncoding>(
    decodingCString nullTerminatedCodeUnits: UnsafePointer<Encoding.CodeUnit>,
    as sourceEncoding: Encoding.Type
  ) {
    self.init(
      String(decodingCString: nullTerminatedCodeUnits, as: sourceEncoding))
  }
}

----Swift.(file).Substring.withCString(_:(UnsafePointer<CChar>) throws -> Result)
extension Substring: StringProtocol  {
  public func withCString<Result>(
    _ body: (UnsafePointer<CChar>) throws -> Result) rethrows -> Result {
    // TODO(String performance): Detect when we cover the rest of a nul-
    // terminated String, and thus can avoid a copy.
    return try String(self).withCString(body)
  }
}

----Swift.(file).Substring.withCString(encodedAs:TargetEncoding.Type,_:(UnsafePointer<TargetEncoding.CodeUnit>) throws -> Result)
extension Substring: StringProtocol  {
  public func withCString<Result, TargetEncoding: _UnicodeEncoding>(
    encodedAs targetEncoding: TargetEncoding.Type,
    _ body: (UnsafePointer<TargetEncoding.CodeUnit>) throws -> Result
  ) rethrows -> Result {
    // TODO(String performance): Detect when we cover the rest of a nul-
    // terminated String, and thus can avoid a copy.
    return try String(self).withCString(encodedAs: targetEncoding, body)
  }
}

----Swift.(file).Substring.customMirror
extension Substring : CustomReflectable  {
 public var customMirror: Mirror { return String(self).customMirror }
}

----Swift.(file).Substring.description
extension Substring : CustomStringConvertible  {
  public var description: String {
    @inline(__always) get { return String(self) }
  }
}

----Swift.(file).Substring.debugDescription
extension Substring : CustomDebugStringConvertible  {
  public var debugDescription: String { return String(self).debugDescription }
}

----Swift.(file).Substring.init(_:String)
extension Substring : LosslessStringConvertible  {
  public init(_ content: String) {
    self = content[...]
  }
}

----Swift.(file).UTF8View.startIndex
extension Substring.UTF8View : BidirectionalCollection  {
  public var startIndex: Index { return _slice.startIndex }
}

----Swift.(file).UTF8View.endIndex
extension Substring.UTF8View : BidirectionalCollection  {
  public var endIndex: Index { return _slice.endIndex }
}

----Swift.(file).UTF8View.subscript(_:Substring.UTF8View.Index)
extension Substring.UTF8View : BidirectionalCollection  {
  public subscript(index: Index) -> Element { return _slice[index] }
}

----Swift.(file).UTF8View.indices
extension Substring.UTF8View : BidirectionalCollection  {
  public var indices: Indices { return _slice.indices }
}

----Swift.(file).UTF8View.index(after:Substring.UTF8View.Index)
extension Substring.UTF8View : BidirectionalCollection  {
  public func index(after i: Index) -> Index { return _slice.index(after: i) }
}

----Swift.(file).UTF8View.formIndex(after:Substring.UTF8View.Index)
extension Substring.UTF8View : BidirectionalCollection  {
  public func formIndex(after i: inout Index) {
    _slice.formIndex(after: &i)
  }
}

----Swift.(file).UTF8View.index(_:Substring.UTF8View.Index,offsetBy:Int)
extension Substring.UTF8View : BidirectionalCollection  {
  public func index(_ i: Index, offsetBy n: Int) -> Index {
    return _slice.index(i, offsetBy: n)
  }
}

----Swift.(file).UTF8View.index(_:Substring.UTF8View.Index,offsetBy:Int,limitedBy:Substring.UTF8View.Index)
extension Substring.UTF8View : BidirectionalCollection  {
  public func index(
    _ i: Index, offsetBy n: Int, limitedBy limit: Index
  ) -> Index? {
    return _slice.index(i, offsetBy: n, limitedBy: limit)
  }
}

----Swift.(file).UTF8View.distance(from:Substring.UTF8View.Index,to:Substring.UTF8View.Index)
extension Substring.UTF8View : BidirectionalCollection  {
  public func distance(from start: Index, to end: Index) -> Int {
    return _slice.distance(from: start, to: end)
  }
}

----Swift.(file).UTF8View.index(before:Substring.UTF8View.Index)
extension Substring.UTF8View : BidirectionalCollection  {
  public func index(before i: Index) -> Index { return _slice.index(before: i) }
}

----Swift.(file).UTF8View.formIndex(before:Substring.UTF8View.Index)
extension Substring.UTF8View : BidirectionalCollection  {
  public func formIndex(before i: inout Index) {
    _slice.formIndex(before: &i)
  }
}

----Swift.(file).UTF8View.subscript(_:Range<Substring.UTF8View.Index>)
extension Substring.UTF8View : BidirectionalCollection  {
  public subscript(r: Range<Index>) -> Substring.UTF8View {
    // FIXME(strings): tests.
    precondition(r.lowerBound >= startIndex && r.upperBound <= endIndex,
      "UTF8View index range out of bounds")
    return Substring.UTF8View(_slice.base, _bounds: r)
  }
}

----Swift.(file).Substring.utf8
extension Substring  {
  public var utf8: UTF8View {
    get {
      return _wholeString.utf8[startIndex..<endIndex]
    }
    set {
      self = Substring(newValue)
    }
  }
}

----Swift.(file).Substring.init(_:Substring.UTF8View)
extension Substring  {
  public init(_ content: UTF8View) {
    self = String(
      content._slice.base._guts
    )[content.startIndex..<content.endIndex]
  }
}

----Swift.(file).UTF16View.startIndex
extension Substring.UTF16View : BidirectionalCollection  {
  public var startIndex: Index { return _slice.startIndex }
}

----Swift.(file).UTF16View.endIndex
extension Substring.UTF16View : BidirectionalCollection  {
  public var endIndex: Index { return _slice.endIndex }
}

----Swift.(file).UTF16View.subscript(_:Substring.UTF16View.Index)
extension Substring.UTF16View : BidirectionalCollection  {
  public subscript(index: Index) -> Element { return _slice[index] }
}

----Swift.(file).UTF16View.indices
extension Substring.UTF16View : BidirectionalCollection  {
  public var indices: Indices { return _slice.indices }
}

----Swift.(file).UTF16View.index(after:Substring.UTF16View.Index)
extension Substring.UTF16View : BidirectionalCollection  {
  public func index(after i: Index) -> Index { return _slice.index(after: i) }
}

----Swift.(file).UTF16View.formIndex(after:Substring.UTF16View.Index)
extension Substring.UTF16View : BidirectionalCollection  {
  public func formIndex(after i: inout Index) {
    _slice.formIndex(after: &i)
  }
}

----Swift.(file).UTF16View.index(_:Substring.UTF16View.Index,offsetBy:Int)
extension Substring.UTF16View : BidirectionalCollection  {
  public func index(_ i: Index, offsetBy n: Int) -> Index {
    return _slice.index(i, offsetBy: n)
  }
}

----Swift.(file).UTF16View.index(_:Substring.UTF16View.Index,offsetBy:Int,limitedBy:Substring.UTF16View.Index)
extension Substring.UTF16View : BidirectionalCollection  {
  public func index(
    _ i: Index, offsetBy n: Int, limitedBy limit: Index
  ) -> Index? {
    return _slice.index(i, offsetBy: n, limitedBy: limit)
  }
}

----Swift.(file).UTF16View.distance(from:Substring.UTF16View.Index,to:Substring.UTF16View.Index)
extension Substring.UTF16View : BidirectionalCollection  {
  public func distance(from start: Index, to end: Index) -> Int {
    return _slice.distance(from: start, to: end)
  }
}

----Swift.(file).UTF16View.index(before:Substring.UTF16View.Index)
extension Substring.UTF16View : BidirectionalCollection  {
  public func index(before i: Index) -> Index { return _slice.index(before: i) }
}

----Swift.(file).UTF16View.formIndex(before:Substring.UTF16View.Index)
extension Substring.UTF16View : BidirectionalCollection  {
  public func formIndex(before i: inout Index) {
    _slice.formIndex(before: &i)
  }
}

----Swift.(file).UTF16View.subscript(_:Range<Substring.UTF16View.Index>)
extension Substring.UTF16View : BidirectionalCollection  {
  public subscript(r: Range<Index>) -> Substring.UTF16View {
    return Substring.UTF16View(_slice.base, _bounds: r)
  }
}

----Swift.(file).Substring.utf16
extension Substring  {
  public var utf16: UTF16View {
    get {
      return _wholeString.utf16[startIndex..<endIndex]
    }
    set {
      self = Substring(newValue)
    }
  }
}

----Swift.(file).Substring.init(_:Substring.UTF16View)
extension Substring  {
  public init(_ content: UTF16View) {
    self = String(
      content._slice.base._guts
    )[content.startIndex..<content.endIndex]
  }
}

----Swift.(file).UnicodeScalarView.startIndex
extension Substring.UnicodeScalarView : BidirectionalCollection  {
  public var startIndex: Index { return _slice.startIndex }
}

----Swift.(file).UnicodeScalarView.endIndex
extension Substring.UnicodeScalarView : BidirectionalCollection  {
  public var endIndex: Index { return _slice.endIndex }
}

----Swift.(file).UnicodeScalarView.subscript(_:Substring.UnicodeScalarView.Index)
extension Substring.UnicodeScalarView : BidirectionalCollection  {
  public subscript(index: Index) -> Element { return _slice[index] }
}

----Swift.(file).UnicodeScalarView.indices
extension Substring.UnicodeScalarView : BidirectionalCollection  {
  public var indices: Indices { return _slice.indices }
}

----Swift.(file).UnicodeScalarView.index(after:Substring.UnicodeScalarView.Index)
extension Substring.UnicodeScalarView : BidirectionalCollection  {
  public func index(after i: Index) -> Index { return _slice.index(after: i) }
}

----Swift.(file).UnicodeScalarView.formIndex(after:Substring.UnicodeScalarView.Index)
extension Substring.UnicodeScalarView : BidirectionalCollection  {
  public func formIndex(after i: inout Index) {
    _slice.formIndex(after: &i)
  }
}

----Swift.(file).UnicodeScalarView.index(_:Substring.UnicodeScalarView.Index,offsetBy:Int)
extension Substring.UnicodeScalarView : BidirectionalCollection  {
  public func index(_ i: Index, offsetBy n: Int) -> Index {
    return _slice.index(i, offsetBy: n)
  }
}

----Swift.(file).UnicodeScalarView.index(_:Substring.UnicodeScalarView.Index,offsetBy:Int,limitedBy:Substring.UnicodeScalarView.Index)
extension Substring.UnicodeScalarView : BidirectionalCollection  {
  public func index(
    _ i: Index, offsetBy n: Int, limitedBy limit: Index
  ) -> Index? {
    return _slice.index(i, offsetBy: n, limitedBy: limit)
  }
}

----Swift.(file).UnicodeScalarView.distance(from:Substring.UnicodeScalarView.Index,to:Substring.UnicodeScalarView.Index)
extension Substring.UnicodeScalarView : BidirectionalCollection  {
  public func distance(from start: Index, to end: Index) -> Int {
    return _slice.distance(from: start, to: end)
  }
}

----Swift.(file).UnicodeScalarView.index(before:Substring.UnicodeScalarView.Index)
extension Substring.UnicodeScalarView : BidirectionalCollection  {
  public func index(before i: Index) -> Index { return _slice.index(before: i) }
}

----Swift.(file).UnicodeScalarView.formIndex(before:Substring.UnicodeScalarView.Index)
extension Substring.UnicodeScalarView : BidirectionalCollection  {
  public func formIndex(before i: inout Index) {
    _slice.formIndex(before: &i)
  }
}

----Swift.(file).UnicodeScalarView.subscript(_:Range<Substring.UnicodeScalarView.Index>)
extension Substring.UnicodeScalarView : BidirectionalCollection  {
  public subscript(r: Range<Index>) -> Substring.UnicodeScalarView {
    return Substring.UnicodeScalarView(_slice.base, _bounds: r)
  }
}

----Swift.(file).Substring.unicodeScalars
extension Substring  {
  public var unicodeScalars: UnicodeScalarView {
    get {
      return _wholeString.unicodeScalars[startIndex..<endIndex]
    }
    set {
      self = Substring(newValue)
    }
  }
}

----Swift.(file).Substring.init(_:Substring.UnicodeScalarView)
extension Substring  {
  public init(_ content: UnicodeScalarView) {
    self = String(
      content._slice.base._guts
    )[content.startIndex..<content.endIndex]
  }
}

----Swift.(file).String.init(_:Substring.UnicodeScalarView)
extension String  {
  public init(_ content: Substring.UnicodeScalarView) {
    self = String(Substring(content))
  }
}

----Swift.(file).UnicodeScalarView.init()
extension Substring.UnicodeScalarView : RangeReplaceableCollection  {
  public init() { _slice = Slice.init() }
}

----Swift.(file).UnicodeScalarView.replaceSubrange(_:Range<Substring.UnicodeScalarView.Index>,with:C)
extension Substring.UnicodeScalarView : RangeReplaceableCollection  {
  public mutating func replaceSubrange<C : Collection>(
    _ target: Range<Index>, with replacement: C
  ) where C.Element == Element {
    _slice.replaceSubrange(target, with: replacement)
  }
}

----Swift.(file).Substring.append(contentsOf:S)
extension Substring : RangeReplaceableCollection  {
  public mutating func append<S : Sequence>(contentsOf elements: S)
  where S.Element == Character {
    var string = String(self)
    self = Substring() // Keep unique storage if possible
    string.append(contentsOf: elements)
    self = Substring(string)
  }
}

----Swift.(file).Substring.lowercased()
extension Substring  {
  public func lowercased() -> String {
    return String(self).lowercased()
  }
}

----Swift.(file).Substring.uppercased()
extension Substring  {
  public func uppercased() -> String {
    return String(self).uppercased()
  }
}

----Swift.(file).Substring.filter(_:(Substring.Element) throws -> Bool)
extension Substring  {
  public func filter(
    _ isIncluded: (Element) throws -> Bool
  ) rethrows -> String {
    return try String(self.lazy.filter(isIncluded))
  }
}

----Swift.(file).Substring.write(_:String)
extension Substring : TextOutputStream  {
  public mutating func write(_ other: String) {
    append(contentsOf: other)
  }
}

----Swift.(file).Substring.write(to:Target)
extension Substring : TextOutputStreamable  {
  public func write<Target : TextOutputStream>(to target: inout Target) {
    target.write(String(self))
  }
}

----Swift.(file).Substring.init(unicodeScalarLiteral:String)
extension Substring : ExpressibleByUnicodeScalarLiteral  {
  public init(unicodeScalarLiteral value: String) {
     self.init(value)
  }
}

----Swift.(file).Substring.init(extendedGraphemeClusterLiteral:String)
extension Substring : ExpressibleByExtendedGraphemeClusterLiteral  {
  public init(extendedGraphemeClusterLiteral value: String) {
     self.init(value)
  }
}

----Swift.(file).Substring.init(stringLiteral:String)
extension Substring : ExpressibleByStringLiteral  {
  public init(stringLiteral value: String) {
     self.init(value)
  }
}

----Swift.(file).String.subscript(_:Range<String.Index>)
extension String  {
  public subscript(r: Range<Index>) -> Substring {
    _boundsCheck(r)
    return Substring(Slice(base: self, bounds: r))
  }
}

----Swift.(file).Substring.subscript(_:Range<Substring.Index>)
extension Substring  {
  public subscript(r: Range<Index>) -> Substring {
    return Substring(_slice[r])
  }
}

----Swift.(file)._UIntBuffer.makeIterator()
extension _UIntBuffer : Sequence  {
  public func makeIterator() -> Iterator {
    return Iterator(self)
  }
}

----Swift.(file)._UIntBuffer.startIndex
extension _UIntBuffer : Collection  {
  public var startIndex : Index {
    @inline(__always)
    get { return Index(bitOffset: 0) }
  }
}

----Swift.(file)._UIntBuffer.endIndex
extension _UIntBuffer : Collection  {
  public var endIndex : Index {
    @inline(__always)
    get { return Index(bitOffset: _bitCount) }
  }
}

----Swift.(file)._UIntBuffer.index(after:_UIntBuffer<Element>.Index)
extension _UIntBuffer : Collection  {
  public func index(after i: Index) -> Index {
    return Index(bitOffset: i.bitOffset &+ _elementWidth)
  }
}

----Swift.(file)._UIntBuffer.subscript(_:_UIntBuffer<Element>.Index)
extension _UIntBuffer : Collection  {
  public subscript(i: Index) -> Element {
    @inline(__always)
    get {
      return Element(truncatingIfNeeded: _storage &>> i.bitOffset)
    }
  }
}

----Swift.(file)._UIntBuffer.index(before:_UIntBuffer<Element>.Index)
extension _UIntBuffer : BidirectionalCollection  {
  public func index(before i: Index) -> Index {
    return Index(bitOffset: i.bitOffset &- _elementWidth)
  }
}

----Swift.(file)._UIntBuffer.index(_:_UIntBuffer<Element>.Index,offsetBy:Int)
extension _UIntBuffer : RandomAccessCollection  {
  public func index(_ i: Index, offsetBy n: Int) -> Index {
    let x = Int(i.bitOffset) &+ n &* Element.bitWidth
    return Index(bitOffset: UInt8(truncatingIfNeeded: x))
  }
}

----Swift.(file)._UIntBuffer.distance(from:_UIntBuffer<Element>.Index,to:_UIntBuffer<Element>.Index)
extension _UIntBuffer : RandomAccessCollection  {
  public func distance(from i: Index, to j: Index) -> Int {
    return (Int(j.bitOffset) &- Int(i.bitOffset)) / Element.bitWidth
  }
}

----Swift.(file)._UIntBuffer.init()
extension _UIntBuffer : RangeReplaceableCollection  {
  public init() {
    _storage = 0
    _bitCount = 0
  }
}

----Swift.(file)._UIntBuffer.capacity
extension _UIntBuffer : RangeReplaceableCollection  {
  public var capacity: Int {
    return Storage.bitWidth / Element.bitWidth
  }
}

----Swift.(file)._UIntBuffer.append(_:Element)
extension _UIntBuffer : RangeReplaceableCollection  {
  public mutating func append(_ newElement: Element) {
    precondition(count + 1 <= capacity)
    _storage &= ~(Storage(Element.max) &<< _bitCount)
    _storage |= Storage(newElement) &<< _bitCount
    _bitCount = _bitCount &+ _elementWidth
  }
}

----Swift.(file)._UIntBuffer.removeFirst()
extension _UIntBuffer : RangeReplaceableCollection  {
  public mutating func removeFirst() -> Element {
    precondition(!isEmpty)
    let result = Element(truncatingIfNeeded: _storage)
    _bitCount = _bitCount &- _elementWidth
    _storage = _storage._fullShiftRight(_elementWidth)
    return result
  }
}

----Swift.(file)._UIntBuffer.replaceSubrange(_:Range<_UIntBuffer<Element>.Index>,with:C)
extension _UIntBuffer : RangeReplaceableCollection  {
  public mutating func replaceSubrange<C: Collection>(
    _ target: Range<Index>, with replacement: C
  ) where C.Element == Element {
    precondition(
      (0..<_bitCount)._contains_(
        target.lowerBound.bitOffset..<target.upperBound.bitOffset))
    
    let replacement1 = _UIntBuffer(replacement)

    let targetCount = distance(
      from: target.lowerBound, to: target.upperBound)
    let growth = replacement1.count &- targetCount
    precondition(count + growth <= capacity)

    let headCount = distance(from: startIndex, to: target.lowerBound)
    let tailOffset = distance(from: startIndex, to: target.upperBound)

    let w = Element.bitWidth
    let headBits = _storage & ._lowBits(headCount &* w)
    let tailBits = _storage._fullShiftRight(tailOffset &* w)

    _storage = headBits
    _storage |= replacement1._storage &<< (headCount &* w)
    _storage |= tailBits &<< ((tailOffset &+ growth) &* w)
    _bitCount = UInt8(
      truncatingIfNeeded: Int(_bitCount) &+ growth &* w)
  }
}

----Swift.(file).UTF16.encodedReplacementCharacter
extension Unicode.UTF16 : Unicode.Encoding  {
  public static var encodedReplacementCharacter : EncodedScalar {
    return EncodedScalar(_storage: 0xFFFD, _bitCount: 16)
  }
}

----Swift.(file).UTF16.decode(_:Unicode.UTF16.EncodedScalar)
extension Unicode.UTF16 : Unicode.Encoding  {
  public static func decode(_ source: EncodedScalar) -> Unicode.Scalar {
    let bits = source._storage
    if _fastPath(source._bitCount == 16) {
      return Unicode.Scalar(_unchecked: bits & 0xffff)
    }
    _internalInvariant(source._bitCount == 32)
    let lower: UInt32 = bits >> 16 & 0x03ff
    let upper: UInt32 = (bits & 0x03ff) << 10
    let value = 0x10000 + (lower | upper)
    return Unicode.Scalar(_unchecked: value)
  }
}

----Swift.(file).UTF16.encode(_:Unicode.Scalar)
extension Unicode.UTF16 : Unicode.Encoding  {
  public static func encode(
    _ source: Unicode.Scalar
  ) -> EncodedScalar? {
    let x = source.value
    if _fastPath(x < ((1 as UInt32) << 16)) {
      return EncodedScalar(_storage: x, _bitCount: 16)
    }
    let x1 = x - ((1 as UInt32) << 16)
    var r = (0xdc00 + (x1 & 0x3ff))
    r &<<= 16
    r |= (0xd800 + (x1 &>> 10 & 0x3ff))
    return EncodedScalar(_storage: r, _bitCount: 32)
  }
}

----Swift.(file).UTF16.transcode(_:FromEncoding.EncodedScalar,from:FromEncoding.Type)
extension Unicode.UTF16 : Unicode.Encoding  {
  public static func transcode<FromEncoding : Unicode.Encoding>(
    _ content: FromEncoding.EncodedScalar, from _: FromEncoding.Type
  ) -> EncodedScalar? {
    if _fastPath(FromEncoding.self == UTF8.self) {
      let c = _identityCast(content, to: UTF8.EncodedScalar.self)
      var b = c.count
      b = b &- 1
      if _fastPath(b == 0) {
        return EncodedScalar(
          _storage: (c._biasedBits &- 0x1) & 0b0__111_1111, _bitCount: 16)
      }
      var s = c._biasedBits &- 0x01010101
      var r = s
      r &<<= 6
      s &>>= 8
      r |= s & 0b0__11_1111
      b = b &- 1
      
      if _fastPath(b == 0) {
        return EncodedScalar(_storage: r & 0b0__111_1111_1111, _bitCount: 16)
      }
      r &<<= 6
      s &>>= 8
      r |= s & 0b0__11_1111
      b = b &- 1
      
      if _fastPath(b == 0) {
        return EncodedScalar(_storage: r & 0xFFFF, _bitCount: 16)
      }
      
      r &<<= 6
      s &>>= 8
      r |= s & 0b0__11_1111
      r &= (1 &<< 21) - 1
      return encode(Unicode.Scalar(_unchecked: r))
    }
    else if _fastPath(FromEncoding.self == UTF16.self) {
      return unsafeBitCast(content, to: UTF16.EncodedScalar.self)
    }
    return encode(FromEncoding.decode(content))
  }
}

----Swift.(file).UTF32.encodedReplacementCharacter
extension Unicode.UTF32 : Unicode.Encoding  {
  public static var encodedReplacementCharacter : EncodedScalar {
    return EncodedScalar(_replacementCodeUnit)
  }
}

----Swift.(file).UTF32.decode(_:Unicode.UTF32.EncodedScalar)
extension Unicode.UTF32 : Unicode.Encoding  {
  public static func decode(_ source: EncodedScalar) -> Unicode.Scalar {
    return Unicode.Scalar(_unchecked: source.first!)
  }
}

----Swift.(file).UTF32.encode(_:Unicode.Scalar)
extension Unicode.UTF32 : Unicode.Encoding  {
  public static func encode(
    _ source: Unicode.Scalar
  ) -> EncodedScalar? {
    return EncodedScalar(source.value)
  }
}

----Swift.(file).Parser.parseScalar(from:I)
extension UTF32.Parser : Unicode.Parser  {
  public mutating func parseScalar<I : IteratorProtocol>(
    from input: inout I
  ) -> Unicode.ParseResult<Encoding.EncodedScalar>
  where I.Element == Encoding.CodeUnit {
    let n = input.next()
    if _fastPath(n != nil), let x = n {
      // Check code unit is valid: not surrogate-reserved and within range.
      guard _fastPath((x &>> 11) != 0b1101_1 && x <= 0x10ffff)
      else { return .error(length: 1) }
      
      // x is a valid scalar.
      return .valid(UTF32.EncodedScalar(x))
    }
    return .emptyInput
  }
}

----Swift.(file).UTF8.encodedReplacementCharacter
extension Unicode.UTF8 : _UnicodeEncoding  {
  public static var encodedReplacementCharacter : EncodedScalar {
    return EncodedScalar.encodedReplacementCharacter
  }
}

----Swift.(file).UTF8.decode(_:Unicode.UTF8.EncodedScalar)
extension Unicode.UTF8 : _UnicodeEncoding  {
  public static func decode(_ source: EncodedScalar) -> Unicode.Scalar {
    switch source.count {
    case 1:
      return Unicode.Scalar(_unchecked: source._biasedBits &- 0x01)
    case 2:
      let bits = source._biasedBits &- 0x0101
      var value = (bits & 0b0_______________________11_1111__0000_0000) &>> 8
      value    |= (bits & 0b0________________________________0001_1111) &<< 6
      return Unicode.Scalar(_unchecked: value)
    case 3:
      let bits = source._biasedBits &- 0x010101
      var value = (bits & 0b0____________11_1111__0000_0000__0000_0000) &>> 16
      value    |= (bits & 0b0_______________________11_1111__0000_0000) &>> 2
      value    |= (bits & 0b0________________________________0000_1111) &<< 12
      return Unicode.Scalar(_unchecked: value)
    default:
      _internalInvariant(source.count == 4)
      let bits = source._biasedBits &- 0x01010101
      var value = (bits & 0b0_11_1111__0000_0000__0000_0000__0000_0000) &>> 24
      value    |= (bits & 0b0____________11_1111__0000_0000__0000_0000) &>> 10
      value    |= (bits & 0b0_______________________11_1111__0000_0000) &<< 4
      value    |= (bits & 0b0________________________________0000_0111) &<< 18
      return Unicode.Scalar(_unchecked: value)
    }
  }
}

----Swift.(file).UTF8.encode(_:Unicode.Scalar)
extension Unicode.UTF8 : _UnicodeEncoding  {
  public static func encode(
    _ source: Unicode.Scalar
  ) -> EncodedScalar? {
    var c = source.value
    if _fastPath(c < (1&<<7)) {
      return EncodedScalar(_containing: UInt8(c))
    }
    var o = c & 0b0__0011_1111
    c &>>= 6
    o &<<= 8
    if _fastPath(c < (1&<<5)) {
      return EncodedScalar(_biasedBits: (o | c) &+ 0b0__1000_0001__1100_0001)
    }
    o |= c & 0b0__0011_1111
    c &>>= 6
    o &<<= 8
    if _fastPath(c < (1&<<4)) {
      return EncodedScalar(
        _biasedBits: (o | c) &+ 0b0__1000_0001__1000_0001__1110_0001)
    }
    o |= c & 0b0__0011_1111
    c &>>= 6
    o &<<= 8
    return EncodedScalar(
      _biasedBits: (o | c ) &+ 0b0__1000_0001__1000_0001__1000_0001__1111_0001)
  }
}

----Swift.(file).UTF8.transcode(_:FromEncoding.EncodedScalar,from:FromEncoding.Type)
extension Unicode.UTF8 : _UnicodeEncoding  {
  public static func transcode<FromEncoding : _UnicodeEncoding>(
    _ content: FromEncoding.EncodedScalar, from _: FromEncoding.Type
  ) -> EncodedScalar? {
    if _fastPath(FromEncoding.self == UTF16.self) {
      let c = _identityCast(content, to: UTF16.EncodedScalar.self)
      var u0 = UInt16(truncatingIfNeeded: c._storage) 
      if _fastPath(u0 < 0x80) {
        return EncodedScalar(_containing: UInt8(truncatingIfNeeded: u0))
      }
      var r = UInt32(u0 & 0b0__11_1111)
      r &<<= 8
      u0 &>>= 6
      if _fastPath(u0 < (1&<<5)) {
        return EncodedScalar(
          _biasedBits: (UInt32(u0) | r) &+ 0b0__1000_0001__1100_0001)
      }
      r |= UInt32(u0 & 0b0__11_1111)
      r &<<= 8
      if _fastPath(u0 & (0xF800 &>> 6) != (0xD800 &>> 6)) {
        u0 &>>= 6
        return EncodedScalar(
          _biasedBits: (UInt32(u0) | r) &+ 0b0__1000_0001__1000_0001__1110_0001)
      }
    }
    else if _fastPath(FromEncoding.self == UTF8.self) {
      return _identityCast(content, to: UTF8.EncodedScalar.self)
    }
    return encode(FromEncoding.decode(content))
  }
}

----Swift.(file)._UTFParser.parseScalar(from:I)
extension _UTFParser
where Encoding.EncodedScalar : RangeReplaceableCollection  {
  public mutating func parseScalar<I : IteratorProtocol>(
    from input: inout I
  ) -> Unicode.ParseResult<Encoding.EncodedScalar>
    where I.Element == Encoding.CodeUnit {

    // Bufferless single-scalar fastpath.
    if _fastPath(_buffer.isEmpty) {
      guard let codeUnit = input.next() else { return .emptyInput }
      // ASCII, return immediately.
      if Encoding._isScalar(codeUnit) {
        return .valid(Encoding.EncodedScalar(CollectionOfOne(codeUnit)))
      }
      // Non-ASCII, proceed to buffering mode.
      _buffer.append(codeUnit)
    } else if Encoding._isScalar(
      Encoding.CodeUnit(truncatingIfNeeded: _buffer._storage)
    ) {
      // ASCII in _buffer.  We don't refill the buffer so we can return
      // to bufferless mode once we've exhausted it.
      let codeUnit = Encoding.CodeUnit(truncatingIfNeeded: _buffer._storage)
      _buffer.remove(at: _buffer.startIndex)
      return .valid(Encoding.EncodedScalar(CollectionOfOne(codeUnit)))
    }
    // Buffering mode.
    // Fill buffer back to 4 bytes (or as many as are left in the iterator).
    repeat {
      if let codeUnit = input.next() {
        _buffer.append(codeUnit)
      } else {
        if _buffer.isEmpty { return .emptyInput }
        break // We still have some bytes left in our buffer.
      }
    } while _buffer.count < _buffer.capacity

    // Find one unicode scalar.
    let (isValid, scalarBitCount) = _parseMultipleCodeUnits()
    _internalInvariant(scalarBitCount % numericCast(Encoding.CodeUnit.bitWidth) == 0)
    _internalInvariant(1...4 ~= scalarBitCount / 8)
    _internalInvariant(scalarBitCount <= _buffer._bitCount)
    
    // Consume the decoded bytes (or maximal subpart of ill-formed sequence).
    let encodedScalar = _bufferedScalar(bitCount: scalarBitCount)
    
    _buffer._storage = UInt32(
      // widen to 64 bits so that we can empty the buffer in the 4-byte case
      truncatingIfNeeded: UInt64(_buffer._storage) &>> scalarBitCount)
      
    _buffer._bitCount = _buffer._bitCount &- scalarBitCount

    if _fastPath(isValid) {
      return .valid(encodedScalar)
    }
    return .error(
      length: Int(scalarBitCount / numericCast(Encoding.CodeUnit.bitWidth)))
  }
}

----Swift.(file).UnicodeDecodingResult.==infix(_:UnicodeDecodingResult,_:UnicodeDecodingResult)
extension UnicodeDecodingResult {
  public static func == (
    lhs: UnicodeDecodingResult,
    rhs: UnicodeDecodingResult
  ) -> Bool {
    switch (lhs, rhs) {
    case (.scalarValue(let lhsScalar), .scalarValue(let rhsScalar)):
      return lhsScalar == rhsScalar
    case (.emptyInput, .emptyInput):
      return true
    case (.error, .error):
      return true
    default:
      return false
    }
  }
}

----Swift.(file)..init()
extension Unicode.UTF8 : UnicodeCodec  {
  public init() { self = ._swift3Buffer(ForwardParser()) }
}

----Swift.(file)..decode(_:I)
extension Unicode.UTF8 : UnicodeCodec  {
  public mutating func decode<I : IteratorProtocol>(
    _ input: inout I
  ) -> UnicodeDecodingResult where I.Element == CodeUnit {
    guard case ._swift3Buffer(var parser) = self else {
      Builtin.unreachable()
    }
    defer { self = ._swift3Buffer(parser) }

    switch parser.parseScalar(from: &input) {
    case .valid(let s): return .scalarValue(UTF8.decode(s))
    case .error: return .error
    case .emptyInput: return .emptyInput
    }
  }
}

----Swift.(file)..encode(_:<<error type>>,into:<<error type>>)
extension Unicode.UTF8 : UnicodeCodec  {
  public static func encode(
    _ input: Unicode.Scalar,
    into processCodeUnit: (CodeUnit) -> Void
  ) {
    var s = encode(input)!._biasedBits
    processCodeUnit(UInt8(truncatingIfNeeded: s) &- 0x01)
    s &>>= 8
    if _fastPath(s == 0) { return }
    processCodeUnit(UInt8(truncatingIfNeeded: s) &- 0x01)
    s &>>= 8
    if _fastPath(s == 0) { return }
    processCodeUnit(UInt8(truncatingIfNeeded: s) &- 0x01)
    s &>>= 8
    if _fastPath(s == 0) { return }
    processCodeUnit(UInt8(truncatingIfNeeded: s) &- 0x01)
  }
}

----Swift.(file)..isContinuation(_:<<error type>>)
extension Unicode.UTF8 : UnicodeCodec  {
  public static func isContinuation(_ byte: CodeUnit) -> Bool {
    return byte & 0b11_00__0000 == 0b10_00__0000
  }
}

----Swift.(file)..init()
extension Unicode.UTF16 : UnicodeCodec  {
  public init() { self = ._swift3Buffer(ForwardParser()) }
}

----Swift.(file)..decode(_:I)
extension Unicode.UTF16 : UnicodeCodec  {
  public mutating func decode<I : IteratorProtocol>(
    _ input: inout I
  ) -> UnicodeDecodingResult where I.Element == CodeUnit {
    guard case ._swift3Buffer(var parser) = self else {
      Builtin.unreachable()
    }
    defer { self = ._swift3Buffer(parser) }
    switch parser.parseScalar(from: &input) {
    case .valid(let s): return .scalarValue(UTF16.decode(s))
    case .error: return .error
    case .emptyInput: return .emptyInput
    }
  }
}

----Swift.(file)..encode(_:<<error type>>,into:<<error type>>)
extension Unicode.UTF16 : UnicodeCodec  {
  public static func encode(
    _ input: Unicode.Scalar,
    into processCodeUnit: (CodeUnit) -> Void
  ) {
    var s = encode(input)!._storage
    processCodeUnit(UInt16(truncatingIfNeeded: s))
    s &>>= 16
    if _fastPath(s == 0) { return }
    processCodeUnit(UInt16(truncatingIfNeeded: s))
  }
}

----Swift.(file)..init()
extension Unicode.UTF32 : UnicodeCodec  {
  public init() { self = ._swift3Codec }
}

----Swift.(file)..decode(_:I)
extension Unicode.UTF32 : UnicodeCodec  {
  public mutating func decode<I : IteratorProtocol>(
    _ input: inout I
  ) -> UnicodeDecodingResult where I.Element == CodeUnit {
    var parser = ForwardParser()
    
    switch parser.parseScalar(from: &input) {
    case .valid(let s): return .scalarValue(UTF32.decode(s))
    case .error:      return .error
    case .emptyInput:   return .emptyInput
    }
  }
}

----Swift.(file)..encode(_:<<error type>>,into:<<error type>>)
extension Unicode.UTF32 : UnicodeCodec  {
  public static func encode(
    _ input: Unicode.Scalar,
    into processCodeUnit: (CodeUnit) -> Void
  ) {
    processCodeUnit(UInt32(input))
  }
}

----Swift.(file).transcode(_:Input,from:InputEncoding.Type,to:OutputEncoding.Type,stoppingOnError:Bool,into:<<error type>>)
public func transcode<
  Input : IteratorProtocol,
  InputEncoding : Unicode.Encoding,
  OutputEncoding : Unicode.Encoding
>(
  _ input: Input,
  from inputEncoding: InputEncoding.Type,
  to outputEncoding: OutputEncoding.Type,
  stoppingOnError stopOnError: Bool,
  into processCodeUnit: (OutputEncoding.CodeUnit) -> Void
) -> Bool
  where InputEncoding.CodeUnit == Input.Element {
  var input = input

  // NB.  It is not possible to optimize this routine to a memcpy if
  // InputEncoding == OutputEncoding.  The reason is that memcpy will not
  // substitute U+FFFD replacement characters for ill-formed sequences.

  var p = InputEncoding.ForwardParser()
  var hadError = false
  loop:
  while true {
    switch p.parseScalar(from: &input) {
    case .valid(let s):
      let t = OutputEncoding.transcode(s, from: inputEncoding)
      guard _fastPath(t != nil), let s = t else { break }
      s.forEach(processCodeUnit)
      continue loop
    case .emptyInput:
      return hadError
    case .error:
      if _slowPath(stopOnError) { return true }
      hadError = true
    }
    OutputEncoding.encodedReplacementCharacter.forEach(processCodeUnit)
  }
}

----Swift.(file).UTF16.width(_:<<error type>>)
extension UTF16  {
  public static func width(_ x: Unicode.Scalar) -> Int {
    return x.value <= 0xFFFF ? 1 : 2
  }
}

----Swift.(file).UTF16.leadSurrogate(_:<<error type>>)
extension UTF16  {
  public static func leadSurrogate(_ x: Unicode.Scalar) -> UTF16.CodeUnit {
    precondition(width(x) == 2)
    return 0xD800 + UTF16.CodeUnit(truncatingIfNeeded:
      (x.value - 0x1_0000) &>> (10 as UInt32))
  }
}

----Swift.(file).UTF16.trailSurrogate(_:<<error type>>)
extension UTF16  {
  public static func trailSurrogate(_ x: Unicode.Scalar) -> UTF16.CodeUnit {
    precondition(width(x) == 2)
    return 0xDC00 + UTF16.CodeUnit(truncatingIfNeeded:
      (x.value - 0x1_0000) & (((1 as UInt32) &<< 10) - 1))
  }
}

----Swift.(file).UTF16.isLeadSurrogate(_:Unicode.UTF16.CodeUnit)
extension UTF16  {
  public static func isLeadSurrogate(_ x: CodeUnit) -> Bool {
    return (x & 0xFC00) == 0xD800
  }
}

----Swift.(file).UTF16.isTrailSurrogate(_:Unicode.UTF16.CodeUnit)
extension UTF16  {
  public static func isTrailSurrogate(_ x: CodeUnit) -> Bool {
    return (x & 0xFC00) == 0xDC00
  }
}

----Swift.(file).UTF16.transcodedLength(of:Input,decodedAs:Encoding.Type,repairingIllFormedSequences:Bool)
extension UTF16  {
  public static func transcodedLength<
    Input : IteratorProtocol,
    Encoding : Unicode.Encoding
  >(
    of input: Input,
    decodedAs sourceEncoding: Encoding.Type,
    repairingIllFormedSequences: Bool
  ) -> (count: Int, isASCII: Bool)?
    where Encoding.CodeUnit == Input.Element {

    var utf16Count = 0
    var i = input
    var d = Encoding.ForwardParser()

    // Fast path for ASCII in a UTF8 buffer
    if sourceEncoding == Unicode.UTF8.self {
      var peek: Encoding.CodeUnit = 0
      while let u = i.next() {
        peek = u
        guard _fastPath(peek < 0x80) else { break }
        utf16Count = utf16Count + 1
      }
      if _fastPath(peek < 0x80) { return (utf16Count, true) }
      
      var d1 = UTF8.ForwardParser()
      d1._buffer.append(numericCast(peek))
      d = _identityCast(d1, to: Encoding.ForwardParser.self)
    }
    
    var utf16BitUnion: CodeUnit = 0
    while true {
      let s = d.parseScalar(from: &i)
      if _fastPath(s._valid != nil), let scalarContent = s._valid {
        let utf16 = transcode(scalarContent, from: sourceEncoding)
          ._unsafelyUnwrappedUnchecked
        utf16Count += utf16.count
        for x in utf16 { utf16BitUnion |= x }
      }
      else if let _ = s._error {
        guard _fastPath(repairingIllFormedSequences) else { return nil }
        utf16Count += 1
        utf16BitUnion |= UTF16._replacementCodeUnit
      }
      else {
        return (utf16Count, utf16BitUnion < 0x80)
      }
    }
  }
}

----Swift.(file).transcode(_:InputEncoding.Type,_:OutputEncoding.Type,_:Input,_:<<error type>>,stopOnError:Bool)
public func transcode<Input, InputEncoding, OutputEncoding>(
  _ inputEncoding: InputEncoding.Type, _ outputEncoding: OutputEncoding.Type,
  _ input: Input, _ output: (OutputEncoding.CodeUnit) -> Void,
  stopOnError: Bool
) -> Bool
  where
  Input : IteratorProtocol,
  InputEncoding : UnicodeCodec,
  OutputEncoding : UnicodeCodec,
  InputEncoding.CodeUnit == Input.Element {
  Builtin.unreachable()
}

----Swift.(file)._UnicodeEncoding.transcode(_:<<error type>>,from:FromEncoding.Type)
extension _UnicodeEncoding  {
  public static func transcode<FromEncoding : Unicode.Encoding>(
    _ content: FromEncoding.EncodedScalar, from _: FromEncoding.Type
  ) -> EncodedScalar? {
    return encode(FromEncoding.decode(content))
  }
}

----Swift.(file).Scalar.value
extension Unicode.Scalar :
    _ExpressibleByBuiltinUnicodeScalarLiteral,
    ExpressibleByUnicodeScalarLiteral  {
  public var value: UInt32 { return _value }
}

----Swift.(file).Scalar.init(_builtinUnicodeScalarLiteral:<<error type>>)
extension Unicode.Scalar :
    _ExpressibleByBuiltinUnicodeScalarLiteral,
    ExpressibleByUnicodeScalarLiteral  {
  public init(_builtinUnicodeScalarLiteral value: Builtin.Int32) {
    self._value = UInt32(value)
  }
}

----Swift.(file).Scalar.init(unicodeScalarLiteral:<<error type>>)
extension Unicode.Scalar :
    _ExpressibleByBuiltinUnicodeScalarLiteral,
    ExpressibleByUnicodeScalarLiteral  {
  public init(unicodeScalarLiteral value: Unicode.Scalar) {
    self = value
  }
}

----Swift.(file).Scalar.init(_:UInt16)
extension Unicode.Scalar :
    _ExpressibleByBuiltinUnicodeScalarLiteral,
    ExpressibleByUnicodeScalarLiteral  {
  public init?(_ v: UInt16) {
    self.init(UInt32(v))
  }
}

----Swift.(file).Scalar.init(_:UInt8)
extension Unicode.Scalar :
    _ExpressibleByBuiltinUnicodeScalarLiteral,
    ExpressibleByUnicodeScalarLiteral  {
  public init(_ v: UInt8) {
    self._value = UInt32(v)
  }
}

----Swift.(file).Scalar.init(_:<<error type>>)
extension Unicode.Scalar :
    _ExpressibleByBuiltinUnicodeScalarLiteral,
    ExpressibleByUnicodeScalarLiteral  {
  public init(_ v: Unicode.Scalar) {
    // This constructor allows one to provide necessary type context to
    // disambiguate between function overloads on 'String' and 'Unicode.Scalar'.
    self = v
  }
}

----Swift.(file).Scalar.escaped(asASCII:Bool)
extension Unicode.Scalar :
    _ExpressibleByBuiltinUnicodeScalarLiteral,
    ExpressibleByUnicodeScalarLiteral  {
  public func escaped(asASCII forceASCII: Bool) -> String {
    func lowNibbleAsHex(_ v: UInt32) -> String {
      let nibble = v & 15
      if nibble < 10 {
        return String(Unicode.Scalar(nibble+48)!)    // 48 = '0'
      } else {
        return String(Unicode.Scalar(nibble-10+65)!) // 65 = 'A'
      }
    }

    if self == "\\" {
      return "\\\\"
    } else if self == "\'" {
      return "\\\'"
    } else if self == "\"" {
      return "\\\""
    } else if _isPrintableASCII {
      return String(self)
    } else if self == "\0" {
      return "\\0"
    } else if self == "\n" {
      return "\\n"
    } else if self == "\r" {
      return "\\r"
    } else if self == "\t" {
      return "\\t"
    } else if UInt32(self) < 128 {
      return "\\u{"
        + lowNibbleAsHex(UInt32(self) >> 4)
        + lowNibbleAsHex(UInt32(self)) + "}"
    } else if !forceASCII {
      return String(self)
    } else if UInt32(self) <= 0xFFFF {
      var result = "\\u{"
      result += lowNibbleAsHex(UInt32(self) >> 12)
      result += lowNibbleAsHex(UInt32(self) >> 8)
      result += lowNibbleAsHex(UInt32(self) >> 4)
      result += lowNibbleAsHex(UInt32(self))
      result += "}"
      return result
    } else {
      // FIXME: Type checker performance prohibits this from being a
      // single chained "+".
      var result = "\\u{"
      result += lowNibbleAsHex(UInt32(self) >> 28)
      result += lowNibbleAsHex(UInt32(self) >> 24)
      result += lowNibbleAsHex(UInt32(self) >> 20)
      result += lowNibbleAsHex(UInt32(self) >> 16)
      result += lowNibbleAsHex(UInt32(self) >> 12)
      result += lowNibbleAsHex(UInt32(self) >> 8)
      result += lowNibbleAsHex(UInt32(self) >> 4)
      result += lowNibbleAsHex(UInt32(self))
      result += "}"
      return result
    }
  }
}

----Swift.(file).Scalar.isASCII
extension Unicode.Scalar :
    _ExpressibleByBuiltinUnicodeScalarLiteral,
    ExpressibleByUnicodeScalarLiteral  {
  public var isASCII: Bool {
    return value <= 127
  }
}

----Swift.(file).Scalar.description
extension Unicode.Scalar : CustomStringConvertible, CustomDebugStringConvertible  {
  public var description: String {
    return String(self)
  }
}

----Swift.(file).Scalar.debugDescription
extension Unicode.Scalar : CustomStringConvertible, CustomDebugStringConvertible  {
  public var debugDescription: String {
    return "\"\(escaped(asASCII: true))\""
  }
}

----Swift.(file).Scalar.hash(into:Hasher)
extension Unicode.Scalar : Hashable  {
  public func hash(into hasher: inout Hasher) {
    hasher.combine(self.value)
  }
}

----Swift.(file).UInt8.init(ascii:<<error type>>)
extension UInt8  {
  public init(ascii v: Unicode.Scalar) {
    precondition(v.value < 128,
        "Code point value does not fit into ASCII")
    self = UInt8(v.value)
  }
}

----Swift.(file).UInt32.init(_:<<error type>>)
extension UInt32  {
  public init(_ v: Unicode.Scalar) {
    self = v.value
  }
}

----Swift.(file).UInt64.init(_:<<error type>>)
extension UInt64  {
  public init(_ v: Unicode.Scalar) {
    self = UInt64(v.value)
  }
}

----Swift.(file).Scalar.==infix(_:<<error type>>,_:<<error type>>)
extension Unicode.Scalar : Equatable  {
  public static func == (lhs: Unicode.Scalar, rhs: Unicode.Scalar) -> Bool {
    return lhs.value == rhs.value
  }
}

----Swift.(file).Scalar.<infix(_:<<error type>>,_:<<error type>>)
extension Unicode.Scalar : Comparable  {
  public static func < (lhs: Unicode.Scalar, rhs: Unicode.Scalar) -> Bool {
    return lhs.value < rhs.value
  }
}

----Swift.(file).Scalar.utf16
extension Unicode.Scalar  {
  public var utf16: UTF16View {
    return UTF16View(value: self)
  }
}

----Swift.(file).UTF16View.startIndex
extension Unicode.Scalar.UTF16View : RandomAccessCollection  {
  public var startIndex: Int {
    return 0
  }
}

----Swift.(file).UTF16View.endIndex
extension Unicode.Scalar.UTF16View : RandomAccessCollection  {
  public var endIndex: Int {
    return 0 + UTF16.width(value)
  }
}

----Swift.(file).UTF16View.subscript(_:Int)
extension Unicode.Scalar.UTF16View : RandomAccessCollection  {
  public subscript(position: Int) -> UTF16.CodeUnit {
    return position == 0 ? (
      endIndex == 1 ? UTF16.CodeUnit(value.value) : UTF16.leadSurrogate(value)
    ) : UTF16.trailSurrogate(value)
  }
}

----Swift.(file).Scalar.init()
extension Unicode.Scalar  {
  public init() {
    Builtin.unreachable()
  }
}

----Swift.(file).Scalar.properties
extension Unicode.Scalar  {
  public var properties: Properties {
    return Properties(self)
  }
}

----Swift.(file).Properties.isAlphabetic
extension Unicode.Scalar.Properties  {
  public var isAlphabetic: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_ALPHABETIC)
  }
}

----Swift.(file).Properties.isASCIIHexDigit
extension Unicode.Scalar.Properties  {
  public var isASCIIHexDigit: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_ASCII_HEX_DIGIT)
  }
}

----Swift.(file).Properties.isBidiControl
extension Unicode.Scalar.Properties  {
  public var isBidiControl: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_BIDI_CONTROL)
  }
}

----Swift.(file).Properties.isBidiMirrored
extension Unicode.Scalar.Properties  {
  public var isBidiMirrored: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_BIDI_MIRRORED)
  }
}

----Swift.(file).Properties.isDash
extension Unicode.Scalar.Properties  {
  public var isDash: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_DASH)
  }
}

----Swift.(file).Properties.isDefaultIgnorableCodePoint
extension Unicode.Scalar.Properties  {
  public var isDefaultIgnorableCodePoint: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_DEFAULT_IGNORABLE_CODE_POINT)
  }
}

----Swift.(file).Properties.isDeprecated
extension Unicode.Scalar.Properties  {
  public var isDeprecated: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_DEPRECATED)
  }
}

----Swift.(file).Properties.isDiacritic
extension Unicode.Scalar.Properties  {
  public var isDiacritic: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_DIACRITIC)
  }
}

----Swift.(file).Properties.isExtender
extension Unicode.Scalar.Properties  {
  public var isExtender: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_EXTENDER)
  }
}

----Swift.(file).Properties.isFullCompositionExclusion
extension Unicode.Scalar.Properties  {
  public var isFullCompositionExclusion: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_FULL_COMPOSITION_EXCLUSION)
  }
}

----Swift.(file).Properties.isGraphemeBase
extension Unicode.Scalar.Properties  {
  public var isGraphemeBase: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_GRAPHEME_BASE)
  }
}

----Swift.(file).Properties.isGraphemeExtend
extension Unicode.Scalar.Properties  {
  public var isGraphemeExtend: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_GRAPHEME_EXTEND)
  }
}

----Swift.(file).Properties.isHexDigit
extension Unicode.Scalar.Properties  {
  public var isHexDigit: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_HEX_DIGIT)
  }
}

----Swift.(file).Properties.isIDContinue
extension Unicode.Scalar.Properties  {
  public var isIDContinue: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_ID_CONTINUE)
  }
}

----Swift.(file).Properties.isIDStart
extension Unicode.Scalar.Properties  {
  public var isIDStart: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_ID_START)
  }
}

----Swift.(file).Properties.isIdeographic
extension Unicode.Scalar.Properties  {
  public var isIdeographic: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_IDEOGRAPHIC)
  }
}

----Swift.(file).Properties.isIDSBinaryOperator
extension Unicode.Scalar.Properties  {
  public var isIDSBinaryOperator: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_IDS_BINARY_OPERATOR)
  }
}

----Swift.(file).Properties.isIDSTrinaryOperator
extension Unicode.Scalar.Properties  {
  public var isIDSTrinaryOperator: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_IDS_TRINARY_OPERATOR)
  }
}

----Swift.(file).Properties.isJoinControl
extension Unicode.Scalar.Properties  {
  public var isJoinControl: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_JOIN_CONTROL)
  }
}

----Swift.(file).Properties.isLogicalOrderException
extension Unicode.Scalar.Properties  {
  public var isLogicalOrderException: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_LOGICAL_ORDER_EXCEPTION)
  }
}

----Swift.(file).Properties.isLowercase
extension Unicode.Scalar.Properties  {
  public var isLowercase: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_LOWERCASE)
  }
}

----Swift.(file).Properties.isMath
extension Unicode.Scalar.Properties  {
  public var isMath: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_MATH)
  }
}

----Swift.(file).Properties.isNoncharacterCodePoint
extension Unicode.Scalar.Properties  {
  public var isNoncharacterCodePoint: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_NONCHARACTER_CODE_POINT)
  }
}

----Swift.(file).Properties.isQuotationMark
extension Unicode.Scalar.Properties  {
  public var isQuotationMark: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_QUOTATION_MARK)
  }
}

----Swift.(file).Properties.isRadical
extension Unicode.Scalar.Properties  {
  public var isRadical: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_RADICAL)
  }
}

----Swift.(file).Properties.isSoftDotted
extension Unicode.Scalar.Properties  {
  public var isSoftDotted: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_SOFT_DOTTED)
  }
}

----Swift.(file).Properties.isTerminalPunctuation
extension Unicode.Scalar.Properties  {
  public var isTerminalPunctuation: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_TERMINAL_PUNCTUATION)
  }
}

----Swift.(file).Properties.isUnifiedIdeograph
extension Unicode.Scalar.Properties  {
  public var isUnifiedIdeograph: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_UNIFIED_IDEOGRAPH)
  }
}

----Swift.(file).Properties.isUppercase
extension Unicode.Scalar.Properties  {
  public var isUppercase: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_UPPERCASE)
  }
}

----Swift.(file).Properties.isWhitespace
extension Unicode.Scalar.Properties  {
  public var isWhitespace: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_WHITE_SPACE)
  }
}

----Swift.(file).Properties.isXIDContinue
extension Unicode.Scalar.Properties  {
  public var isXIDContinue: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_XID_CONTINUE)
  }
}

----Swift.(file).Properties.isXIDStart
extension Unicode.Scalar.Properties  {
  public var isXIDStart: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_XID_START)
  }
}

----Swift.(file).Properties.isSentenceTerminal
extension Unicode.Scalar.Properties  {
  public var isSentenceTerminal: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_S_TERM)
  }
}

----Swift.(file).Properties.isVariationSelector
extension Unicode.Scalar.Properties  {
  public var isVariationSelector: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_VARIATION_SELECTOR)
  }
}

----Swift.(file).Properties.isPatternSyntax
extension Unicode.Scalar.Properties  {
  public var isPatternSyntax: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_PATTERN_SYNTAX)
  }
}

----Swift.(file).Properties.isPatternWhitespace
extension Unicode.Scalar.Properties  {
  public var isPatternWhitespace: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_PATTERN_WHITE_SPACE)
  }
}

----Swift.(file).Properties.isCased
extension Unicode.Scalar.Properties  {
  public var isCased: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_CASED)
  }
}

----Swift.(file).Properties.isCaseIgnorable
extension Unicode.Scalar.Properties  {
  public var isCaseIgnorable: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_CASE_IGNORABLE)
  }
}

----Swift.(file).Properties.changesWhenLowercased
extension Unicode.Scalar.Properties  {
  public var changesWhenLowercased: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_CHANGES_WHEN_LOWERCASED)
  }
}

----Swift.(file).Properties.changesWhenUppercased
extension Unicode.Scalar.Properties  {
  public var changesWhenUppercased: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_CHANGES_WHEN_UPPERCASED)
  }
}

----Swift.(file).Properties.changesWhenTitlecased
extension Unicode.Scalar.Properties  {
  public var changesWhenTitlecased: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_CHANGES_WHEN_TITLECASED)
  }
}

----Swift.(file).Properties.changesWhenCaseFolded
extension Unicode.Scalar.Properties  {
  public var changesWhenCaseFolded: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_CHANGES_WHEN_CASEFOLDED)
  }
}

----Swift.(file).Properties.changesWhenCaseMapped
extension Unicode.Scalar.Properties  {
  public var changesWhenCaseMapped: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_CHANGES_WHEN_CASEMAPPED)
  }
}

----Swift.(file).Properties.changesWhenNFKCCaseFolded
extension Unicode.Scalar.Properties  {
  public var changesWhenNFKCCaseFolded: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_CHANGES_WHEN_NFKC_CASEFOLDED)
  }
}

----Swift.(file).Properties.isEmoji
extension Unicode.Scalar.Properties  {
  public var isEmoji: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_EMOJI)
  }
}

----Swift.(file).Properties.isEmojiPresentation
extension Unicode.Scalar.Properties  {
  public var isEmojiPresentation: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_EMOJI_PRESENTATION)
  }
}

----Swift.(file).Properties.isEmojiModifier
extension Unicode.Scalar.Properties  {
  public var isEmojiModifier: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_EMOJI_MODIFIER)
  }
}

----Swift.(file).Properties.isEmojiModifierBase
extension Unicode.Scalar.Properties  {
  public var isEmojiModifierBase: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_EMOJI_MODIFIER_BASE)
  }
}

----Swift.(file).Properties.lowercaseMapping
extension Unicode.Scalar.Properties  {
  public var lowercaseMapping: String {
    return _applyMapping(__swift_stdlib_u_strToLower)
  }
}

----Swift.(file).Properties.titlecaseMapping
extension Unicode.Scalar.Properties  {
  public var titlecaseMapping: String {
    return _applyMapping { ptr, cap, src, len, locale, err in
      return __swift_stdlib_u_strToTitle(ptr, cap, src, len, nil, locale, err)
    }
  }
}

----Swift.(file).Properties.uppercaseMapping
extension Unicode.Scalar.Properties  {
  public var uppercaseMapping: String {
    return _applyMapping(__swift_stdlib_u_strToUpper)
  }
}

----Swift.(file).Properties.age
extension Unicode.Scalar.Properties  {
  public var age: Unicode.Version? {
    var versionInfo: __swift_stdlib_UVersionInfo = (0, 0, 0, 0)
    withUnsafeMutablePointer(to: &versionInfo) { tuplePtr in
      tuplePtr.withMemoryRebound(to: UInt8.self, capacity: 4) {
        versionInfoPtr in
        __swift_stdlib_u_charAge(icuValue, versionInfoPtr)
      }
    }
    guard versionInfo.0 != 0 else { return nil }
    return (major: Int(versionInfo.0), minor: Int(versionInfo.1))
  }
}

----Swift.(file).Properties.generalCategory
extension Unicode.Scalar.Properties  {
  public var generalCategory: Unicode.GeneralCategory {
    let rawValue = __swift_stdlib_UCharCategory(
      __swift_stdlib_UCharCategory.RawValue(
      __swift_stdlib_u_getIntPropertyValue(
        icuValue, __swift_stdlib_UCHAR_GENERAL_CATEGORY)))
    return Unicode.GeneralCategory(rawValue: rawValue)
  }
}

----Swift.(file).Properties.nameAlias
extension Unicode.Scalar.Properties  {
  public var nameAlias: String? {
    return _scalarName(__swift_stdlib_U_CHAR_NAME_ALIAS)
  }
}

----Swift.(file).Properties.canonicalCombiningClass
extension Unicode.Scalar.Properties  {
  public var canonicalCombiningClass: Unicode.CanonicalCombiningClass {
    let rawValue = UInt8(__swift_stdlib_u_getIntPropertyValue(
      icuValue, __swift_stdlib_UCHAR_CANONICAL_COMBINING_CLASS))
    return Unicode.CanonicalCombiningClass(rawValue: rawValue)
  }
}

----Swift.(file).Properties.numericType
extension Unicode.Scalar.Properties  {
  public var numericType: Unicode.NumericType? {
    let rawValue = __swift_stdlib_UNumericType(
      __swift_stdlib_UNumericType.RawValue(
      __swift_stdlib_u_getIntPropertyValue(
        icuValue, __swift_stdlib_UCHAR_NUMERIC_TYPE)))
    return Unicode.NumericType(rawValue: rawValue)
  }
}

----Swift.(file).Properties.numericValue
extension Unicode.Scalar.Properties  {
  public var numericValue: Double? {
    let icuNoNumericValue: Double = -123456789
    let result = __swift_stdlib_u_getNumericValue(icuValue)
    return result != icuNoNumericValue ? result : nil
  }
}

----Swift.(file).Unmanaged.fromOpaque(_:UnsafeRawPointer)
extension Unmanaged {
  public static func fromOpaque(_ value: UnsafeRawPointer) -> Unmanaged {
    return Unmanaged(_private: unsafeBitCast(value, to: Instance.self))
  }
}

----Swift.(file).Unmanaged.toOpaque()
extension Unmanaged {
  public func toOpaque() -> UnsafeMutableRawPointer {
    return unsafeBitCast(_value, to: UnsafeMutableRawPointer.self)
  }
}

----Swift.(file).Unmanaged.passRetained(_:Instance)
extension Unmanaged {
  public static func passRetained(_ value: Instance) -> Unmanaged {
    return Unmanaged(_private: value).retain()
  }
}

----Swift.(file).Unmanaged.passUnretained(_:Instance)
extension Unmanaged {
  public static func passUnretained(_ value: Instance) -> Unmanaged {
    return Unmanaged(_private: value)
  }
}

----Swift.(file).Unmanaged.takeUnretainedValue()
extension Unmanaged {
  public func takeUnretainedValue() -> Instance {
    return _value
  }
}

----Swift.(file).Unmanaged.takeRetainedValue()
extension Unmanaged {
  public func takeRetainedValue() -> Instance {
    let result = _value
    release()
    return result
  }
}

----Swift.(file).Unmanaged.retain()
extension Unmanaged {
  public func retain() -> Unmanaged {
    Builtin.retain(_value)
    return self
  }
}

----Swift.(file).Unmanaged.release()
extension Unmanaged {
  public func release() {
    Builtin.release(_value)
  }
}

----Swift.(file).Unmanaged.autorelease()
extension Unmanaged {
  public func autorelease() -> Unmanaged {
    Builtin.autorelease(_value)
    return self
  }
}

----Swift.(file).UnsafePointer.init(_:<<error type>>)
extension UnsafePointer {
  public init(_ _rawValue : Builtin.RawPointer) {
    self._rawValue = _rawValue
  }
}

----Swift.(file).UnsafePointer.deallocate()
extension UnsafePointer {
  public func deallocate() {
    Builtin.deallocRaw(_rawValue, (-1)._builtinWordValue, (-1)._builtinWordValue)
  }
}

----Swift.(file).UnsafePointer.pointee
extension UnsafePointer {
  public var pointee: Pointee {
    @_transparent unsafeAddress {
      return self
    }
  }
}

----Swift.(file).UnsafePointer.withMemoryRebound(to:T.Type,capacity:Int,_:(UnsafePointer<T>) throws -> Result)
extension UnsafePointer {
  public func withMemoryRebound<T, Result>(to type: T.Type, capacity count: Int,
    _ body: (UnsafePointer<T>) throws -> Result
  ) rethrows -> Result {
    Builtin.bindMemory(_rawValue, count._builtinWordValue, T.self)
    defer {
      Builtin.bindMemory(_rawValue, count._builtinWordValue, Pointee.self)
    }
    return try body(UnsafePointer<T>(_rawValue))
  }
}

----Swift.(file).UnsafePointer.subscript(_:Int)
extension UnsafePointer {
  public subscript(i: Int) -> Pointee {
    @_transparent
    unsafeAddress {
      return self + i
    }
  }
}

----Swift.(file).UnsafeMutablePointer.init(_:<<error type>>)
extension UnsafeMutablePointer {
  public init(_ _rawValue : Builtin.RawPointer) {
    self._rawValue = _rawValue
  }
}

----Swift.(file).UnsafeMutablePointer.init(mutating:UnsafePointer<Pointee>)
extension UnsafeMutablePointer {
  public init(mutating other: UnsafePointer<Pointee>) {
    self._rawValue = other._rawValue
  }
}

----Swift.(file).UnsafeMutablePointer.init(mutating:UnsafePointer<Pointee>?)
extension UnsafeMutablePointer {
  public init?(mutating other: UnsafePointer<Pointee>?) {
    guard let unwrapped = other else { return nil }
    self.init(mutating: unwrapped)
  }
}

----Swift.(file).UnsafeMutablePointer.allocate(capacity:Int)
extension UnsafeMutablePointer {
  public static func allocate(capacity count: Int)
    -> UnsafeMutablePointer<Pointee> {
    let size = MemoryLayout<Pointee>.stride * count
    let rawPtr =
      Builtin.allocRaw(size._builtinWordValue, Builtin.alignof(Pointee.self))
    Builtin.bindMemory(rawPtr, count._builtinWordValue, Pointee.self)
    return UnsafeMutablePointer(rawPtr)
  }
}

----Swift.(file).UnsafeMutablePointer.deallocate()
extension UnsafeMutablePointer {
  public func deallocate() {
    Builtin.deallocRaw(_rawValue, (-1)._builtinWordValue,
                       Builtin.alignof(Pointee.self))
  }
}

----Swift.(file).UnsafeMutablePointer.pointee
extension UnsafeMutablePointer {
  public var pointee: Pointee {
    @_transparent unsafeAddress {
      return UnsafePointer(self)
    }
    @_transparent nonmutating unsafeMutableAddress {
      return self
    }
  }
}

----Swift.(file).UnsafeMutablePointer.initialize(repeating:Pointee,count:Int)
extension UnsafeMutablePointer {
  public func initialize(repeating repeatedValue: Pointee, count: Int) {
    // FIXME: add tests (since the `count` has been added)
    precondition(count >= 0,
      "UnsafeMutablePointer.initialize(repeating:count:): negative count")
    // Must not use `initializeFrom` with a `Collection` as that will introduce
    // a cycle.
    for offset in 0..<count {
      Builtin.initialize(repeatedValue, (self + offset)._rawValue)
    }
  }
}

----Swift.(file).UnsafeMutablePointer.initialize(to:Pointee)
extension UnsafeMutablePointer {
  public func initialize(to value: Pointee) {
    Builtin.initialize(value, self._rawValue)
  }
}

----Swift.(file).UnsafeMutablePointer.move()
extension UnsafeMutablePointer {
  public func move() -> Pointee {
    return Builtin.take(_rawValue)
  }
}

----Swift.(file).UnsafeMutablePointer.assign(repeating:Pointee,count:Int)
extension UnsafeMutablePointer {
  public func assign(repeating repeatedValue: Pointee, count: Int) {
    precondition(count >= 0, "UnsafeMutablePointer.assign(repeating:count:) with negative count")
    for i in 0..<count {
      self[i] = repeatedValue
    }
  }
}

----Swift.(file).UnsafeMutablePointer.assign(from:UnsafePointer<Pointee>,count:Int)
extension UnsafeMutablePointer {
  public func assign(from source: UnsafePointer<Pointee>, count: Int) {
    precondition(
      count >= 0, "UnsafeMutablePointer.assign with negative count")
    if UnsafePointer(self) < source || UnsafePointer(self) >= source + count {
      // assign forward from a disjoint or following overlapping range.
      Builtin.assignCopyArrayFrontToBack(
        Pointee.self, self._rawValue, source._rawValue, count._builtinWordValue)
      // This builtin is equivalent to:
      // for i in 0..<count {
      //   self[i] = source[i]
      // }
    }
    else if UnsafePointer(self) != source {
      // assign backward from a non-following overlapping range.
      Builtin.assignCopyArrayBackToFront(
        Pointee.self, self._rawValue, source._rawValue, count._builtinWordValue)
      // This builtin is equivalent to:
      // var i = count-1
      // while i >= 0 {
      //   self[i] = source[i]
      //   i -= 1
      // }
    }
  }
}

----Swift.(file).UnsafeMutablePointer.moveInitialize(from:UnsafeMutablePointer<Pointee>,count:Int)
extension UnsafeMutablePointer {
  public func moveInitialize(from source: UnsafeMutablePointer, count: Int) {
    precondition(
      count >= 0, "UnsafeMutablePointer.moveInitialize with negative count")
    if self < source || self >= source + count {
      // initialize forward from a disjoint or following overlapping range.
      Builtin.takeArrayFrontToBack(
        Pointee.self, self._rawValue, source._rawValue, count._builtinWordValue)
      // This builtin is equivalent to:
      // for i in 0..<count {
      //   (self + i).initialize(to: (source + i).move())
      // }
    }
    else {
      // initialize backward from a non-following overlapping range.
      Builtin.takeArrayBackToFront(
        Pointee.self, self._rawValue, source._rawValue, count._builtinWordValue)
      // This builtin is equivalent to:
      // var src = source + count
      // var dst = self + count
      // while dst != self {
      //   (--dst).initialize(to: (--src).move())
      // }
    }
  }
}

----Swift.(file).UnsafeMutablePointer.initialize(from:UnsafePointer<Pointee>,count:Int)
extension UnsafeMutablePointer {
  public func initialize(from source: UnsafePointer<Pointee>, count: Int) {
    precondition(
      count >= 0, "UnsafeMutablePointer.initialize with negative count")
    precondition(
      UnsafePointer(self) + count <= source ||
      source + count <= UnsafePointer(self),
      "UnsafeMutablePointer.initialize overlapping range")
    Builtin.copyArray(
      Pointee.self, self._rawValue, source._rawValue, count._builtinWordValue)
    // This builtin is equivalent to:
    // for i in 0..<count {
    //   (self + i).initialize(to: source[i])
    // }
  }
}

----Swift.(file).UnsafeMutablePointer.moveAssign(from:UnsafeMutablePointer<Pointee>,count:Int)
extension UnsafeMutablePointer {
  public func moveAssign(from source: UnsafeMutablePointer, count: Int) {
    precondition(
      count >= 0, "UnsafeMutablePointer.moveAssign(from:) with negative count")
    precondition(
      self + count <= source || source + count <= self,
      "moveAssign overlapping range")
    Builtin.assignTakeArray(
      Pointee.self, self._rawValue, source._rawValue, count._builtinWordValue)
    // These builtins are equivalent to:
    // for i in 0..<count {
    //   self[i] = (source + i).move()
    // }
  }
}

----Swift.(file).UnsafeMutablePointer.deinitialize(count:Int)
extension UnsafeMutablePointer {
  public func deinitialize(count: Int) -> UnsafeMutableRawPointer {
    precondition(count >= 0, "UnsafeMutablePointer.deinitialize with negative count")
    // FIXME: optimization should be implemented, where if the `count` value
    // is 1, the `Builtin.destroy(Pointee.self, _rawValue)` gets called.
    Builtin.destroyArray(Pointee.self, _rawValue, count._builtinWordValue)
    return UnsafeMutableRawPointer(self)
  }
}

----Swift.(file).UnsafeMutablePointer.withMemoryRebound(to:T.Type,capacity:Int,_:(UnsafeMutablePointer<T>) throws -> Result)
extension UnsafeMutablePointer {
  public func withMemoryRebound<T, Result>(to type: T.Type, capacity count: Int,
    _ body: (UnsafeMutablePointer<T>) throws -> Result
  ) rethrows -> Result {
    Builtin.bindMemory(_rawValue, count._builtinWordValue, T.self)
    defer {
      Builtin.bindMemory(_rawValue, count._builtinWordValue, Pointee.self)
    }
    return try body(UnsafeMutablePointer<T>(_rawValue))
  }
}

----Swift.(file).UnsafeMutablePointer.subscript(_:Int)
extension UnsafeMutablePointer {
  public subscript(i: Int) -> Pointee {
    @_transparent
    unsafeAddress {
      return UnsafePointer(self + i)
    }
    @_transparent
    nonmutating unsafeMutableAddress {
      return self + i
    }
  }
}

----Swift.(file).UnsafeRawPointer.init(_:<<error type>>)
extension UnsafeRawPointer {
  public init(_ _rawValue: Builtin.RawPointer) {
    self._rawValue = _rawValue
  }
}

----Swift.(file).UnsafeRawPointer.init(_:UnsafeMutableRawPointer)
extension UnsafeRawPointer {
  public init(_ other: UnsafeMutableRawPointer) {
    _rawValue = other._rawValue
  }
}

----Swift.(file).UnsafeRawPointer.deallocate()
extension UnsafeRawPointer {
  public func deallocate() {
    Builtin.deallocRaw(_rawValue, (-1)._builtinWordValue, (-1)._builtinWordValue)
  }
}

----Swift.(file).UnsafeRawPointer.bindMemory(to:T.Type,capacity:Int)
extension UnsafeRawPointer {
  public func bindMemory<T>(
    to type: T.Type, capacity count: Int
  ) -> UnsafePointer<T> {
    Builtin.bindMemory(_rawValue, count._builtinWordValue, type)
    return UnsafePointer<T>(_rawValue)
  }
}

----Swift.(file).UnsafeRawPointer.assumingMemoryBound(to:T.Type)
extension UnsafeRawPointer {
  public func assumingMemoryBound<T>(to: T.Type) -> UnsafePointer<T> {
    return UnsafePointer<T>(_rawValue)
  }
}

----Swift.(file).UnsafeRawPointer.load(fromByteOffset:Int,as:T.Type)
extension UnsafeRawPointer {
  public func load<T>(fromByteOffset offset: Int = 0, as type: T.Type) -> T {
    precondition(0 == (UInt(bitPattern: self + offset)
        & (UInt(MemoryLayout<T>.alignment) - 1)),
      "load from misaligned raw pointer")

    return Builtin.loadRaw((self + offset)._rawValue)
  }
}

----Swift.(file).UnsafeRawPointer.advanced(by:Int)
extension UnsafeRawPointer: Strideable  {
  public func advanced(by n: Int) -> UnsafeRawPointer {
    return UnsafeRawPointer(Builtin.gepRaw_Word(_rawValue, n._builtinWordValue))
  }
}

----Swift.(file).UnsafeMutableRawPointer.init(_:<<error type>>)
extension UnsafeMutableRawPointer {
  public init(_ _rawValue: Builtin.RawPointer) {
    self._rawValue = _rawValue
  }
}

----Swift.(file).UnsafeMutableRawPointer.init(mutating:UnsafeRawPointer)
extension UnsafeMutableRawPointer {
  public init(mutating other: UnsafeRawPointer) {
    _rawValue = other._rawValue
  }
}

----Swift.(file).UnsafeMutableRawPointer.allocate(byteCount:Int,alignment:Int)
extension UnsafeMutableRawPointer {
  public static func allocate(
    byteCount: Int, alignment: Int
  ) -> UnsafeMutableRawPointer {
    return UnsafeMutableRawPointer(Builtin.allocRaw(
        byteCount._builtinWordValue, alignment._builtinWordValue))
  }
}

----Swift.(file).UnsafeMutableRawPointer.deallocate()
extension UnsafeMutableRawPointer {
  public func deallocate() {
    Builtin.deallocRaw(_rawValue, (-1)._builtinWordValue, (-1)._builtinWordValue)
  }
}

----Swift.(file).UnsafeMutableRawPointer.bindMemory(to:T.Type,capacity:Int)
extension UnsafeMutableRawPointer {
  public func bindMemory<T>(
    to type: T.Type, capacity count: Int
  ) -> UnsafeMutablePointer<T> {
    Builtin.bindMemory(_rawValue, count._builtinWordValue, type)
    return UnsafeMutablePointer<T>(_rawValue)
  }
}

----Swift.(file).UnsafeMutableRawPointer.assumingMemoryBound(to:T.Type)
extension UnsafeMutableRawPointer {
  public func assumingMemoryBound<T>(to: T.Type) -> UnsafeMutablePointer<T> {
    return UnsafeMutablePointer<T>(_rawValue)
  }
}

----Swift.(file).UnsafeMutableRawPointer.initializeMemory(as:T.Type,repeating:T,count:Int)
extension UnsafeMutableRawPointer {
  public func initializeMemory<T>(
    as type: T.Type, repeating repeatedValue: T, count: Int
  ) -> UnsafeMutablePointer<T> {
    precondition(count >= 0,
      "UnsafeMutableRawPointer.initializeMemory: negative count")

    Builtin.bindMemory(_rawValue, count._builtinWordValue, type)
    var nextPtr = self
    for _ in 0..<count {
      Builtin.initialize(repeatedValue, nextPtr._rawValue)
      nextPtr += MemoryLayout<T>.stride
    }
    return UnsafeMutablePointer(_rawValue)
  }
}

----Swift.(file).UnsafeMutableRawPointer.initializeMemory(as:T.Type,from:UnsafePointer<T>,count:Int)
extension UnsafeMutableRawPointer {
  public func initializeMemory<T>(
    as type: T.Type, from source: UnsafePointer<T>, count: Int
  ) -> UnsafeMutablePointer<T> {
    precondition(
      count >= 0,
      "UnsafeMutableRawPointer.initializeMemory with negative count")
    precondition(
      (UnsafeRawPointer(self + count * MemoryLayout<T>.stride)
        <= UnsafeRawPointer(source))
      || UnsafeRawPointer(source + count) <= UnsafeRawPointer(self),
      "UnsafeMutableRawPointer.initializeMemory overlapping range")

    Builtin.bindMemory(_rawValue, count._builtinWordValue, type)
    Builtin.copyArray(
      T.self, self._rawValue, source._rawValue, count._builtinWordValue)
    // This builtin is equivalent to:
    // for i in 0..<count {
    //   (self.assumingMemoryBound(to: T.self) + i).initialize(to: source[i])
    // }
    return UnsafeMutablePointer(_rawValue)
  }
}

----Swift.(file).UnsafeMutableRawPointer.moveInitializeMemory(as:T.Type,from:UnsafeMutablePointer<T>,count:Int)
extension UnsafeMutableRawPointer {
  public func moveInitializeMemory<T>(
    as type: T.Type, from source: UnsafeMutablePointer<T>, count: Int
  ) -> UnsafeMutablePointer<T> {
    precondition(
      count >= 0,
      "UnsafeMutableRawPointer.moveInitializeMemory with negative count")

    Builtin.bindMemory(_rawValue, count._builtinWordValue, type)
    if self < UnsafeMutableRawPointer(source)
       || self >= UnsafeMutableRawPointer(source + count) {
      // initialize forward from a disjoint or following overlapping range.
      Builtin.takeArrayFrontToBack(
        T.self, self._rawValue, source._rawValue, count._builtinWordValue)
      // This builtin is equivalent to:
      // for i in 0..<count {
      //   (self.assumingMemoryBound(to: T.self) + i)
      //   .initialize(to: (source + i).move())
      // }
    }
    else {
      // initialize backward from a non-following overlapping range.
      Builtin.takeArrayBackToFront(
        T.self, self._rawValue, source._rawValue, count._builtinWordValue)
      // This builtin is equivalent to:
      // var src = source + count
      // var dst = self.assumingMemoryBound(to: T.self) + count
      // while dst != self {
      //   (--dst).initialize(to: (--src).move())
      // }
    }
    return UnsafeMutablePointer(_rawValue)
  }
}

----Swift.(file).UnsafeMutableRawPointer.load(fromByteOffset:Int,as:T.Type)
extension UnsafeMutableRawPointer {
  public func load<T>(fromByteOffset offset: Int = 0, as type: T.Type) -> T {
    precondition(0 == (UInt(bitPattern: self + offset)
        & (UInt(MemoryLayout<T>.alignment) - 1)),
      "load from misaligned raw pointer")

    return Builtin.loadRaw((self + offset)._rawValue)
  }
}

----Swift.(file).UnsafeMutableRawPointer.storeBytes(of:T,toByteOffset:Int,as:T.Type)
extension UnsafeMutableRawPointer {
  public func storeBytes<T>(
    of value: T, toByteOffset offset: Int = 0, as type: T.Type
  ) {
    precondition(0 == (UInt(bitPattern: self + offset)
        & (UInt(MemoryLayout<T>.alignment) - 1)),
      "storeBytes to misaligned raw pointer")

    var temp = value
    withUnsafeMutablePointer(to: &temp) { source in
      let rawSrc = UnsafeMutableRawPointer(source)._rawValue
      // FIXME: to be replaced by _memcpy when conversions are implemented.
      Builtin.int_memcpy_RawPointer_RawPointer_Int64(
        (self + offset)._rawValue, rawSrc, UInt64(MemoryLayout<T>.size)._value,
        /*volatile:*/ false._value)
    }
  }
}

----Swift.(file).UnsafeMutableRawPointer.copyMemory(from:UnsafeRawPointer,byteCount:Int)
extension UnsafeMutableRawPointer {
  public func copyMemory(from source: UnsafeRawPointer, byteCount: Int) {
    precondition(
      byteCount >= 0, "UnsafeMutableRawPointer.copyMemory with negative count")

    _memmove(dest: self, src: source, size: UInt(byteCount))
  }
}

----Swift.(file).UnsafeMutableRawPointer.advanced(by:Int)
extension UnsafeMutableRawPointer: Strideable  {
  public func advanced(by n: Int) -> UnsafeMutableRawPointer {
    return UnsafeMutableRawPointer(Builtin.gepRaw_Word(_rawValue, n._builtinWordValue))
  }
}

----Swift.(file).OpaquePointer.init(_:UnsafeMutableRawPointer)
extension OpaquePointer  {
  public init(_ from: UnsafeMutableRawPointer) {
    self._rawValue = from._rawValue
  }
}

----Swift.(file).OpaquePointer.init(_:UnsafeRawPointer)
extension OpaquePointer  {
  public init(_ from: UnsafeRawPointer) {
    self._rawValue = from._rawValue
  }
}

----Swift.(file)._ValidUTF8Buffer.makeIterator()
extension _ValidUTF8Buffer : Sequence  {
  public func makeIterator() -> Iterator {
    return Iterator(self)
  }
}

----Swift.(file)._ValidUTF8Buffer.startIndex
extension _ValidUTF8Buffer : Collection  {
  public var startIndex : Index {
    return Index(_biasedBits: _biasedBits)
  }
}

----Swift.(file)._ValidUTF8Buffer.endIndex
extension _ValidUTF8Buffer : Collection  {
  public var endIndex : Index {
    return Index(_biasedBits: 0)
  }
}

----Swift.(file)._ValidUTF8Buffer.count
extension _ValidUTF8Buffer : Collection  {
  public var count : Int {
    return UInt32.bitWidth &>> 3 &- _biasedBits.leadingZeroBitCount &>> 3
  }
}

----Swift.(file)._ValidUTF8Buffer.isEmpty
extension _ValidUTF8Buffer : Collection  {
  public var isEmpty : Bool {
    return _biasedBits == 0
  }
}

----Swift.(file)._ValidUTF8Buffer.index(after:_ValidUTF8Buffer.Index)
extension _ValidUTF8Buffer : Collection  {
  public func index(after i: Index) -> Index {
    precondition(i._biasedBits != 0)
    return Index(_biasedBits: i._biasedBits >> 8)
  }
}

----Swift.(file)._ValidUTF8Buffer.subscript(_:_ValidUTF8Buffer.Index)
extension _ValidUTF8Buffer : Collection  {
  public subscript(i: Index) -> Element {
    return Element(truncatingIfNeeded: i._biasedBits) &- 1
  }
}

----Swift.(file)._ValidUTF8Buffer.index(before:_ValidUTF8Buffer.Index)
extension _ValidUTF8Buffer : BidirectionalCollection  {
  public func index(before i: Index) -> Index {
    let offset = _ValidUTF8Buffer(_biasedBits: i._biasedBits).count
    precondition(offset != 0)
    return Index(_biasedBits: _biasedBits &>> (offset &<< 3 - 8))
  }
}

----Swift.(file)._ValidUTF8Buffer.distance(from:_ValidUTF8Buffer.Index,to:_ValidUTF8Buffer.Index)
extension _ValidUTF8Buffer : RandomAccessCollection  {
  public func distance(from i: Index, to j: Index) -> Int {
    precondition(_isValid(i))
    precondition(_isValid(j))
    return (
      i._biasedBits.leadingZeroBitCount - j._biasedBits.leadingZeroBitCount
    ) &>> 3
  }
}

----Swift.(file)._ValidUTF8Buffer.index(_:_ValidUTF8Buffer.Index,offsetBy:Int)
extension _ValidUTF8Buffer : RandomAccessCollection  {
  public func index(_ i: Index, offsetBy n: Int) -> Index {
    let startOffset = distance(from: startIndex, to: i)
    let newOffset = startOffset + n
    precondition(newOffset >= 0)
    precondition(newOffset <= count)
    return Index(_biasedBits: _biasedBits._fullShiftRight(newOffset &<< 3))
  }
}

----Swift.(file)._ValidUTF8Buffer.init()
extension _ValidUTF8Buffer : RangeReplaceableCollection  {
  public init() {
    _biasedBits = 0
  }
}

----Swift.(file)._ValidUTF8Buffer.capacity
extension _ValidUTF8Buffer : RangeReplaceableCollection  {
  public var capacity: Int {
    return _ValidUTF8Buffer.capacity
  }
}

----Swift.(file)._ValidUTF8Buffer.capacity
extension _ValidUTF8Buffer : RangeReplaceableCollection  {
  public static var capacity: Int {
    return UInt32.bitWidth / Element.bitWidth
  }
}

----Swift.(file)._ValidUTF8Buffer.append(_:_ValidUTF8Buffer.Element)
extension _ValidUTF8Buffer : RangeReplaceableCollection  {
  public mutating func append(_ e: Element) {
    precondition(count + 1 <= capacity)
    _internalInvariant(
      e != 192 && e != 193 && !(245...255).contains(e), "invalid UTF8 byte")
    _biasedBits |= UInt32(e &+ 1) &<< (count &<< 3)
  }
}

----Swift.(file)._ValidUTF8Buffer.removeFirst()
extension _ValidUTF8Buffer : RangeReplaceableCollection  {
  public mutating func removeFirst() -> Element {
    precondition(!isEmpty)
    let result = Element(truncatingIfNeeded: _biasedBits) &- 1
    _biasedBits = _biasedBits._fullShiftRight(8)
    return result
  }
}

----Swift.(file)._ValidUTF8Buffer.replaceSubrange(_:Range<_ValidUTF8Buffer.Index>,with:C)
extension _ValidUTF8Buffer : RangeReplaceableCollection  {
  public mutating func replaceSubrange<C: Collection>(
    _ target: Range<Index>, with replacement: C
  ) where C.Element == Element {
    precondition(_isValid(target.lowerBound))
    precondition(_isValid(target.upperBound))
    var r = _ValidUTF8Buffer()
    for x in self[..<target.lowerBound] { r.append(x) }
    for x in replacement                { r.append(x) }
    for x in self[target.upperBound...] { r.append(x) }
    self = r
  }
}

----Swift.(file)._ValidUTF8Buffer.append(contentsOf:_ValidUTF8Buffer)
extension _ValidUTF8Buffer  {
  public mutating func append(contentsOf other: _ValidUTF8Buffer) {
    precondition(count + other.count <= capacity)
    _biasedBits |= UInt32(
      truncatingIfNeeded: other._biasedBits) &<< (count &<< 3)
  }
}

----Swift.(file)._ValidUTF8Buffer.encodedReplacementCharacter
extension _ValidUTF8Buffer  {
  public static var encodedReplacementCharacter : _ValidUTF8Buffer {
    return _ValidUTF8Buffer(_biasedBits: 0xBD_BF_EF &+ 0x01_01_01)
  }
}