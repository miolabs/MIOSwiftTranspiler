

----Swift.(file)..(error_type).CodeUnit
extension Unicode.ASCII : Unicode.Encoding  {
  public typealias CodeUnit = U
}

----Swift.(file)..(error_type).EncodedScalar
extension Unicode.ASCII : Unicode.Encoding  {
  public typealias EncodedScalar = CollectionOfOne<CodeUnit>
}

----Swift.(file)..(error_type).encodedReplacementCharacter
extension Unicode.ASCII : Unicode.Encoding  {
  public static var encodedReplacementCharacter : EncodedScalar {
    return EncodedScalar(0x1a) // U+001A SUBSTITUTE; best we can do for ASCII
  }
}

----Swift.(file)..(error_type).decode(_:Unicode.ASCII.EncodedScalar)
extension Unicode.ASCII : Unicode.Encoding  {
  public static func decode(_ source: EncodedScalar) -> Unicode.Scalar {
    return Unicode.Scalar(_unchecked: UInt32(
        source.first._unsafelyUnwrappedUnchecked))
  }
}

----Swift.(file)..(error_type).encode(_:Unicode.Scalar)
extension Unicode.ASCII : Unicode.Encoding  {
  public static func encode(
    _ source: Unicode.Scalar
  ) -> EncodedScalar? {
    guard source.value < (1&<<7) else { return nil }
    return EncodedScalar(UInt8(truncatingIfNeeded: source.value))
  }
}

----Swift.(file)..(error_type).transcode(_:FromEncoding.EncodedScalar,from:FromEncoding.Type)
extension Unicode.ASCII : Unicode.Encoding  {
  public static func transcode<FromEncoding : Unicode.Encoding>(
    _ content: FromEncoding.EncodedScalar, from _: FromEncoding.Type
  ) -> EncodedScalar? {
    if _fastPath(FromEncoding.self == UTF16.self) {
      let c = _identityCast(content, to: UTF16.EncodedScalar.self)
      guard (c._storage & 0xFF80 == 0) else { return nil }
      return EncodedScalar(CodeUnit(c._storage & 0x7f))
    }
    else if _fastPath(FromEncoding.self == UTF8.self) {
      let c = _identityCast(content, to: UTF8.EncodedScalar.self)
      let first = c.first.unsafelyUnwrapped
      guard (first < 0x80) else { return nil }
      return EncodedScalar(CodeUnit(first))
    }
    return encode(FromEncoding.decode(content))
  }
}

----Swift.(file)..(error_type).Parser.init()
extension  {
    public init() { }
}

----Swift.(file)..(error_type).ForwardParser
extension Unicode.ASCII : Unicode.Encoding  {
  public typealias ForwardParser = P
}

----Swift.(file)..(error_type).ReverseParser
extension Unicode.ASCII : Unicode.Encoding  {
  public typealias ReverseParser = P
}

----Swift.(file)..(error_type).Encoding
extension Unicode.ASCII.Parser : Unicode.Parser  {
  public typealias Encoding = Unicode.A
}

----Swift.(file)..(error_type).parseScalar(from:I)
extension Unicode.ASCII.Parser : Unicode.Parser  {
  public mutating func parseScalar<I : IteratorProtocol>(
    from input: inout I
  ) -> Unicode.ParseResult<Encoding.EncodedScalar>
  where I.Element == Encoding.CodeUnit {
    let n = input.next()
    if _fastPath(n != nil), let x = n {
      guard _fastPath(Int8(truncatingIfNeeded: x) >= 0)
      else { return .error(length: 1) }
      return .valid(Unicode.ASCII.EncodedScalar(x))
    }
    return .emptyInput
  }
}

----Swift.(file).min(_:T,_:T)
public func min<T : Comparable>(_ x: T, _ y: T) -> T {
  // In case `x == y` we pick `x`.
  // This preserves any pre-existing order in case `T` has identity,
  // which is important for e.g. the stability of sorting algorithms.
  // `(min(x, y), max(x, y))` should return `(x, y)` in case `x == y`.
  return y < x ? y : x
}

----Swift.(file).min(_:T,_:T,_:T,_:[T])
public func min<T : Comparable>(_ x: T, _ y: T, _ z: T, _ rest: T...) -> T {
  var minValue = min(min(x, y), z)
  // In case `value == minValue`, we pick `minValue`. See min(_:_:).
  for value in rest where value < minValue {
    minValue = value
  }
  return minValue
}

----Swift.(file).max(_:T,_:T)
public func max<T : Comparable>(_ x: T, _ y: T) -> T {
  // In case `x == y`, we pick `y`. See min(_:_:).
  return y >= x ? y : x
}

----Swift.(file).max(_:T,_:T,_:T,_:[T])
public func max<T : Comparable>(_ x: T, _ y: T, _ z: T, _ rest: T...) -> T {
  var maxValue = max(max(x, y), z)
  // In case `value == maxValue`, we pick `value`. See min(_:_:).
  for value in rest where value >= maxValue {
    maxValue = value
  }
  return maxValue
}

----Swift.(file).EnumeratedSequence.init(_base:Base)
extension EnumeratedSequence {
  internal init(_base: Base) {
    self._base = _base
  }
}

----Swift.(file).EnumeratedSequence.Iterator.init(_base:Base.Iterator)
extension EnumeratedSequence.Iterator {
    internal init(_base: Base.Iterator) {
      self._base = _base
      self._count = 0
    }
}

----Swift.(file).EnumeratedSequence.Iterator.Element
extension EnumeratedSequence.Iterator: IteratorProtocol, Sequence  {
  public typealias Element = (offset: Int, element: Base.Element)
}

----Swift.(file).EnumeratedSequence.Iterator.next()
extension EnumeratedSequence.Iterator: IteratorProtocol, Sequence  {
  public mutating func next() -> Element? {
    guard let b = _base.next() else { return nil }
    let result = (offset: _count, element: b)
    _count += 1 
    return result
  }
}

----Swift.(file).EnumeratedSequence.makeIterator()
extension EnumeratedSequence: Sequence  {
  public __consuming func makeIterator() -> Iterator {
    return Iterator(_base: _base.makeIterator())
  }
}

----Swift.(file).AnyHashable.init(_box:_AnyHashableBox)
extension AnyHashable {
  internal init(_box box: _AnyHashableBox) {
    self._box = box
  }
}

----Swift.(file).AnyHashable.init(_:H)
extension AnyHashable {
  public init<H : Hashable>(_ base: H) {
    if let custom =
      (base as? _HasCustomAnyHashableRepresentation)?._toCustomAnyHashable() {
      self = custom
      return
    }

    self.init(_box: _ConcreteHashableBox(false)) // Dummy value
    _makeAnyHashableUpcastingToHashableBaseType(
      base,
      storingResultInto: &self)
  }
}

----Swift.(file).AnyHashable.init(_usingDefaultRepresentationOf:H)
extension AnyHashable {
  internal init<H : Hashable>(_usingDefaultRepresentationOf base: H) {
    self._box = _ConcreteHashableBox(base)
  }
}

----Swift.(file).AnyHashable.base
extension AnyHashable {
  public var base: Any {
    return _box._base
  }
}

----Swift.(file).AnyHashable.==infix(_:AnyHashable,_:AnyHashable)
extension AnyHashable : Equatable  {
  public static func == (lhs: AnyHashable, rhs: AnyHashable) -> Bool {
    return lhs._box._canonicalBox._isEqual(to: rhs._box._canonicalBox) ?? false
  }
}

----Swift.(file).AnyHashable.hashValue
extension AnyHashable : Hashable  {
  public var hashValue: Int {
    return _box._canonicalBox._hashValue
  }
}

----Swift.(file).AnyHashable.hash(into:Hasher)
extension AnyHashable : Hashable  {
  public func hash(into hasher: inout Hasher) {
    _box._canonicalBox._hash(into: &hasher)
  }
}

----Swift.(file).AnyHashable.description
extension AnyHashable : CustomStringConvertible  {
  public var description: String {
    return String(describing: base)
  }
}

----Swift.(file).AnyHashable.debugDescription
extension AnyHashable : CustomDebugStringConvertible  {
  public var debugDescription: String {
    return "AnyHashable(" + String(reflecting: base) + ")"
  }
}

----Swift.(file).AnyHashable.customMirror
extension AnyHashable : CustomReflectable  {
  public var customMirror: Mirror {
    return Mirror(
      self,
      children: ["value": base])
  }
}

----Swift.(file).Array.init(_buffer:<<error type>>)
extension Array {
  internal init(_buffer: _Buffer) {
    self._buffer = _buffer
  }
}

----Swift.(file).Array.capacity
extension Array: _ArrayProtocol  {
  public var capacity: Int {
    return _getCapacity()
  }
}

----Swift.(file).Array.Index
extension Array: RandomAccessCollection, MutableCollection  {
  public typealias Index = I
}

----Swift.(file).Array.Indices
extension Array: RandomAccessCollection, MutableCollection  {
  public typealias Indices = Range<Int>
}

----Swift.(file).Array.Iterator
extension Array: RandomAccessCollection, MutableCollection  {
  public typealias Iterator = IndexingIterator<Array>
}

----Swift.(file).Array.startIndex
extension Array: RandomAccessCollection, MutableCollection  {
  public var startIndex: Int {
    return 0
  }
}

----Swift.(file).Array.endIndex
extension Array: RandomAccessCollection, MutableCollection  {
  public var endIndex: Int {
    @inlinable
    get {
      return _getCount()
    }
  }
}

----Swift.(file).Array.index(after:Int)
extension Array: RandomAccessCollection, MutableCollection  {
  public func index(after i: Int) -> Int {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    return i + 1
  }
}

----Swift.(file).Array.formIndex(after:Int)
extension Array: RandomAccessCollection, MutableCollection  {
  public func formIndex(after i: inout Int) {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    i += 1
  }
}

----Swift.(file).Array.index(before:Int)
extension Array: RandomAccessCollection, MutableCollection  {
  public func index(before i: Int) -> Int {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    return i - 1
  }
}

----Swift.(file).Array.formIndex(before:Int)
extension Array: RandomAccessCollection, MutableCollection  {
  public func formIndex(before i: inout Int) {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    i -= 1
  }
}

----Swift.(file).Array.index(_:Int,offsetBy:Int)
extension Array: RandomAccessCollection, MutableCollection  {
  public func index(_ i: Int, offsetBy distance: Int) -> Int {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    return i + distance
  }
}

----Swift.(file).Array.index(_:Int,offsetBy:Int,limitedBy:Int)
extension Array: RandomAccessCollection, MutableCollection  {
  public func index(
    _ i: Int, offsetBy distance: Int, limitedBy limit: Int
  ) -> Int? {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    let l = limit - i
    if distance > 0 ? l >= 0 && l < distance : l <= 0 && distance < l {
      return nil
    }
    return i + distance
  }
}

----Swift.(file).Array.distance(from:Int,to:Int)
extension Array: RandomAccessCollection, MutableCollection  {
  public func distance(from start: Int, to end: Int) -> Int {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    return end - start
  }
}

----Swift.(file).Array.subscript(_:Int)
extension Array: RandomAccessCollection, MutableCollection  {
  public subscript(index: Int) -> Element {
    get {
      // This call may be hoisted or eliminated by the optimizer.  If
      // there is an inout violation, this value may be stale so needs to be
      // checked again below.
      let wasNativeTypeChecked = _hoistableIsNativeTypeChecked()

      // Make sure the index is in range and wasNativeTypeChecked is
      // still valid.
      let token = _checkSubscript(
        index, wasNativeTypeChecked: wasNativeTypeChecked)

      return _getElement(
        index, wasNativeTypeChecked: wasNativeTypeChecked,
        matchingSubscriptCheck: token)
    }
    _modify {
      _makeMutableAndUnique() // makes the array native, too
      _checkSubscript_native(index)
      let address = _buffer.subscriptBaseAddress + index
      yield &address.pointee
    }
  }
}

----Swift.(file).Array.subscript(_:Range<Int>)
extension Array: RandomAccessCollection, MutableCollection  {
  public subscript(bounds: Range<Int>) -> ArraySlice<Element> {
    get {
      _checkIndex(bounds.lowerBound)
      _checkIndex(bounds.upperBound)
      return ArraySlice(_buffer: _buffer[bounds])
    }
    set(rhs) {
      _checkIndex(bounds.lowerBound)
      _checkIndex(bounds.upperBound)
      // If the replacement buffer has same identity, and the ranges match,
      // then this was a pinned in-place modification, nothing further needed.
      if self[bounds]._buffer.identity != rhs._buffer.identity
      || bounds != rhs.startIndex..<rhs.endIndex {
        self.replaceSubrange(bounds, with: rhs)
      }
    }
  }
}

----Swift.(file).Array.count
extension Array: RandomAccessCollection, MutableCollection  {
  public var count: Int {
    return _getCount()
  }
}

----Swift.(file).Array.init(arrayLiteral:[Element])
extension Array: ExpressibleByArrayLiteral  {
  public init(arrayLiteral elements: Element...) {
    self = elements
  }
}

----Swift.(file).Array.init()
extension Array: RangeReplaceableCollection  {
  public init() {
    _buffer = _Buffer()
  }
}

----Swift.(file).Array.init(_:S)
extension Array: RangeReplaceableCollection  {
  public init<S: Sequence>(_ s: S) where S.Element == Element {
    self = Array(
      _buffer: _Buffer(
        _buffer: s._copyToContiguousArray()._buffer,
        shiftedToStartIndex: 0))
  }
}

----Swift.(file).Array.init(repeating:Element,count:Int)
extension Array: RangeReplaceableCollection  {
  public init(repeating repeatedValue: Element, count: Int) {
    var p: UnsafeMutablePointer<Element>
    (self, p) = Array._allocateUninitialized(count)
    for _ in 0..<count {
      p.initialize(to: repeatedValue)
      p += 1
    }
  }
}

----Swift.(file).Array.init(_uninitializedCount:Int)
extension Array: RangeReplaceableCollection  {
  internal init(_uninitializedCount count: Int) {
    _precondition(count >= 0, "Can't construct Array with count < 0")
    // Note: Sinking this constructor into an else branch below causes an extra
    // Retain/Release.
    _buffer = _Buffer()
    if count > 0 {
      // Creating a buffer instead of calling reserveCapacity saves doing an
      // unnecessary uniqueness check. We disable inlining here to curb code
      // growth.
      _buffer = Array._allocateBufferUninitialized(minimumCapacity: count)
      _buffer.count = count
    }
    // Can't store count here because the buffer might be pointing to the
    // shared empty array.
  }
}

----Swift.(file).Array.reserveCapacity(_:Int)
extension Array: RangeReplaceableCollection  {
  public mutating func reserveCapacity(_ minimumCapacity: Int) {
    if _buffer.requestUniqueMutableBackingBuffer(
      minimumCapacity: minimumCapacity) == nil {

      let newBuffer = _ContiguousArrayBuffer<Element>(
        _uninitializedCount: count, minimumCapacity: minimumCapacity)

      _buffer._copyContents(
        subRange: _buffer.indices,
        initializing: newBuffer.firstElementAddress)
      _buffer = _Buffer(
        _buffer: newBuffer, shiftedToStartIndex: _buffer.startIndex)
    }
    _internalInvariant(capacity >= minimumCapacity)
  }
}

----Swift.(file).Array.append(_:Element)
extension Array: RangeReplaceableCollection  {
  public mutating func append(_ newElement: __owned Element) {
    _makeUniqueAndReserveCapacityIfNotUnique()
    let oldCount = _getCount()
    _reserveCapacityAssumingUniqueBuffer(oldCount: oldCount)
    _appendElementAssumeUniqueAndCapacity(oldCount, newElement: newElement)
  }
}

----Swift.(file).Array.append(contentsOf:S)
extension Array: RangeReplaceableCollection  {
  public mutating func append<S: Sequence>(contentsOf newElements: __owned S)
    where S.Element == Element {

    let newElementsCount = newElements.underestimatedCount
    reserveCapacityForAppend(newElementsCount: newElementsCount)

    let oldCount = self.count
    let startNewElements = _buffer.firstElementAddress + oldCount
    let buf = UnsafeMutableBufferPointer(
                start: startNewElements, 
                count: self.capacity - oldCount)

    let (remainder,writtenUpTo) = buf.initialize(from: newElements)
    
    // trap on underflow from the sequence's underestimate:
    let writtenCount = buf.distance(from: buf.startIndex, to: writtenUpTo)
    _precondition(newElementsCount <= writtenCount, 
      "newElements.underestimatedCount was an overestimate")
    // can't check for overflow as sequences can underestimate

    _buffer.count += writtenCount

    if writtenUpTo == buf.endIndex {
      // there may be elements that didn't fit in the existing buffer,
      // append them in slow sequence-only mode
      _buffer._arrayAppendSequence(IteratorSequence(remainder))
    }
  }
}

----Swift.(file).Array.reserveCapacityForAppend(newElementsCount:Int)
extension Array: RangeReplaceableCollection  {
  internal mutating func reserveCapacityForAppend(newElementsCount: Int) {
    let oldCount = self.count
    let oldCapacity = self.capacity
    let newCount = oldCount + newElementsCount

    // Ensure uniqueness, mutability, and sufficient storage.  Note that
    // for consistency, we need unique self even if newElements is empty.
    self.reserveCapacity(
      newCount > oldCapacity ?
      Swift.max(newCount, _growArrayCapacity(oldCapacity))
      : newCount)
  }
}

----Swift.(file).Array.remove(at:Int)
extension Array: RangeReplaceableCollection  {
  public mutating func remove(at index: Int) -> Element {
    _precondition(index < endIndex, "Index out of range")
    _precondition(index >= startIndex, "Index out of range")
    _makeUniqueAndReserveCapacityIfNotUnique()
    let newCount = _getCount() - 1
    let pointer = (_buffer.firstElementAddress + index)
    let result = pointer.move()
    pointer.moveInitialize(from: pointer + 1, count: newCount - index)
    _buffer.count = newCount
    return result
  }
}

----Swift.(file).Array.insert(_:Element,at:Int)
extension Array: RangeReplaceableCollection  {
  public mutating func insert(_ newElement: __owned Element, at i: Int) {
    _checkIndex(i)
    self.replaceSubrange(i..<i, with: CollectionOfOne(newElement))
  }
}

----Swift.(file).Array.removeAll(keepingCapacity:Bool)
extension Array: RangeReplaceableCollection  {
  public mutating func removeAll(keepingCapacity keepCapacity: Bool = false) {
    if !keepCapacity {
      _buffer = _Buffer()
    }
    else {
      self.replaceSubrange(indices, with: EmptyCollection())
    }
  }
}

----Swift.(file).Array.withContiguousMutableStorageIfAvailable(_:(inout UnsafeMutableBufferPointer<Element>) throws -> R)
extension Array: RangeReplaceableCollection  {
  public mutating func withContiguousMutableStorageIfAvailable<R>(
    _ body: (inout UnsafeMutableBufferPointer<Element>) throws -> R
  ) rethrows -> R? {
    return try withUnsafeMutableBufferPointer {
      (bufferPointer) -> R in
      return try body(&bufferPointer)
    }
  }
}

----Swift.(file).Array.withContiguousStorageIfAvailable(_:(UnsafeBufferPointer<Element>) throws -> R)
extension Array: RangeReplaceableCollection  {
  public func withContiguousStorageIfAvailable<R>(
    _ body: (UnsafeBufferPointer<Element>) throws -> R
  ) rethrows -> R? {
    return try withUnsafeBufferPointer {
      (bufferPointer) -> R in
      return try body(bufferPointer)
    }
  }
}

----Swift.(file).Array.+infix(_:Array<Element>,_:Array<Element>)
extension Array  {
  public static func + (lhs: Array, rhs: Array) -> Array {
    var lhs = lhs
    lhs.append(contentsOf: rhs)
    return lhs
  }
}

----Swift.(file).Array.+=infix(_:Array<Element>,_:Array<Element>)
extension Array  {
  public static func += (lhs: inout Array, rhs: Array) {
    lhs.append(contentsOf: rhs)
  }
}

----Swift.(file).Array.customMirror
extension Array: CustomReflectable  {
  public var customMirror: Mirror {
    return Mirror(
      self,
      unlabeledChildren: self,
      displayStyle: .collection)
  }
}

----Swift.(file).Array.description
extension Array: CustomStringConvertible, CustomDebugStringConvertible  {
  public var description: String {
    return _makeCollectionDescription()
  }
}

----Swift.(file).Array.debugDescription
extension Array: CustomStringConvertible, CustomDebugStringConvertible  {
  public var debugDescription: String {
    // Always show sugared representation for Arrays.
    return _makeCollectionDescription()
  }
}

----Swift.(file).Array.init(_unsafeUninitializedCapacity:Int,initializingWith:(inout UnsafeMutableBufferPointer<Element>, inout Int) throws -> Void)
extension Array  {
  public init(
    _unsafeUninitializedCapacity: Int,
    initializingWith initializer: (
      _ buffer: inout UnsafeMutableBufferPointer<Element>,
      _ initializedCount: inout Int) throws -> Void
  ) rethrows {
    var firstElementAddress: UnsafeMutablePointer<Element>
    (self, firstElementAddress) =
      Array._allocateUninitialized(_unsafeUninitializedCapacity)
    
    var initializedCount = 0
    defer {
      // Update self.count even if initializer throws an error.
      _precondition(
        initializedCount <= _unsafeUninitializedCapacity,
        "Initialized count set to greater than specified capacity."
      )
      self._buffer.count = initializedCount
    }
    var buffer = UnsafeMutableBufferPointer<Element>(
      start: firstElementAddress, count: _unsafeUninitializedCapacity)
    try initializer(&buffer, &initializedCount)
  }
}

----Swift.(file).Array.withUnsafeBufferPointer(_:(UnsafeBufferPointer<Element>) throws -> R)
extension Array  {
  public func withUnsafeBufferPointer<R>(
    _ body: (UnsafeBufferPointer<Element>) throws -> R
  ) rethrows -> R {
    return try _buffer.withUnsafeBufferPointer(body)
  }
}

----Swift.(file).Array.withUnsafeMutableBufferPointer(_:(inout UnsafeMutableBufferPointer<Element>) throws -> R)
extension Array  {
  public mutating func withUnsafeMutableBufferPointer<R>(
    _ body: (inout UnsafeMutableBufferPointer<Element>) throws -> R
  ) rethrows -> R {
    let count = self.count
    // Ensure unique storage
    _buffer._outlinedMakeUniqueBuffer(bufferCount: count)

    // Ensure that body can't invalidate the storage or its bounds by
    // moving self into a temporary working array.
    // NOTE: The stack promotion optimization that keys of the
    // "array.withUnsafeMutableBufferPointer" semantics annotation relies on the
    // array buffer not being able to escape in the closure. It can do this
    // because we swap the array buffer in self with an empty buffer here. Any
    // escape via the address of self in the closure will therefore escape the
    // empty array.

    var work = Array()
    (work, self) = (self, work)

    // Create an UnsafeBufferPointer over work that we can pass to body
    let pointer = work._buffer.firstElementAddress
    var inoutBufferPointer = UnsafeMutableBufferPointer(
      start: pointer, count: count)

    // Put the working array back before returning.
    defer {
      _precondition(
        inoutBufferPointer.baseAddress == pointer &&
        inoutBufferPointer.count == count,
        "Array withUnsafeMutableBufferPointer: replacing the buffer is not allowed")

      (work, self) = (self, work)
    }

    // Invoke the body.
    return try body(&inoutBufferPointer)
  }
}

----Swift.(file).Array.replaceSubrange(_:Range<Int>,with:C)
extension Array  {
  public mutating func replaceSubrange<C>(
    _ subrange: Range<Int>,
    with newElements: __owned C
  ) where C: Collection, C.Element == Element {
    _precondition(subrange.lowerBound >= self._buffer.startIndex,
      "Array replace: subrange start is negative")

    _precondition(subrange.upperBound <= _buffer.endIndex,
      "Array replace: subrange extends past the end")

    let oldCount = _buffer.count
    let eraseCount = subrange.count
    let insertCount = newElements.count
    let growth = insertCount - eraseCount

    if _buffer.requestUniqueMutableBackingBuffer(
      minimumCapacity: oldCount + growth) != nil {

      _buffer.replaceSubrange(
        subrange, with: insertCount, elementsOf: newElements)
    } else {
      _buffer._arrayOutOfPlaceReplace(subrange, with: newElements, count: insertCount)
    }
  }
}

----Swift.(file).Array.==infix(_:Array<Element>,_:Array<Element>)
extension Array: Equatable where Element: Equatable  {
  public static func ==(lhs: Array<Element>, rhs: Array<Element>) -> Bool {
    let lhsCount = lhs.count
    if lhsCount != rhs.count {
      return false
    }

    // Test referential equality.
    if lhsCount == 0 || lhs._buffer.identity == rhs._buffer.identity {
      return true
    }


    _internalInvariant(lhs.startIndex == 0 && rhs.startIndex == 0)
    _internalInvariant(lhs.endIndex == lhsCount && rhs.endIndex == lhsCount)

    // We know that lhs.count == rhs.count, compare element wise.
    for idx in 0..<lhsCount {
      if lhs[idx] != rhs[idx] {
        return false
      }
    }

    return true
  }
}

----Swift.(file).Array.hash(into:Hasher)
extension Array: Hashable where Element: Hashable  {
  public func hash(into hasher: inout Hasher) {
    hasher.combine(count) // discriminator
    for element in self {
      hasher.combine(element)
    }
  }
}

----Swift.(file).Array.withUnsafeMutableBytes(_:(UnsafeMutableRawBufferPointer) throws -> R)
extension Array  {
  public mutating func withUnsafeMutableBytes<R>(
    _ body: (UnsafeMutableRawBufferPointer) throws -> R
  ) rethrows -> R {
    return try self.withUnsafeMutableBufferPointer {
      return try body(UnsafeMutableRawBufferPointer($0))
    }
  }
}

----Swift.(file).Array.withUnsafeBytes(_:(UnsafeRawBufferPointer) throws -> R)
extension Array  {
  public func withUnsafeBytes<R>(
    _ body: (UnsafeRawBufferPointer) throws -> R
  ) rethrows -> R {
    return try self.withUnsafeBufferPointer {
      try body(UnsafeRawBufferPointer($0))
    }
  }
}

----Swift.(file).Array.init(_immutableCocoaArray:AnyObject)
extension Array  {
  public init(_immutableCocoaArray: AnyObject) {
    self = _bridgeCocoaArray(_immutableCocoaArray)
  }
}

----Swift.(file)._ArrayBuffer.init(_buffer:<<error type>>,shiftedToStartIndex:Int)
extension _ArrayBuffer  {
  internal init(_buffer source: NativeBuffer, shiftedToStartIndex: Int) {
    _internalInvariant(shiftedToStartIndex == 0, "shiftedToStartIndex must be 0")
    _storage = _ArrayBridgeStorage(native: source._storage)
  }
}

----Swift.(file)._ArrayBuffer.arrayPropertyIsNativeTypeChecked
extension _ArrayBuffer  {
  internal var arrayPropertyIsNativeTypeChecked: Bool {
    return _isNativeTypeChecked
  }
}

----Swift.(file)._ArrayBuffer.isUniquelyReferenced()
extension _ArrayBuffer  {
  internal mutating func isUniquelyReferenced() -> Bool {
    if !_isClassOrObjCExistential(Element.self) {
      return _storage.isUniquelyReferencedUnflaggedNative()
    }

    // This is a performance optimization. This code used to be:
    //
    //   return _storage.isUniquelyReferencedNative() && _isNative.
    //
    // SR-6437
    if !_storage.isUniquelyReferencedNative() {
      return false
    }
    return _isNative
  }
}

----Swift.(file)._ArrayBuffer.requestUniqueMutableBackingBuffer(minimumCapacity:Int)
extension _ArrayBuffer  {
  internal mutating func requestUniqueMutableBackingBuffer(minimumCapacity: Int)
  -> NativeBuffer? {
    if _fastPath(isUniquelyReferenced()) {
      let b = _native
      if _fastPath(b.capacity >= minimumCapacity) {
        return b
      }
    }
    return nil
  }
}

----Swift.(file)._ArrayBuffer.isMutableAndUniquelyReferenced()
extension _ArrayBuffer  {
  internal mutating func isMutableAndUniquelyReferenced() -> Bool {
    return isUniquelyReferenced()
  }
}

----Swift.(file)._ArrayBuffer.requestNativeBuffer()
extension _ArrayBuffer  {
  internal func requestNativeBuffer() -> NativeBuffer? {
    if !_isClassOrObjCExistential(Element.self) {
      return _native
    }
    return _fastPath(_storage.isNative) ? _native : nil
  }
}

----Swift.(file)._ArrayBuffer.subscript(_:Range<Int>)
extension _ArrayBuffer  {
  internal subscript(bounds: Range<Int>) -> _SliceBuffer<Element> {
    get {
      _typeCheck(bounds)
      if _fastPath(_isNative) {
        return _native[bounds]
      }
      return _nonNative[bounds].unsafeCastElements(to: Element.self)
    }
    set {
      fatalError("not implemented")
    }
  }
}

----Swift.(file)._ArrayBuffer.firstElementAddress
extension _ArrayBuffer  {
  internal var firstElementAddress: UnsafeMutablePointer<Element> {
    _internalInvariant(_isNative, "must be a native buffer")
    return _native.firstElementAddress
  }
}

----Swift.(file)._ArrayBuffer.firstElementAddressIfContiguous
extension _ArrayBuffer  {
  internal var firstElementAddressIfContiguous: UnsafeMutablePointer<Element>? {
    return _fastPath(_isNative) ? firstElementAddress : nil
  }
}

----Swift.(file)._ArrayBuffer.count
extension _ArrayBuffer  {
  internal var count: Int {
    @inline(__always)
    get {
      return _fastPath(_isNative) ? _native.count : _nonNative.count
    }
    set {
      _internalInvariant(_isNative, "attempting to update count of Cocoa array")
      _native.count = newValue
    }
  }
}

----Swift.(file)._ArrayBuffer.capacity
extension _ArrayBuffer  {
  internal var capacity: Int {
    return _fastPath(_isNative) ? _native.capacity : _nonNative.count
  }
}

----Swift.(file)._ArrayBuffer.getElement(_:Int,wasNativeTypeChecked:Bool)
extension _ArrayBuffer  {
  internal func getElement(_ i: Int, wasNativeTypeChecked: Bool) -> Element {
    if _fastPath(wasNativeTypeChecked) {
      return _nativeTypeChecked[i]
    }
    return unsafeBitCast(_getElementSlowPath(i), to: Element.self)
  }
}

----Swift.(file)._ArrayBuffer.subscript(_:Int)
extension _ArrayBuffer  {
  internal subscript(i: Int) -> Element {
    get {
      return getElement(i, wasNativeTypeChecked: _isNativeTypeChecked)
    }
    
    nonmutating set {
      if _fastPath(_isNative) {
        _native[i] = newValue
      }
      else {
        var refCopy = self
        refCopy.replaceSubrange(
          i..<(i + 1),
          with: 1,
          elementsOf: CollectionOfOne(newValue))
      }
    }
  }
}

----Swift.(file)._ArrayBuffer.withUnsafeBufferPointer(_:(UnsafeBufferPointer<Element>) throws -> R)
extension _ArrayBuffer  {
  internal func withUnsafeBufferPointer<R>(
    _ body: (UnsafeBufferPointer<Element>) throws -> R
  ) rethrows -> R {
    if _fastPath(_isNative) {
      defer { _fixLifetime(self) }
      return try body(
        UnsafeBufferPointer(start: firstElementAddress, count: count))
    }
    return try ContiguousArray(self).withUnsafeBufferPointer(body)
  }
}

----Swift.(file)._ArrayBuffer.withUnsafeMutableBufferPointer(_:(UnsafeMutableBufferPointer<Element>) throws -> R)
extension _ArrayBuffer  {
  internal mutating func withUnsafeMutableBufferPointer<R>(
    _ body: (UnsafeMutableBufferPointer<Element>) throws -> R
  ) rethrows -> R {
    _internalInvariant(
      _isNative || count == 0,
      "Array is bridging an opaque NSArray; can't get a pointer to the elements"
    )
    defer { _fixLifetime(self) }
    return try body(UnsafeMutableBufferPointer(
      start: firstElementAddressIfContiguous, count: count))
  }
}

----Swift.(file)._ArrayBuffer.owner
extension _ArrayBuffer  {
  internal var owner: AnyObject {
    return _fastPath(_isNative) ? _native._storage : _nonNative.buffer
  }
}

----Swift.(file)._ArrayBuffer.nativeOwner
extension _ArrayBuffer  {
  internal var nativeOwner: AnyObject {
    _internalInvariant(_isNative, "Expect a native array")
    return _native._storage
  }
}

----Swift.(file)._ArrayBuffer.identity
extension _ArrayBuffer  {
  internal var identity: UnsafeRawPointer {
    if _isNative {
      return _native.identity
    }
    else {
      return UnsafeRawPointer(
        Unmanaged.passUnretained(_nonNative.buffer).toOpaque())
    }
  }
}

----Swift.(file)._ArrayBuffer.startIndex
extension _ArrayBuffer  {
  internal var startIndex: Int {
    return 0
  }
}

----Swift.(file)._ArrayBuffer.endIndex
extension _ArrayBuffer  {
  internal var endIndex: Int {
    return count
  }
}

----Swift.(file)._ArrayBuffer.Indices
extension _ArrayBuffer  {
  internal typealias Indices = Range<Int>
}

----Swift.(file)._ArrayBuffer.Storage
extension _ArrayBuffer  {
  internal typealias Storage = _ContiguousArrayStorage<Element>
}

----Swift.(file)._ArrayBuffer.NativeBuffer
extension _ArrayBuffer  {
  internal typealias NativeBuffer = _ContiguousArrayBuffer<Element>
}

----Swift.(file)._ArrayBufferProtocol.subscriptBaseAddress
extension _ArrayBufferProtocol where Indices == Range<Int> {
  internal var subscriptBaseAddress: UnsafeMutablePointer<Element> {
    return firstElementAddress
  }
}

----Swift.(file)._ArrayBufferProtocol.init(copying:Self)
extension _ArrayBufferProtocol where Indices == Range<Int> {
  internal init(copying buffer: Self) {
    let newBuffer = _ContiguousArrayBuffer<Element>(
      _uninitializedCount: buffer.count, minimumCapacity: buffer.count)
    buffer._copyContents(
      subRange: buffer.indices,
      initializing: newBuffer.firstElementAddress)
    self = Self( _buffer: newBuffer, shiftedToStartIndex: buffer.startIndex)
  }
}

----Swift.(file)._ArrayBufferProtocol.replaceSubrange(_:Range<Int>,with:Int,elementsOf:C)
extension _ArrayBufferProtocol where Indices == Range<Int> {
  internal mutating func replaceSubrange<C>(
    _ subrange: Range<Int>,
    with newCount: Int,
    elementsOf newValues: __owned C
  ) where C : Collection, C.Element == Element {
    _internalInvariant(startIndex == 0, "_SliceBuffer should override this function.")
    let oldCount = self.count
    let eraseCount = subrange.count

    let growth = newCount - eraseCount
    self.count = oldCount + growth

    let elements = self.subscriptBaseAddress
    let oldTailIndex = subrange.upperBound
    let oldTailStart = elements + oldTailIndex
    let newTailIndex = oldTailIndex + growth
    let newTailStart = oldTailStart + growth
    let tailCount = oldCount - subrange.upperBound

    if growth > 0 {
      // Slide the tail part of the buffer forwards, in reverse order
      // so as not to self-clobber.
      newTailStart.moveInitialize(from: oldTailStart, count: tailCount)

      // Assign over the original subrange
      var i = newValues.startIndex
      for j in subrange {
        elements[j] = newValues[i]
        newValues.formIndex(after: &i)
      }
      // Initialize the hole left by sliding the tail forward
      for j in oldTailIndex..<newTailIndex {
        (elements + j).initialize(to: newValues[i])
        newValues.formIndex(after: &i)
      }
      _expectEnd(of: newValues, is: i)
    }
    else { // We're not growing the buffer
      // Assign all the new elements into the start of the subrange
      var i = subrange.lowerBound
      var j = newValues.startIndex
      for _ in 0..<newCount {
        elements[i] = newValues[j]
        i += 1
        newValues.formIndex(after: &j)
      }
      _expectEnd(of: newValues, is: j)

      // If the size didn't change, we're done.
      if growth == 0 {
        return
      }

      // Move the tail backward to cover the shrinkage.
      let shrinkage = -growth
      if tailCount > shrinkage {   // If the tail length exceeds the shrinkage

        // Assign over the rest of the replaced range with the first
        // part of the tail.
        newTailStart.moveAssign(from: oldTailStart, count: shrinkage)

        // Slide the rest of the tail back
        oldTailStart.moveInitialize(
          from: oldTailStart + shrinkage, count: tailCount - shrinkage)
      }
      else {                      // Tail fits within erased elements
        // Assign over the start of the replaced range with the tail
        newTailStart.moveAssign(from: oldTailStart, count: tailCount)

        // Destroy elements remaining after the tail in subrange
        (newTailStart + tailCount).deinitialize(
          count: shrinkage - tailCount)
      }
    }
  }
}

----Swift.(file).ArraySlice.init(_buffer:<<error type>>)
extension ArraySlice {
  internal init(_buffer: _Buffer) {
    self._buffer = _buffer
  }
}

----Swift.(file).ArraySlice.init(_buffer:<<error type>>)
extension ArraySlice {
  internal init(_buffer buffer: _ContiguousArrayBuffer<Element>) {
    self.init(_buffer: _Buffer(_buffer: buffer, shiftedToStartIndex: 0))
  }
}

----Swift.(file).ArraySlice.capacity
extension ArraySlice: _ArrayProtocol  {
  public var capacity: Int {
    return _getCapacity()
  }
}

----Swift.(file).ArraySlice.Index
extension ArraySlice: RandomAccessCollection, MutableCollection  {
  public typealias Index = I
}

----Swift.(file).ArraySlice.Indices
extension ArraySlice: RandomAccessCollection, MutableCollection  {
  public typealias Indices = Range<Int>
}

----Swift.(file).ArraySlice.Iterator
extension ArraySlice: RandomAccessCollection, MutableCollection  {
  public typealias Iterator = IndexingIterator<ArraySlice>
}

----Swift.(file).ArraySlice.startIndex
extension ArraySlice: RandomAccessCollection, MutableCollection  {
  public var startIndex: Int {
    return _buffer.startIndex
  }
}

----Swift.(file).ArraySlice.endIndex
extension ArraySlice: RandomAccessCollection, MutableCollection  {
  public var endIndex: Int {
    return _buffer.endIndex
  }
}

----Swift.(file).ArraySlice.index(after:Int)
extension ArraySlice: RandomAccessCollection, MutableCollection  {
  public func index(after i: Int) -> Int {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    return i + 1
  }
}

----Swift.(file).ArraySlice.formIndex(after:Int)
extension ArraySlice: RandomAccessCollection, MutableCollection  {
  public func formIndex(after i: inout Int) {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    i += 1
  }
}

----Swift.(file).ArraySlice.index(before:Int)
extension ArraySlice: RandomAccessCollection, MutableCollection  {
  public func index(before i: Int) -> Int {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    return i - 1
  }
}

----Swift.(file).ArraySlice.formIndex(before:Int)
extension ArraySlice: RandomAccessCollection, MutableCollection  {
  public func formIndex(before i: inout Int) {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    i -= 1
  }
}

----Swift.(file).ArraySlice.index(_:Int,offsetBy:Int)
extension ArraySlice: RandomAccessCollection, MutableCollection  {
  public func index(_ i: Int, offsetBy distance: Int) -> Int {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    return i + distance
  }
}

----Swift.(file).ArraySlice.index(_:Int,offsetBy:Int,limitedBy:Int)
extension ArraySlice: RandomAccessCollection, MutableCollection  {
  public func index(
    _ i: Int, offsetBy distance: Int, limitedBy limit: Int
  ) -> Int? {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    let l = limit - i
    if distance > 0 ? l >= 0 && l < distance : l <= 0 && distance < l {
      return nil
    }
    return i + distance
  }
}

----Swift.(file).ArraySlice.distance(from:Int,to:Int)
extension ArraySlice: RandomAccessCollection, MutableCollection  {
  public func distance(from start: Int, to end: Int) -> Int {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    return end - start
  }
}

----Swift.(file).ArraySlice.subscript(_:Int)
extension ArraySlice: RandomAccessCollection, MutableCollection  {
  public subscript(index: Int) -> Element {
    get {
      // This call may be hoisted or eliminated by the optimizer.  If
      // there is an inout violation, this value may be stale so needs to be
      // checked again below.
      let wasNativeTypeChecked = _hoistableIsNativeTypeChecked()

      // Make sure the index is in range and wasNativeTypeChecked is
      // still valid.
      let token = _checkSubscript(
        index, wasNativeTypeChecked: wasNativeTypeChecked)

      return _getElement(
        index, wasNativeTypeChecked: wasNativeTypeChecked,
        matchingSubscriptCheck: token)
    }
    _modify {
      _makeMutableAndUnique() // makes the array native, too
      _checkSubscript_native(index)
      let address = _buffer.subscriptBaseAddress + index
      yield &address.pointee
    }
  }
}

----Swift.(file).ArraySlice.subscript(_:Range<Int>)
extension ArraySlice: RandomAccessCollection, MutableCollection  {
  public subscript(bounds: Range<Int>) -> ArraySlice<Element> {
    get {
      _checkIndex(bounds.lowerBound)
      _checkIndex(bounds.upperBound)
      return ArraySlice(_buffer: _buffer[bounds])
    }
    set(rhs) {
      _checkIndex(bounds.lowerBound)
      _checkIndex(bounds.upperBound)
      // If the replacement buffer has same identity, and the ranges match,
      // then this was a pinned in-place modification, nothing further needed.
      if self[bounds]._buffer.identity != rhs._buffer.identity
      || bounds != rhs.startIndex..<rhs.endIndex {
        self.replaceSubrange(bounds, with: rhs)
      }
    }
  }
}

----Swift.(file).ArraySlice.count
extension ArraySlice: RandomAccessCollection, MutableCollection  {
  public var count: Int {
    return _getCount()
  }
}

----Swift.(file).ArraySlice.init(arrayLiteral:[Element])
extension ArraySlice: ExpressibleByArrayLiteral  {
  public init(arrayLiteral elements: Element...) {
    self.init(_buffer: ContiguousArray(elements)._buffer)
  }
}

----Swift.(file).ArraySlice.init()
extension ArraySlice: RangeReplaceableCollection  {
  public init() {
    _buffer = _Buffer()
  }
}

----Swift.(file).ArraySlice.init(_:S)
extension ArraySlice: RangeReplaceableCollection  {
  public init<S: Sequence>(_ s: S)
    where S.Element == Element {

    self = ArraySlice(
      _buffer: _Buffer(
        _buffer: s._copyToContiguousArray()._buffer,
        shiftedToStartIndex: 0))
  }
}

----Swift.(file).ArraySlice.init(repeating:Element,count:Int)
extension ArraySlice: RangeReplaceableCollection  {
  public init(repeating repeatedValue: Element, count: Int) {
    var p: UnsafeMutablePointer<Element>
    (self, p) = ArraySlice._allocateUninitialized(count)
    for _ in 0..<count {
      p.initialize(to: repeatedValue)
      p += 1
    }
  }
}

----Swift.(file).ArraySlice.init(_uninitializedCount:Int)
extension ArraySlice: RangeReplaceableCollection  {
  internal init(_uninitializedCount count: Int) {
    _precondition(count >= 0, "Can't construct ArraySlice with count < 0")
    // Note: Sinking this constructor into an else branch below causes an extra
    // Retain/Release.
    _buffer = _Buffer()
    if count > 0 {
      // Creating a buffer instead of calling reserveCapacity saves doing an
      // unnecessary uniqueness check. We disable inlining here to curb code
      // growth.
      _buffer = ArraySlice._allocateBufferUninitialized(minimumCapacity: count)
      _buffer.count = count
    }
    // Can't store count here because the buffer might be pointing to the
    // shared empty array.
  }
}

----Swift.(file).ArraySlice.reserveCapacity(_:Int)
extension ArraySlice: RangeReplaceableCollection  {
  public mutating func reserveCapacity(_ minimumCapacity: Int) {
    if _buffer.requestUniqueMutableBackingBuffer(
      minimumCapacity: minimumCapacity) == nil {

      let newBuffer = _ContiguousArrayBuffer<Element>(
        _uninitializedCount: count, minimumCapacity: minimumCapacity)

      _buffer._copyContents(
        subRange: _buffer.indices,
        initializing: newBuffer.firstElementAddress)
      _buffer = _Buffer(
        _buffer: newBuffer, shiftedToStartIndex: _buffer.startIndex)
    }
    _internalInvariant(capacity >= minimumCapacity)
  }
}

----Swift.(file).ArraySlice.append(_:Element)
extension ArraySlice: RangeReplaceableCollection  {
  public mutating func append(_ newElement: __owned Element) {
    _makeUniqueAndReserveCapacityIfNotUnique()
    let oldCount = _getCount()
    _reserveCapacityAssumingUniqueBuffer(oldCount: oldCount)
    _appendElementAssumeUniqueAndCapacity(oldCount, newElement: newElement)
  }
}

----Swift.(file).ArraySlice.append(contentsOf:S)
extension ArraySlice: RangeReplaceableCollection  {
  public mutating func append<S: Sequence>(contentsOf newElements: __owned S)
    where S.Element == Element {

    let newElementsCount = newElements.underestimatedCount
    reserveCapacityForAppend(newElementsCount: newElementsCount)

    let oldCount = self.count
    let startNewElements = _buffer.firstElementAddress + oldCount
    let buf = UnsafeMutableBufferPointer(
                start: startNewElements, 
                count: self.capacity - oldCount)

    let (remainder,writtenUpTo) = buf.initialize(from: newElements)
    
    // trap on underflow from the sequence's underestimate:
    let writtenCount = buf.distance(from: buf.startIndex, to: writtenUpTo)
    _precondition(newElementsCount <= writtenCount, 
      "newElements.underestimatedCount was an overestimate")
    // can't check for overflow as sequences can underestimate

    _buffer.count += writtenCount

    if writtenUpTo == buf.endIndex {
      // there may be elements that didn't fit in the existing buffer,
      // append them in slow sequence-only mode
      _buffer._arrayAppendSequence(IteratorSequence(remainder))
    }
  }
}

----Swift.(file).ArraySlice.reserveCapacityForAppend(newElementsCount:Int)
extension ArraySlice: RangeReplaceableCollection  {
  internal mutating func reserveCapacityForAppend(newElementsCount: Int) {
    let oldCount = self.count
    let oldCapacity = self.capacity
    let newCount = oldCount + newElementsCount

    // Ensure uniqueness, mutability, and sufficient storage.  Note that
    // for consistency, we need unique self even if newElements is empty.
    self.reserveCapacity(
      newCount > oldCapacity ?
      Swift.max(newCount, _growArrayCapacity(oldCapacity))
      : newCount)
  }
}

----Swift.(file).ArraySlice.remove(at:Int)
extension ArraySlice: RangeReplaceableCollection  {
  public mutating func remove(at index: Int) -> Element {
    let result = self[index]
    self.replaceSubrange(index..<(index + 1), with: EmptyCollection())
    return result
  }
}

----Swift.(file).ArraySlice.insert(_:Element,at:Int)
extension ArraySlice: RangeReplaceableCollection  {
  public mutating func insert(_ newElement: __owned Element, at i: Int) {
    _checkIndex(i)
    self.replaceSubrange(i..<i, with: CollectionOfOne(newElement))
  }
}

----Swift.(file).ArraySlice.removeAll(keepingCapacity:Bool)
extension ArraySlice: RangeReplaceableCollection  {
  public mutating func removeAll(keepingCapacity keepCapacity: Bool = false) {
    if !keepCapacity {
      _buffer = _Buffer()
    }
    else {
      self.replaceSubrange(indices, with: EmptyCollection())
    }
  }
}

----Swift.(file).ArraySlice.withContiguousMutableStorageIfAvailable(_:(inout UnsafeMutableBufferPointer<Element>) throws -> R)
extension ArraySlice: RangeReplaceableCollection  {
  public mutating func withContiguousMutableStorageIfAvailable<R>(
    _ body: (inout UnsafeMutableBufferPointer<Element>) throws -> R
  ) rethrows -> R? {
    return try withUnsafeMutableBufferPointer {
      (bufferPointer) -> R in
      return try body(&bufferPointer)
    }
  }
}

----Swift.(file).ArraySlice.withContiguousStorageIfAvailable(_:(UnsafeBufferPointer<Element>) throws -> R)
extension ArraySlice: RangeReplaceableCollection  {
  public func withContiguousStorageIfAvailable<R>(
    _ body: (UnsafeBufferPointer<Element>) throws -> R
  ) rethrows -> R? {
    return try withUnsafeBufferPointer {
      (bufferPointer) -> R in
      return try body(bufferPointer)
    }
  }
}

----Swift.(file).ArraySlice.customMirror
extension ArraySlice: CustomReflectable  {
  public var customMirror: Mirror {
    return Mirror(
      self,
      unlabeledChildren: self,
      displayStyle: .collection)
  }
}

----Swift.(file).ArraySlice.description
extension ArraySlice: CustomStringConvertible, CustomDebugStringConvertible  {
  public var description: String {
    return _makeCollectionDescription()
  }
}

----Swift.(file).ArraySlice.debugDescription
extension ArraySlice: CustomStringConvertible, CustomDebugStringConvertible  {
  public var debugDescription: String {
    return _makeCollectionDescription(withTypeName: "ArraySlice")
  }
}

----Swift.(file).ArraySlice.withUnsafeBufferPointer(_:(UnsafeBufferPointer<Element>) throws -> R)
extension ArraySlice  {
  public func withUnsafeBufferPointer<R>(
    _ body: (UnsafeBufferPointer<Element>) throws -> R
  ) rethrows -> R {
    return try _buffer.withUnsafeBufferPointer(body)
  }
}

----Swift.(file).ArraySlice.withUnsafeMutableBufferPointer(_:(inout UnsafeMutableBufferPointer<Element>) throws -> R)
extension ArraySlice  {
  public mutating func withUnsafeMutableBufferPointer<R>(
    _ body: (inout UnsafeMutableBufferPointer<Element>) throws -> R
  ) rethrows -> R {
    let count = self.count
    // Ensure unique storage
    _buffer._outlinedMakeUniqueBuffer(bufferCount: count)

    // Ensure that body can't invalidate the storage or its bounds by
    // moving self into a temporary working array.
    // NOTE: The stack promotion optimization that keys of the
    // "array.withUnsafeMutableBufferPointer" semantics annotation relies on the
    // array buffer not being able to escape in the closure. It can do this
    // because we swap the array buffer in self with an empty buffer here. Any
    // escape via the address of self in the closure will therefore escape the
    // empty array.

    var work = ArraySlice()
    (work, self) = (self, work)

    // Create an UnsafeBufferPointer over work that we can pass to body
    let pointer = work._buffer.firstElementAddress
    var inoutBufferPointer = UnsafeMutableBufferPointer(
      start: pointer, count: count)

    // Put the working array back before returning.
    defer {
      _precondition(
        inoutBufferPointer.baseAddress == pointer &&
        inoutBufferPointer.count == count,
        "ArraySlice withUnsafeMutableBufferPointer: replacing the buffer is not allowed")

      (work, self) = (self, work)
    }

    // Invoke the body.
    return try body(&inoutBufferPointer)
  }
}

----Swift.(file).ArraySlice.replaceSubrange(_:Range<Int>,with:C)
extension ArraySlice  {
  public mutating func replaceSubrange<C>(
    _ subrange: Range<Int>,
    with newElements: __owned C
  ) where C: Collection, C.Element == Element {
    _precondition(subrange.lowerBound >= _buffer.startIndex,
      "ArraySlice replace: subrange start is before the startIndex")

    _precondition(subrange.upperBound <= _buffer.endIndex,
      "ArraySlice replace: subrange extends past the end")

    let oldCount = _buffer.count
    let eraseCount = subrange.count
    let insertCount = newElements.count
    let growth = insertCount - eraseCount

    if _buffer.requestUniqueMutableBackingBuffer(
      minimumCapacity: oldCount + growth) != nil {

      _buffer.replaceSubrange(
        subrange, with: insertCount, elementsOf: newElements)
    } else {
      _buffer._arrayOutOfPlaceReplace(subrange, with: newElements, count: insertCount)
    }
  }
}

----Swift.(file).ArraySlice.==infix(_:ArraySlice<Element>,_:ArraySlice<Element>)
extension ArraySlice: Equatable where Element: Equatable  {
  public static func ==(lhs: ArraySlice<Element>, rhs: ArraySlice<Element>) -> Bool {
    let lhsCount = lhs.count
    if lhsCount != rhs.count {
      return false
    }

    // Test referential equality.
    if lhsCount == 0 || lhs._buffer.identity == rhs._buffer.identity {
      return true
    }


    var streamLHS = lhs.makeIterator()
    var streamRHS = rhs.makeIterator()

    var nextLHS = streamLHS.next()
    while nextLHS != nil {
      let nextRHS = streamRHS.next()
      if nextLHS != nextRHS {
        return false
      }
      nextLHS = streamLHS.next()
    }


    return true
  }
}

----Swift.(file).ArraySlice.hash(into:Hasher)
extension ArraySlice: Hashable where Element: Hashable  {
  public func hash(into hasher: inout Hasher) {
    hasher.combine(count) // discriminator
    for element in self {
      hasher.combine(element)
    }
  }
}

----Swift.(file).ArraySlice.withUnsafeMutableBytes(_:(UnsafeMutableRawBufferPointer) throws -> R)
extension ArraySlice  {
  public mutating func withUnsafeMutableBytes<R>(
    _ body: (UnsafeMutableRawBufferPointer) throws -> R
  ) rethrows -> R {
    return try self.withUnsafeMutableBufferPointer {
      return try body(UnsafeMutableRawBufferPointer($0))
    }
  }
}

----Swift.(file).ArraySlice.withUnsafeBytes(_:(UnsafeRawBufferPointer) throws -> R)
extension ArraySlice  {
  public func withUnsafeBytes<R>(
    _ body: (UnsafeRawBufferPointer) throws -> R
  ) rethrows -> R {
    return try self.withUnsafeBufferPointer {
      try body(UnsafeRawBufferPointer($0))
    }
  }
}

----Swift.(file).ArraySlice.init(_startIndex:Int)
extension ArraySlice  {
  init(_startIndex: Int) {
    self.init(
      _buffer: _Buffer(
        _buffer: ContiguousArray()._buffer,
        shiftedToStartIndex: _startIndex))
  }
}

----Swift.(file)._ArrayProtocol.filter(_:(Self.Element) throws -> Bool)
extension _ArrayProtocol  {
  public __consuming func filter(
    _ isIncluded: (Element) throws -> Bool
  ) rethrows -> [Element] {
    return try _filter(isIncluded)
  }
}

----Swift.(file).assert(_:() -> Bool,_:() -> String,file:StaticString,line:UInt)
public func assert(
  _ condition: @autoclosure () -> Bool,
  _ message: @autoclosure () -> String = String(),
  file: StaticString = #file, line: UInt = #line
) {
  // Only assert in debug mode.
  if _isDebugAssertConfiguration() {
    if !_branchHint(condition(), expected: true) {
      _assertionFailure("Assertion failed", message(), file: file, line: line,
        flags: _fatalErrorFlags())
    }
  }
}

----Swift.(file).precondition(_:() -> Bool,_:() -> String,file:StaticString,line:UInt)
public func precondition(
  _ condition: @autoclosure () -> Bool,
  _ message: @autoclosure () -> String = String(),
  file: StaticString = #file, line: UInt = #line
) {
  // Only check in debug and release mode. In release mode just trap.
  if _isDebugAssertConfiguration() {
    if !_branchHint(condition(), expected: true) {
      _assertionFailure("Precondition failed", message(), file: file, line: line,
        flags: _fatalErrorFlags())
    }
  } else if _isReleaseAssertConfiguration() {
    let error = !condition()
    Builtin.condfail(error._value)
  }
}

----Swift.(file).assertionFailure(_:() -> String,file:StaticString,line:UInt)
public func assertionFailure(
  _ message: @autoclosure () -> String = String(),
  file: StaticString = #file, line: UInt = #line
) {
  if _isDebugAssertConfiguration() {
    _assertionFailure("Fatal error", message(), file: file, line: line,
      flags: _fatalErrorFlags())
  }
  else if _isFastAssertConfiguration() {
    _conditionallyUnreachable()
  }
}

----Swift.(file).preconditionFailure(_:() -> String,file:StaticString,line:UInt)
public func preconditionFailure(
  _ message: @autoclosure () -> String = String(),
  file: StaticString = #file, line: UInt = #line
) -> Never {
  // Only check in debug and release mode.  In release mode just trap.
  if _isDebugAssertConfiguration() {
    _assertionFailure("Fatal error", message(), file: file, line: line,
      flags: _fatalErrorFlags())
  } else if _isReleaseAssertConfiguration() {
    Builtin.int_trap()
  }
  _conditionallyUnreachable()
}

----Swift.(file).fatalError(_:() -> String,file:StaticString,line:UInt)
public func fatalError(
  _ message: @autoclosure () -> String = String(),
  file: StaticString = #file, line: UInt = #line
) -> Never {
  _assertionFailure("Fatal error", message(), file: file, line: line,
    flags: _fatalErrorFlags())
}

----Swift.(file).BidirectionalCollection.Element
extension BidirectionalCollection {
  override associatedtype E
}

----Swift.(file).BidirectionalCollection.Index
extension BidirectionalCollection {
  override associatedtype I
}

----Swift.(file).BidirectionalCollection.SubSequence
extension BidirectionalCollection {
  override associatedtype S
}

----Swift.(file).BidirectionalCollection.Indices
extension BidirectionalCollection {
  override associatedtype I
}

----Swift.(file).BidirectionalCollection.index(before:Self.Index)
extension BidirectionalCollection {
  func index(before i: Index) -> I
}

----Swift.(file).BidirectionalCollection.formIndex(before:Self.Index)
extension BidirectionalCollection {
  func formIndex(before i: inout Index)
}

----Swift.(file).BidirectionalCollection.index(after:Self.Index)
extension BidirectionalCollection {
  override func index(after i: Index) -> I
}

----Swift.(file).BidirectionalCollection.formIndex(after:Self.Index)
extension BidirectionalCollection {
  override func formIndex(after i: inout Index)
}

----Swift.(file).BidirectionalCollection.index(_:Self.Index,offsetBy:Int)
extension BidirectionalCollection {
  @_nonoverride func index(_ i: Index, offsetBy distance: Int) -> I
}

----Swift.(file).BidirectionalCollection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)
extension BidirectionalCollection {
  @_nonoverride func index(
    _ i: Index, offsetBy distance: Int, limitedBy limit: Index
  ) -> Index?
}

----Swift.(file).BidirectionalCollection.distance(from:Self.Index,to:Self.Index)
extension BidirectionalCollection {
  @_nonoverride func distance(from start: Index, to end: Index) -> I
}

----Swift.(file).BidirectionalCollection.indices
extension BidirectionalCollection {
  override var indices: Indices { get }
}

----Swift.(file).BidirectionalCollection.subscript(_:Range<Self.Index>)
extension BidirectionalCollection {
  override subscript(bounds: Range<Index>) -> SubSequence { get }
}

----Swift.(file).BidirectionalCollection.subscript(_:Self.Index)
extension BidirectionalCollection {
  override subscript(position: Index) -> Element { get }
}

----Swift.(file).BidirectionalCollection.startIndex
extension BidirectionalCollection {
  override var startIndex: Index { get }
}

----Swift.(file).BidirectionalCollection.endIndex
extension BidirectionalCollection {
  override var endIndex: Index { get }
}

----Swift.(file).BidirectionalCollection.formIndex(before:Self.Index)
extension BidirectionalCollection  {
  public func formIndex(before i: inout Index) {
    i = index(before: i)
  }
}

----Swift.(file).BidirectionalCollection.index(_:Self.Index,offsetBy:Int)
extension BidirectionalCollection  {
  public func index(_ i: Index, offsetBy distance: Int) -> Index {
    return _index(i, offsetBy: distance)
  }
}

----Swift.(file).BidirectionalCollection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)
extension BidirectionalCollection  {
  public func index(
    _ i: Index, offsetBy distance: Int, limitedBy limit: Index
  ) -> Index? {
    return _index(i, offsetBy: distance, limitedBy: limit)
  }
}

----Swift.(file).BidirectionalCollection.distance(from:Self.Index,to:Self.Index)
extension BidirectionalCollection  {
  public func distance(from start: Index, to end: Index) -> Int {
    return _distance(from: start, to: end)
  }
}

----Swift.(file).BidirectionalCollection.popLast()
extension BidirectionalCollection where SubSequence == Self  {
  public mutating func popLast() -> Element? {
    guard !isEmpty else { return nil }
    let element = last!
    self = self[startIndex..<index(before: endIndex)]
    return element
  }
}

----Swift.(file).BidirectionalCollection.removeLast()
extension BidirectionalCollection where SubSequence == Self  {
  public mutating func removeLast() -> Element {
    let element = last!
    self = self[startIndex..<index(before: endIndex)]
    return element
  }
}

----Swift.(file).BidirectionalCollection.removeLast(_:Int)
extension BidirectionalCollection where SubSequence == Self  {
  public mutating func removeLast(_ k: Int) {
    if k == 0 { return }
    _precondition(k >= 0, "Number of elements to remove should be non-negative")
    _precondition(count >= k,
      "Can't remove more items from a collection than it contains")
    self = self[startIndex..<index(endIndex, offsetBy: -k)]
  }
}

----Swift.(file).BidirectionalCollection.dropLast(_:Int)
extension BidirectionalCollection  {
  public __consuming func dropLast(_ k: Int) -> SubSequence {
    _precondition(
      k >= 0, "Can't drop a negative number of elements from a collection")
    let end = index(
      endIndex,
      offsetBy: -k,
      limitedBy: startIndex) ?? startIndex
    return self[startIndex..<end]
  }
}

----Swift.(file).BidirectionalCollection.suffix(_:Int)
extension BidirectionalCollection  {
  public __consuming func suffix(_ maxLength: Int) -> SubSequence {
    _precondition(
      maxLength >= 0,
      "Can't take a suffix of negative length from a collection")
    let start = index(
      endIndex,
      offsetBy: -maxLength,
      limitedBy: startIndex) ?? startIndex
    return self[start..<endIndex]
  }
}

----Swift.(file)._UnsafeBitset.word(for:Int)
extension _UnsafeBitset  {
  internal static func word(for element: Int) -> Int {
    _internalInvariant(element >= 0)
    // Note: We perform on UInts to get faster unsigned math (shifts).
    let element = UInt(bitPattern: element)
    let capacity = UInt(bitPattern: Word.capacity)
    return Int(bitPattern: element / capacity)
  }
}

----Swift.(file)._UnsafeBitset.bit(for:Int)
extension _UnsafeBitset  {
  internal static func bit(for element: Int) -> Int {
    _internalInvariant(element >= 0)
    // Note: We perform on UInts to get faster unsigned math (masking).
    let element = UInt(bitPattern: element)
    let capacity = UInt(bitPattern: Word.capacity)
    return Int(bitPattern: element % capacity)
  }
}

----Swift.(file)._UnsafeBitset.split(_:Int)
extension _UnsafeBitset  {
  internal static func split(_ element: Int) -> (word: Int, bit: Int) {
    return (word(for: element), bit(for: element))
  }
}

----Swift.(file)._UnsafeBitset.join(word:Int,bit:Int)
extension _UnsafeBitset  {
  internal static func join(word: Int, bit: Int) -> Int {
    _internalInvariant(bit >= 0 && bit < Word.capacity)
    return word &* Word.capacity &+ bit
  }
}

----Swift.(file)._UnsafeBitset.wordCount(forCapacity:Int)
extension _UnsafeBitset  {
  internal static func wordCount(forCapacity capacity: Int) -> Int {
    return word(for: capacity &+ Word.capacity &- 1)
  }
}

----Swift.(file)._UnsafeBitset.capacity
extension _UnsafeBitset  {
  internal var capacity: Int {
    @inline(__always)
    get {
      return wordCount &* Word.capacity
    }
  }
}

----Swift.(file)._UnsafeBitset.isValid(_:Int)
extension _UnsafeBitset  {
  internal func isValid(_ element: Int) -> Bool {
    return element >= 0 && element <= capacity
  }
}

----Swift.(file)._UnsafeBitset.uncheckedContains(_:Int)
extension _UnsafeBitset  {
  internal func uncheckedContains(_ element: Int) -> Bool {
    _internalInvariant(isValid(element))
    let (word, bit) = _UnsafeBitset.split(element)
    return words[word].uncheckedContains(bit)
  }
}

----Swift.(file)._UnsafeBitset.uncheckedInsert(_:Int)
extension _UnsafeBitset  {
  internal func uncheckedInsert(_ element: Int) -> Bool {
    _internalInvariant(isValid(element))
    let (word, bit) = _UnsafeBitset.split(element)
    return words[word].uncheckedInsert(bit)
  }
}

----Swift.(file)._UnsafeBitset.uncheckedRemove(_:Int)
extension _UnsafeBitset  {
  internal func uncheckedRemove(_ element: Int) -> Bool {
    _internalInvariant(isValid(element))
    let (word, bit) = _UnsafeBitset.split(element)
    return words[word].uncheckedRemove(bit)
  }
}

----Swift.(file)._UnsafeBitset.clear()
extension _UnsafeBitset  {
  internal func clear() {
    words.assign(repeating: .empty, count: wordCount)
  }
}

----Swift.(file)._UnsafeBitset.Element
extension _UnsafeBitset: Sequence  {
  internal typealias Element = I
}

----Swift.(file)._UnsafeBitset.count
extension _UnsafeBitset: Sequence  {
  internal var count: Int {
    var count = 0
    for w in 0 ..< wordCount {
      count += words[w].count
    }
    return count
  }
}

----Swift.(file)._UnsafeBitset.underestimatedCount
extension _UnsafeBitset: Sequence  {
  internal var underestimatedCount: Int {
    return count
  }
}

----Swift.(file)._UnsafeBitset.makeIterator()
extension _UnsafeBitset: Sequence  {
  func makeIterator() -> Iterator {
    return Iterator(self)
  }
}

----Swift.(file)._UnsafeBitset.Word.capacity
extension _UnsafeBitset.Word  {
  internal static var capacity: Int {
    @inline(__always)
    get {
      return UInt.bitWidth
    }
  }
}

----Swift.(file)._UnsafeBitset.Word.uncheckedContains(_:Int)
extension _UnsafeBitset.Word  {
  internal func uncheckedContains(_ bit: Int) -> Bool {
    _internalInvariant(bit >= 0 && bit < UInt.bitWidth)
    return value & (1 &<< bit) != 0
  }
}

----Swift.(file)._UnsafeBitset.Word.uncheckedInsert(_:Int)
extension _UnsafeBitset.Word  {
  internal mutating func uncheckedInsert(_ bit: Int) -> Bool {
    _internalInvariant(bit >= 0 && bit < UInt.bitWidth)
    let mask: UInt = 1 &<< bit
    let inserted = value & mask == 0
    value |= mask
    return inserted
  }
}

----Swift.(file)._UnsafeBitset.Word.uncheckedRemove(_:Int)
extension _UnsafeBitset.Word  {
  internal mutating func uncheckedRemove(_ bit: Int) -> Bool {
    _internalInvariant(bit >= 0 && bit < UInt.bitWidth)
    let mask: UInt = 1 &<< bit
    let removed = value & mask != 0
    value &= ~mask
    return removed
  }
}

----Swift.(file)._UnsafeBitset.Word.minimum
extension _UnsafeBitset.Word  {
  var minimum: Int? {
    @inline(__always)
    get {
      guard value != 0 else { return nil }
      return value.trailingZeroBitCount
    }
  }
}

----Swift.(file)._UnsafeBitset.Word.maximum
extension _UnsafeBitset.Word  {
  var maximum: Int? {
    @inline(__always)
    get {
      guard value != 0 else { return nil }
      return _UnsafeBitset.Word.capacity &- 1 &- value.leadingZeroBitCount
    }
  }
}

----Swift.(file)._UnsafeBitset.Word.complement
extension _UnsafeBitset.Word  {
  var complement: _UnsafeBitset.Word {
    @inline(__always)
    get {
      return _UnsafeBitset.Word(~value)
    }
  }
}

----Swift.(file)._UnsafeBitset.Word.subtracting(elementsBelow:Int)
extension _UnsafeBitset.Word  {
  internal func subtracting(elementsBelow bit: Int) -> _UnsafeBitset.Word {
    _internalInvariant(bit >= 0 && bit < _UnsafeBitset.Word.capacity)
    let mask = UInt.max &<< bit
    return _UnsafeBitset.Word(value & mask)
  }
}

----Swift.(file)._UnsafeBitset.Word.intersecting(elementsBelow:Int)
extension _UnsafeBitset.Word  {
  internal func intersecting(elementsBelow bit: Int) -> _UnsafeBitset.Word {
    _internalInvariant(bit >= 0 && bit < _UnsafeBitset.Word.capacity)
    let mask: UInt = (1 as UInt &<< bit) &- 1
    return _UnsafeBitset.Word(value & mask)
  }
}

----Swift.(file)._UnsafeBitset.Word.intersecting(elementsAbove:Int)
extension _UnsafeBitset.Word  {
  internal func intersecting(elementsAbove bit: Int) -> _UnsafeBitset.Word {
    _internalInvariant(bit >= 0 && bit < _UnsafeBitset.Word.capacity)
    let mask = (UInt.max &<< bit) &<< 1
    return _UnsafeBitset.Word(value & mask)
  }
}

----Swift.(file)._UnsafeBitset.Word.empty
extension _UnsafeBitset.Word  {
  internal static var empty: _UnsafeBitset.Word {
    @inline(__always)
    get {
      return _UnsafeBitset.Word(0)
    }
  }
}

----Swift.(file)._UnsafeBitset.Word.allBits
extension _UnsafeBitset.Word  {
  internal static var allBits: _UnsafeBitset.Word {
    @inline(__always)
    get {
      return _UnsafeBitset.Word(UInt.max)
    }
  }
}

----Swift.(file)._UnsafeBitset.Word.count
extension _UnsafeBitset.Word: Sequence, IteratorProtocol  {
  internal var count: Int {
    return value.nonzeroBitCount
  }
}

----Swift.(file)._UnsafeBitset.Word.underestimatedCount
extension _UnsafeBitset.Word: Sequence, IteratorProtocol  {
  internal var underestimatedCount: Int {
    return count
  }
}

----Swift.(file)._UnsafeBitset.Word.isEmpty
extension _UnsafeBitset.Word: Sequence, IteratorProtocol  {
  internal var isEmpty: Bool {
    @inline(__always)
    get {
      return value == 0
    }
  }
}

----Swift.(file)._UnsafeBitset.Word.next()
extension _UnsafeBitset.Word: Sequence, IteratorProtocol  {
  internal mutating func next() -> Int? {
    guard value != 0 else { return nil }
    let bit = value.trailingZeroBitCount
    value &= value &- 1       // Clear lowest nonzero bit.
    return bit
  }
}

----Swift.(file).Bool.init()
extension Bool {
  public init() {
    let zero: Int8 = 0
    self._value = Builtin.trunc_Int8_Int1(zero._value)
  }
}

----Swift.(file).Bool.init(_:<<error type>>)
extension Bool {
  internal init(_ v: Builtin.Int1) { self._value = v }
}

----Swift.(file).Bool.init(_:Bool)
extension Bool {
  public init(_ value: Bool) {
    self = value
  }
}

----Swift.(file).Bool.random(using:T)
extension Bool {
  public static func random<T: RandomNumberGenerator>(
    using generator: inout T
  ) -> Bool {
    return (generator.next() >> 17) & 1 == 0
  }
}

----Swift.(file).Bool.random()
extension Bool {
  public static func random() -> Bool {
    var g = SystemRandomNumberGenerator()
    return Bool.random(using: &g)
  }
}

----Swift.(file).Bool.init(_builtinBooleanLiteral:<<error type>>)
extension Bool : _ExpressibleByBuiltinBooleanLiteral, ExpressibleByBooleanLiteral  {
  public init(_builtinBooleanLiteral value: Builtin.Int1) {
    self._value = value
  }
}

----Swift.(file).Bool.init(booleanLiteral:Bool)
extension Bool : _ExpressibleByBuiltinBooleanLiteral, ExpressibleByBooleanLiteral  {
  public init(booleanLiteral value: Bool) {
    self = value
  }
}

----Swift.(file).Bool.description
extension Bool : CustomStringConvertible  {
  public var description: String {
    return self ? "true" : "false"
  }
}

----Swift.(file).Bool.==infix(_:Bool,_:Bool)
extension Bool: Equatable  {
  public static func == (lhs: Bool, rhs: Bool) -> Bool {
    return Bool(Builtin.cmp_eq_Int1(lhs._value, rhs._value))
  }
}

----Swift.(file).Bool.hash(into:Hasher)
extension Bool: Hashable  {
  public func hash(into hasher: inout Hasher) {
    hasher.combine((self ? 1 : 0) as UInt8)
  }
}

----Swift.(file).Bool.init(_:String)
extension Bool : LosslessStringConvertible  {
  public init?(_ description: String) {
    if description == "true" {
      self = true
    } else if description == "false" {
      self = false
    } else {
      return nil
    }
  }
}

----Swift.(file).Bool.!prefix(_:Bool)
extension Bool  {
  public static prefix func ! (a: Bool) -> Bool {
    return Bool(Builtin.xor_Int1(a._value, true._value))
  }
}

----Swift.(file).Bool.&&infix(_:Bool,_:() throws -> Bool)
extension Bool  {
  public static func && (lhs: Bool, rhs: @autoclosure () throws -> Bool) rethrows
      -> Bool {
    return lhs ? try rhs() : false
  }
}

----Swift.(file).Bool.||infix(_:Bool,_:() throws -> Bool)
extension Bool  {
  public static func || (lhs: Bool, rhs: @autoclosure () throws -> Bool) rethrows
      -> Bool {
    return lhs ? true : try rhs()
  }
}

----Swift.(file).Bool.toggle()
extension Bool  {
  public mutating func toggle() {
    self = !self
  }
}

----Swift.(file).AutoreleasingUnsafeMutablePointer.init(_:<<error type>>)
extension AutoreleasingUnsafeMutablePointer {
  init(_ _rawValue: Builtin.RawPointer) {
    self._rawValue = _rawValue
  }
}

----Swift.(file).AutoreleasingUnsafeMutablePointer.pointee
extension AutoreleasingUnsafeMutablePointer {
  public var pointee: Pointee {
    @_transparent _read {
      // We can do a strong load normally.
      yield UnsafePointer(self).pointee
    }
    /// Set the value the pointer points to, copying over the previous value.
    ///
    /// AutoreleasingUnsafeMutablePointers are assumed to reference a
    /// value with __autoreleasing ownership semantics, like 'NSFoo**'
    /// in ARC. This autoreleases the argument before trivially
    /// storing it to the referenced memory.
    @_transparent nonmutating set {
      // Autorelease the object reference.
      typealias OptionalAnyObject = AnyObject?
      let newAnyObject = unsafeBitCast(newValue, to: OptionalAnyObject.self)
      Builtin.retain(newAnyObject)
      Builtin.autorelease(newAnyObject)
      // Trivially assign it as an OpaquePointer; the pointer references an
      // autoreleasing slot, so retains/releases of the original value are
      // unneeded.
      typealias OptionalUnmanaged = Unmanaged<AnyObject>?
      UnsafeMutablePointer<Pointee>(_rawValue).withMemoryRebound(
        to: OptionalUnmanaged.self, capacity: 1) {
        if let newAnyObject = newAnyObject {
          $0.pointee = Unmanaged.passUnretained(newAnyObject)
        }
        else {
          $0.pointee = nil
        }
      }
    }
  }
}

----Swift.(file).AutoreleasingUnsafeMutablePointer.subscript(_:Int)
extension AutoreleasingUnsafeMutablePointer {
  public subscript(i: Int) -> Pointee {
    @_transparent
    _read {
      // We can do a strong load normally.
      yield ((UnsafePointer<Pointee>(self) + i).pointee)
    }
  }
}

----Swift.(file).AutoreleasingUnsafeMutablePointer.init(_:UnsafePointer<U>)
extension AutoreleasingUnsafeMutablePointer {
  internal init<U>(_ from: UnsafePointer<U>) {
    self._rawValue = from._rawValue
  }
}

----Swift.(file).AutoreleasingUnsafeMutablePointer.init(_:UnsafePointer<U>?)
extension AutoreleasingUnsafeMutablePointer {
  internal init?<U>(_ from: UnsafePointer<U>?) {
    guard let unwrapped = from else { return nil }
    self.init(unwrapped)
  }
}

----Swift.(file).UnsafeMutableRawPointer.init(_:AutoreleasingUnsafeMutablePointer<T>)
extension UnsafeMutableRawPointer  {
  public init<T>(_ other: AutoreleasingUnsafeMutablePointer<T>) {
    _rawValue = other._rawValue
  }
}

----Swift.(file).UnsafeMutableRawPointer.init(_:AutoreleasingUnsafeMutablePointer<T>?)
extension UnsafeMutableRawPointer  {
  public init?<T>(_ other: AutoreleasingUnsafeMutablePointer<T>?) {
    guard let unwrapped = other else { return nil }
    self.init(unwrapped)
  }
}

----Swift.(file).UnsafeRawPointer.init(_:AutoreleasingUnsafeMutablePointer<T>)
extension UnsafeRawPointer  {
  public init<T>(_ other: AutoreleasingUnsafeMutablePointer<T>) {
    _rawValue = other._rawValue
  }
}

----Swift.(file).UnsafeRawPointer.init(_:AutoreleasingUnsafeMutablePointer<T>?)
extension UnsafeRawPointer  {
  public init?<T>(_ other: AutoreleasingUnsafeMutablePointer<T>?) {
    guard let unwrapped = other else { return nil }
    self.init(unwrapped)
  }
}

----Swift.(file).ManagedBufferPointer.init(_:Int)
extension ManagedBufferPointer
where Header == _BridgingBufferHeader, Element == AnyObject  {
  internal init(_ count: Int) {
    self.init(
      _uncheckedBufferClass: _BridgingBufferStorage.self,
      minimumCapacity: count)
    self.withUnsafeMutablePointerToHeader {
      $0.initialize(to: Header(count))
    }
  }
}

----Swift.(file).ManagedBufferPointer.count
extension ManagedBufferPointer
where Header == _BridgingBufferHeader, Element == AnyObject  {
  internal var count: Int {
    @inline(__always)
    get {
      return header.count
    }
    @inline(__always)
    set {
      return header.count = newValue
    }
  }
}

----Swift.(file).ManagedBufferPointer.subscript(_:Int)
extension ManagedBufferPointer
where Header == _BridgingBufferHeader, Element == AnyObject  {
  internal subscript(i: Int) -> Element {
    @inline(__always)
    get {
      return withUnsafeMutablePointerToElements { $0[i] }
    }
  }
}

----Swift.(file).ManagedBufferPointer.baseAddress
extension ManagedBufferPointer
where Header == _BridgingBufferHeader, Element == AnyObject  {
  internal var baseAddress: UnsafeMutablePointer<Element> {
    @inline(__always)
    get {
      return withUnsafeMutablePointerToElements { $0 }
    }
  }
}

----Swift.(file).ManagedBufferPointer.storage
extension ManagedBufferPointer
where Header == _BridgingBufferHeader, Element == AnyObject  {
  internal var storage: AnyObject? {
    @inline(__always)
    get {
      return buffer
    }
  }
}

----Swift.(file).unsafeBitCast(_:T,to:U.Type)
public func unsafeBitCast<T, U>(_ x: T, to type: U.Type) -> U {
  _precondition(MemoryLayout<T>.size == MemoryLayout<U>.size,
    "Can't unsafeBitCast between types of different sizes")
  return Builtin.reinterpretCast(x)
}

----Swift.(file).==infix(_:<<error type>>,_:<<error type>>)
internal func == (
  lhs: Builtin.NativeObject, rhs: Builtin.NativeObject
) -> Bool {
  return unsafeBitCast(lhs, to: Int.self) == unsafeBitCast(rhs, to: Int.self)
}

----Swift.(file).!=infix(_:<<error type>>,_:<<error type>>)
internal func != (
  lhs: Builtin.NativeObject, rhs: Builtin.NativeObject
) -> Bool {
  return !(lhs == rhs)
}

----Swift.(file).==infix(_:<<error type>>,_:<<error type>>)
internal func == (
  lhs: Builtin.RawPointer, rhs: Builtin.RawPointer
) -> Bool {
  return unsafeBitCast(lhs, to: Int.self) == unsafeBitCast(rhs, to: Int.self)
}

----Swift.(file).!=infix(_:<<error type>>,_:<<error type>>)
internal func != (lhs: Builtin.RawPointer, rhs: Builtin.RawPointer) -> Bool {
  return !(lhs == rhs)
}

----Swift.(file).==infix(_:Any.Type?,_:Any.Type?)
public func == (t0: Any.Type?, t1: Any.Type?) -> Bool {
  switch (t0, t1) {
  case (.none, .none): return true
  case let (.some(ty0), .some(ty1)):
    return Bool(Builtin.is_same_metatype(ty0, ty1))
  default: return false
  }
}

----Swift.(file).!=infix(_:Any.Type?,_:Any.Type?)
public func != (t0: Any.Type?, t1: Any.Type?) -> Bool {
  return !(t0 == t1)
}

----Swift.(file).unsafeDowncast(_:AnyObject,to:T.Type)
public func unsafeDowncast<T : AnyObject>(_ x: AnyObject, to type: T.Type) -> T {
  _debugPrecondition(x is T, "invalid unsafeDowncast")
  return Builtin.castReference(x)
}

----Swift.(file).getSwiftClassInstanceExtents(_:AnyClass)
internal func getSwiftClassInstanceExtents(_ theClass: AnyClass)
  -> (negative: UInt, positive: UInt)

----Swift.(file).getObjCClassInstanceExtents(_:AnyClass)
internal func getObjCClassInstanceExtents(_ theClass: AnyClass)
  -> (negative: UInt, positive: UInt)

----Swift.(file).ManagedBufferPointer.init(_nativeObject:<<error type>>)
extension ManagedBufferPointer  {
  public init(_nativeObject buffer: Builtin.NativeObject) {
    self._nativeBuffer = buffer
  }
}

----Swift.(file).type(of:T)
public func type<T, Metatype>(of value: T) -> Metatype {
  // This implementation is never used, since calls to `Swift.type(of:)` are
  // resolved as a special case by the type checker.
  Builtin.staticReport(_trueAfterDiagnostics(), true._value,
    ("internal consistency error: 'type(of:)' operation failed to resolve"
     as StaticString).utf8Start._rawValue)
  Builtin.unreachable()
}

----Swift.(file).withoutActuallyEscaping(_:ClosureType,do:(ClosureType) throws -> ResultType)
public func withoutActuallyEscaping<ClosureType, ResultType>(
  _ closure: ClosureType,
  do body: (_ escapingClosure: ClosureType) throws -> ResultType
) rethrows -> ResultType {
  // This implementation is never used, since calls to
  // `Swift.withoutActuallyEscaping(_:do:)` are resolved as a special case by
  // the type checker.
  Builtin.staticReport(_trueAfterDiagnostics(), true._value,
    ("internal consistency error: 'withoutActuallyEscaping(_:do:)' operation failed to resolve"
     as StaticString).utf8Start._rawValue)
  Builtin.unreachable()
}

----Swift.(file).String.init(cString:UnsafePointer<CChar>)
extension String  {
  public init(cString: UnsafePointer<CChar>) {
    let len = UTF8._nullCodeUnitOffset(in: cString)
    self = String._fromUTF8Repairing(
      UnsafeBufferPointer(start: cString._asUInt8, count: len)).0
  }
}

----Swift.(file).String.init(cString:UnsafePointer<UInt8>)
extension String  {
  public init(cString: UnsafePointer<UInt8>) {
    let len = UTF8._nullCodeUnitOffset(in: cString)
    self = String._fromUTF8Repairing(
      UnsafeBufferPointer(start: cString, count: len)).0
  }
}

----Swift.(file).String.init(validatingUTF8:UnsafePointer<CChar>)
extension String  {
  public init?(validatingUTF8 cString: UnsafePointer<CChar>) {
    let len = UTF8._nullCodeUnitOffset(in: cString)
    guard let str = String._tryFromUTF8(
      UnsafeBufferPointer(start: cString._asUInt8, count: len))
    else { return nil }

    self = str
  }
}

----Swift.(file).String.decodeCString(_:UnsafePointer<Encoding.CodeUnit>?,as:Encoding.Type,repairingInvalidCodeUnits:Bool)
extension String  {
  public static func decodeCString<Encoding : _UnicodeEncoding>(
    _ cString: UnsafePointer<Encoding.CodeUnit>?,
    as encoding: Encoding.Type,
    repairingInvalidCodeUnits isRepairing: Bool = true
  ) -> (result: String, repairsMade: Bool)? {
    guard let cPtr = cString else { return nil }

    if _fastPath(encoding == Unicode.UTF8.self) {
      let ptr = UnsafeRawPointer(cPtr).assumingMemoryBound(to: UInt8.self)
      let len = UTF8._nullCodeUnitOffset(in: ptr)
      let codeUnits = UnsafeBufferPointer(start: ptr, count: len)
      if isRepairing {
        return String._fromUTF8Repairing(codeUnits)
      } else {
        guard let str = String._tryFromUTF8(codeUnits) else { return nil }
        return (str, false)
      }
    }

    var end = cPtr
    while end.pointee != 0 { end += 1 }
    let len = end - cPtr
    let codeUnits = UnsafeBufferPointer(start: cPtr, count: len)
    return String._fromCodeUnits(
      codeUnits, encoding: encoding, repair: isRepairing)
  }
}

----Swift.(file).String.init(decodingCString:UnsafePointer<Encoding.CodeUnit>,as:Encoding.Type)
extension String  {
  public init<Encoding: Unicode.Encoding>(
    decodingCString ptr: UnsafePointer<Encoding.CodeUnit>,
    as sourceEncoding: Encoding.Type
  ) {
    self = String.decodeCString(ptr, as: sourceEncoding)!.0
  }
}

----Swift.(file).CChar
public typealias CChar = I

----Swift.(file).CUnsignedChar
public typealias CUnsignedChar = U

----Swift.(file).CUnsignedShort
public typealias CUnsignedShort = U

----Swift.(file).CUnsignedInt
public typealias CUnsignedInt = U

----Swift.(file).CUnsignedLong
public typealias CUnsignedLong = U

----Swift.(file).CUnsignedLongLong
public typealias CUnsignedLongLong = U

----Swift.(file).CSignedChar
public typealias CSignedChar = I

----Swift.(file).CShort
public typealias CShort = I

----Swift.(file).CInt
public typealias CInt = I

----Swift.(file).CLong
public typealias CLong = I

----Swift.(file).CLongLong
public typealias CLongLong = I

----Swift.(file).CFloat
public typealias CFloat = F

----Swift.(file).CDouble
public typealias CDouble = D

----Swift.(file).CLongDouble
public typealias CLongDouble = F

----Swift.(file).CWideChar
public typealias CWideChar = Unicode.S

----Swift.(file).CChar16
public typealias CChar16 = U

----Swift.(file).CChar32
public typealias CChar32 = Unicode.S

----Swift.(file).CBool
public typealias CBool = B

----Swift.(file).OpaquePointer.init(_:<<error type>>)
extension OpaquePointer {
  internal init(_ v: Builtin.RawPointer) {
    self._rawValue = v
  }
}

----Swift.(file).OpaquePointer.init(bitPattern:Int)
extension OpaquePointer {
  public init?(bitPattern: Int) {
    if bitPattern == 0 { return nil }
    self._rawValue = Builtin.inttoptr_Word(bitPattern._builtinWordValue)
  }
}

----Swift.(file).OpaquePointer.init(bitPattern:UInt)
extension OpaquePointer {
  public init?(bitPattern: UInt) {
    if bitPattern == 0 { return nil }
    self._rawValue = Builtin.inttoptr_Word(bitPattern._builtinWordValue)
  }
}

----Swift.(file).OpaquePointer.init(_:UnsafePointer<T>)
extension OpaquePointer {
  public init<T>(_ from: UnsafePointer<T>) {
    self._rawValue = from._rawValue
  }
}

----Swift.(file).OpaquePointer.init(_:UnsafePointer<T>?)
extension OpaquePointer {
  public init?<T>(_ from: UnsafePointer<T>?) {
    guard let unwrapped = from else { return nil }
    self.init(unwrapped)
  }
}

----Swift.(file).OpaquePointer.init(_:UnsafeMutablePointer<T>)
extension OpaquePointer {
  public init<T>(_ from: UnsafeMutablePointer<T>) {
    self._rawValue = from._rawValue
  }
}

----Swift.(file).OpaquePointer.init(_:UnsafeMutablePointer<T>?)
extension OpaquePointer {
  public init?<T>(_ from: UnsafeMutablePointer<T>?) {
    guard let unwrapped = from else { return nil }
    self.init(unwrapped)
  }
}

----Swift.(file).OpaquePointer.==infix(_:OpaquePointer,_:OpaquePointer)
extension OpaquePointer: Equatable  {
  public static func == (lhs: OpaquePointer, rhs: OpaquePointer) -> Bool {
    return Bool(Builtin.cmp_eq_RawPointer(lhs._rawValue, rhs._rawValue))
  }
}

----Swift.(file).OpaquePointer.hash(into:Hasher)
extension OpaquePointer: Hashable  {
  public func hash(into hasher: inout Hasher) {
    hasher.combine(Int(Builtin.ptrtoint_Word(_rawValue)))
  }
}

----Swift.(file).OpaquePointer.debugDescription
extension OpaquePointer : CustomDebugStringConvertible  {
  public var debugDescription: String {
    return _rawPointerToString(_rawValue)
  }
}

----Swift.(file).Int.init(bitPattern:OpaquePointer?)
extension Int  {
  public init(bitPattern pointer: OpaquePointer?) {
    self.init(bitPattern: UnsafeRawPointer(pointer))
  }
}

----Swift.(file).UInt.init(bitPattern:OpaquePointer?)
extension UInt  {
  public init(bitPattern pointer: OpaquePointer?) {
    self.init(bitPattern: UnsafeRawPointer(pointer))
  }
}

----Swift.(file).CVaListPointer.init(_fromUnsafeMutablePointer:UnsafeMutableRawPointer)
extension CVaListPointer {
  init(_fromUnsafeMutablePointer from: UnsafeMutableRawPointer) {
    _value = from
  }
}

----Swift.(file).CVaListPointer.debugDescription
extension CVaListPointer : CustomDebugStringConvertible  {
  public var debugDescription: String {
    return _value.debugDescription
  }
}

----Swift.(file).Character.init(unchecked:String)
extension Character {
  internal init(unchecked str: String) {
    self._str = str
    _invariantCheck()
  }
}

----Swift.(file).Character.UTF8View
extension Character  {
  typealias UTF8View = String.U
}

----Swift.(file).Character.utf8
extension Character  {
  internal var utf8: UTF8View {
    return _str.utf8
  }
}

----Swift.(file).Character.UTF16View
extension Character  {
  typealias UTF16View = String.U
}

----Swift.(file).Character.utf16
extension Character  {
  internal var utf16: UTF16View {
    return _str.utf16
  }
}

----Swift.(file).Character.UnicodeScalarView
extension Character  {
  public typealias UnicodeScalarView = String.U
}

----Swift.(file).Character.unicodeScalars
extension Character  {
  public var unicodeScalars: UnicodeScalarView {
    return _str.unicodeScalars
  }
}

----Swift.(file).Character.init(_:Unicode.Scalar)
extension Character :
  _ExpressibleByBuiltinExtendedGraphemeClusterLiteral,
  ExpressibleByExtendedGraphemeClusterLiteral
 {
  public init(_ content: Unicode.Scalar) {
    self.init(unchecked: String(content))
  }
}

----Swift.(file).Character.init(_builtinUnicodeScalarLiteral:<<error type>>)
extension Character :
  _ExpressibleByBuiltinExtendedGraphemeClusterLiteral,
  ExpressibleByExtendedGraphemeClusterLiteral
 {
  public init(_builtinUnicodeScalarLiteral value: Builtin.Int32) {
    self.init(Unicode.Scalar(_builtinUnicodeScalarLiteral: value))
  }
}

----Swift.(file).Character.init(_builtinExtendedGraphemeClusterLiteral:<<error type>>,utf8CodeUnitCount:<<error type>>,isASCII:<<error type>>)
extension Character :
  _ExpressibleByBuiltinExtendedGraphemeClusterLiteral,
  ExpressibleByExtendedGraphemeClusterLiteral
 {
  public init(
    _builtinExtendedGraphemeClusterLiteral start: Builtin.RawPointer,
    utf8CodeUnitCount: Builtin.Word,
    isASCII: Builtin.Int1
  ) {
    self.init(unchecked: String(
      _builtinExtendedGraphemeClusterLiteral: start,
      utf8CodeUnitCount: utf8CodeUnitCount,
      isASCII: isASCII))
  }
}

----Swift.(file).Character.init(extendedGraphemeClusterLiteral:Character)
extension Character :
  _ExpressibleByBuiltinExtendedGraphemeClusterLiteral,
  ExpressibleByExtendedGraphemeClusterLiteral
 {
  public init(extendedGraphemeClusterLiteral value: Character) {
    self.init(unchecked: value._str)
  }
}

----Swift.(file).Character.init(_:String)
extension Character :
  _ExpressibleByBuiltinExtendedGraphemeClusterLiteral,
  ExpressibleByExtendedGraphemeClusterLiteral
 {
  public init(_ s: String) {
    _precondition(!s.isEmpty,
      "Can't form a Character from an empty String")
    _debugPrecondition(s.index(after: s.startIndex) == s.endIndex,
      "Can't form a Character from a String containing more than one extended grapheme cluster")
    self.init(unchecked: s)
  }
}

----Swift.(file).Character.description
extension Character : CustomStringConvertible  {
 public var description: String {
   return _str
 }
}

----Swift.(file).Character.debugDescription
extension Character : CustomDebugStringConvertible  {
 public var debugDescription: String {
   return _str.debugDescription
 }
}

----Swift.(file).String.init(_:Character)
extension String  {
  public init(_ c: Character) {
    self.init(c._str._guts)
  }
}

----Swift.(file).Character.==infix(_:Character,_:Character)
extension Character : Equatable  {
  public static func == (lhs: Character, rhs: Character) -> Bool {
    return lhs._str == rhs._str
  }
}

----Swift.(file).Character.<infix(_:Character,_:Character)
extension Character : Comparable  {
  public static func < (lhs: Character, rhs: Character) -> Bool {
    return lhs._str < rhs._str
  }
}

----Swift.(file).Character.hash(into:Hasher)
extension Character: Hashable  {
  public func hash(into hasher: inout Hasher) {
    _str.hash(into: &hasher)
  }
}

----Swift.(file).Character.isASCII
extension Character  {
  public var isASCII: Bool {
    return asciiValue != nil
  }
}

----Swift.(file).Character.asciiValue
extension Character  {
  public var asciiValue: UInt8? {
    if _slowPath(self == "\r\n") { return 0x000A /* LINE FEED (LF) */ }
    if _slowPath(!_isSingleScalar || _firstScalar.value >= 0x80) { return nil }
    return UInt8(_firstScalar.value)
  }
}

----Swift.(file).Character.isWhitespace
extension Character  {
  public var isWhitespace: Bool {
    return _firstScalar.properties.isWhitespace
  }
}

----Swift.(file).Character.isNewline
extension Character  {
  public var isNewline: Bool {
    switch _firstScalar.value {
      case 0x000A...0x000D /* LF ... CR */: return true
      case 0x0085 /* NEXT LINE (NEL) */: return true
      case 0x2028 /* LINE SEPARATOR */: return true
      case 0x2029 /* PARAGRAPH SEPARATOR */: return true
      default: return false
    }
  }
}

----Swift.(file).Character.isNumber
extension Character  {
  public var isNumber: Bool {
    return _firstScalar.properties.numericType != nil
  }
}

----Swift.(file).Character.isWholeNumber
extension Character  {
  public var isWholeNumber: Bool {
    return wholeNumberValue != nil
  }
}

----Swift.(file).Character.wholeNumberValue
extension Character  {
  public var wholeNumberValue: Int? {
    guard _isSingleScalar else { return nil }
    guard let value = _firstScalar.properties.numericValue else { return nil }
    return Int(exactly: value)
  }
}

----Swift.(file).Character.isHexDigit
extension Character  {
  public var isHexDigit: Bool {
    return hexDigitValue != nil
  }
}

----Swift.(file).Character.hexDigitValue
extension Character  {
  public var hexDigitValue: Int? {
    guard _isSingleScalar else { return nil }
    let value = _firstScalar.value
    switch value {
      // DIGIT ZERO..DIGIT NINE
      case 0x0030...0x0039: return Int(value &- 0x0030)
      // LATIN CAPITAL LETTER A..LATIN CAPITAL LETTER F
      case 0x0041...0x0046: return Int((value &+ 10) &- 0x0041)
      // LATIN SMALL LETTER A..LATIN SMALL LETTER F
      case 0x0061...0x0066: return Int((value &+ 10) &- 0x0061)
      // FULLWIDTH DIGIT ZERO..FULLWIDTH DIGIT NINE
      case 0xFF10...0xFF19: return Int(value &- 0xFF10)
      // FULLWIDTH LATIN CAPITAL LETTER A..FULLWIDTH LATIN CAPITAL LETTER F
      case 0xFF21...0xFF26: return Int((value &+ 10) &- 0xFF21)
      // FULLWIDTH LATIN SMALL LETTER A..FULLWIDTH LATIN SMALL LETTER F
      case 0xFF41...0xFF46: return Int((value &+ 10) &- 0xFF41)

      default: return nil
    }
  }
}

----Swift.(file).Character.isLetter
extension Character  {
  public var isLetter: Bool {
    return _firstScalar.properties.isAlphabetic
  }
}

----Swift.(file).Character.uppercased()
extension Character  {
  public func uppercased() -> String { return String(self).uppercased() }
}

----Swift.(file).Character.lowercased()
extension Character  {
  public func lowercased() -> String { return String(self).lowercased() }
}

----Swift.(file).Character.isUppercase
extension Character  {
  public var isUppercase: Bool {
    if _fastPath(_isSingleScalar && _firstScalar.properties.isUppercase) {
      return true
    }
    return _isUppercased && isCased
  }
}

----Swift.(file).Character.isLowercase
extension Character  {
  public var isLowercase: Bool {
    if _fastPath(_isSingleScalar && _firstScalar.properties.isLowercase) {
      return true
    }
    return _isLowercased && isCased
  }
}

----Swift.(file).Character.isCased
extension Character  {
  public var isCased: Bool {
    if _fastPath(_isSingleScalar && _firstScalar.properties.isCased) {
      return true
    }
    return !_isUppercased || !_isLowercased
  }
}

----Swift.(file).Character.isSymbol
extension Character  {
  public var isSymbol: Bool {
    return _firstScalar.properties.generalCategory._isSymbol
  }
}

----Swift.(file).Character.isMathSymbol
extension Character  {
  public var isMathSymbol: Bool {
    return _firstScalar.properties.isMath
  }
}

----Swift.(file).Character.isCurrencySymbol
extension Character  {
  public var isCurrencySymbol: Bool {
    return _firstScalar.properties.generalCategory == .currencySymbol
  }
}

----Swift.(file).Character.isPunctuation
extension Character  {
  public var isPunctuation: Bool {
    return _firstScalar.properties.generalCategory._isPunctuation
  }
}

----Swift.(file).ClosedRange.lowerBound
extension ClosedRange {
  public let l
}

----Swift.(file).ClosedRange.upperBound
extension ClosedRange {
  public let u
}

----Swift.(file).ClosedRange.init(uncheckedBounds:(lower: Bound, upper: Bound))
extension ClosedRange {
  public init(uncheckedBounds bounds: (lower: Bound, upper: Bound)) {
    self.lowerBound = bounds.lower
    self.upperBound = bounds.upper
  }
}

----Swift.(file).ClosedRange.isEmpty
extension ClosedRange  {
  public var isEmpty: Bool {
    return false
  }
}

----Swift.(file).ClosedRange.relative(to:C)
extension ClosedRange: RangeExpression  {
  public func relative<C: Collection>(to collection: C) -> Range<Bound>
  where C.Index == Bound {
    return Range(
      uncheckedBounds: (
        lower: lowerBound, upper: collection.index(after: self.upperBound)))
  }
}

----Swift.(file).ClosedRange.contains(_:Bound)
extension ClosedRange: RangeExpression  {
  public func contains(_ element: Bound) -> Bool {
    return element >= self.lowerBound && element <= self.upperBound
  }
}

----Swift.(file).ClosedRange.Element
extension ClosedRange: Sequence
where Bound: Strideable, Bound.Stride: SignedInteger  {
  public typealias Element = B
}

----Swift.(file).ClosedRange.Iterator
extension ClosedRange: Sequence
where Bound: Strideable, Bound.Stride: SignedInteger  {
  public typealias Iterator = IndexingIterator<ClosedRange<Bound>>
}

----Swift.(file).ClosedRange.Index.pastEnd
extension ClosedRange.Index {
    case p
}

----Swift.(file).ClosedRange.Index.inRange
extension ClosedRange.Index {
    case inRange(Bound)
}

----Swift.(file).ClosedRange.Index.==infix(_:ClosedRange<Bound>.Index,_:ClosedRange<Bound>.Index)
extension ClosedRange.Index : Comparable  {
  public static func == (
    lhs: ClosedRange<Bound>.Index,
    rhs: ClosedRange<Bound>.Index
  ) -> Bool {
    switch (lhs, rhs) {
    case (.inRange(let l), .inRange(let r)):
      return l == r
    case (.pastEnd, .pastEnd):
      return true
    default:
      return false
    }
  }
}

----Swift.(file).ClosedRange.Index.<infix(_:ClosedRange<Bound>.Index,_:ClosedRange<Bound>.Index)
extension ClosedRange.Index : Comparable  {
  public static func < (
    lhs: ClosedRange<Bound>.Index,
    rhs: ClosedRange<Bound>.Index
  ) -> Bool {
    switch (lhs, rhs) {
    case (.inRange(let l), .inRange(let r)):
      return l < r
    case (.inRange, .pastEnd):
      return true
    default:
      return false
    }
  }
}

----Swift.(file).ClosedRange.Index.hash(into:Hasher)
extension ClosedRange.Index: Hashable
where Bound: Strideable, Bound.Stride: SignedInteger, Bound: Hashable  {
  public func hash(into hasher: inout Hasher) {
    switch self {
    case .inRange(let value):
      hasher.combine(0 as Int8)
      hasher.combine(value)
    case .pastEnd:
      hasher.combine(1 as Int8)
    }
  }
}

----Swift.(file).ClosedRange.SubSequence
extension ClosedRange: Collection, BidirectionalCollection, RandomAccessCollection
where Bound : Strideable, Bound.Stride : SignedInteger
 {
  public typealias SubSequence = Slice<ClosedRange<Bound>>
}

----Swift.(file).ClosedRange.startIndex
extension ClosedRange: Collection, BidirectionalCollection, RandomAccessCollection
where Bound : Strideable, Bound.Stride : SignedInteger
 {
  public var startIndex: Index {
    return .inRange(lowerBound)
  }
}

----Swift.(file).ClosedRange.endIndex
extension ClosedRange: Collection, BidirectionalCollection, RandomAccessCollection
where Bound : Strideable, Bound.Stride : SignedInteger
 {
  public var endIndex: Index {
    return .pastEnd
  }
}

----Swift.(file).ClosedRange.index(after:ClosedRange<Bound>.Index)
extension ClosedRange: Collection, BidirectionalCollection, RandomAccessCollection
where Bound : Strideable, Bound.Stride : SignedInteger
 {
  public func index(after i: Index) -> Index {
    switch i {
    case .inRange(let x):
      return x == upperBound
        ? .pastEnd
        : .inRange(x.advanced(by: 1))
    case .pastEnd: 
      _preconditionFailure("Incrementing past end index")
    }
  }
}

----Swift.(file).ClosedRange.index(before:ClosedRange<Bound>.Index)
extension ClosedRange: Collection, BidirectionalCollection, RandomAccessCollection
where Bound : Strideable, Bound.Stride : SignedInteger
 {
  public func index(before i: Index) -> Index {
    switch i {
    case .inRange(let x):
      _precondition(x > lowerBound, "Incrementing past start index")
      return .inRange(x.advanced(by: -1))
    case .pastEnd: 
      _precondition(upperBound >= lowerBound, "Incrementing past start index")
      return .inRange(upperBound)
    }
  }
}

----Swift.(file).ClosedRange.index(_:ClosedRange<Bound>.Index,offsetBy:Int)
extension ClosedRange: Collection, BidirectionalCollection, RandomAccessCollection
where Bound : Strideable, Bound.Stride : SignedInteger
 {
  public func index(_ i: Index, offsetBy distance: Int) -> Index {
    switch i {
    case .inRange(let x):
      let d = x.distance(to: upperBound)
      if distance <= d {
        let newPosition = x.advanced(by: numericCast(distance))
        _precondition(newPosition >= lowerBound,
          "Advancing past start index")
        return .inRange(newPosition)
      }
      if d - -1 == distance { return .pastEnd }
      _preconditionFailure("Advancing past end index")
    case .pastEnd:
      if distance == 0 {
        return i
      } 
      if distance < 0 {
        return index(.inRange(upperBound), offsetBy: numericCast(distance + 1))
      }
      _preconditionFailure("Advancing past end index")
    }
  }
}

----Swift.(file).ClosedRange.distance(from:ClosedRange<Bound>.Index,to:ClosedRange<Bound>.Index)
extension ClosedRange: Collection, BidirectionalCollection, RandomAccessCollection
where Bound : Strideable, Bound.Stride : SignedInteger
 {
  public func distance(from start: Index, to end: Index) -> Int {
    switch (start, end) {
    case let (.inRange(left), .inRange(right)):
      // in range <--> in range
      return numericCast(left.distance(to: right))
    case let (.inRange(left), .pastEnd):
      // in range --> end
      return numericCast(1 + left.distance(to: upperBound))
    case let (.pastEnd, .inRange(right)):
      // in range <-- end
      return numericCast(upperBound.distance(to: right) - 1)
    case (.pastEnd, .pastEnd):
      // end <--> end
      return 0
    }
  }
}

----Swift.(file).ClosedRange.subscript(_:ClosedRange<Bound>.Index)
extension ClosedRange: Collection, BidirectionalCollection, RandomAccessCollection
where Bound : Strideable, Bound.Stride : SignedInteger
 {
  public subscript(position: Index) -> Bound {
    // FIXME: swift-3-indexing-model: range checks and tests.
    switch position {
    case .inRange(let x): return x
    case .pastEnd: _preconditionFailure("Index out of range")
    }
  }
}

----Swift.(file).ClosedRange.subscript(_:Range<ClosedRange<Bound>.Index>)
extension ClosedRange: Collection, BidirectionalCollection, RandomAccessCollection
where Bound : Strideable, Bound.Stride : SignedInteger
 {
  public subscript(bounds: Range<Index>)
    -> Slice<ClosedRange<Bound>> {
    return Slice(base: self, bounds: bounds)
  }
}

----Swift.(file).Comparable....infix(_:Self,_:Self)
extension Comparable  {
  public static func ... (minimum: Self, maximum: Self) -> ClosedRange<Self> {
    _precondition(
      minimum <= maximum, "Can't form Range with upperBound < lowerBound")
    return ClosedRange(uncheckedBounds: (lower: minimum, upper: maximum))
  }
}

----Swift.(file).ClosedRange.==infix(_:ClosedRange<Bound>,_:ClosedRange<Bound>)
extension ClosedRange: Equatable  {
  public static func == (
    lhs: ClosedRange<Bound>, rhs: ClosedRange<Bound>
  ) -> Bool {
    return lhs.lowerBound == rhs.lowerBound && lhs.upperBound == rhs.upperBound
  }
}

----Swift.(file).ClosedRange.hash(into:Hasher)
extension ClosedRange: Hashable where Bound: Hashable  {
  public func hash(into hasher: inout Hasher) {
    hasher.combine(lowerBound)
    hasher.combine(upperBound)
  }
}

----Swift.(file).ClosedRange.description
extension ClosedRange : CustomStringConvertible  {
  public var description: String {
    return "\(lowerBound)...\(upperBound)"
  }
}

----Swift.(file).ClosedRange.debugDescription
extension ClosedRange : CustomDebugStringConvertible  {
  public var debugDescription: String {
    return "ClosedRange(\(String(reflecting: lowerBound))"
    + "...\(String(reflecting: upperBound)))"
  }
}

----Swift.(file).ClosedRange.customMirror
extension ClosedRange : CustomReflectable  {
  public var customMirror: Mirror {
    return Mirror(
      self, children: ["lowerBound": lowerBound, "upperBound": upperBound])
  }
}

----Swift.(file).ClosedRange.clamped(to:ClosedRange<Bound>)
extension ClosedRange  {
  public func clamped(to limits: ClosedRange) -> ClosedRange {
    let lower =         
      limits.lowerBound > self.lowerBound ? limits.lowerBound
          : limits.upperBound < self.lowerBound ? limits.upperBound
          : self.lowerBound
    let upper =
      limits.upperBound < self.upperBound ? limits.upperBound
          : limits.lowerBound > self.upperBound ? limits.lowerBound
          : self.upperBound
    return ClosedRange(uncheckedBounds: (lower: lower, upper: upper))
  }
}

----Swift.(file).ClosedRange.init(_:Range<Bound>)
extension ClosedRange where Bound: Strideable, Bound.Stride : SignedInteger  {
  public init(_ other: Range<Bound>) {
    _precondition(!other.isEmpty, "Can't form an empty closed range")
    let upperBound = other.upperBound.advanced(by: -1)
    self.init(uncheckedBounds: (lower: other.lowerBound, upper: upperBound))
  }
}

----Swift.(file).ClosedRange.overlaps(_:ClosedRange<Bound>)
extension ClosedRange  {
  public func overlaps(_ other: ClosedRange<Bound>) -> Bool {
    return self.contains(other.lowerBound) || other.contains(lowerBound)
  }
}

----Swift.(file).ClosedRange.overlaps(_:Range<Bound>)
extension ClosedRange  {
  public func overlaps(_ other: Range<Bound>) -> Bool {
    return other.overlaps(self)
  }
}

----Swift.(file).CountableClosedRange
public typealias CountableClosedRange<Bound: Strideable> = ClosedRange<Bound>
  where Bound.Stride : S

----Swift.(file).IndexingIterator.init(_elements:Elements)
extension IndexingIterator {
  init(_elements: Elements) {
    self._elements = _elements
    self._position = _elements.startIndex
  }
}

----Swift.(file).IndexingIterator.init(_elements:Elements,_position:Elements.Index)
extension IndexingIterator {
  init(_elements: Elements, _position: Elements.Index) {
    self._elements = _elements
    self._position = _position
  }
}

----Swift.(file).IndexingIterator.Element
extension IndexingIterator: IteratorProtocol, Sequence  {
  public typealias Element = Elements.E
}

----Swift.(file).IndexingIterator.Iterator
extension IndexingIterator: IteratorProtocol, Sequence  {
  public typealias Iterator = IndexingIterator<Elements>
}

----Swift.(file).IndexingIterator.SubSequence
extension IndexingIterator: IteratorProtocol, Sequence  {
  public typealias SubSequence = AnySequence<Element>
}

----Swift.(file).IndexingIterator.next()
extension IndexingIterator: IteratorProtocol, Sequence  {
  public mutating func next() -> Elements.Element? {
    if _position == _elements.endIndex { return nil }
    let element = _elements[_position]
    _elements.formIndex(after: &_position)
    return element
  }
}

----Swift.(file).Collection.IndexDistance
extension Collection {
  typealias IndexDistance = I
}

----Swift.(file).Collection.Element
extension Collection {
  override associatedtype E
}

----Swift.(file).Collection.Index
extension Collection {
  associatedtype Index : C
}

----Swift.(file).Collection.startIndex
extension Collection {
  var startIndex: Index { get }
}

----Swift.(file).Collection.endIndex
extension Collection {
  var endIndex: Index { get }
}

----Swift.(file).Collection.Iterator
extension Collection {
  associatedtype I
}

----Swift.(file).Collection.makeIterator()
extension Collection {
  override func makeIterator() -> I
}

----Swift.(file).Collection.SubSequence
extension Collection {
  associatedtype SubSequence: Collection = Slice<Self>
  where SubSequence.Index == Index,
        Element == SubSequence.Element,
        SubSequence.SubSequence == S
}

----Swift.(file).Collection.subscript(_:Self.Index)
extension Collection {
  subscript(position: Index) -> Element { get }
}

----Swift.(file).Collection.subscript(_:Range<Self.Index>)
extension Collection {
  subscript(bounds: Range<Index>) -> SubSequence { get }
}

----Swift.(file).Collection.Indices
extension Collection {
  associatedtype Indices : Collection = DefaultIndices<Self>
    where Indices.Element == Index, 
          Indices.Index == Index,
          Indices.SubSequence == I
}

----Swift.(file).Collection.indices
extension Collection {
  var indices: Indices { get }
}

----Swift.(file).Collection.isEmpty
extension Collection {
  var isEmpty: Bool { get }
}

----Swift.(file).Collection.count
extension Collection {
  var count: Int { get }
}

----Swift.(file).Collection.index(_:Self.Index,offsetBy:Int)
extension Collection {
  func index(_ i: Index, offsetBy distance: Int) -> I
}

----Swift.(file).Collection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)
extension Collection {
  func index(
    _ i: Index, offsetBy distance: Int, limitedBy limit: Index
  ) -> Index?
}

----Swift.(file).Collection.distance(from:Self.Index,to:Self.Index)
extension Collection {
  func distance(from start: Index, to end: Index) -> I
}

----Swift.(file).Collection.index(after:Self.Index)
extension Collection {
  func index(after i: Index) -> I
}

----Swift.(file).Collection.formIndex(after:Self.Index)
extension Collection {
  func formIndex(after i: inout Index)
}

----Swift.(file).Collection.formIndex(after:Self.Index)
extension Collection  {
  public func formIndex(after i: inout Index) {
    i = index(after: i)
  }
}

----Swift.(file).Collection.index(_:Self.Index,offsetBy:Int)
extension Collection  {
  public func index(_ i: Index, offsetBy distance: Int) -> Index {
    return self._advanceForward(i, by: distance)
  }
}

----Swift.(file).Collection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)
extension Collection  {
  public func index(
    _ i: Index, offsetBy distance: Int, limitedBy limit: Index
  ) -> Index? {
    return self._advanceForward(i, by: distance, limitedBy: limit)
  }
}

----Swift.(file).Collection.formIndex(_:Self.Index,offsetBy:Int)
extension Collection  {
  public func formIndex(_ i: inout Index, offsetBy distance: Int) {
    i = index(i, offsetBy: distance)
  }
}

----Swift.(file).Collection.formIndex(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)
extension Collection  {
  public func formIndex(
    _ i: inout Index, offsetBy distance: Int, limitedBy limit: Index
  ) -> Bool {
    if let advancedIndex = index(i, offsetBy: distance, limitedBy: limit) {
      i = advancedIndex
      return true
    }
    i = limit
    return false
  }
}

----Swift.(file).Collection.distance(from:Self.Index,to:Self.Index)
extension Collection  {
  public func distance(from start: Index, to end: Index) -> Int {
    _precondition(start <= end,
      "Only BidirectionalCollections can have end come before start")

    var start = start
    var count = 0
    while start != end {
      count = count + 1
      formIndex(after: &start)
    }
    return count
  }
}

----Swift.(file).Collection.randomElement(using:T)
extension Collection  {
  public func randomElement<T: RandomNumberGenerator>(
    using generator: inout T
  ) -> Element? {
    guard !isEmpty else { return nil }
    let random = Int.random(in: 0 ..< count, using: &generator)
    let idx = index(startIndex, offsetBy: random)
    return self[idx]
  }
}

----Swift.(file).Collection.randomElement()
extension Collection  {
  public func randomElement() -> Element? {
    var g = SystemRandomNumberGenerator()
    return randomElement(using: &g)
  }
}

----Swift.(file).Collection.makeIterator()
extension Collection where Iterator == IndexingIterator<Self>  {
  public __consuming func makeIterator() -> IndexingIterator<Self> {
    return IndexingIterator(_elements: self)
  }
}

----Swift.(file).Collection.subscript(_:Range<Self.Index>)
extension Collection where SubSequence == Slice<Self>  {
  public subscript(bounds: Range<Index>) -> Slice<Self> {
    _failEarlyRangeCheck(bounds, bounds: startIndex..<endIndex)
    return Slice(base: self, bounds: bounds)
  }
}

----Swift.(file).Collection.popFirst()
extension Collection where SubSequence == Self  {
  public mutating func popFirst() -> Element? {
    // TODO: swift-3-indexing-model - review the following
    guard !isEmpty else { return nil }
    let element = first!
    self = self[index(after: startIndex)..<endIndex]
    return element
  }
}

----Swift.(file).Collection.isEmpty
extension Collection  {
  public var isEmpty: Bool {
    return startIndex == endIndex
  }
}

----Swift.(file).Collection.first
extension Collection  {
  public var first: Element? {
    let start = startIndex
    if start != endIndex { return self[start] }
    else { return nil }
  }
}

----Swift.(file).Collection.underestimatedCount
extension Collection  {
  public var underestimatedCount: Int {
    // TODO: swift-3-indexing-model - review the following
    return count
  }
}

----Swift.(file).Collection.count
extension Collection  {
  public var count: Int {
    return distance(from: startIndex, to: endIndex)
  }
}

----Swift.(file).Collection.map(_:(Self.Element) throws -> T)
extension Collection  {
  public func map<T>(
    _ transform: (Element) throws -> T
  ) rethrows -> [T] {
    // TODO: swift-3-indexing-model - review the following
    let n = self.count
    if n == 0 {
      return []
    }

    var result = ContiguousArray<T>()
    result.reserveCapacity(n)

    var i = self.startIndex

    for _ in 0..<n {
      result.append(try transform(self[i]))
      formIndex(after: &i)
    }

    _expectEnd(of: self, is: i)
    return Array(result)
  }
}

----Swift.(file).Collection.dropFirst(_:Int)
extension Collection  {
  public __consuming func dropFirst(_ k: Int = 1) -> SubSequence {
    _precondition(k >= 0, "Can't drop a negative number of elements from a collection")
    let start = index(startIndex, offsetBy: k, limitedBy: endIndex) ?? endIndex
    return self[start..<endIndex]
  }
}

----Swift.(file).Collection.dropLast(_:Int)
extension Collection  {
  public __consuming func dropLast(_ k: Int = 1) -> SubSequence {
    _precondition(
      k >= 0, "Can't drop a negative number of elements from a collection")
    let amount = Swift.max(0, count - k)
    let end = index(startIndex,
      offsetBy: amount, limitedBy: endIndex) ?? endIndex
    return self[startIndex..<end]
  }
}

----Swift.(file).Collection.drop(while:(Self.Element) throws -> Bool)
extension Collection  {
  public __consuming func drop(
    while predicate: (Element) throws -> Bool
  ) rethrows -> SubSequence {
    var start = startIndex
    while try start != endIndex && predicate(self[start]) {
      formIndex(after: &start)
    } 
    return self[start..<endIndex]
  }
}

----Swift.(file).Collection.prefix(_:Int)
extension Collection  {
  public __consuming func prefix(_ maxLength: Int) -> SubSequence {
    _precondition(
      maxLength >= 0,
      "Can't take a prefix of negative length from a collection")
    let end = index(startIndex,
      offsetBy: maxLength, limitedBy: endIndex) ?? endIndex
    return self[startIndex..<end]
  }
}

----Swift.(file).Collection.prefix(while:(Self.Element) throws -> Bool)
extension Collection  {
  public __consuming func prefix(
    while predicate: (Element) throws -> Bool
  ) rethrows -> SubSequence {
    var end = startIndex
    while try end != endIndex && predicate(self[end]) {
      formIndex(after: &end)
    }
    return self[startIndex..<end]
  }
}

----Swift.(file).Collection.suffix(_:Int)
extension Collection  {
  public __consuming func suffix(_ maxLength: Int) -> SubSequence {
    _precondition(
      maxLength >= 0,
      "Can't take a suffix of negative length from a collection")
    let amount = Swift.max(0, count - maxLength)
    let start = index(startIndex,
      offsetBy: amount, limitedBy: endIndex) ?? endIndex
    return self[start..<endIndex]
  }
}

----Swift.(file).Collection.prefix(upTo:Self.Index)
extension Collection  {
  public __consuming func prefix(upTo end: Index) -> SubSequence {
    return self[startIndex..<end]
  }
}

----Swift.(file).Collection.suffix(from:Self.Index)
extension Collection  {
  public __consuming func suffix(from start: Index) -> SubSequence {
    return self[start..<endIndex]
  }
}

----Swift.(file).Collection.prefix(through:Self.Index)
extension Collection  {
  public __consuming func prefix(through position: Index) -> SubSequence {
    return prefix(upTo: index(after: position))
  }
}

----Swift.(file).Collection.split(maxSplits:Int,omittingEmptySubsequences:Bool,whereSeparator:(Self.Element) throws -> Bool)
extension Collection  {
  public __consuming func split(
    maxSplits: Int = Int.max,
    omittingEmptySubsequences: Bool = true,
    whereSeparator isSeparator: (Element) throws -> Bool
  ) rethrows -> [SubSequence] {
    // TODO: swift-3-indexing-model - review the following
    _precondition(maxSplits >= 0, "Must take zero or more splits")

    var result: [SubSequence] = []
    var subSequenceStart: Index = startIndex

    func appendSubsequence(end: Index) -> Bool {
      if subSequenceStart == end && omittingEmptySubsequences {
        return false
      }
      result.append(self[subSequenceStart..<end])
      return true
    }

    if maxSplits == 0 || isEmpty {
      _ = appendSubsequence(end: endIndex)
      return result
    }

    var subSequenceEnd = subSequenceStart
    let cachedEndIndex = endIndex
    while subSequenceEnd != cachedEndIndex {
      if try isSeparator(self[subSequenceEnd]) {
        let didAppend = appendSubsequence(end: subSequenceEnd)
        formIndex(after: &subSequenceEnd)
        subSequenceStart = subSequenceEnd
        if didAppend && result.count == maxSplits {
          break
        }
        continue
      }
      formIndex(after: &subSequenceEnd)
    }

    if subSequenceStart != cachedEndIndex || !omittingEmptySubsequences {
      result.append(self[subSequenceStart..<cachedEndIndex])
    }

    return result
  }
}

----Swift.(file).Collection.split(separator:Self.Element,maxSplits:Int,omittingEmptySubsequences:Bool)
extension Collection where Element : Equatable  {
  public __consuming func split(
    separator: Element,
    maxSplits: Int = Int.max,
    omittingEmptySubsequences: Bool = true
  ) -> [SubSequence] {
    // TODO: swift-3-indexing-model - review the following
    return split(
      maxSplits: maxSplits,
      omittingEmptySubsequences: omittingEmptySubsequences,
      whereSeparator: { $0 == separator })
  }
}

----Swift.(file).Collection.removeFirst()
extension Collection where SubSequence == Self  {
  public mutating func removeFirst() -> Element {
    // TODO: swift-3-indexing-model - review the following
    _precondition(!isEmpty, "Can't remove items from an empty collection")
    let element = first!
    self = self[index(after: startIndex)..<endIndex]
    return element
  }
}

----Swift.(file).Collection.removeFirst(_:Int)
extension Collection where SubSequence == Self  {
  public mutating func removeFirst(_ k: Int) {
    if k == 0 { return }
    _precondition(k >= 0, "Number of elements to remove should be non-negative")
    _precondition(count >= k,
      "Can't remove more items from a collection than it contains")
    self = self[index(startIndex, offsetBy: k)..<endIndex]
  }
}

----Swift.(file).BidirectionalCollection.last
extension BidirectionalCollection  {
  public var last: Element? {
    return isEmpty ? nil : self[index(before: endIndex)]
  }
}

----Swift.(file).Collection.firstIndex(of:Self.Element)
extension Collection where Element : Equatable  {
  public func firstIndex(of element: Element) -> Index? {
    if let result = _customIndexOfEquatableElement(element) {
      return result
    }

    var i = self.startIndex
    while i != self.endIndex {
      if self[i] == element {
        return i
      }
      self.formIndex(after: &i)
    }
    return nil
  }
}

----Swift.(file).Collection.firstIndex(where:(Self.Element) throws -> Bool)
extension Collection  {
  public func firstIndex(
    where predicate: (Element) throws -> Bool
  ) rethrows -> Index? {
    var i = self.startIndex
    while i != self.endIndex {
      if try predicate(self[i]) {
        return i
      }
      self.formIndex(after: &i)
    }
    return nil
  }
}

----Swift.(file).BidirectionalCollection.last(where:(Self.Element) throws -> Bool)
extension BidirectionalCollection  {
  public func last(
    where predicate: (Element) throws -> Bool
  ) rethrows -> Element? {
    return try lastIndex(where: predicate).map { self[$0] }
  }
}

----Swift.(file).BidirectionalCollection.lastIndex(where:(Self.Element) throws -> Bool)
extension BidirectionalCollection  {
  public func lastIndex(
    where predicate: (Element) throws -> Bool
  ) rethrows -> Index? {
    var i = endIndex
    while i != startIndex {
      formIndex(before: &i)
      if try predicate(self[i]) {
        return i
      }
    }
    return nil
  }
}

----Swift.(file).BidirectionalCollection.lastIndex(of:Self.Element)
extension BidirectionalCollection where Element : Equatable  {
  public func lastIndex(of element: Element) -> Index? {
    if let result = _customLastIndexOfEquatableElement(element) {
      return result
    }
    return lastIndex(where: { $0 == element })
  }
}

----Swift.(file).MutableCollection.partition(by:(Self.Element) throws -> Bool)
extension MutableCollection  {
  public mutating func partition(
    by belongsInSecondPartition: (Element) throws -> Bool
  ) rethrows -> Index {
    return try _halfStablePartition(isSuffixElement: belongsInSecondPartition)
  }
}

----Swift.(file).MutableCollection.partition(by:(Self.Element) throws -> Bool)
extension MutableCollection where Self : BidirectionalCollection  {
  public mutating func partition(
    by belongsInSecondPartition: (Element) throws -> Bool
  ) rethrows -> Index {
    let maybeOffset = try _withUnsafeMutableBufferPointerIfSupported {
      (bufferPointer) -> Int in
      let unsafeBufferPivot = try bufferPointer._partitionImpl(
        by: belongsInSecondPartition)
      return unsafeBufferPivot - bufferPointer.startIndex
    }
    if let offset = maybeOffset {
      return index(startIndex, offsetBy: offset)
    } else {
      return try _partitionImpl(by: belongsInSecondPartition)
    }
  }
}

----Swift.(file).Sequence.shuffled(using:T)
extension Sequence  {
  public func shuffled<T: RandomNumberGenerator>(
    using generator: inout T
  ) -> [Element] {
    var result = ContiguousArray(self)
    result.shuffle(using: &generator)
    return Array(result)
  }
}

----Swift.(file).Sequence.shuffled()
extension Sequence  {
  public func shuffled() -> [Element] {
    var g = SystemRandomNumberGenerator()
    return shuffled(using: &g)
  }
}

----Swift.(file).MutableCollection.shuffle(using:T)
extension MutableCollection where Self : RandomAccessCollection  {
  public mutating func shuffle<T: RandomNumberGenerator>(
    using generator: inout T
  ) {
    guard count > 1 else { return }
    var amount = count
    var currentIndex = startIndex
    while amount > 1 {
      let random = Int.random(in: 0 ..< amount, using: &generator)
      amount -= 1
      swapAt(
        currentIndex,
        index(currentIndex, offsetBy: random)
      )
      formIndex(after: &currentIndex)
    }
  }
}

----Swift.(file).MutableCollection.shuffle()
extension MutableCollection where Self : RandomAccessCollection  {
  public mutating func shuffle() {
    var g = SystemRandomNumberGenerator()
    shuffle(using: &g)
  }
}

----Swift.(file).CollectionOfOne.init(_:Element)
extension CollectionOfOne {
  public init(_ element: Element) {
    self._element = element
  }
}

----Swift.(file).CollectionOfOne.Iterator.init(_elements:Element?)
extension CollectionOfOne.Iterator {
    init(_elements: Element?) {
      self._elements = _elements
    }
}

----Swift.(file).CollectionOfOne.Iterator.next()
extension CollectionOfOne.Iterator: IteratorProtocol  {
  public mutating func next() -> Element? {
    let result = _elements
    _elements = nil
    return result
  }
}

----Swift.(file).CollectionOfOne.Index
extension CollectionOfOne: RandomAccessCollection, MutableCollection  {
  public typealias Index = I
}

----Swift.(file).CollectionOfOne.Indices
extension CollectionOfOne: RandomAccessCollection, MutableCollection  {
  public typealias Indices = Range<Int>
}

----Swift.(file).CollectionOfOne.SubSequence
extension CollectionOfOne: RandomAccessCollection, MutableCollection  {
  public typealias SubSequence = Slice<CollectionOfOne<Element>>
}

----Swift.(file).CollectionOfOne.startIndex
extension CollectionOfOne: RandomAccessCollection, MutableCollection  {
  public var startIndex: Index {
    return 0
  }
}

----Swift.(file).CollectionOfOne.endIndex
extension CollectionOfOne: RandomAccessCollection, MutableCollection  {
  public var endIndex: Index {
    return 1
  }
}

----Swift.(file).CollectionOfOne.index(after:CollectionOfOne<Element>.Index)
extension CollectionOfOne: RandomAccessCollection, MutableCollection  {
  public func index(after i: Index) -> Index {
    _precondition(i == startIndex)
    return 1
  }
}

----Swift.(file).CollectionOfOne.index(before:CollectionOfOne<Element>.Index)
extension CollectionOfOne: RandomAccessCollection, MutableCollection  {
  public func index(before i: Index) -> Index {
    _precondition(i == endIndex)
    return 0
  }
}

----Swift.(file).CollectionOfOne.makeIterator()
extension CollectionOfOne: RandomAccessCollection, MutableCollection  {
  public __consuming func makeIterator() -> Iterator {
    return Iterator(_elements: _element)
  }
}

----Swift.(file).CollectionOfOne.subscript(_:Int)
extension CollectionOfOne: RandomAccessCollection, MutableCollection  {
  public subscript(position: Int) -> Element {
    get {
      _precondition(position == 0, "Index out of range")
      return _element
    }
    _modify {
      _precondition(position == 0, "Index out of range")
      yield &_element
    }
  }
}

----Swift.(file).CollectionOfOne.subscript(_:Range<Int>)
extension CollectionOfOne: RandomAccessCollection, MutableCollection  {
  public subscript(bounds: Range<Int>) -> SubSequence {
    get {
      _failEarlyRangeCheck(bounds, bounds: 0..<1)
      return Slice(base: self, bounds: bounds)
    }
    set {
      _failEarlyRangeCheck(bounds, bounds: 0..<1)
      let n = newValue.count
      _precondition(bounds.count == n, "CollectionOfOne can't be resized")
      if n == 1 { self = newValue.base }
    }
  }
}

----Swift.(file).CollectionOfOne.count
extension CollectionOfOne: RandomAccessCollection, MutableCollection  {
  public var count: Int {
    return 1
  }
}

----Swift.(file).CollectionOfOne.debugDescription
extension CollectionOfOne : CustomDebugStringConvertible  {
  public var debugDescription: String {
    return "CollectionOfOne(\(String(reflecting: _element)))"
  }
}

----Swift.(file).CollectionOfOne.customMirror
extension CollectionOfOne : CustomReflectable  {
  public var customMirror: Mirror {
    return Mirror(self, children: ["element": _element])
  }
}

----Swift.(file).Comparable.<infix(_:Self,_:Self)
extension Comparable {
  static func < (lhs: Self, rhs: Self) -> B
}

----Swift.(file).Comparable.<=infix(_:Self,_:Self)
extension Comparable {
  static func <= (lhs: Self, rhs: Self) -> B
}

----Swift.(file).Comparable.>=infix(_:Self,_:Self)
extension Comparable {
  static func >= (lhs: Self, rhs: Self) -> B
}

----Swift.(file).Comparable.>infix(_:Self,_:Self)
extension Comparable {
  static func > (lhs: Self, rhs: Self) -> B
}

----Swift.(file).Comparable.>infix(_:Self,_:Self)
extension Comparable  {
  public static func > (lhs: Self, rhs: Self) -> Bool {
    return rhs < lhs
  }
}

----Swift.(file).Comparable.<=infix(_:Self,_:Self)
extension Comparable  {
  public static func <= (lhs: Self, rhs: Self) -> Bool {
    return !(rhs < lhs)
  }
}

----Swift.(file).Comparable.>=infix(_:Self,_:Self)
extension Comparable  {
  public static func >= (lhs: Self, rhs: Self) -> Bool {
    return !(lhs < rhs)
  }
}

----Swift.(file).RawRepresentable.RawValue
extension RawRepresentable {
  associatedtype R
}

----Swift.(file).RawRepresentable.init(rawValue:Self.RawValue)
extension RawRepresentable {
  init?(rawValue: RawValue)
}

----Swift.(file).RawRepresentable.rawValue
extension RawRepresentable {
  var rawValue: RawValue { get }
}

----Swift.(file).==infix(_:T,_:T)
public func == <T : RawRepresentable>(lhs: T, rhs: T) -> Bool
  where T.RawValue : Equatable {
  return lhs.rawValue == rhs.rawValue
}

----Swift.(file).!=infix(_:T,_:T)
public func != <T : RawRepresentable>(lhs: T, rhs: T) -> Bool
  where T.RawValue : Equatable {
  return lhs.rawValue != rhs.rawValue
}

----Swift.(file).!=infix(_:T,_:T)
public func != <T : Equatable>(lhs: T, rhs: T) -> Bool
  where T : RawRepresentable, T.RawValue : Equatable {
  return lhs.rawValue != rhs.rawValue
}

----Swift.(file).RawRepresentable.hashValue
extension RawRepresentable where RawValue: Hashable, Self: Hashable  {
  public var hashValue: Int {
    return rawValue.hashValue
  }
}

----Swift.(file).RawRepresentable.hash(into:Hasher)
extension RawRepresentable where RawValue: Hashable, Self: Hashable  {
  public func hash(into hasher: inout Hasher) {
    hasher.combine(rawValue)
  }
}

----Swift.(file).CaseIterable.AllCases
extension CaseIterable {
  associatedtype AllCases: Collection
    where AllCases.Element == S
}

----Swift.(file).CaseIterable.allCases
extension CaseIterable {
  static var allCases: AllCases { get }
}

----Swift.(file).ExpressibleByNilLiteral.init(nilLiteral:())
extension ExpressibleByNilLiteral {
  init(nilLiteral: ())
}

----Swift.(file).ExpressibleByIntegerLiteral.IntegerLiteralType
extension ExpressibleByIntegerLiteral {
  associatedtype IntegerLiteralType : _
}

----Swift.(file).ExpressibleByIntegerLiteral.init(integerLiteral:Self.IntegerLiteralType)
extension ExpressibleByIntegerLiteral {
  init(integerLiteral value: IntegerLiteralType)
}

----Swift.(file).ExpressibleByFloatLiteral.FloatLiteralType
extension ExpressibleByFloatLiteral {
  associatedtype FloatLiteralType : _
}

----Swift.(file).ExpressibleByFloatLiteral.init(floatLiteral:Self.FloatLiteralType)
extension ExpressibleByFloatLiteral {
  init(floatLiteral value: FloatLiteralType)
}

----Swift.(file).ExpressibleByBooleanLiteral.BooleanLiteralType
extension ExpressibleByBooleanLiteral {
  associatedtype BooleanLiteralType : _
}

----Swift.(file).ExpressibleByBooleanLiteral.init(booleanLiteral:Self.BooleanLiteralType)
extension ExpressibleByBooleanLiteral {
  init(booleanLiteral value: BooleanLiteralType)
}

----Swift.(file).ExpressibleByUnicodeScalarLiteral.UnicodeScalarLiteralType
extension ExpressibleByUnicodeScalarLiteral {
  associatedtype UnicodeScalarLiteralType : _
}

----Swift.(file).ExpressibleByUnicodeScalarLiteral.init(unicodeScalarLiteral:Self.UnicodeScalarLiteralType)
extension ExpressibleByUnicodeScalarLiteral {
  init(unicodeScalarLiteral value: UnicodeScalarLiteralType)
}

----Swift.(file).ExpressibleByExtendedGraphemeClusterLiteral.ExtendedGraphemeClusterLiteralType
extension ExpressibleByExtendedGraphemeClusterLiteral {
  associatedtype ExtendedGraphemeClusterLiteralType
    : _
}

----Swift.(file).ExpressibleByExtendedGraphemeClusterLiteral.init(extendedGraphemeClusterLiteral:Self.ExtendedGraphemeClusterLiteralType)
extension ExpressibleByExtendedGraphemeClusterLiteral {
  init(extendedGraphemeClusterLiteral value: ExtendedGraphemeClusterLiteralType)
}

----Swift.(file).ExpressibleByExtendedGraphemeClusterLiteral.init(unicodeScalarLiteral:Self.ExtendedGraphemeClusterLiteralType)
extension ExpressibleByExtendedGraphemeClusterLiteral
  where ExtendedGraphemeClusterLiteralType == UnicodeScalarLiteralType  {
  public init(unicodeScalarLiteral value: ExtendedGraphemeClusterLiteralType) {
    self.init(extendedGraphemeClusterLiteral: value)
  }
}

----Swift.(file).ExpressibleByStringLiteral.StringLiteralType
extension ExpressibleByStringLiteral {
  associatedtype StringLiteralType : _
}

----Swift.(file).ExpressibleByStringLiteral.init(stringLiteral:Self.StringLiteralType)
extension ExpressibleByStringLiteral {
  init(stringLiteral value: StringLiteralType)
}

----Swift.(file).ExpressibleByStringLiteral.init(extendedGraphemeClusterLiteral:Self.StringLiteralType)
extension ExpressibleByStringLiteral
  where StringLiteralType == ExtendedGraphemeClusterLiteralType  {
  public init(extendedGraphemeClusterLiteral value: StringLiteralType) {
    self.init(stringLiteral: value)
  }
}

----Swift.(file).ExpressibleByArrayLiteral.ArrayLiteralElement
extension ExpressibleByArrayLiteral {
  associatedtype A
}

----Swift.(file).ExpressibleByArrayLiteral.init(arrayLiteral:[Self.ArrayLiteralElement])
extension ExpressibleByArrayLiteral {
  init(arrayLiteral elements: ArrayLiteralElement...)
}

----Swift.(file).ExpressibleByDictionaryLiteral.Key
extension ExpressibleByDictionaryLiteral {
  associatedtype K
}

----Swift.(file).ExpressibleByDictionaryLiteral.Value
extension ExpressibleByDictionaryLiteral {
  associatedtype V
}

----Swift.(file).ExpressibleByDictionaryLiteral.init(dictionaryLiteral:[(Self.Key, Self.Value)])
extension ExpressibleByDictionaryLiteral {
  init(dictionaryLiteral elements: (Key, Value)...)
}

----Swift.(file).ExpressibleByStringInterpolation.StringInterpolation
extension ExpressibleByStringInterpolation {
  associatedtype StringInterpolation : StringInterpolationProtocol
    = DefaultStringInterpolation
    where StringInterpolation.StringLiteralType == S
}

----Swift.(file).ExpressibleByStringInterpolation.init(stringInterpolation:Self.StringInterpolation)
extension ExpressibleByStringInterpolation {
  init(stringInterpolation: StringInterpolation)
}

----Swift.(file).ExpressibleByStringInterpolation.init(stringInterpolation:DefaultStringInterpolation)
extension ExpressibleByStringInterpolation
  where StringInterpolation == DefaultStringInterpolation  {
  public init(stringInterpolation: DefaultStringInterpolation) {
    self.init(stringLiteral: stringInterpolation.make())
  }
}

----Swift.(file).StringInterpolationProtocol.StringLiteralType
extension StringInterpolationProtocol {
  associatedtype StringLiteralType : _
}

----Swift.(file).StringInterpolationProtocol.init(literalCapacity:Int,interpolationCount:Int)
extension StringInterpolationProtocol {
  init(literalCapacity: Int, interpolationCount: Int)
}

----Swift.(file).StringInterpolationProtocol.appendLiteral(_:Self.StringLiteralType)
extension StringInterpolationProtocol {
  mutating func appendLiteral(_ literal: StringLiteralType)
}

----Swift.(file).ContiguousArray.init(_buffer:<<error type>>)
extension ContiguousArray {
  internal init(_buffer: _Buffer) {
    self._buffer = _buffer
  }
}

----Swift.(file).ContiguousArray.capacity
extension ContiguousArray: _ArrayProtocol  {
  public var capacity: Int {
    return _getCapacity()
  }
}

----Swift.(file).ContiguousArray.Index
extension ContiguousArray: RandomAccessCollection, MutableCollection  {
  public typealias Index = I
}

----Swift.(file).ContiguousArray.Indices
extension ContiguousArray: RandomAccessCollection, MutableCollection  {
  public typealias Indices = Range<Int>
}

----Swift.(file).ContiguousArray.Iterator
extension ContiguousArray: RandomAccessCollection, MutableCollection  {
  public typealias Iterator = IndexingIterator<ContiguousArray>
}

----Swift.(file).ContiguousArray.startIndex
extension ContiguousArray: RandomAccessCollection, MutableCollection  {
  public var startIndex: Int {
    return 0
  }
}

----Swift.(file).ContiguousArray.endIndex
extension ContiguousArray: RandomAccessCollection, MutableCollection  {
  public var endIndex: Int {
    @inlinable
    get {
      return _getCount()
    }
  }
}

----Swift.(file).ContiguousArray.index(after:Int)
extension ContiguousArray: RandomAccessCollection, MutableCollection  {
  public func index(after i: Int) -> Int {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    return i + 1
  }
}

----Swift.(file).ContiguousArray.formIndex(after:Int)
extension ContiguousArray: RandomAccessCollection, MutableCollection  {
  public func formIndex(after i: inout Int) {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    i += 1
  }
}

----Swift.(file).ContiguousArray.index(before:Int)
extension ContiguousArray: RandomAccessCollection, MutableCollection  {
  public func index(before i: Int) -> Int {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    return i - 1
  }
}

----Swift.(file).ContiguousArray.formIndex(before:Int)
extension ContiguousArray: RandomAccessCollection, MutableCollection  {
  public func formIndex(before i: inout Int) {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    i -= 1
  }
}

----Swift.(file).ContiguousArray.index(_:Int,offsetBy:Int)
extension ContiguousArray: RandomAccessCollection, MutableCollection  {
  public func index(_ i: Int, offsetBy distance: Int) -> Int {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    return i + distance
  }
}

----Swift.(file).ContiguousArray.index(_:Int,offsetBy:Int,limitedBy:Int)
extension ContiguousArray: RandomAccessCollection, MutableCollection  {
  public func index(
    _ i: Int, offsetBy distance: Int, limitedBy limit: Int
  ) -> Int? {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    let l = limit - i
    if distance > 0 ? l >= 0 && l < distance : l <= 0 && distance < l {
      return nil
    }
    return i + distance
  }
}

----Swift.(file).ContiguousArray.distance(from:Int,to:Int)
extension ContiguousArray: RandomAccessCollection, MutableCollection  {
  public func distance(from start: Int, to end: Int) -> Int {
    // NOTE: this is a manual specialization of index movement for a Strideable
    // index that is required for Array performance.  The optimizer is not
    // capable of creating partial specializations yet.
    // NOTE: Range checks are not performed here, because it is done later by
    // the subscript function.
    return end - start
  }
}

----Swift.(file).ContiguousArray.subscript(_:Int)
extension ContiguousArray: RandomAccessCollection, MutableCollection  {
  public subscript(index: Int) -> Element {
    get {
      _checkSubscript_native(index)
      return _buffer.getElement(index)
    }
    _modify {
      _makeMutableAndUnique()
      _checkSubscript_native(index)
      let address = _buffer.subscriptBaseAddress + index
      yield &address.pointee
    }
  }
}

----Swift.(file).ContiguousArray.subscript(_:Range<Int>)
extension ContiguousArray: RandomAccessCollection, MutableCollection  {
  public subscript(bounds: Range<Int>) -> ArraySlice<Element> {
    get {
      _checkIndex(bounds.lowerBound)
      _checkIndex(bounds.upperBound)
      return ArraySlice(_buffer: _buffer[bounds])
    }
    set(rhs) {
      _checkIndex(bounds.lowerBound)
      _checkIndex(bounds.upperBound)
      // If the replacement buffer has same identity, and the ranges match,
      // then this was a pinned in-place modification, nothing further needed.
      if self[bounds]._buffer.identity != rhs._buffer.identity
      || bounds != rhs.startIndex..<rhs.endIndex {
        self.replaceSubrange(bounds, with: rhs)
      }
    }
  }
}

----Swift.(file).ContiguousArray.count
extension ContiguousArray: RandomAccessCollection, MutableCollection  {
  public var count: Int {
    return _getCount()
  }
}

----Swift.(file).ContiguousArray.init(arrayLiteral:[Element])
extension ContiguousArray: ExpressibleByArrayLiteral  {
  public init(arrayLiteral elements: Element...) {
    self.init(_buffer: ContiguousArray(elements)._buffer)
  }
}

----Swift.(file).ContiguousArray.init()
extension ContiguousArray: RangeReplaceableCollection  {
  public init() {
    _buffer = _Buffer()
  }
}

----Swift.(file).ContiguousArray.init(_:S)
extension ContiguousArray: RangeReplaceableCollection  {
  public init<S: Sequence>(_ s: S) where S.Element == Element {
    self = ContiguousArray(
      _buffer: _Buffer(
        _buffer: s._copyToContiguousArray()._buffer,
        shiftedToStartIndex: 0))
  }
}

----Swift.(file).ContiguousArray.init(repeating:Element,count:Int)
extension ContiguousArray: RangeReplaceableCollection  {
  public init(repeating repeatedValue: Element, count: Int) {
    var p: UnsafeMutablePointer<Element>
    (self, p) = ContiguousArray._allocateUninitialized(count)
    for _ in 0..<count {
      p.initialize(to: repeatedValue)
      p += 1
    }
  }
}

----Swift.(file).ContiguousArray.init(_uninitializedCount:Int)
extension ContiguousArray: RangeReplaceableCollection  {
  internal init(_uninitializedCount count: Int) {
    _precondition(count >= 0, "Can't construct ContiguousArray with count < 0")
    // Note: Sinking this constructor into an else branch below causes an extra
    // Retain/Release.
    _buffer = _Buffer()
    if count > 0 {
      // Creating a buffer instead of calling reserveCapacity saves doing an
      // unnecessary uniqueness check. We disable inlining here to curb code
      // growth.
      _buffer = ContiguousArray._allocateBufferUninitialized(minimumCapacity: count)
      _buffer.count = count
    }
    // Can't store count here because the buffer might be pointing to the
    // shared empty array.
  }
}

----Swift.(file).ContiguousArray.reserveCapacity(_:Int)
extension ContiguousArray: RangeReplaceableCollection  {
  public mutating func reserveCapacity(_ minimumCapacity: Int) {
    if _buffer.requestUniqueMutableBackingBuffer(
      minimumCapacity: minimumCapacity) == nil {

      let newBuffer = _ContiguousArrayBuffer<Element>(
        _uninitializedCount: count, minimumCapacity: minimumCapacity)

      _buffer._copyContents(
        subRange: _buffer.indices,
        initializing: newBuffer.firstElementAddress)
      _buffer = _Buffer(
        _buffer: newBuffer, shiftedToStartIndex: _buffer.startIndex)
    }
    _internalInvariant(capacity >= minimumCapacity)
  }
}

----Swift.(file).ContiguousArray.append(_:Element)
extension ContiguousArray: RangeReplaceableCollection  {
  public mutating func append(_ newElement: __owned Element) {
    _makeUniqueAndReserveCapacityIfNotUnique()
    let oldCount = _getCount()
    _reserveCapacityAssumingUniqueBuffer(oldCount: oldCount)
    _appendElementAssumeUniqueAndCapacity(oldCount, newElement: newElement)
  }
}

----Swift.(file).ContiguousArray.append(contentsOf:S)
extension ContiguousArray: RangeReplaceableCollection  {
  public mutating func append<S: Sequence>(contentsOf newElements: __owned S)
    where S.Element == Element {

    let newElementsCount = newElements.underestimatedCount
    reserveCapacityForAppend(newElementsCount: newElementsCount)

    let oldCount = self.count
    let startNewElements = _buffer.firstElementAddress + oldCount
    let buf = UnsafeMutableBufferPointer(
                start: startNewElements, 
                count: self.capacity - oldCount)

    let (remainder,writtenUpTo) = buf.initialize(from: newElements)
    
    // trap on underflow from the sequence's underestimate:
    let writtenCount = buf.distance(from: buf.startIndex, to: writtenUpTo)
    _precondition(newElementsCount <= writtenCount, 
      "newElements.underestimatedCount was an overestimate")
    // can't check for overflow as sequences can underestimate

    _buffer.count += writtenCount

    if writtenUpTo == buf.endIndex {
      // there may be elements that didn't fit in the existing buffer,
      // append them in slow sequence-only mode
      _buffer._arrayAppendSequence(IteratorSequence(remainder))
    }
  }
}

----Swift.(file).ContiguousArray.reserveCapacityForAppend(newElementsCount:Int)
extension ContiguousArray: RangeReplaceableCollection  {
  internal mutating func reserveCapacityForAppend(newElementsCount: Int) {
    let oldCount = self.count
    let oldCapacity = self.capacity
    let newCount = oldCount + newElementsCount

    // Ensure uniqueness, mutability, and sufficient storage.  Note that
    // for consistency, we need unique self even if newElements is empty.
    self.reserveCapacity(
      newCount > oldCapacity ?
      Swift.max(newCount, _growArrayCapacity(oldCapacity))
      : newCount)
  }
}

----Swift.(file).ContiguousArray.remove(at:Int)
extension ContiguousArray: RangeReplaceableCollection  {
  public mutating func remove(at index: Int) -> Element {
    _precondition(index < endIndex, "Index out of range")
    _precondition(index >= startIndex, "Index out of range")
    _makeUniqueAndReserveCapacityIfNotUnique()
    let newCount = _getCount() - 1
    let pointer = (_buffer.firstElementAddress + index)
    let result = pointer.move()
    pointer.moveInitialize(from: pointer + 1, count: newCount - index)
    _buffer.count = newCount
    return result
  }
}

----Swift.(file).ContiguousArray.insert(_:Element,at:Int)
extension ContiguousArray: RangeReplaceableCollection  {
  public mutating func insert(_ newElement: __owned Element, at i: Int) {
    _checkIndex(i)
    self.replaceSubrange(i..<i, with: CollectionOfOne(newElement))
  }
}

----Swift.(file).ContiguousArray.removeAll(keepingCapacity:Bool)
extension ContiguousArray: RangeReplaceableCollection  {
  public mutating func removeAll(keepingCapacity keepCapacity: Bool = false) {
    if !keepCapacity {
      _buffer = _Buffer()
    }
    else {
      self.replaceSubrange(indices, with: EmptyCollection())
    }
  }
}

----Swift.(file).ContiguousArray.withContiguousMutableStorageIfAvailable(_:(inout UnsafeMutableBufferPointer<Element>) throws -> R)
extension ContiguousArray: RangeReplaceableCollection  {
  public mutating func withContiguousMutableStorageIfAvailable<R>(
    _ body: (inout UnsafeMutableBufferPointer<Element>) throws -> R
  ) rethrows -> R? {
    return try withUnsafeMutableBufferPointer {
      (bufferPointer) -> R in
      return try body(&bufferPointer)
    }
  }
}

----Swift.(file).ContiguousArray.withContiguousStorageIfAvailable(_:(UnsafeBufferPointer<Element>) throws -> R)
extension ContiguousArray: RangeReplaceableCollection  {
  public func withContiguousStorageIfAvailable<R>(
    _ body: (UnsafeBufferPointer<Element>) throws -> R
  ) rethrows -> R? {
    return try withUnsafeBufferPointer {
      (bufferPointer) -> R in
      return try body(bufferPointer)
    }
  }
}

----Swift.(file).ContiguousArray.customMirror
extension ContiguousArray: CustomReflectable  {
  public var customMirror: Mirror {
    return Mirror(
      self,
      unlabeledChildren: self,
      displayStyle: .collection)
  }
}

----Swift.(file).ContiguousArray.description
extension ContiguousArray: CustomStringConvertible, CustomDebugStringConvertible  {
  public var description: String {
    return _makeCollectionDescription()
  }
}

----Swift.(file).ContiguousArray.debugDescription
extension ContiguousArray: CustomStringConvertible, CustomDebugStringConvertible  {
  public var debugDescription: String {
    return _makeCollectionDescription(withTypeName: "ContiguousArray")
  }
}

----Swift.(file).ContiguousArray.withUnsafeBufferPointer(_:(UnsafeBufferPointer<Element>) throws -> R)
extension ContiguousArray  {
  public func withUnsafeBufferPointer<R>(
    _ body: (UnsafeBufferPointer<Element>) throws -> R
  ) rethrows -> R {
    return try _buffer.withUnsafeBufferPointer(body)
  }
}

----Swift.(file).ContiguousArray.withUnsafeMutableBufferPointer(_:(inout UnsafeMutableBufferPointer<Element>) throws -> R)
extension ContiguousArray  {
  public mutating func withUnsafeMutableBufferPointer<R>(
    _ body: (inout UnsafeMutableBufferPointer<Element>) throws -> R
  ) rethrows -> R {
    let count = self.count
    // Ensure unique storage
    _buffer._outlinedMakeUniqueBuffer(bufferCount: count)

    // Ensure that body can't invalidate the storage or its bounds by
    // moving self into a temporary working array.
    // NOTE: The stack promotion optimization that keys of the
    // "array.withUnsafeMutableBufferPointer" semantics annotation relies on the
    // array buffer not being able to escape in the closure. It can do this
    // because we swap the array buffer in self with an empty buffer here. Any
    // escape via the address of self in the closure will therefore escape the
    // empty array.

    var work = ContiguousArray()
    (work, self) = (self, work)

    // Create an UnsafeBufferPointer over work that we can pass to body
    let pointer = work._buffer.firstElementAddress
    var inoutBufferPointer = UnsafeMutableBufferPointer(
      start: pointer, count: count)

    // Put the working array back before returning.
    defer {
      _precondition(
        inoutBufferPointer.baseAddress == pointer &&
        inoutBufferPointer.count == count,
        "ContiguousArray withUnsafeMutableBufferPointer: replacing the buffer is not allowed")

      (work, self) = (self, work)
    }

    // Invoke the body.
    return try body(&inoutBufferPointer)
  }
}

----Swift.(file).ContiguousArray.replaceSubrange(_:Range<Int>,with:C)
extension ContiguousArray  {
  public mutating func replaceSubrange<C>(
    _ subrange: Range<Int>,
    with newElements: __owned C
  ) where C: Collection, C.Element == Element {
    _precondition(subrange.lowerBound >= self._buffer.startIndex,
      "ContiguousArray replace: subrange start is negative")

    _precondition(subrange.upperBound <= _buffer.endIndex,
      "ContiguousArray replace: subrange extends past the end")

    let oldCount = _buffer.count
    let eraseCount = subrange.count
    let insertCount = newElements.count
    let growth = insertCount - eraseCount

    if _buffer.requestUniqueMutableBackingBuffer(
      minimumCapacity: oldCount + growth) != nil {

      _buffer.replaceSubrange(
        subrange, with: insertCount, elementsOf: newElements)
    } else {
      _buffer._arrayOutOfPlaceReplace(subrange, with: newElements, count: insertCount)
    }
  }
}

----Swift.(file).ContiguousArray.==infix(_:ContiguousArray<Element>,_:ContiguousArray<Element>)
extension ContiguousArray: Equatable where Element: Equatable  {
  public static func ==(lhs: ContiguousArray<Element>, rhs: ContiguousArray<Element>) -> Bool {
    let lhsCount = lhs.count
    if lhsCount != rhs.count {
      return false
    }

    // Test referential equality.
    if lhsCount == 0 || lhs._buffer.identity == rhs._buffer.identity {
      return true
    }


    _internalInvariant(lhs.startIndex == 0 && rhs.startIndex == 0)
    _internalInvariant(lhs.endIndex == lhsCount && rhs.endIndex == lhsCount)

    // We know that lhs.count == rhs.count, compare element wise.
    for idx in 0..<lhsCount {
      if lhs[idx] != rhs[idx] {
        return false
      }
    }

    return true
  }
}

----Swift.(file).ContiguousArray.hash(into:Hasher)
extension ContiguousArray: Hashable where Element: Hashable  {
  public func hash(into hasher: inout Hasher) {
    hasher.combine(count) // discriminator
    for element in self {
      hasher.combine(element)
    }
  }
}

----Swift.(file).ContiguousArray.withUnsafeMutableBytes(_:(UnsafeMutableRawBufferPointer) throws -> R)
extension ContiguousArray  {
  public mutating func withUnsafeMutableBytes<R>(
    _ body: (UnsafeMutableRawBufferPointer) throws -> R
  ) rethrows -> R {
    return try self.withUnsafeMutableBufferPointer {
      return try body(UnsafeMutableRawBufferPointer($0))
    }
  }
}

----Swift.(file).ContiguousArray.withUnsafeBytes(_:(UnsafeRawBufferPointer) throws -> R)
extension ContiguousArray  {
  public func withUnsafeBytes<R>(
    _ body: (UnsafeRawBufferPointer) throws -> R
  ) rethrows -> R {
    return try self.withUnsafeBufferPointer {
      try body(UnsafeRawBufferPointer($0))
    }
  }
}

----Swift.(file).+=infix(_:_ContiguousArrayBuffer<Element>,_:C)
internal func += <Element, C : Collection>(
  lhs: inout _ContiguousArrayBuffer<Element>, rhs: __owned C
) where C.Element == Element {

  let oldCount = lhs.count
  let newCount = oldCount + numericCast(rhs.count)

  let buf: UnsafeMutableBufferPointer<Element>
  
  if _fastPath(newCount <= lhs.capacity) {
    buf = UnsafeMutableBufferPointer(start: lhs.firstElementAddress + oldCount, count: numericCast(rhs.count))
    lhs.count = newCount
  }
  else {
    var newLHS = _ContiguousArrayBuffer<Element>(
      _uninitializedCount: newCount,
      minimumCapacity: _growArrayCapacity(lhs.capacity))

    newLHS.firstElementAddress.moveInitialize(
      from: lhs.firstElementAddress, count: oldCount)
    lhs.count = 0
    (lhs, newLHS) = (newLHS, lhs)
    buf = UnsafeMutableBufferPointer(start: lhs.firstElementAddress + oldCount, count: numericCast(rhs.count))
  }

  var (remainders,writtenUpTo) = buf.initialize(from: rhs)

  // ensure that exactly rhs.count elements were written
  _precondition(remainders.next() == nil, "rhs underreported its count")
  _precondition(writtenUpTo == buf.endIndex, "rhs overreported its count")    
}

----Swift.(file)._ContiguousArrayBuffer.startIndex
extension _ContiguousArrayBuffer : RandomAccessCollection  {
  internal var startIndex: Int {
    return 0
  }
}

----Swift.(file)._ContiguousArrayBuffer.endIndex
extension _ContiguousArrayBuffer : RandomAccessCollection  {
  internal var endIndex: Int {
    return count
  }
}

----Swift.(file)._ContiguousArrayBuffer.Indices
extension _ContiguousArrayBuffer : RandomAccessCollection  {
  internal typealias Indices = Range<Int>
}

----Swift.(file).UnsafeBufferPointer.withUnsafeBytes(_:(UnsafeRawBufferPointer) throws -> R)
extension UnsafeBufferPointer: _HasContiguousBytes  {
  func withUnsafeBytes<R>(
    _ body: (UnsafeRawBufferPointer) throws -> R
  ) rethrows -> R {
    let ptr = UnsafeRawPointer(self.baseAddress._unsafelyUnwrappedUnchecked)
    let len = self.count &* MemoryLayout<Element>.stride
    return try body(UnsafeRawBufferPointer(start: ptr, count: len))
  }
}

----Swift.(file).UnsafeMutableBufferPointer.withUnsafeBytes(_:(UnsafeRawBufferPointer) throws -> R)
extension UnsafeMutableBufferPointer: _HasContiguousBytes  {
  func withUnsafeBytes<R>(
    _ body: (UnsafeRawBufferPointer) throws -> R
  ) rethrows -> R {
    let ptr = UnsafeRawPointer(self.baseAddress._unsafelyUnwrappedUnchecked)
    let len = self.count &* MemoryLayout<Element>.stride
    return try body(UnsafeRawBufferPointer(start: ptr, count: len))
  }
}

----Swift.(file).String.withUnsafeBytes(_:(UnsafeRawBufferPointer) throws -> R)
extension String: _HasContiguousBytes  {
  internal func withUnsafeBytes<R>(
    _ body: (UnsafeRawBufferPointer) throws -> R
  ) rethrows -> R {
    return try self._withUTF8 { return try body(UnsafeRawBufferPointer($0)) }
  }
}

----Swift.(file).Substring.withUnsafeBytes(_:(UnsafeRawBufferPointer) throws -> R)
extension Substring: _HasContiguousBytes  {
  internal func withUnsafeBytes<R>(
    _ body: (UnsafeRawBufferPointer) throws -> R
  ) rethrows -> R {
    return try self._withUTF8 { return try body(UnsafeRawBufferPointer($0)) }
  }
}

----Swift.(file).Dictionary.init()
extension Dictionary {
  public init() {
    self.init(_native: _NativeDictionary())
  }
}

----Swift.(file).Dictionary.init(minimumCapacity:Int)
extension Dictionary {
  init(minimumCapacity: Int) {
    _variant = _Variant(native: _NativeDictionary(capacity: minimumCapacity))
  }
}

----Swift.(file).Dictionary.init(uniqueKeysWithValues:S)
extension Dictionary {
  public init<S: Sequence>(
    uniqueKeysWithValues keysAndValues: __owned S
  ) where S.Element == (Key, Value) {
    if let d = keysAndValues as? Dictionary<Key, Value> {
      self = d
      return
    }
    var native = _NativeDictionary<Key, Value>(
      capacity: keysAndValues.underestimatedCount)
    // '_MergeError.keyCollision' is caught and handled with an appropriate
    // error message one level down, inside native.merge(_:...). We throw an
    // error instead of calling fatalError() directly because we want the
    // message to include the duplicate key, and the closure only has access to
    // the conflicting values.
    try! native.merge(
      keysAndValues,
      isUnique: true,
      uniquingKeysWith: { _, _ in throw _MergeError.keyCollision })
    self.init(_native: native)
  }
}

----Swift.(file).Dictionary.init(_:S,uniquingKeysWith:(Value, Value) throws -> Value)
extension Dictionary {
  public init<S: Sequence>(
    _ keysAndValues: __owned S,
    uniquingKeysWith combine: (Value, Value) throws -> Value
  ) rethrows where S.Element == (Key, Value) {
    var native = _NativeDictionary<Key, Value>(
      capacity: keysAndValues.underestimatedCount)
    try native.merge(keysAndValues, isUnique: true, uniquingKeysWith: combine)
    self.init(_native: native)
  }
}

----Swift.(file).Dictionary.init(grouping:S,by:(S.Element) throws -> Key)
extension Dictionary {
  public init<S: Sequence>(
    grouping values: __owned S,
    by keyForValue: (S.Element) throws -> Key
  ) rethrows where Value == [S.Element] {
    try self.init(_native: _NativeDictionary(grouping: values, by: keyForValue))
  }
}

----Swift.(file)..(error_type).bridged()
extension _NativeDictionary  {
  __consuming internal func bridged() -> AnyObject {
    // We can zero-cost bridge if our keys are verbatim
    // or if we're the empty singleton.

    // Temporary var for SOME type safety.
    let nsDictionary: _NSDictionaryCore

    if _storage === _RawDictionaryStorage.empty || count == 0 {
      nsDictionary = _RawDictionaryStorage.empty
    } else if _isBridgedVerbatimToObjectiveC(Key.self),
      _isBridgedVerbatimToObjectiveC(Value.self) {
      nsDictionary = unsafeDowncast(
        _storage,
        to: _DictionaryStorage<Key, Value>.self)
    } else {
      nsDictionary = _SwiftDeferredNSDictionary(self)
    }

    return nsDictionary
  }
}

----Swift.(file)._CocoaDictionary.isEqual(to:_CocoaDictionary)
extension _CocoaDictionary  {
  internal func isEqual(to other: _CocoaDictionary) -> Bool {
    return _stdlib_NSObject_isEqual(self.object, other.object)
  }
}

----Swift.(file)._CocoaDictionary.Key
extension _CocoaDictionary: _DictionaryBuffer  {
  internal typealias Key = A
}

----Swift.(file)._CocoaDictionary.Value
extension _CocoaDictionary: _DictionaryBuffer  {
  internal typealias Value = A
}

----Swift.(file)._CocoaDictionary.startIndex
extension _CocoaDictionary: _DictionaryBuffer  {
  internal var startIndex: Index {
    @_effects(releasenone)
    get {
      let allKeys = _stdlib_NSDictionary_allKeys(self.object)
      return Index(Index.Storage(self, allKeys), offset: 0)
    }
  }
}

----Swift.(file)._CocoaDictionary.endIndex
extension _CocoaDictionary: _DictionaryBuffer  {
  internal var endIndex: Index {
    @_effects(releasenone)
    get {
      let allKeys = _stdlib_NSDictionary_allKeys(self.object)
      return Index(Index.Storage(self, allKeys), offset: allKeys.count)
    }
  }
}

----Swift.(file)._CocoaDictionary.index(after:_CocoaDictionary.Index)
extension _CocoaDictionary: _DictionaryBuffer  {
  internal func index(after index: Index) -> Index {
    validate(index)
    var result = index
    result._offset += 1
    return result
  }
}

----Swift.(file)._CocoaDictionary.validate(_:_CocoaDictionary.Index)
extension _CocoaDictionary: _DictionaryBuffer  {
  internal func validate(_ index: Index) {
    _precondition(index.storage.base.object === self.object, "Invalid index")
    _precondition(index._offset < index.storage.allKeys.count,
      "Attempt to access endIndex")
  }
}

----Swift.(file)._CocoaDictionary.formIndex(after:_CocoaDictionary.Index,isUnique:Bool)
extension _CocoaDictionary: _DictionaryBuffer  {
  internal func formIndex(after index: inout Index, isUnique: Bool) {
    validate(index)
    index._offset += 1
  }
}

----Swift.(file)._CocoaDictionary.index(forKey:_CocoaDictionary.Key)
extension _CocoaDictionary: _DictionaryBuffer  {
  internal func index(forKey key: Key) -> Index? {
    // Fast path that does not involve creating an array of all keys.  In case
    // the key is present, this lookup is a penalty for the slow path, but the
    // potential savings are significant: we could skip a memory allocation and
    // a linear search.
    if lookup(key) == nil {
      return nil
    }

    let allKeys = _stdlib_NSDictionary_allKeys(object)
    for i in 0..<allKeys.count {
      if _stdlib_NSObject_isEqual(key, allKeys[i]) {
        return Index(Index.Storage(self, allKeys), offset: i)
      }
    }
    _internalInvariantFailure(
      "An NSDictionary key wassn't listed amongst its enumerated contents")
  }
}

----Swift.(file)._CocoaDictionary.count
extension _CocoaDictionary: _DictionaryBuffer  {
  internal var count: Int {
    let nsd = unsafeBitCast(object, to: _NSDictionary.self)
    return nsd.count
  }
}

----Swift.(file)._CocoaDictionary.contains(_:_CocoaDictionary.Key)
extension _CocoaDictionary: _DictionaryBuffer  {
  internal func contains(_ key: Key) -> Bool {
    let nsd = unsafeBitCast(object, to: _NSDictionary.self)
    return nsd.object(forKey: key) != nil
  }
}

----Swift.(file)._CocoaDictionary.lookup(_:_CocoaDictionary.Key)
extension _CocoaDictionary: _DictionaryBuffer  {
  internal func lookup(_ key: Key) -> Value? {
    let nsd = unsafeBitCast(object, to: _NSDictionary.self)
    return nsd.object(forKey: key)
  }
}

----Swift.(file)._CocoaDictionary.lookup(_:_CocoaDictionary.Index)
extension _CocoaDictionary: _DictionaryBuffer  {
  internal func lookup(_ index: Index) -> (key: Key, value: Value) {
    _precondition(index.storage.base.object === self.object, "Invalid index")
    let key: Key = index.storage.allKeys[index._offset]
    let value: Value = index.storage.base.object.object(forKey: key)!
    return (key, value)
  }
}

----Swift.(file)._CocoaDictionary.key(at:_CocoaDictionary.Index)
extension _CocoaDictionary: _DictionaryBuffer  {
  func key(at index: Index) -> Key {
    _precondition(index.storage.base.object === self.object, "Invalid index")
    return index.key
  }
}

----Swift.(file)._CocoaDictionary.value(at:_CocoaDictionary.Index)
extension _CocoaDictionary: _DictionaryBuffer  {
  func value(at index: Index) -> Value {
    _precondition(index.storage.base.object === self.object, "Invalid index")
    let key = index.storage.allKeys[index._offset]
    return index.storage.base.object.object(forKey: key)!
  }
}

----Swift.(file)._CocoaDictionary.mapValues(_:(Value) throws -> T)
extension _CocoaDictionary  {
  internal func mapValues<Key: Hashable, Value, T>(
    _ transform: (Value) throws -> T
  ) rethrows -> _NativeDictionary<Key, T> {
    var result = _NativeDictionary<Key, T>(capacity: self.count)
    for (cocoaKey, cocoaValue) in self {
      let key = _forceBridgeFromObjectiveC(cocoaKey, Key.self)
      let value = _forceBridgeFromObjectiveC(cocoaValue, Value.self)
      try result.insertNew(key: key, value: transform(value))
    }
    return result
  }
}

----Swift.(file)._CocoaDictionary.Index.handleBitPattern
extension _CocoaDictionary.Index  {
  internal var handleBitPattern: UInt {
    @_effects(readonly)
    get {
      return unsafeBitCast(storage, to: UInt.self)
    }
  }
}

----Swift.(file)._CocoaDictionary.Index.dictionary
extension _CocoaDictionary.Index  {
  internal var dictionary: _CocoaDictionary {
    @_effects(releasenone)
    get {
      return storage.base
    }
  }
}

----Swift.(file)._CocoaDictionary.Index.key
extension _CocoaDictionary.Index  {
  internal var key: AnyObject {
    @_effects(readonly)
    get {
      _precondition(_offset < storage.allKeys.count,
        "Attempting to access Dictionary elements using an invalid index")
      return storage.allKeys[_offset]
    }
  }
}

----Swift.(file)._CocoaDictionary.Index.age
extension _CocoaDictionary.Index  {
  internal var age: Int32 {
    @_effects(readonly)
    get {
      return _HashTable.age(for: storage.base.object)
    }
  }
}

----Swift.(file)._CocoaDictionary.Index.==infix(_:_CocoaDictionary.Index,_:_CocoaDictionary.Index)
extension _CocoaDictionary.Index: Equatable  {
  internal static func == (
    lhs: _CocoaDictionary.Index,
    rhs: _CocoaDictionary.Index
  ) -> Bool {
    _precondition(lhs.storage.base.object === rhs.storage.base.object,
      "Comparing indexes from different dictionaries")
    return lhs._offset == rhs._offset
  }
}

----Swift.(file)._CocoaDictionary.Index.<infix(_:_CocoaDictionary.Index,_:_CocoaDictionary.Index)
extension _CocoaDictionary.Index: Comparable  {
  internal static func < (
    lhs: _CocoaDictionary.Index,
    rhs: _CocoaDictionary.Index
  ) -> Bool {
    _precondition(lhs.storage.base.object === rhs.storage.base.object,
      "Comparing indexes from different dictionaries")
    return lhs._offset < rhs._offset
  }
}

----Swift.(file)._CocoaDictionary.makeIterator()
extension _CocoaDictionary: Sequence  {
  internal __consuming func makeIterator() -> Iterator {
    return Iterator(self)
  }
}

----Swift.(file)._CocoaDictionary.Iterator.Element
extension _CocoaDictionary.Iterator: IteratorProtocol  {
  internal typealias Element = (key: AnyObject, value: AnyObject)
}

----Swift.(file)._CocoaDictionary.Iterator.nextKey()
extension _CocoaDictionary.Iterator: IteratorProtocol  {
  internal func nextKey() -> AnyObject? {
    if itemIndex < 0 {
      return nil
    }
    let base = self.base
    if itemIndex == itemCount {
      let stackBufCount = _fastEnumerationStackBuf.count
      // We can't use `withUnsafeMutablePointer` here to get pointers to
      // properties, because doing so might introduce a writeback storage, but
      // fast enumeration relies on the pointer identity of the enumeration
      // state struct.
      itemCount = base.object.countByEnumerating(
        with: _fastEnumerationStatePtr,
        objects: UnsafeMutableRawPointer(_fastEnumerationStackBufPtr)
          .assumingMemoryBound(to: AnyObject.self),
        count: stackBufCount)
      if itemCount == 0 {
        itemIndex = -1
        return nil
      }
      itemIndex = 0
    }
    let itemsPtrUP =
    UnsafeMutableRawPointer(_fastEnumerationState.itemsPtr!)
      .assumingMemoryBound(to: AnyObject.self)
    let itemsPtr = _UnmanagedAnyObjectArray(itemsPtrUP)
    let key: AnyObject = itemsPtr[itemIndex]
    itemIndex += 1
    return key
  }
}

----Swift.(file)._CocoaDictionary.Iterator.next()
extension _CocoaDictionary.Iterator: IteratorProtocol  {
  internal func next() -> Element? {
    guard let key = nextKey() else { return nil }
    let value: AnyObject = base.object.object(forKey: key)!
    return (key, value)
  }
}

----Swift.(file).Dictionary.init(_unsafeUninitializedCapacity:Int,allowingDuplicates:Bool,initializingWith:(UnsafeMutableBufferPointer<Key>, UnsafeMutableBufferPointer<Value>, inout Int) -> Void)
extension Dictionary  {
  init(
    _unsafeUninitializedCapacity capacity: Int,
    allowingDuplicates: Bool,
    initializingWith initializer: (
      _ keys: UnsafeMutableBufferPointer<Key>,
      _ values: UnsafeMutableBufferPointer<Value>,
      _ initializedCount: inout Int
    ) -> Void
  ) {
    self.init(_native: _NativeDictionary(
        _unsafeUninitializedCapacity: capacity,
        allowingDuplicates: allowingDuplicates,
        initializingWith: initializer))
  }
}

----Swift.(file)..(error_type).init(_unsafeUninitializedCapacity:Int,allowingDuplicates:Bool,initializingWith:<<error type>>)
extension _NativeDictionary  {
  internal init(
    _unsafeUninitializedCapacity capacity: Int,
    allowingDuplicates: Bool,
    initializingWith initializer: (
      _ keys: UnsafeMutableBufferPointer<Key>,
      _ values: UnsafeMutableBufferPointer<Value>,
      _ initializedCount: inout Int
    ) -> Void
  ) {
    self.init(capacity: capacity)
    var initializedCount = 0
    initializer(
      UnsafeMutableBufferPointer(start: _keys, count: capacity),
      UnsafeMutableBufferPointer(start: _values, count: capacity),
      &initializedCount)
    _precondition(count >= 0 && count <= capacity)
    _storage._count = initializedCount

    // Hash initialized elements and move each of them into their correct
    // buckets.
    //
    // - We have some number of unprocessed elements at the start of the
    //   key/value buffers -- buckets up to and including `bucket`. Everything
    //   in this region is either unprocessed or in use. There are no
    //   uninitialized entries in it.
    //
    // - Everything after `bucket` is either uninitialized or in use. This
    //   region works exactly like regular dictionary storage.
    //
    // - "in use" is tracked by the bitmap in `hashTable`, the same way it would
    //   be for a working Dictionary.
    //
    // Each iteration of the loop below processes an unprocessed element, and/or
    // reduces the size of the unprocessed region, while ensuring the above
    // invariants.
    var bucket = _HashTable.Bucket(offset: initializedCount - 1)
    while bucket.offset >= 0 {
      if hashTable._isOccupied(bucket) {
        // We've moved an element here in a previous iteration.
        bucket.offset -= 1
        continue
      }
      // Find the target bucket for this entry and mark it as in use.
      let target: Bucket
      if _isDebugAssertConfiguration() || allowingDuplicates {
        let (b, found) = find(_keys[bucket.offset])
        if found {
          _internalInvariant(b != bucket)
          _precondition(allowingDuplicates, "Duplicate keys found")
          // Discard duplicate entry.
          uncheckedDestroy(at: bucket)
          _storage._count -= 1
          bucket.offset -= 1
          continue
        }
        hashTable.insert(b)
        target = b
      } else {
        let hashValue = self.hashValue(for: _keys[bucket.offset])
        target = hashTable.insertNew(hashValue: hashValue)
      }

      if target > bucket {
        // The target is outside the unprocessed region.  We can simply move the
        // entry, leaving behind an uninitialized bucket.
        moveEntry(from: bucket, to: target)
        // Restore invariants by lowering the region boundary.
        bucket.offset -= 1
      } else if target == bucket {
        // Already in place.
        bucket.offset -= 1
      } else {
        // The target bucket is also in the unprocessed region. Swap the current
        // item into place, then try again with the swapped-in value, so that we
        // don't lose it.
        swapEntry(target, with: bucket)
      }
    }
    // When there are no more unprocessed entries, we're left with a valid
    // Dictionary.
  }
}

----Swift.(file)._EmptyDictionarySingleton.copy(with:<<error type>>)
extension _EmptyDictionarySingleton: _NSDictionaryCore  {
  internal func copy(with zone: _SwiftNSZone?) -> AnyObject {
    return self
  }
}

----Swift.(file)._EmptyDictionarySingleton.count
extension _EmptyDictionarySingleton: _NSDictionaryCore  {
  internal var count: Int {
    return 0
  }
}

----Swift.(file)._EmptyDictionarySingleton.countByEnumerating(with:UnsafeMutablePointer<_SwiftNSFastEnumerationState>,objects:UnsafeMutablePointer<AnyObject>?,count:Int)
extension _EmptyDictionarySingleton: _NSDictionaryCore  {
  internal func countByEnumerating(
    with state: UnsafeMutablePointer<_SwiftNSFastEnumerationState>,
    objects: UnsafeMutablePointer<AnyObject>?, count: Int
  ) -> Int {
    // Even though we never do anything in here, we need to update the
    // state so that callers know we actually ran.

    var theState = state.pointee
    if theState.state == 0 {
      theState.state = 1 // Arbitrary non-zero value.
      theState.itemsPtr = AutoreleasingUnsafeMutablePointer(objects)
      theState.mutationsPtr = _fastEnumerationStorageMutationsPtr
    }
    state.pointee = theState

    return 0
  }
}

----Swift.(file)._EmptyDictionarySingleton.object(forKey:AnyObject)
extension _EmptyDictionarySingleton: _NSDictionaryCore  {
  internal func object(forKey aKey: AnyObject) -> AnyObject? {
    return nil
  }
}

----Swift.(file)._EmptyDictionarySingleton.keyEnumerator()
extension _EmptyDictionarySingleton: _NSDictionaryCore  {
  internal func keyEnumerator() -> _NSEnumerator {
    return _SwiftEmptyNSEnumerator()
  }
}

----Swift.(file)._EmptyDictionarySingleton.getObjects(_:UnsafeMutablePointer<AnyObject>?,andKeys:UnsafeMutablePointer<AnyObject>?,count:Int)
extension _EmptyDictionarySingleton: _NSDictionaryCore  {
  internal func getObjects(
    _ objects: UnsafeMutablePointer<AnyObject>?,
    andKeys keys: UnsafeMutablePointer<AnyObject>?,
    count: Int) {
    // Do nothing, we're empty
  }
}

----Swift.(file)._RawDictionaryStorage.empty
extension _RawDictionaryStorage  {
  internal static var empty: _EmptyDictionarySingleton {
    return Builtin.bridgeFromRawPointer(
      Builtin.addressof(&_swiftEmptyDictionarySingleton))
  }
}

----Swift.(file)._DictionaryStorage.copy(original:_RawDictionaryStorage)
extension _DictionaryStorage  {
  internal static func copy(
    original: _RawDictionaryStorage
  ) -> _DictionaryStorage {
    return allocate(
      scale: original._scale,
      age: original._age,
      seed: original._seed)
  }
}

----Swift.(file)._DictionaryStorage.resize(original:_RawDictionaryStorage,capacity:Int,move:Bool)
extension _DictionaryStorage  {
  static internal func resize(
    original: _RawDictionaryStorage,
    capacity: Int,
    move: Bool
  ) -> _DictionaryStorage {
    let scale = _HashTable.scale(forCapacity: capacity)
    return allocate(scale: scale, age: nil, seed: nil)
  }
}

----Swift.(file)._DictionaryStorage.allocate(capacity:Int)
extension _DictionaryStorage  {
  static internal func allocate(capacity: Int) -> _DictionaryStorage {
    let scale = _HashTable.scale(forCapacity: capacity)
    return allocate(scale: scale, age: nil, seed: nil)
  }
}

----Swift.(file)._DictionaryStorage.convert(_:<<error type>>,capacity:Int)
extension _DictionaryStorage  {
  static internal func convert(
    _ cocoa: _CocoaDictionary,
    capacity: Int
  ) -> _DictionaryStorage {
    let scale = _HashTable.scale(forCapacity: capacity)
    let age = _HashTable.age(for: cocoa.object)
    return allocate(scale: scale, age: age, seed: nil)
  }
}

----Swift.(file)._DictionaryStorage.allocate(scale:Int8,age:Int32?,seed:Int?)
extension _DictionaryStorage  {
  static internal func allocate(
    scale: Int8,
    age: Int32?,
    seed: Int?
  ) -> _DictionaryStorage {
    // The entry count must be representable by an Int value; hence the scale's
    // peculiar upper bound.
    _internalInvariant(scale >= 0 && scale < Int.bitWidth - 1)

    let bucketCount = (1 as Int) &<< scale
    let wordCount = _UnsafeBitset.wordCount(forCapacity: bucketCount)
    let storage = Builtin.allocWithTailElems_3(
      _DictionaryStorage<Key, Value>.self,
      wordCount._builtinWordValue, _HashTable.Word.self,
      bucketCount._builtinWordValue, Key.self,
      bucketCount._builtinWordValue, Value.self)

    let metadataAddr = Builtin.projectTailElems(storage, _HashTable.Word.self)
    let keysAddr = Builtin.getTailAddr_Word(
      metadataAddr, wordCount._builtinWordValue, _HashTable.Word.self,
      Key.self)
    let valuesAddr = Builtin.getTailAddr_Word(
      keysAddr, bucketCount._builtinWordValue, Key.self,
      Value.self)
    storage._count = 0
    storage._capacity = _HashTable.capacity(forScale: scale)
    storage._scale = scale
    storage._reservedScale = 0
    storage._extra = 0

    if let age = age {
      storage._age = age
    } else {
      // The default mutation count is simply a scrambled version of the storage
      // address.
      storage._age = Int32(
        truncatingIfNeeded: ObjectIdentifier(storage).hashValue)
    }

    storage._seed = seed ?? _HashTable.hashSeed(for: storage, scale: scale)
    storage._rawKeys = UnsafeMutableRawPointer(keysAddr)
    storage._rawValues = UnsafeMutableRawPointer(valuesAddr)

    // Initialize hash table metadata.
    storage._hashTable.clear()
    return storage
  }
}

----Swift.(file).LazyDropWhileSequence.Element
extension LazyDropWhileSequence {
  public typealias Element = Base.E
}

----Swift.(file).LazyDropWhileSequence.init(_base:Base,predicate:(LazyDropWhileSequence<Base>.Element) -> Bool)
extension LazyDropWhileSequence {
  internal init(_base: Base, predicate: @escaping (Element) -> Bool) {
    self._base = _base
    self._predicate = predicate
  }
}

----Swift.(file).LazyDropWhileSequence.Iterator.Element
extension LazyDropWhileSequence.Iterator {
    public typealias Element = Base.E
}

----Swift.(file).LazyDropWhileSequence.Iterator.init(_base:Base.Iterator,predicate:(LazyDropWhileSequence<Base>.Iterator.Element) -> Bool)
extension LazyDropWhileSequence.Iterator {
    internal init(_base: Base.Iterator, predicate: @escaping (Element) -> Bool) {
      self._base = _base
      self._predicate = predicate
    }
}

----Swift.(file).LazyDropWhileSequence.Iterator.next()
extension LazyDropWhileSequence.Iterator: IteratorProtocol  {
  public mutating func next() -> Element? {
    // Once the predicate has failed for the first time, the base iterator
    // can be used for the rest of the elements.
    if _predicateHasFailed {
      return _base.next()
    }

    // Retrieve and discard elements from the base iterator until one fails
    // the predicate.
    while let nextElement = _base.next() {
      if !_predicate(nextElement) {
        _predicateHasFailed = true
        return nextElement
      }
    }
    return nil
  }
}

----Swift.(file).LazyDropWhileSequence.makeIterator()
extension LazyDropWhileSequence: Sequence  {
  public __consuming func makeIterator() -> Iterator {
    return Iterator(_base: _base.makeIterator(), predicate: _predicate)
  }
}

----Swift.(file).LazyDropWhileSequence.Elements
extension LazyDropWhileSequence: LazySequenceProtocol  {
  public typealias Elements = L
}

----Swift.(file).LazySequenceProtocol.drop(while:(Self.Elements.Element) -> Bool)
extension LazySequenceProtocol  {
  public __consuming func drop(
    while predicate: @escaping (Elements.Element) -> Bool
  ) -> LazyDropWhileSequence<Self.Elements> {
    return LazyDropWhileSequence(_base: self.elements, predicate: predicate)
  }
}

----Swift.(file).LazyDropWhileCollection
public typealias LazyDropWhileCollection<T: Collection> = LazyDropWhileSequence<T>

----Swift.(file).LazyDropWhileCollection.SubSequence
extension LazyDropWhileCollection: Collection  {
  public typealias SubSequence = Slice<LazyDropWhileCollection<Base>>
}

----Swift.(file).LazyDropWhileCollection.Index
extension LazyDropWhileCollection: Collection  {
  public typealias Index = Base.I
}

----Swift.(file).LazyDropWhileCollection.startIndex
extension LazyDropWhileCollection: Collection  {
  public var startIndex: Index {
    var index = _base.startIndex
    while index != _base.endIndex && _predicate(_base[index]) {
      _base.formIndex(after: &index)
    }
    return index
  }
}

----Swift.(file).LazyDropWhileCollection.endIndex
extension LazyDropWhileCollection: Collection  {
  public var endIndex: Index {
    return _base.endIndex
  }
}

----Swift.(file).LazyDropWhileCollection.index(after:LazyDropWhileSequence<Base>.Index)
extension LazyDropWhileCollection: Collection  {
  public func index(after i: Index) -> Index {
    _precondition(i < _base.endIndex, "Can't advance past endIndex")
    return _base.index(after: i)
  }
}

----Swift.(file).LazyDropWhileCollection.subscript(_:LazyDropWhileSequence<Base>.Index)
extension LazyDropWhileCollection: Collection  {
  public subscript(position: Index) -> Element {
    return _base[position]
  }
}

----Swift.(file).LazyDropWhileCollection.index(before:LazyDropWhileSequence<Base>.Index)
extension LazyDropWhileCollection: BidirectionalCollection 
where Base: BidirectionalCollection  {
  public func index(before i: Index) -> Index {
    _precondition(i > startIndex, "Can't move before startIndex")
    return _base.index(before: i)
  }
}

----Swift.(file).dump(_:T,to:TargetStream,name:String?,indent:Int,maxDepth:Int,maxItems:Int)
public func dump<T, TargetStream : TextOutputStream>(
  _ value: T,
  to target: inout TargetStream,
  name: String? = nil,
  indent: Int = 0,
  maxDepth: Int = .max,
  maxItems: Int = .max
) -> T {
  var maxItemCounter = maxItems
  var visitedItems = [ObjectIdentifier : Int]()
  target._lock()
  defer { target._unlock() }
  _dump_unlocked(
    value,
    to: &target,
    name: name,
    indent: indent,
    maxDepth: maxDepth,
    maxItemCounter: &maxItemCounter,
    visitedItems: &visitedItems)
  return value
}

----Swift.(file).dump(_:T,name:String?,indent:Int,maxDepth:Int,maxItems:Int)
public func dump<T>(
  _ value: T,
  name: String? = nil,
  indent: Int = 0,
  maxDepth: Int = .max,
  maxItems: Int = .max
) -> T {
  var stdoutStream = _Stdout()
  return dump(
    value,
    to: &stdoutStream,
    name: name,
    indent: indent,
    maxDepth: maxDepth,
    maxItems: maxItems)
}

----Swift.(file).EmptyCollection.init()
extension EmptyCollection {
  public init() {}
}

----Swift.(file).EmptyCollection.Iterator.init()
extension EmptyCollection.Iterator {
    public init() {}
}

----Swift.(file).EmptyCollection.Iterator.next()
extension EmptyCollection.Iterator: IteratorProtocol, Sequence  {
  public mutating func next() -> Element? {
    return nil
  }
}

----Swift.(file).EmptyCollection.makeIterator()
extension EmptyCollection: Sequence  {
  public func makeIterator() -> Iterator {
    return Iterator()
  }
}

----Swift.(file).EmptyCollection.Index
extension EmptyCollection: RandomAccessCollection, MutableCollection  {
  public typealias Index = I
}

----Swift.(file).EmptyCollection.Indices
extension EmptyCollection: RandomAccessCollection, MutableCollection  {
  public typealias Indices = Range<Int>
}

----Swift.(file).EmptyCollection.SubSequence
extension EmptyCollection: RandomAccessCollection, MutableCollection  {
  public typealias SubSequence = EmptyCollection<Element>
}

----Swift.(file).EmptyCollection.startIndex
extension EmptyCollection: RandomAccessCollection, MutableCollection  {
  public var startIndex: Index {
    return 0
  }
}

----Swift.(file).EmptyCollection.endIndex
extension EmptyCollection: RandomAccessCollection, MutableCollection  {
  public var endIndex: Index {
    return 0
  }
}

----Swift.(file).EmptyCollection.index(after:EmptyCollection<Element>.Index)
extension EmptyCollection: RandomAccessCollection, MutableCollection  {
  public func index(after i: Index) -> Index {
    _preconditionFailure("EmptyCollection can't advance indices")
  }
}

----Swift.(file).EmptyCollection.index(before:EmptyCollection<Element>.Index)
extension EmptyCollection: RandomAccessCollection, MutableCollection  {
  public func index(before i: Index) -> Index {
    _preconditionFailure("EmptyCollection can't advance indices")
  }
}

----Swift.(file).EmptyCollection.subscript(_:EmptyCollection<Element>.Index)
extension EmptyCollection: RandomAccessCollection, MutableCollection  {
  public subscript(position: Index) -> Element {
    get {
      _preconditionFailure("Index out of range")
    }
    set {
      _preconditionFailure("Index out of range")
    }
  }
}

----Swift.(file).EmptyCollection.subscript(_:Range<EmptyCollection<Element>.Index>)
extension EmptyCollection: RandomAccessCollection, MutableCollection  {
  public subscript(bounds: Range<Index>) -> SubSequence {
    get {
      _debugPrecondition(bounds.lowerBound == 0 && bounds.upperBound == 0,
        "Index out of range")
      return self
    }
    set {
      _debugPrecondition(bounds.lowerBound == 0 && bounds.upperBound == 0,
        "Index out of range")
    }
  }
}

----Swift.(file).EmptyCollection.count
extension EmptyCollection: RandomAccessCollection, MutableCollection  {
  public var count: Int {
    return 0
  }
}

----Swift.(file).EmptyCollection.index(_:EmptyCollection<Element>.Index,offsetBy:Int)
extension EmptyCollection: RandomAccessCollection, MutableCollection  {
  public func index(_ i: Index, offsetBy n: Int) -> Index {
    _debugPrecondition(i == startIndex && n == 0, "Index out of range")
    return i
  }
}

----Swift.(file).EmptyCollection.index(_:EmptyCollection<Element>.Index,offsetBy:Int,limitedBy:EmptyCollection<Element>.Index)
extension EmptyCollection: RandomAccessCollection, MutableCollection  {
  public func index(
    _ i: Index, offsetBy n: Int, limitedBy limit: Index
  ) -> Index? {
    _debugPrecondition(i == startIndex && limit == startIndex,
      "Index out of range")
    return n == 0 ? i : nil
  }
}

----Swift.(file).EmptyCollection.distance(from:EmptyCollection<Element>.Index,to:EmptyCollection<Element>.Index)
extension EmptyCollection: RandomAccessCollection, MutableCollection  {
  public func distance(from start: Index, to end: Index) -> Int {
    _debugPrecondition(start == 0, "From must be startIndex (or endIndex)")
    _debugPrecondition(end == 0, "To must be endIndex (or startIndex)")
    return 0
  }
}

----Swift.(file).EmptyCollection.==infix(_:EmptyCollection<Element>,_:EmptyCollection<Element>)
extension EmptyCollection : Equatable  {
  public static func == (
    lhs: EmptyCollection<Element>, rhs: EmptyCollection<Element>
  ) -> Bool {
    return true
  }
}

----Swift.(file).Equatable.==infix(_:Self,_:Self)
extension Equatable {
  static func == (lhs: Self, rhs: Self) -> B
}

----Swift.(file).Equatable.!=infix(_:Self,_:Self)
extension Equatable  {
  public static func != (lhs: Self, rhs: Self) -> Bool {
    return !(lhs == rhs)
  }
}

----Swift.(file).===infix(_:AnyObject?,_:AnyObject?)
public func === (lhs: AnyObject?, rhs: AnyObject?) -> Bool {
  switch (lhs, rhs) {
  case let (l?, r?):
    return ObjectIdentifier(l) == ObjectIdentifier(r)
  case (nil, nil):
    return true
  default:
    return false
  }
}

----Swift.(file).!==infix(_:AnyObject?,_:AnyObject?)
public func !== (lhs: AnyObject?, rhs: AnyObject?) -> Bool {
  return !(lhs === rhs)
}

----Swift.(file).LazyFilterSequence.init(_base:Base,_:(Base.Element) -> Bool)
extension LazyFilterSequence {
  init(_base base: Base, _ isIncluded: @escaping (Base.Element) -> Bool) {
    self._base = base
    self._predicate = isIncluded
  }
}

----Swift.(file).LazyFilterSequence.Iterator.base
extension LazyFilterSequence.Iterator {
    public var base: Base.Iterator { return _base }
}

----Swift.(file).LazyFilterSequence.Iterator.init(_base:Base.Iterator,_:(Base.Element) -> Bool)
extension LazyFilterSequence.Iterator {
    internal init(_base: Base.Iterator, _ isIncluded: @escaping (Base.Element) -> Bool) {
      self._base = _base
      self._predicate = isIncluded
    }
}

----Swift.(file).LazyFilterSequence.Iterator.Element
extension LazyFilterSequence.Iterator: IteratorProtocol, Sequence  {
  public typealias Element = Base.E
}

----Swift.(file).LazyFilterSequence.Iterator.next()
extension LazyFilterSequence.Iterator: IteratorProtocol, Sequence  {
  public mutating func next() -> Element? {
    while let n = _base.next() {
      if _predicate(n) {
        return n
      }
    }
    return nil
  }
}

----Swift.(file).LazyFilterSequence.Element
extension LazyFilterSequence: Sequence  {
  public typealias Element = Base.E
}

----Swift.(file).LazyFilterSequence.makeIterator()
extension LazyFilterSequence: Sequence  {
  public __consuming func makeIterator() -> Iterator {
    return Iterator(_base: _base.makeIterator(), _predicate)
  }
}

----Swift.(file).LazyFilterCollection
public typealias LazyFilterCollection<T: Collection> = LazyFilterSequence<T>

----Swift.(file).LazyFilterCollection.SubSequence
extension LazyFilterCollection: Collection  {
  public typealias SubSequence = LazyFilterCollection<Base.SubSequence>
}

----Swift.(file).LazyFilterCollection.underestimatedCount
extension LazyFilterCollection: Collection  {
  public var underestimatedCount: Int { return 0 }
}

----Swift.(file).LazyFilterCollection.Index
extension LazyFilterCollection: Collection  {
  public typealias Index = Base.I
}

----Swift.(file).LazyFilterCollection.startIndex
extension LazyFilterCollection: Collection  {
  public var startIndex: Index {
    var index = _base.startIndex
    while index != _base.endIndex && !_predicate(_base[index]) {
      _base.formIndex(after: &index)
    }
    return index
  }
}

----Swift.(file).LazyFilterCollection.endIndex
extension LazyFilterCollection: Collection  {
  public var endIndex: Index {
    return _base.endIndex
  }
}

----Swift.(file).LazyFilterCollection.index(after:LazyFilterSequence<Base>.Index)
extension LazyFilterCollection: Collection  {
  public func index(after i: Index) -> Index {
    var i = i
    formIndex(after: &i)
    return i
  }
}

----Swift.(file).LazyFilterCollection.formIndex(after:LazyFilterSequence<Base>.Index)
extension LazyFilterCollection: Collection  {
  public func formIndex(after i: inout Index) {
    // TODO: swift-3-indexing-model: _failEarlyRangeCheck i?
    var index = i
    _precondition(index != _base.endIndex, "Can't advance past endIndex")
    repeat {
      _base.formIndex(after: &index)
    } while index != _base.endIndex && !_predicate(_base[index])
    i = index
  }
}

----Swift.(file).LazyFilterCollection.distance(from:LazyFilterSequence<Base>.Index,to:LazyFilterSequence<Base>.Index)
extension LazyFilterCollection: Collection  {
  public func distance(from start: Index, to end: Index) -> Int {
    // The following line makes sure that distance(from:to:) is invoked on the
    // _base at least once, to trigger a _precondition in forward only
    // collections.
    _ = _base.distance(from: start, to: end)
    var _start: Index
    let _end: Index
    let step: Int
    if start > end {
      _start = end
      _end = start
      step = -1
    }
    else {
      _start = start
      _end = end
      step = 1
    }
    var count = 0
    while _start != _end {
      count += step
      formIndex(after: &_start)
    }
    return count
  }
}

----Swift.(file).LazyFilterCollection.index(_:LazyFilterSequence<Base>.Index,offsetBy:Int)
extension LazyFilterCollection: Collection  {
  public func index(_ i: Index, offsetBy n: Int) -> Index {
    var i = i
    let step = n.signum()
    // The following line makes sure that index(_:offsetBy:) is invoked on the
    // _base at least once, to trigger a _precondition in forward only
    // collections.
    _ensureBidirectional(step: step)
    for _ in 0 ..< abs(numericCast(n)) {
      _advanceIndex(&i, step: step)
    }
    return i
  }
}

----Swift.(file).LazyFilterCollection.formIndex(_:LazyFilterSequence<Base>.Index,offsetBy:Int)
extension LazyFilterCollection: Collection  {
  public func formIndex(_ i: inout Index, offsetBy n: Int) {
    i = index(i, offsetBy: n)
  }
}

----Swift.(file).LazyFilterCollection.index(_:LazyFilterSequence<Base>.Index,offsetBy:Int,limitedBy:LazyFilterSequence<Base>.Index)
extension LazyFilterCollection: Collection  {
  public func index(
    _ i: Index, offsetBy n: Int, limitedBy limit: Index
  ) -> Index? {
    var i = i
    let step = n.signum()
    // The following line makes sure that index(_:offsetBy:limitedBy:) is
    // invoked on the _base at least once, to trigger a _precondition in
    // forward only collections.
    _ensureBidirectional(step: step)
    for _ in 0 ..< abs(numericCast(n)) {
      if i == limit {
        return nil
      }
      _advanceIndex(&i, step: step)
    }
    return i
  }
}

----Swift.(file).LazyFilterCollection.formIndex(_:LazyFilterSequence<Base>.Index,offsetBy:Int,limitedBy:LazyFilterSequence<Base>.Index)
extension LazyFilterCollection: Collection  {
  public func formIndex(
    _ i: inout Index, offsetBy n: Int, limitedBy limit: Index
  ) -> Bool {
    if let advancedIndex = index(i, offsetBy: n, limitedBy: limit) {
      i = advancedIndex
      return true
    }
    i = limit
    return false
  }
}

----Swift.(file).LazyFilterCollection.subscript(_:LazyFilterSequence<Base>.Index)
extension LazyFilterCollection: Collection  {
  public subscript(position: Index) -> Element {
    return _base[position]
  }
}

----Swift.(file).LazyFilterCollection.subscript(_:Range<LazyFilterSequence<Base>.Index>)
extension LazyFilterCollection: Collection  {
  public subscript(bounds: Range<Index>) -> SubSequence {
    return SubSequence(_base: _base[bounds], _predicate)
  }
}

----Swift.(file).LazyFilterCollection.index(before:LazyFilterSequence<Base>.Index)
extension LazyFilterCollection : BidirectionalCollection
  where Base : BidirectionalCollection  {
  public func index(before i: Index) -> Index {
    var i = i
    formIndex(before: &i)
    return i
  }
}

----Swift.(file).LazyFilterCollection.formIndex(before:LazyFilterSequence<Base>.Index)
extension LazyFilterCollection : BidirectionalCollection
  where Base : BidirectionalCollection  {
  public func formIndex(before i: inout Index) {
    // TODO: swift-3-indexing-model: _failEarlyRangeCheck i?
    var index = i
    _precondition(index != _base.startIndex, "Can't retreat before startIndex")
    repeat {
      _base.formIndex(before: &index)
    } while !_predicate(_base[index])
    i = index
  }
}

----Swift.(file).LazySequenceProtocol.filter(_:(Self.Elements.Element) -> Bool)
extension LazySequenceProtocol  {
  public __consuming func filter(
    _ isIncluded: @escaping (Elements.Element) -> Bool
  ) -> LazyFilterSequence<Self.Elements> {
    return LazyFilterSequence(_base: self.elements, isIncluded)
  }
}

----Swift.(file).LazyFilterSequence.filter(_:(LazyFilterSequence<Base>.Element) -> Bool)
extension LazyFilterSequence  {
  public __consuming func filter(
    _ isIncluded: @escaping (Element) -> Bool
  ) -> LazyFilterSequence<Base> {
    return LazyFilterSequence(_base: _base) {
      isIncluded($0) && self._predicate($0)
    }
  }
}

----Swift.(file).LazySequenceProtocol.flatMap(_:(Self.Elements.Element) -> SegmentOfResult)
extension LazySequenceProtocol  {
  public func flatMap<SegmentOfResult>(
    _ transform: @escaping (Elements.Element) -> SegmentOfResult
  ) -> LazySequence<
    FlattenSequence<LazyMapSequence<Elements, SegmentOfResult>>> {
    return self.map(transform).joined()
  }
}

----Swift.(file).LazySequenceProtocol.compactMap(_:(Self.Elements.Element) -> ElementOfResult?)
extension LazySequenceProtocol  {
  public func compactMap<ElementOfResult>(
    _ transform: @escaping (Elements.Element) -> ElementOfResult?
  ) -> LazyMapSequence<
    LazyFilterSequence<
      LazyMapSequence<Elements, ElementOfResult?>>,
    ElementOfResult
  > {
    return self.map(transform).filter { $0 != nil }.map { $0! }
  }
}

----Swift.(file).FlattenSequence.init(_base:Base)
extension FlattenSequence {
  internal init(_base: Base) {
    self._base = _base
  }
}

----Swift.(file).FlattenSequence.Iterator.init(_base:Base.Iterator)
extension FlattenSequence.Iterator {
    internal init(_base: Base.Iterator) {
      self._base = _base
    }
}

----Swift.(file).FlattenSequence.Iterator.Element
extension FlattenSequence.Iterator: IteratorProtocol  {
  public typealias Element = Base.Element.E
}

----Swift.(file).FlattenSequence.Iterator.next()
extension FlattenSequence.Iterator: IteratorProtocol  {
  public mutating func next() -> Element? {
    repeat {
      if _fastPath(_inner != nil) {
        let ret = _inner!.next()
        if _fastPath(ret != nil) {
          return ret
        }
      }
      let s = _base.next()
      if _slowPath(s == nil) {
        return nil
      }
      _inner = s!.makeIterator()
    }
    while true
  }
}

----Swift.(file).FlattenSequence.makeIterator()
extension FlattenSequence: Sequence  {
  public __consuming func makeIterator() -> Iterator {
    return Iterator(_base: _base.makeIterator())
  }
}

----Swift.(file).Sequence.joined()
extension Sequence where Element : Sequence  {
  public __consuming func joined() -> FlattenSequence<Self> {
    return FlattenSequence(_base: self)
  }
}

----Swift.(file).LazySequenceProtocol.joined()
extension LazySequenceProtocol where Element : Sequence  {
  public __consuming func joined() -> LazySequence<FlattenSequence<Elements>> {
    return FlattenSequence(_base: elements).lazy
  }
}

----Swift.(file).FlattenCollection
public typealias FlattenCollection<T: Collection> = FlattenSequence<T> where T.Element: C

----Swift.(file).FlattenSequence.Index.init(_:Base.Index,_:Base.Element.Index?)
extension FlattenSequence.Index {
    internal init(_ _outer: Base.Index, _ inner: Base.Element.Index?) {
      self._outer = _outer
      self._inner = inner
    }
}

----Swift.(file).FlattenSequence.Index.==infix(_:FlattenCollection<Base>.Index,_:FlattenCollection<Base>.Index)
extension FlattenSequence.Index : Equatable where Base: Collection, Base.Element: Collection  {
  public static func == (
    lhs: FlattenCollection<Base>.Index,
    rhs: FlattenCollection<Base>.Index
  ) -> Bool {
    return lhs._outer == rhs._outer && lhs._inner == rhs._inner
  }
}

----Swift.(file).FlattenSequence.Index.<infix(_:FlattenCollection<Base>.Index,_:FlattenCollection<Base>.Index)
extension FlattenSequence.Index : Comparable where Base: Collection, Base.Element: Collection  {
  public static func < (
    lhs: FlattenCollection<Base>.Index,
    rhs: FlattenCollection<Base>.Index
  ) -> Bool {
    // FIXME: swift-3-indexing-model: tests.
    if lhs._outer != rhs._outer {
      return lhs._outer < rhs._outer
    }

    if let lhsInner = lhs._inner, let rhsInner = rhs._inner {
      return lhsInner < rhsInner
    }

    // When combined, the two conditions above guarantee that both
    // `_outer` indices are `_base.endIndex` and both `_inner` indices
    // are `nil`, since `_inner` is `nil` iff `_outer == base.endIndex`.
    _precondition(lhs._inner == nil && rhs._inner == nil)

    return false
  }
}

----Swift.(file).FlattenSequence.Index.hash(into:Hasher)
extension FlattenSequence.Index : Hashable
  where Base: Collection, Base.Element: Collection, Base.Index : Hashable, Base.Element.Index : Hashable  {
  public func hash(into hasher: inout Hasher) {
    hasher.combine(_outer)
    hasher.combine(_inner)
  }
}

----Swift.(file).FlattenCollection.startIndex
extension FlattenCollection: Collection  {
  public var startIndex: Index {
    let end = _base.endIndex
    var outer = _base.startIndex
    while outer != end {
      let innerCollection = _base[outer]
      if !innerCollection.isEmpty {
        return Index(outer, innerCollection.startIndex)
      }
      _base.formIndex(after: &outer)
    }

    return endIndex
  }
}

----Swift.(file).FlattenCollection.endIndex
extension FlattenCollection: Collection  {
  public var endIndex: Index {
    return Index(_base.endIndex, nil)
  }
}

----Swift.(file).FlattenCollection.index(after:FlattenSequence<Base>.Index)
extension FlattenCollection: Collection  {
  public func index(after i: Index) -> Index {
    return _index(after: i)
  }
}

----Swift.(file).FlattenCollection.formIndex(after:FlattenSequence<Base>.Index)
extension FlattenCollection: Collection  {
  public func formIndex(after i: inout Index) {
    i = index(after: i)
  }
}

----Swift.(file).FlattenCollection.distance(from:FlattenSequence<Base>.Index,to:FlattenSequence<Base>.Index)
extension FlattenCollection: Collection  {
  public func distance(from start: Index, to end: Index) -> Int {
    // The following check makes sure that distance(from:to:) is invoked on the
    // _base at least once, to trigger a _precondition in forward only
    // collections.
    if end < start {
      _ = _base.distance(from: _base.endIndex, to: _base.startIndex)
    }
    var _start: Index
    let _end: Index
    let step: Int
    if start > end {
      _start = end
      _end = start
      step = -1
    }
    else {
      _start = start
      _end = end
      step = 1
    }
    var count = 0
    while _start != _end {
      count += step
      formIndex(after: &_start)
    }
    return count
  }
}

----Swift.(file).FlattenCollection.index(_:FlattenSequence<Base>.Index,offsetBy:Int)
extension FlattenCollection: Collection  {
  public func index(_ i: Index, offsetBy n: Int) -> Index {
    var i = i
    let step = n.signum()
    _ensureBidirectional(step: step)
    for _ in 0 ..< abs(n) {
      _advanceIndex(&i, step: step)
    }
    return i
  }
}

----Swift.(file).FlattenCollection.formIndex(_:FlattenSequence<Base>.Index,offsetBy:Int)
extension FlattenCollection: Collection  {
  public func formIndex(_ i: inout Index, offsetBy n: Int) {
    i = index(i, offsetBy: n)
  }
}

----Swift.(file).FlattenCollection.index(_:FlattenSequence<Base>.Index,offsetBy:Int,limitedBy:FlattenSequence<Base>.Index)
extension FlattenCollection: Collection  {
  public func index(
    _ i: Index, offsetBy n: Int, limitedBy limit: Index
  ) -> Index? {
    var i = i
    let step = n.signum()
    // The following line makes sure that index(_:offsetBy:limitedBy:) is
    // invoked on the _base at least once, to trigger a _precondition in
    // forward only collections.
    _ensureBidirectional(step: step)
    for _ in 0 ..< abs(n) {
      if i == limit {
        return nil
      }
      _advanceIndex(&i, step: step)
    }
    return i
  }
}

----Swift.(file).FlattenCollection.formIndex(_:FlattenSequence<Base>.Index,offsetBy:Int,limitedBy:FlattenSequence<Base>.Index)
extension FlattenCollection: Collection  {
  public func formIndex(
    _ i: inout Index, offsetBy n: Int, limitedBy limit: Index
  ) -> Bool {
    if let advancedIndex = index(i, offsetBy: n, limitedBy: limit) {
      i = advancedIndex
      return true
    }
    i = limit
    return false
  }
}

----Swift.(file).FlattenCollection.subscript(_:FlattenSequence<Base>.Index)
extension FlattenCollection: Collection  {
  public subscript(position: Index) -> Base.Element.Element {
    return _base[position._outer][position._inner!]
  }
}

----Swift.(file).FlattenCollection.subscript(_:Range<FlattenSequence<Base>.Index>)
extension FlattenCollection: Collection  {
  public subscript(bounds: Range<Index>) -> SubSequence {
    return Slice(base: self, bounds: bounds)
  }
}

----Swift.(file).FlattenCollection.index(before:FlattenSequence<Base>.Index)
extension FlattenCollection : BidirectionalCollection
  where Base : BidirectionalCollection, Base.Element : BidirectionalCollection  {
  public func index(before i: Index) -> Index {
    return _index(before: i)
  }
}

----Swift.(file).FlattenCollection.formIndex(before:FlattenSequence<Base>.Index)
extension FlattenCollection : BidirectionalCollection
  where Base : BidirectionalCollection, Base.Element : BidirectionalCollection  {
  public func formIndex(before i: inout Index) {
    i = index(before: i)
  }
}

----Swift.(file).FloatingPoint.Exponent
extension FloatingPoint {
  associatedtype Exponent: S
}

----Swift.(file).FloatingPoint.init(sign:FloatingPointSign,exponent:Self.Exponent,significand:Self)
extension FloatingPoint {
  init(sign: FloatingPointSign, exponent: Exponent, significand: Self)
}

----Swift.(file).FloatingPoint.init(signOf:Self,magnitudeOf:Self)
extension FloatingPoint {
  init(signOf: Self, magnitudeOf: Self)
}

----Swift.(file).FloatingPoint.init(_:Int)
extension FloatingPoint {
  init(_ value: Int)
}

----Swift.(file).FloatingPoint.init(_:Source)
extension FloatingPoint {
  init<Source : BinaryInteger>(_ value: Source)
}

----Swift.(file).FloatingPoint.init(exactly:Source)
extension FloatingPoint {
  init?<Source : BinaryInteger>(exactly value: Source)
}

----Swift.(file).FloatingPoint.radix
extension FloatingPoint {
  static var radix: Int { get }
}

----Swift.(file).FloatingPoint.nan
extension FloatingPoint {
  static var nan: Self { get }
}

----Swift.(file).FloatingPoint.signalingNaN
extension FloatingPoint {
  static var signalingNaN: Self { get }
}

----Swift.(file).FloatingPoint.infinity
extension FloatingPoint {
  static var infinity: Self { get }
}

----Swift.(file).FloatingPoint.greatestFiniteMagnitude
extension FloatingPoint {
  static var greatestFiniteMagnitude: Self { get }
}

----Swift.(file).FloatingPoint.pi
extension FloatingPoint {
  static var pi: Self { get }
}

----Swift.(file).FloatingPoint.ulp
extension FloatingPoint {
  var ulp: Self { get }
}

----Swift.(file).FloatingPoint.ulpOfOne
extension FloatingPoint {
  static var ulpOfOne: Self { get }
}

----Swift.(file).FloatingPoint.leastNormalMagnitude
extension FloatingPoint {
  static var leastNormalMagnitude: Self { get }
}

----Swift.(file).FloatingPoint.leastNonzeroMagnitude
extension FloatingPoint {
  static var leastNonzeroMagnitude: Self { get }
}

----Swift.(file).FloatingPoint.sign
extension FloatingPoint {
  var sign: FloatingPointSign { get }
}

----Swift.(file).FloatingPoint.exponent
extension FloatingPoint {
  var exponent: Exponent { get }
}

----Swift.(file).FloatingPoint.significand
extension FloatingPoint {
  var significand: Self { get }
}

----Swift.(file).FloatingPoint.+infix(_:Self,_:Self)
extension FloatingPoint {
  override static func +(lhs: Self, rhs: Self) -> S
}

----Swift.(file).FloatingPoint.+=infix(_:Self,_:Self)
extension FloatingPoint {
  override static func +=(lhs: inout Self, rhs: Self)
}

----Swift.(file).FloatingPoint.-prefix(_:Self)
extension FloatingPoint {
  override static prefix func - (_ operand: Self) -> S
}

----Swift.(file).FloatingPoint.negate()
extension FloatingPoint {
  override mutating func negate()
}

----Swift.(file).FloatingPoint.-infix(_:Self,_:Self)
extension FloatingPoint {
  override static func -(lhs: Self, rhs: Self) -> S
}

----Swift.(file).FloatingPoint.-=infix(_:Self,_:Self)
extension FloatingPoint {
  override static func -=(lhs: inout Self, rhs: Self)
}

----Swift.(file).FloatingPoint.*infix(_:Self,_:Self)
extension FloatingPoint {
  override static func *(lhs: Self, rhs: Self) -> S
}

----Swift.(file).FloatingPoint.*=infix(_:Self,_:Self)
extension FloatingPoint {
  override static func *=(lhs: inout Self, rhs: Self)
}

----Swift.(file).FloatingPoint./infix(_:Self,_:Self)
extension FloatingPoint {
  static func /(lhs: Self, rhs: Self) -> S
}

----Swift.(file).FloatingPoint./=infix(_:Self,_:Self)
extension FloatingPoint {
  static func /=(lhs: inout Self, rhs: Self)
}

----Swift.(file).FloatingPoint.remainder(dividingBy:Self)
extension FloatingPoint {
  func remainder(dividingBy other: Self) -> S
}

----Swift.(file).FloatingPoint.formRemainder(dividingBy:Self)
extension FloatingPoint {
  mutating func formRemainder(dividingBy other: Self)
}

----Swift.(file).FloatingPoint.truncatingRemainder(dividingBy:Self)
extension FloatingPoint {
  func truncatingRemainder(dividingBy other: Self) -> S
}

----Swift.(file).FloatingPoint.formTruncatingRemainder(dividingBy:Self)
extension FloatingPoint {
  mutating func formTruncatingRemainder(dividingBy other: Self)
}

----Swift.(file).FloatingPoint.squareRoot()
extension FloatingPoint {
  func squareRoot() -> S
}

----Swift.(file).FloatingPoint.formSquareRoot()
extension FloatingPoint {
  mutating func formSquareRoot()
}

----Swift.(file).FloatingPoint.addingProduct(_:Self,_:Self)
extension FloatingPoint {
  func addingProduct(_ lhs: Self, _ rhs: Self) -> S
}

----Swift.(file).FloatingPoint.addProduct(_:Self,_:Self)
extension FloatingPoint {
  mutating func addProduct(_ lhs: Self, _ rhs: Self)
}

----Swift.(file).FloatingPoint.minimum(_:Self,_:Self)
extension FloatingPoint {
  static func minimum(_ x: Self, _ y: Self) -> S
}

----Swift.(file).FloatingPoint.maximum(_:Self,_:Self)
extension FloatingPoint {
  static func maximum(_ x: Self, _ y: Self) -> S
}

----Swift.(file).FloatingPoint.minimumMagnitude(_:Self,_:Self)
extension FloatingPoint {
  static func minimumMagnitude(_ x: Self, _ y: Self) -> S
}

----Swift.(file).FloatingPoint.maximumMagnitude(_:Self,_:Self)
extension FloatingPoint {
  static func maximumMagnitude(_ x: Self, _ y: Self) -> S
}

----Swift.(file).FloatingPoint.rounded(_:FloatingPointRoundingRule)
extension FloatingPoint {
  func rounded(_ rule: FloatingPointRoundingRule) -> S
}

----Swift.(file).FloatingPoint.round(_:FloatingPointRoundingRule)
extension FloatingPoint {
  mutating func round(_ rule: FloatingPointRoundingRule)
}

----Swift.(file).FloatingPoint.nextUp
extension FloatingPoint {
  var nextUp: Self { get }
}

----Swift.(file).FloatingPoint.nextDown
extension FloatingPoint {
  var nextDown: Self { get }
}

----Swift.(file).FloatingPoint.isEqual(to:Self)
extension FloatingPoint {
  func isEqual(to other: Self) -> B
}

----Swift.(file).FloatingPoint.isLess(than:Self)
extension FloatingPoint {
  func isLess(than other: Self) -> B
}

----Swift.(file).FloatingPoint.isLessThanOrEqualTo(_:Self)
extension FloatingPoint {
  func isLessThanOrEqualTo(_ other: Self) -> B
}

----Swift.(file).FloatingPoint.isTotallyOrdered(belowOrEqualTo:Self)
extension FloatingPoint {
  func isTotallyOrdered(belowOrEqualTo other: Self) -> B
}

----Swift.(file).FloatingPoint.isNormal
extension FloatingPoint {
  var isNormal: Bool { get }
}

----Swift.(file).FloatingPoint.isZero
extension FloatingPoint {
  var isZero: Bool { get }
}

----Swift.(file).FloatingPoint.isSubnormal
extension FloatingPoint {
  var isSubnormal: Bool { get }
}

----Swift.(file).FloatingPoint.isInfinite
extension FloatingPoint {
  var isInfinite: Bool { get }
}

----Swift.(file).FloatingPoint.isSignalingNaN
extension FloatingPoint {
  var isSignalingNaN: Bool { get }
}

----Swift.(file).FloatingPoint.floatingPointClass
extension FloatingPoint {
  var floatingPointClass: FloatingPointClassification { get }
}

----Swift.(file).FloatingPoint.isCanonical
extension FloatingPoint {
  var isCanonical: Bool { get }
}

----Swift.(file).FloatingPointSign.plus
extension FloatingPointSign {
  case p
}

----Swift.(file).FloatingPointSign.minus
extension FloatingPointSign {
  case m
}

----Swift.(file).FloatingPointSign.init(rawValue:Int)
extension FloatingPointSign {
  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .plus
    case 1: self = .minus
    default: return nil
    }
  }
}

----Swift.(file).FloatingPointSign.rawValue
extension FloatingPointSign {
  public var rawValue: Int {
    switch self {
    case .plus: return 0
    case .minus: return 1
    }
  }
}

----Swift.(file).FloatingPointSign.==infix(_:FloatingPointSign,_:FloatingPointSign)
extension FloatingPointSign {
  public static func ==(a: FloatingPointSign, b: FloatingPointSign) -> Bool {
    return a.rawValue == b.rawValue
  }
}

----Swift.(file).FloatingPointSign.hashValue
extension FloatingPointSign {
  public var hashValue: Int { return rawValue.hashValue }
}

----Swift.(file).FloatingPointSign.hash(into:Hasher)
extension FloatingPointSign {
  public func hash(into hasher: inout Hasher) {
    hasher.combine(rawValue)
  }
}

----Swift.(file).FloatingPointClassification.signalingNaN
extension FloatingPointClassification {
  case s
}

----Swift.(file).FloatingPointClassification.quietNaN
extension FloatingPointClassification {
  case q
}

----Swift.(file).FloatingPointClassification.negativeInfinity
extension FloatingPointClassification {
  case n
}

----Swift.(file).FloatingPointClassification.negativeNormal
extension FloatingPointClassification {
  case n
}

----Swift.(file).FloatingPointClassification.negativeSubnormal
extension FloatingPointClassification {
  case n
}

----Swift.(file).FloatingPointClassification.negativeZero
extension FloatingPointClassification {
  case n
}

----Swift.(file).FloatingPointClassification.positiveZero
extension FloatingPointClassification {
  case p
}

----Swift.(file).FloatingPointClassification.positiveSubnormal
extension FloatingPointClassification {
  case p
}

----Swift.(file).FloatingPointClassification.positiveNormal
extension FloatingPointClassification {
  case p
}

----Swift.(file).FloatingPointClassification.positiveInfinity
extension FloatingPointClassification {
  case p
}

----Swift.(file).FloatingPointRoundingRule.toNearestOrAwayFromZero
extension FloatingPointRoundingRule {
  case t
}

----Swift.(file).FloatingPointRoundingRule.toNearestOrEven
extension FloatingPointRoundingRule {
  case t
}

----Swift.(file).FloatingPointRoundingRule.up
extension FloatingPointRoundingRule {
  case u
}

----Swift.(file).FloatingPointRoundingRule.down
extension FloatingPointRoundingRule {
  case d
}

----Swift.(file).FloatingPointRoundingRule.towardZero
extension FloatingPointRoundingRule {
  case t
}

----Swift.(file).FloatingPointRoundingRule.awayFromZero
extension FloatingPointRoundingRule {
  case a
}

----Swift.(file).FloatingPoint.==infix(_:Self,_:Self)
extension FloatingPoint  {
  public static func == (lhs: Self, rhs: Self) -> Bool {
    return lhs.isEqual(to: rhs)
  }
}

----Swift.(file).FloatingPoint.<infix(_:Self,_:Self)
extension FloatingPoint  {
  public static func < (lhs: Self, rhs: Self) -> Bool {
    return lhs.isLess(than: rhs)
  }
}

----Swift.(file).FloatingPoint.<=infix(_:Self,_:Self)
extension FloatingPoint  {
  public static func <= (lhs: Self, rhs: Self) -> Bool {
    return lhs.isLessThanOrEqualTo(rhs)
  }
}

----Swift.(file).FloatingPoint.>infix(_:Self,_:Self)
extension FloatingPoint  {
  public static func > (lhs: Self, rhs: Self) -> Bool {
    return rhs.isLess(than: lhs)
  }
}

----Swift.(file).FloatingPoint.>=infix(_:Self,_:Self)
extension FloatingPoint  {
  public static func >= (lhs: Self, rhs: Self) -> Bool {
    return rhs.isLessThanOrEqualTo(lhs)
  }
}

----Swift.(file).BinaryFloatingPoint.RawSignificand
extension BinaryFloatingPoint {
  associatedtype RawSignificand: U
}

----Swift.(file).BinaryFloatingPoint.RawExponent
extension BinaryFloatingPoint {
  associatedtype RawExponent: U
}

----Swift.(file).BinaryFloatingPoint.init(sign:FloatingPointSign,exponentBitPattern:Self.RawExponent,significandBitPattern:Self.RawSignificand)
extension BinaryFloatingPoint {
  init(sign: FloatingPointSign,
       exponentBitPattern: RawExponent,
       significandBitPattern: RawSignificand)
}

----Swift.(file).BinaryFloatingPoint.init(_:Float)
extension BinaryFloatingPoint {
  init(_ value: Float)
}

----Swift.(file).BinaryFloatingPoint.init(_:Double)
extension BinaryFloatingPoint {
  init(_ value: Double)
}

----Swift.(file).BinaryFloatingPoint.init(_:Float80)
extension BinaryFloatingPoint {
  init(_ value: Float80)
}

----Swift.(file).BinaryFloatingPoint.init(_:Source)
extension BinaryFloatingPoint {
  init<Source : BinaryFloatingPoint>(_ value: Source)
}

----Swift.(file).BinaryFloatingPoint.init(exactly:Source)
extension BinaryFloatingPoint {
  init?<Source : BinaryFloatingPoint>(exactly value: Source)
}

----Swift.(file).BinaryFloatingPoint.exponentBitCount
extension BinaryFloatingPoint {
  static var exponentBitCount: Int { get }
}

----Swift.(file).BinaryFloatingPoint.significandBitCount
extension BinaryFloatingPoint {
  static var significandBitCount: Int { get }
}

----Swift.(file).BinaryFloatingPoint.exponentBitPattern
extension BinaryFloatingPoint {
  var exponentBitPattern: RawExponent { get }
}

----Swift.(file).BinaryFloatingPoint.significandBitPattern
extension BinaryFloatingPoint {
  var significandBitPattern: RawSignificand { get }
}

----Swift.(file).BinaryFloatingPoint.binade
extension BinaryFloatingPoint {
  var binade: Self { get }
}

----Swift.(file).BinaryFloatingPoint.significandWidth
extension BinaryFloatingPoint {
  var significandWidth: Int { get }
}

----Swift.(file).FloatingPoint.ulpOfOne
extension FloatingPoint  {
  public static var ulpOfOne: Self {
    return (1 as Self).ulp
  }
}

----Swift.(file).FloatingPoint.rounded(_:FloatingPointRoundingRule)
extension FloatingPoint  {
  public func rounded(_ rule: FloatingPointRoundingRule) -> Self {
    var lhs = self
    lhs.round(rule)
    return lhs
  }
}

----Swift.(file).FloatingPoint.rounded()
extension FloatingPoint  {
  public func rounded() -> Self {
    return rounded(.toNearestOrAwayFromZero)
  }
}

----Swift.(file).FloatingPoint.round()
extension FloatingPoint  {
  public mutating func round() {
    round(.toNearestOrAwayFromZero)
  }
}

----Swift.(file).FloatingPoint.nextDown
extension FloatingPoint  {
  public var nextDown: Self {
    @inline(__always)
    get {
      return -(-self).nextUp
    }
  }
}

----Swift.(file).FloatingPoint.truncatingRemainder(dividingBy:Self)
extension FloatingPoint  {
  public func truncatingRemainder(dividingBy other: Self) -> Self {
    var lhs = self
    lhs.formTruncatingRemainder(dividingBy: other)
    return lhs
  }
}

----Swift.(file).FloatingPoint.remainder(dividingBy:Self)
extension FloatingPoint  {
  public func remainder(dividingBy other: Self) -> Self {
    var lhs = self
    lhs.formRemainder(dividingBy: other)
    return lhs
  }
}

----Swift.(file).FloatingPoint.squareRoot()
extension FloatingPoint  {
  public func squareRoot( ) -> Self {
    var lhs = self
    lhs.formSquareRoot( )
    return lhs
  }
}

----Swift.(file).FloatingPoint.addingProduct(_:Self,_:Self)
extension FloatingPoint  {
  public func addingProduct(_ lhs: Self, _ rhs: Self) -> Self {
    var addend = self
    addend.addProduct(lhs, rhs)
    return addend
  }
}

----Swift.(file).FloatingPoint.minimum(_:Self,_:Self)
extension FloatingPoint  {
  public static func minimum(_ x: Self, _ y: Self) -> Self {
    if x.isSignalingNaN || y.isSignalingNaN {
      //  Produce a quiet NaN matching platform arithmetic behavior.
      return x + y
    }
    if x <= y || y.isNaN { return x }
    return y
  }
}

----Swift.(file).FloatingPoint.maximum(_:Self,_:Self)
extension FloatingPoint  {
  public static func maximum(_ x: Self, _ y: Self) -> Self {
    if x.isSignalingNaN || y.isSignalingNaN {
      //  Produce a quiet NaN matching platform arithmetic behavior.
      return x + y
    }
    if x > y || y.isNaN { return x }
    return y
  }
}

----Swift.(file).FloatingPoint.minimumMagnitude(_:Self,_:Self)
extension FloatingPoint  {
  public static func minimumMagnitude(_ x: Self, _ y: Self) -> Self {
    if x.isSignalingNaN || y.isSignalingNaN {
      //  Produce a quiet NaN matching platform arithmetic behavior.
      return x + y
    }
    if x.magnitude <= y.magnitude || y.isNaN { return x }
    return y
  }
}

----Swift.(file).FloatingPoint.maximumMagnitude(_:Self,_:Self)
extension FloatingPoint  {
  public static func maximumMagnitude(_ x: Self, _ y: Self) -> Self {
    if x.isSignalingNaN || y.isSignalingNaN {
      //  Produce a quiet NaN matching platform arithmetic behavior.
      return x + y
    }
    if x.magnitude > y.magnitude || y.isNaN { return x }
    return y
  }
}

----Swift.(file).FloatingPoint.floatingPointClass
extension FloatingPoint  {
  public var floatingPointClass: FloatingPointClassification {
    if isSignalingNaN { return .signalingNaN }
    if isNaN { return .quietNaN }
    if isInfinite { return sign == .minus ? .negativeInfinity : .positiveInfinity }
    if isNormal { return sign == .minus ? .negativeNormal : .positiveNormal }
    if isSubnormal { return sign == .minus ? .negativeSubnormal : .positiveSubnormal }
    return sign == .minus ? .negativeZero : .positiveZero
  }
}

----Swift.(file).BinaryFloatingPoint.radix
extension BinaryFloatingPoint  {
  public static var radix: Int { return 2 }
}

----Swift.(file).BinaryFloatingPoint.init(signOf:Self,magnitudeOf:Self)
extension BinaryFloatingPoint  {
  public init(signOf: Self, magnitudeOf: Self) {
    self.init(sign: signOf.sign,
      exponentBitPattern: magnitudeOf.exponentBitPattern,
      significandBitPattern: magnitudeOf.significandBitPattern)
  }
}

----Swift.(file).BinaryFloatingPoint.init(_:Source)
extension BinaryFloatingPoint  {
  public init<Source : BinaryFloatingPoint>(_ value: Source) {
    self = Self._convert(from: value).value
  }
}

----Swift.(file).BinaryFloatingPoint.init(exactly:Source)
extension BinaryFloatingPoint  {
  public init?<Source : BinaryFloatingPoint>(exactly value: Source) {
    let (value_, exact) = Self._convert(from: value)
    guard exact else { return nil }
    self = value_
  }
}

----Swift.(file).BinaryFloatingPoint.isTotallyOrdered(belowOrEqualTo:Self)
extension BinaryFloatingPoint  {
  public func isTotallyOrdered(belowOrEqualTo other: Self) -> Bool {
    // Quick return when possible.
    if self < other { return true }
    if other > self { return false }
    // Self and other are either equal or unordered.
    // Every negative-signed value (even NaN) is less than every positive-
    // signed value, so if the signs do not match, we simply return the
    // sign bit of self.
    if sign != other.sign { return sign == .minus }
    // Sign bits match; look at exponents.
    if exponentBitPattern > other.exponentBitPattern { return sign == .minus }
    if exponentBitPattern < other.exponentBitPattern { return sign == .plus }
    // Signs and exponents match, look at significands.
    if significandBitPattern > other.significandBitPattern {
      return sign == .minus
    }
    if significandBitPattern < other.significandBitPattern {
      return sign == .plus
    }
    //  Sign, exponent, and significand all match.
    return true
  }
}

----Swift.(file).BinaryFloatingPoint.init(_:Source)
extension BinaryFloatingPoint where Self.RawSignificand : FixedWidthInteger  {
  public init<Source : BinaryInteger>(_ value: Source) {
    self = Self._convert(from: value).value
  }
}

----Swift.(file).BinaryFloatingPoint.init(exactly:Source)
extension BinaryFloatingPoint where Self.RawSignificand : FixedWidthInteger  {
  public init?<Source : BinaryInteger>(exactly value: Source) {
    let (value_, exact) = Self._convert(from: value)
    guard exact else { return nil }
    self = value_
  }
}

----Swift.(file).BinaryFloatingPoint.random(in:Range<Self>,using:T)
extension BinaryFloatingPoint where Self.RawSignificand : FixedWidthInteger  {
  public static func random<T: RandomNumberGenerator>(
    in range: Range<Self>,
    using generator: inout T
  ) -> Self {
    _precondition(
      !range.isEmpty,
      "Can't get random value with an empty range"
    )
    let delta = range.upperBound - range.lowerBound
    //  TODO: this still isn't quite right, because the computation of delta
    //  can overflow (e.g. if .upperBound = .maximumFiniteMagnitude and
    //  .lowerBound = -.upperBound); this should be re-written with an
    //  algorithm that handles that case correctly, but this precondition
    //  is an acceptable short-term fix.
    _precondition(
      delta.isFinite,
      "There is no uniform distribution on an infinite range"
    )
    let rand: Self.RawSignificand
    if Self.RawSignificand.bitWidth == Self.significandBitCount + 1 {
      rand = generator.next()
    } else {
      let significandCount = Self.significandBitCount + 1
      let maxSignificand: Self.RawSignificand = 1 << significandCount
      // Rather than use .next(upperBound:), which has to work with arbitrary
      // upper bounds, and therefore does extra work to avoid bias, we can take
      // a shortcut because we know that maxSignificand is a power of two.
      rand = generator.next() & (maxSignificand - 1)
    }
    let unitRandom = Self.init(rand) * (Self.ulpOfOne / 2)
    let randFloat = delta * unitRandom + range.lowerBound
    if randFloat == range.upperBound {
      return Self.random(in: range, using: &generator)
    }
    return randFloat
  }
}

----Swift.(file).BinaryFloatingPoint.random(in:Range<Self>)
extension BinaryFloatingPoint where Self.RawSignificand : FixedWidthInteger  {
  public static func random(in range: Range<Self>) -> Self {
    var g = SystemRandomNumberGenerator()
    return Self.random(in: range, using: &g)
  }
}

----Swift.(file).BinaryFloatingPoint.random(in:ClosedRange<Self>,using:T)
extension BinaryFloatingPoint where Self.RawSignificand : FixedWidthInteger  {
  public static func random<T: RandomNumberGenerator>(
    in range: ClosedRange<Self>,
    using generator: inout T
  ) -> Self {
    _precondition(
      !range.isEmpty,
      "Can't get random value with an empty range"
    )
    let delta = range.upperBound - range.lowerBound
    //  TODO: this still isn't quite right, because the computation of delta
    //  can overflow (e.g. if .upperBound = .maximumFiniteMagnitude and
    //  .lowerBound = -.upperBound); this should be re-written with an
    //  algorithm that handles that case correctly, but this precondition
    //  is an acceptable short-term fix.
    _precondition(
      delta.isFinite,
      "There is no uniform distribution on an infinite range"
    )
    let rand: Self.RawSignificand
    if Self.RawSignificand.bitWidth == Self.significandBitCount + 1 {
      rand = generator.next()
      let tmp: UInt8 = generator.next() & 1
      if rand == Self.RawSignificand.max && tmp == 1 {
        return range.upperBound
      }
    } else {
      let significandCount = Self.significandBitCount + 1
      let maxSignificand: Self.RawSignificand = 1 << significandCount
      rand = generator.next(upperBound: maxSignificand + 1)
      if rand == maxSignificand {
        return range.upperBound
      }
    }
    let unitRandom = Self.init(rand) * (Self.ulpOfOne / 2)
    let randFloat = delta * unitRandom + range.lowerBound
    return randFloat
  }
}

----Swift.(file).BinaryFloatingPoint.random(in:ClosedRange<Self>)
extension BinaryFloatingPoint where Self.RawSignificand : FixedWidthInteger  {
  public static func random(in range: ClosedRange<Self>) -> Self {
    var g = SystemRandomNumberGenerator()
    return Self.random(in: range, using: &g)
  }
}

----Swift.(file)._HashTable.maxLoadFactor
extension _HashTable  {
  private static var maxLoadFactor: Double {
    @inline(__always) get { return 3 / 4 }
  }
}

----Swift.(file)._HashTable.capacity(forScale:Int8)
extension _HashTable  {
  internal static func capacity(forScale scale: Int8) -> Int {
    let bucketCount = (1 as Int) &<< scale
    return Int(Double(bucketCount) * maxLoadFactor)
  }
}

----Swift.(file)._HashTable.scale(forCapacity:Int)
extension _HashTable  {
  internal static func scale(forCapacity capacity: Int) -> Int8 {
    let capacity = Swift.max(capacity, 1)
    // Calculate the minimum number of entries we need to allocate to satisfy
    // the maximum load factor. `capacity + 1` below ensures that we always
    // leave at least one hole.
    let minimumEntries = Swift.max(
      Int((Double(capacity) / maxLoadFactor).rounded(.up)),
      capacity + 1)
    // The actual number of entries we need to allocate is the lowest power of
    // two greater than or equal to the minimum entry count. Calculate its
    // exponent.
    let exponent = (Swift.max(minimumEntries, 2) - 1)._binaryLogarithm() + 1
    _internalInvariant(exponent >= 0 && exponent < Int.bitWidth)
    // The scale is the exponent corresponding to the bucket count.
    let scale = Int8(truncatingIfNeeded: exponent)
    _internalInvariant(self.capacity(forScale: scale) >= capacity)
    return scale
  }
}

----Swift.(file)._HashTable.age(for:AnyObject)
extension _HashTable  {
  internal static func age(for cocoa: AnyObject) -> Int32 {
    let hash = ObjectIdentifier(cocoa).hashValue
    return Int32(truncatingIfNeeded: hash)
  }
}

----Swift.(file)._HashTable.hashSeed(for:AnyObject,scale:Int8)
extension _HashTable  {
  internal static func hashSeed(
    for object: AnyObject,
    scale: Int8
  ) -> Int {
    // We generate a new hash seed whenever a new hash table is allocated and
    // whenever an existing table is resized, so that we avoid certain copy
    // operations becoming quadratic.  (For background details, see
    // https://bugs.swift.org/browse/SR-3268)
    //
    // Note that we do reuse the existing seed when making copy-on-write copies
    // so that we avoid breaking value semantics.
    if Hasher._isDeterministic {
      // When we're using deterministic hashing, the scale value as the seed is
      // still allowed, and it covers most cases. (Unfortunately some operations
      // that merge two similar-sized hash tables will still be quadratic.)
      return Int(scale)
    }
    // Use the object address as the hash seed. This is cheaper than
    // SystemRandomNumberGenerator, while it has the same practical effect.
    // Addresses aren't entirely random, but that's not the goal here -- the
    // 128-bit execution seed takes care of randomization. We only need to
    // guarantee that no two tables with the same seed can coexist at the same
    // time (apart from copy-on-write derivatives of the same table).
    return unsafeBitCast(object, to: Int.self)
  }
}

----Swift.(file)._HashTable.Bucket.==infix(_:_HashTable.Bucket,_:_HashTable.Bucket)
extension _HashTable.Bucket: Equatable  {
  static func == (lhs: _HashTable.Bucket, rhs: _HashTable.Bucket) -> Bool {
    return lhs.offset == rhs.offset
  }
}

----Swift.(file)._HashTable.Bucket.<infix(_:_HashTable.Bucket,_:_HashTable.Bucket)
extension _HashTable.Bucket: Comparable  {
  static func < (lhs: _HashTable.Bucket, rhs: _HashTable.Bucket) -> Bool {
    return lhs.offset < rhs.offset
  }
}

----Swift.(file)._HashTable.Index.==infix(_:_HashTable.Index,_:_HashTable.Index)
extension _HashTable.Index: Equatable  {
  internal static func ==(
    lhs: _HashTable.Index,
    rhs: _HashTable.Index
  ) -> Bool {
    _precondition(lhs.age == rhs.age,
      "Can't compare indices belonging to different collections")
    return lhs.bucket == rhs.bucket
  }
}

----Swift.(file)._HashTable.Index.<infix(_:_HashTable.Index,_:_HashTable.Index)
extension _HashTable.Index: Comparable  {
  internal static func <(
    lhs: _HashTable.Index,
    rhs: _HashTable.Index
  ) -> Bool {
    _precondition(lhs.age == rhs.age,
      "Can't compare indices belonging to different collections")
    return lhs.bucket < rhs.bucket
  }
}

----Swift.(file)._HashTable.makeIterator()
extension _HashTable: Sequence  {
  internal func makeIterator() -> Iterator {
    return Iterator(self)
  }
}

----Swift.(file)._HashTable.isValid(_:_HashTable.Bucket)
extension _HashTable  {
  internal func isValid(_ bucket: Bucket) -> Bool {
    return bucket.offset >= 0 && bucket.offset < bucketCount
  }
}

----Swift.(file)._HashTable.isOccupied(_:_HashTable.Bucket)
extension _HashTable  {
  internal func isOccupied(_ bucket: Bucket) -> Bool {
    return isValid(bucket) && _isOccupied(bucket)
  }
}

----Swift.(file)._HashTable.checkOccupied(_:_HashTable.Bucket)
extension _HashTable  {
  internal func checkOccupied(_ bucket: Bucket) {
    _precondition(isOccupied(bucket),
      "Attempting to access Collection elements using an invalid Index")
  }
}

----Swift.(file)._HashTable.occupiedBucket(after:_HashTable.Bucket)
extension _HashTable  {
  internal func occupiedBucket(after bucket: Bucket) -> Bucket {
    _internalInvariant(isValid(bucket))
    let word = bucket.word
    if let bit = words[word].intersecting(elementsAbove: bucket.bit).minimum {
      return Bucket(word: word, bit: bit)
    }
    return _firstOccupiedBucket(fromWord: word + 1)
  }
}

----Swift.(file)._HashTable.startBucket
extension _HashTable  {
  internal var startBucket: Bucket {
    return _firstOccupiedBucket(fromWord: 0)
  }
}

----Swift.(file)._HashTable.endBucket
extension _HashTable  {
  internal var endBucket: Bucket {
    @inline(__always)
    get {
      return Bucket(offset: bucketCount)
    }
  }
}

----Swift.(file)._HashTable.idealBucket(forHashValue:Int)
extension _HashTable  {
  internal func idealBucket(forHashValue hashValue: Int) -> Bucket {
    return Bucket(offset: hashValue & bucketMask)
  }
}

----Swift.(file)._HashTable.bucket(wrappedAfter:_HashTable.Bucket)
extension _HashTable  {
  internal func bucket(wrappedAfter bucket: Bucket) -> Bucket {
    // The bucket is less than bucketCount, which is power of two less than
    // Int.max. Therefore adding 1 does not overflow.
    return Bucket(offset: (bucket.offset &+ 1) & bucketMask)
  }
}

----Swift.(file)._HashTable.previousHole(before:_HashTable.Bucket)
extension _HashTable  {
  internal func previousHole(before bucket: Bucket) -> Bucket {
    _internalInvariant(isValid(bucket))
    // Note that if we have only a single partial word, its out-of-bounds bits
    // are guaranteed to be all set, so the formula below gives correct results.
    var word = bucket.word
    if let bit =
      words[word]
        .complement
        .intersecting(elementsBelow: bucket.bit)
        .maximum {
      return Bucket(word: word, bit: bit)
    }
    var wrap = false
    while true {
      word -= 1
      if word < 0 {
        _precondition(!wrap, "Hash table has no holes")
        wrap = true
        word = wordCount - 1
      }
      if let bit = words[word].complement.maximum {
        return Bucket(word: word, bit: bit)
      }
    }
  }
}

----Swift.(file)._HashTable.nextHole(atOrAfter:_HashTable.Bucket)
extension _HashTable  {
  internal func nextHole(atOrAfter bucket: Bucket) -> Bucket {
    _internalInvariant(isValid(bucket))
    // Note that if we have only a single partial word, its out-of-bounds bits
    // are guaranteed to be all set, so the formula below gives correct results.
    var word = bucket.word
    if let bit =
      words[word]
        .complement
        .subtracting(elementsBelow: bucket.bit)
        .minimum {
      return Bucket(word: word, bit: bit)
    }
    var wrap = false
    while true {
      word &+= 1
      if word == wordCount {
        _precondition(!wrap, "Hash table has no holes")
        wrap = true
        word = 0
      }
      if let bit = words[word].complement.minimum {
        return Bucket(word: word, bit: bit)
      }
    }
  }
}

----Swift.(file)._HashTable.copyContents(of:_HashTable)
extension _HashTable  {
  internal func copyContents(of other: _HashTable) {
    _internalInvariant(bucketCount == other.bucketCount)
    self.words.assign(from: other.words, count: wordCount)
  }
}

----Swift.(file)._HashTable.insertNew(hashValue:Int)
extension _HashTable  {
  internal func insertNew(hashValue: Int) -> Bucket {
    let hole = nextHole(atOrAfter: idealBucket(forHashValue: hashValue))
    insert(hole)
    return hole
  }
}

----Swift.(file)._HashTable.insert(_:_HashTable.Bucket)
extension _HashTable  {
  internal func insert(_ bucket: Bucket) {
    _internalInvariant(!isOccupied(bucket))
    words[bucket.word].uncheckedInsert(bucket.bit)
  }
}

----Swift.(file)._HashTable.clear()
extension _HashTable  {
  internal func clear() {
    if bucketCount < Word.capacity {
      // We have only a single partial word. Set all out of bounds bits, so that
      // `occupiedBucket(after:)` and `nextHole(atOrAfter:)` works correctly
      // without a special case.
      words[0] = Word.allBits.subtracting(elementsBelow: bucketCount)
    } else {
      words.assign(repeating: .empty, count: wordCount)
    }
  }
}

----Swift.(file)._HashTable.delete(at:_HashTable.Bucket,with:D)
extension _HashTable  {
  internal func delete<D: _HashTableDelegate>(
    at bucket: Bucket,
    with delegate: D
  ) {
    _internalInvariant(isOccupied(bucket))

    // If we've put a hole in a chain of contiguous elements, some element after
    // the hole may belong where the new hole is.

    var hole = bucket
    var candidate = self.bucket(wrappedAfter: hole)

    guard _isOccupied(candidate) else {
      // Fast path: Don't get the first bucket when there's nothing to do.
      words[hole.word].uncheckedRemove(hole.bit)
      return
    }

    // Find the first bucket in the contiguous chain that contains the entry
    // we've just deleted.
    let start = self.bucket(wrappedAfter: previousHole(before: bucket))

    // Relocate out-of-place elements in the chain, repeating until we get to
    // the end of the chain.
    while _isOccupied(candidate) {
      let candidateHash = delegate.hashValue(at: candidate)
      let ideal = idealBucket(forHashValue: candidateHash)

      // Does this element belong between start and hole?  We need two
      // separate tests depending on whether [start, hole] wraps around the
      // end of the storage.
      let c0 = ideal >= start
      let c1 = ideal <= hole
      if start <= hole ? (c0 && c1) : (c0 || c1) {
        delegate.moveEntry(from: candidate, to: hole)
        hole = candidate
      }
      candidate = self.bucket(wrappedAfter: candidate)
    }

    words[hole.word].uncheckedRemove(hole.bit)
  }
}

----Swift.(file).Hashable.hashValue
extension Hashable {
  var hashValue: Int { get }
}

----Swift.(file).Hashable.hash(into:Hasher)
extension Hashable {
  func hash(into hasher: inout Hasher)
}

----Swift.(file).Hashable_isEqual_indirect(_:UnsafePointer<T>,_:UnsafePointer<T>)
internal func Hashable_isEqual_indirect<T : Hashable>(
  _ lhs: UnsafePointer<T>,
  _ rhs: UnsafePointer<T>
) -> Bool {
  return lhs.pointee == rhs.pointee
}

----Swift.(file).Hashable_hashValue_indirect(_:UnsafePointer<T>)
internal func Hashable_hashValue_indirect<T : Hashable>(
  _ value: UnsafePointer<T>
) -> Int {
  return value.pointee.hashValue
}

----Swift.(file).Hasher.init()
extension Hasher {
  public init() {
    self._core = _Core()
  }
}

----Swift.(file).Hasher.init(_seed:Int)
extension Hasher {
  internal init(_seed: Int) {
    self._core = _Core(seed: _seed)
  }
}

----Swift.(file).Hasher.init(_rawSeed:(UInt64, UInt64))
extension Hasher {
  internal init(_rawSeed: (UInt64, UInt64)) {
    self._core = _Core(state: _State(rawSeed: _rawSeed))
  }
}

----Swift.(file).Hasher.combine(_:H)
extension Hasher {
  public mutating func combine<H: Hashable>(_ value: H) {
    value.hash(into: &self)
  }
}

----Swift.(file).Hasher.combine(bytes:UnsafeRawBufferPointer)
extension Hasher {
  public mutating func combine(bytes: UnsafeRawBufferPointer) {
    _core.combine(bytes: bytes)
  }
}

----Swift.(file).Hasher.finalize()
extension Hasher {
  public __consuming func finalize() -> Int {
    var core = _core
    return Int(truncatingIfNeeded: core.finalize())
  }
}

----Swift.(file).__swift_stdlib_UErrorCode.isFailure
extension __swift_stdlib_UErrorCode  {
  internal var isFailure: Bool {
    return rawValue > __swift_stdlib_U_ZERO_ERROR.rawValue
  }
}

----Swift.(file).__swift_stdlib_UErrorCode.isWarning
extension __swift_stdlib_UErrorCode  {
  internal var isWarning: Bool {
    return rawValue < __swift_stdlib_U_ZERO_ERROR.rawValue
  }
}

----Swift.(file).__swift_stdlib_UErrorCode.isSuccess
extension __swift_stdlib_UErrorCode  {
  internal var isSuccess: Bool {
    return rawValue <= __swift_stdlib_U_ZERO_ERROR.rawValue
  }
}

----Swift.(file).DefaultIndices.init(_elements:Elements,startIndex:Elements.Index,endIndex:Elements.Index)
extension DefaultIndices {
  internal init(
    _elements: Elements,
    startIndex: Elements.Index,
    endIndex: Elements.Index
  ) {
    self._elements = _elements
    self._startIndex = startIndex
    self._endIndex = endIndex
  }
}

----Swift.(file).DefaultIndices.Index
extension DefaultIndices: Collection  {
  public typealias Index = Elements.I
}

----Swift.(file).DefaultIndices.Element
extension DefaultIndices: Collection  {
  public typealias Element = Elements.I
}

----Swift.(file).DefaultIndices.Indices
extension DefaultIndices: Collection  {
  public typealias Indices = DefaultIndices<Elements>
}

----Swift.(file).DefaultIndices.SubSequence
extension DefaultIndices: Collection  {
  public typealias SubSequence = DefaultIndices<Elements>
}

----Swift.(file).DefaultIndices.Iterator
extension DefaultIndices: Collection  {
  public typealias Iterator = IndexingIterator<DefaultIndices<Elements>>
}

----Swift.(file).DefaultIndices.startIndex
extension DefaultIndices: Collection  {
  public var startIndex: Index {
    return _startIndex
  }
}

----Swift.(file).DefaultIndices.endIndex
extension DefaultIndices: Collection  {
  public var endIndex: Index {
    return _endIndex
  }
}

----Swift.(file).DefaultIndices.subscript(_:DefaultIndices<Elements>.Index)
extension DefaultIndices: Collection  {
  public subscript(i: Index) -> Elements.Index {
    // FIXME: swift-3-indexing-model: range check.
    return i
  }
}

----Swift.(file).DefaultIndices.subscript(_:Range<DefaultIndices<Elements>.Index>)
extension DefaultIndices: Collection  {
  public subscript(bounds: Range<Index>) -> DefaultIndices<Elements> {
    // FIXME: swift-3-indexing-model: range check.
    return DefaultIndices(
      _elements: _elements,
      startIndex: bounds.lowerBound,
      endIndex: bounds.upperBound)
  }
}

----Swift.(file).DefaultIndices.index(after:DefaultIndices<Elements>.Index)
extension DefaultIndices: Collection  {
  public func index(after i: Index) -> Index {
    // FIXME: swift-3-indexing-model: range check.
    return _elements.index(after: i)
  }
}

----Swift.(file).DefaultIndices.formIndex(after:DefaultIndices<Elements>.Index)
extension DefaultIndices: Collection  {
  public func formIndex(after i: inout Index) {
    // FIXME: swift-3-indexing-model: range check.
    _elements.formIndex(after: &i)
  }
}

----Swift.(file).DefaultIndices.indices
extension DefaultIndices: Collection  {
  public var indices: Indices {
    return self
  }
}

----Swift.(file).DefaultIndices.index(before:DefaultIndices<Elements>.Index)
extension DefaultIndices: BidirectionalCollection
where Elements: BidirectionalCollection  {
  public func index(before i: Index) -> Index {
    // FIXME: swift-3-indexing-model: range check.
    return _elements.index(before: i)
  }
}

----Swift.(file).DefaultIndices.formIndex(before:DefaultIndices<Elements>.Index)
extension DefaultIndices: BidirectionalCollection
where Elements: BidirectionalCollection  {
  public func formIndex(before i: inout Index) {
    // FIXME: swift-3-indexing-model: range check.
    _elements.formIndex(before: &i)
  }
}

----Swift.(file).Collection.indices
extension Collection where Indices == DefaultIndices<Self>  {
  public var indices: DefaultIndices<Self> {
    return DefaultIndices(
      _elements: self,
      startIndex: self.startIndex,
      endIndex: self.endIndex)
  }
}

----Swift.(file).readLine(strippingNewline:Bool)
public func readLine(strippingNewline: Bool = true) -> String? {
  var linePtrVar: UnsafeMutablePointer<UInt8>?
  var readBytes = swift_stdlib_readLine_stdin(&linePtrVar)
  if readBytes == -1 {
    return nil
  }
  _internalInvariant(readBytes >= 0,
    "unexpected return value from swift_stdlib_readLine_stdin")
  if readBytes == 0 {
    return ""
  }

  let linePtr = linePtrVar!
  if strippingNewline {
    // FIXME: Unicode conformance.  To fix this, we need to reimplement the
    // code we call above to get a line, since it will only stop on LF.
    //
    // <rdar://problem/20013999> Recognize Unicode newlines in readLine()
    //
    // Recognize only LF and CR+LF combinations for now.
    let cr = UInt8(ascii: "\r")
    let lf = UInt8(ascii: "\n")
    if readBytes == 1 && linePtr[0] == lf {
      return ""
    }
    if readBytes >= 2 {
      switch (linePtr[readBytes - 2], linePtr[readBytes - 1]) {
      case (cr, lf):
        readBytes -= 2
        break
      case (_, lf):
        readBytes -= 1
        break
      default:
        ()
      }
    }
  }
  let result = String._fromUTF8Repairing(
    UnsafeBufferPointer(start: linePtr, count: readBytes)).0
  _swift_stdlib_free(linePtr)
  return result
}

----Swift.(file).FixedWidthInteger.init(_:S,radix:Int)
extension FixedWidthInteger  {
  public init?<S : StringProtocol>(_ text: S, radix: Int = 10) {
    _precondition(2...36 ~= radix, "Radix not in range 2...36")

    if let str = text as? String, str._guts.isFastUTF8 {
      guard let ret = str._guts.withFastUTF8 ({ utf8 -> Self? in
        var iter = utf8.makeIterator()
        return _parseASCII(codeUnits: &iter, radix: Self(radix))
      }) else {
        return nil
      }
      self = ret
      return
    }

    // TODO(String performance): We can provide fast paths for common radices,
    // native UTF-8 storage, etc.

    var iter = text.utf8.makeIterator()
    guard let ret = Self._parseASCIISlowPath(
      codeUnits: &iter, radix: Self(radix)
    ) else { return nil }

    self = ret
  }
}

----Swift.(file).FixedWidthInteger.init(_:String)
extension FixedWidthInteger  {
  public init?(_ description: String) {
    self.init(description, radix: 10)
  }
}

----Swift.(file).ExpressibleByIntegerLiteral.init(integerLiteral:Self)
extension ExpressibleByIntegerLiteral
  where Self : _ExpressibleByBuiltinIntegerLiteral  {
  public init(integerLiteral value: Self) {
    self = value
  }
}

----Swift.(file).AdditiveArithmetic.zero
extension AdditiveArithmetic {
  static var zero: Self { get }
}

----Swift.(file).AdditiveArithmetic.+infix(_:Self,_:Self)
extension AdditiveArithmetic {
  static func +(lhs: Self, rhs: Self) -> S
}

----Swift.(file).AdditiveArithmetic.+=infix(_:Self,_:Self)
extension AdditiveArithmetic {
  static func +=(lhs: inout Self, rhs: Self)
}

----Swift.(file).AdditiveArithmetic.-infix(_:Self,_:Self)
extension AdditiveArithmetic {
  static func -(lhs: Self, rhs: Self) -> S
}

----Swift.(file).AdditiveArithmetic.-=infix(_:Self,_:Self)
extension AdditiveArithmetic {
  static func -=(lhs: inout Self, rhs: Self)
}

----Swift.(file).AdditiveArithmetic.zero
public extension AdditiveArithmetic where Self : ExpressibleByIntegerLiteral  {
  static var zero: Self {
    return 0
  }
}

----Swift.(file).Numeric.init(exactly:T)
extension Numeric {
  init?<T : BinaryInteger>(exactly source: T)
}

----Swift.(file).Numeric.Magnitude
extension Numeric {
  associatedtype Magnitude : Comparable, N
}

----Swift.(file).Numeric.magnitude
extension Numeric {
  var magnitude: Magnitude { get }
}

----Swift.(file).Numeric.*infix(_:Self,_:Self)
extension Numeric {
  static func *(lhs: Self, rhs: Self) -> S
}

----Swift.(file).Numeric.*=infix(_:Self,_:Self)
extension Numeric {
  static func *=(lhs: inout Self, rhs: Self)
}

----Swift.(file).SignedNumeric.-prefix(_:Self)
extension SignedNumeric {
  static prefix func - (_ operand: Self) -> S
}

----Swift.(file).SignedNumeric.negate()
extension SignedNumeric {
  mutating func negate()
}

----Swift.(file).SignedNumeric.-prefix(_:Self)
extension SignedNumeric  {
  public static prefix func - (_ operand: Self) -> Self {
    var result = operand
    result.negate()
    return result
  }
}

----Swift.(file).SignedNumeric.negate()
extension SignedNumeric  {
  public mutating func negate() {
    self = 0 - self
  }
}

----Swift.(file).abs(_:T)
public func abs<T : SignedNumeric & Comparable>(_ x: T) -> T {
  if T.self == T.Magnitude.self {
    return unsafeBitCast(x.magnitude, to: T.self)
  }

  return x < (0 as T) ? -x : x
}

----Swift.(file).AdditiveArithmetic.+prefix(_:Self)
extension AdditiveArithmetic  {
  public static prefix func + (x: Self) -> Self {
    return x
  }
}

----Swift.(file).BinaryInteger.isSigned
extension BinaryInteger {
  static var isSigned: Bool { get }
}

----Swift.(file).BinaryInteger.init(exactly:T)
extension BinaryInteger {
  init?<T : BinaryFloatingPoint>(exactly source: T)
}

----Swift.(file).BinaryInteger.init(_:T)
extension BinaryInteger {
  init<T : BinaryFloatingPoint>(_ source: T)
}

----Swift.(file).BinaryInteger.init(_:T)
extension BinaryInteger {
  init<T : BinaryInteger>(_ source: T)
}

----Swift.(file).BinaryInteger.init(truncatingIfNeeded:T)
extension BinaryInteger {
  init<T : BinaryInteger>(truncatingIfNeeded source: T)
}

----Swift.(file).BinaryInteger.init(clamping:T)
extension BinaryInteger {
  init<T : BinaryInteger>(clamping source: T)
}

----Swift.(file).BinaryInteger.Words
extension BinaryInteger {
  associatedtype Words : RandomAccessCollection
      where Words.Element == UInt, Words.Index == I
}

----Swift.(file).BinaryInteger.words
extension BinaryInteger {
  var words: Words { get }
}

----Swift.(file).BinaryInteger.bitWidth
extension BinaryInteger {
  var bitWidth: Int { get }
}

----Swift.(file).BinaryInteger.trailingZeroBitCount
extension BinaryInteger {
  var trailingZeroBitCount: Int { get }
}

----Swift.(file).BinaryInteger./infix(_:Self,_:Self)
extension BinaryInteger {
  static func /(lhs: Self, rhs: Self) -> S
}

----Swift.(file).BinaryInteger./=infix(_:Self,_:Self)
extension BinaryInteger {
  static func /=(lhs: inout Self, rhs: Self)
}

----Swift.(file).BinaryInteger.%infix(_:Self,_:Self)
extension BinaryInteger {
  static func %(lhs: Self, rhs: Self) -> S
}

----Swift.(file).BinaryInteger.%=infix(_:Self,_:Self)
extension BinaryInteger {
  static func %=(lhs: inout Self, rhs: Self)
}

----Swift.(file).BinaryInteger.+infix(_:Self,_:Self)
extension BinaryInteger {
  override static func +(lhs: Self, rhs: Self) -> S
}

----Swift.(file).BinaryInteger.+=infix(_:Self,_:Self)
extension BinaryInteger {
  override static func +=(lhs: inout Self, rhs: Self)
}

----Swift.(file).BinaryInteger.-infix(_:Self,_:Self)
extension BinaryInteger {
  override static func -(lhs: Self, rhs: Self) -> S
}

----Swift.(file).BinaryInteger.-=infix(_:Self,_:Self)
extension BinaryInteger {
  override static func -=(lhs: inout Self, rhs: Self)
}

----Swift.(file).BinaryInteger.*infix(_:Self,_:Self)
extension BinaryInteger {
  override static func *(lhs: Self, rhs: Self) -> S
}

----Swift.(file).BinaryInteger.*=infix(_:Self,_:Self)
extension BinaryInteger {
  override static func *=(lhs: inout Self, rhs: Self)
}

----Swift.(file).BinaryInteger.~prefix(_:Self)
extension BinaryInteger {
  static prefix func ~ (_ x: Self) -> S
}

----Swift.(file).BinaryInteger.&infix(_:Self,_:Self)
extension BinaryInteger {
  static func &(lhs: Self, rhs: Self) -> S
}

----Swift.(file).BinaryInteger.&=infix(_:Self,_:Self)
extension BinaryInteger {
  static func &=(lhs: inout Self, rhs: Self)
}

----Swift.(file).BinaryInteger.|infix(_:Self,_:Self)
extension BinaryInteger {
  static func |(lhs: Self, rhs: Self) -> S
}

----Swift.(file).BinaryInteger.|=infix(_:Self,_:Self)
extension BinaryInteger {
  static func |=(lhs: inout Self, rhs: Self)
}

----Swift.(file).BinaryInteger.^infix(_:Self,_:Self)
extension BinaryInteger {
  static func ^(lhs: Self, rhs: Self) -> S
}

----Swift.(file).BinaryInteger.^=infix(_:Self,_:Self)
extension BinaryInteger {
  static func ^=(lhs: inout Self, rhs: Self)
}

----Swift.(file).BinaryInteger.>>infix(_:Self,_:RHS)
extension BinaryInteger {
  static func >> <RHS: BinaryInteger>(lhs: Self, rhs: RHS) -> S
}

----Swift.(file).BinaryInteger.>>=infix(_:Self,_:RHS)
extension BinaryInteger {
  static func >>= <RHS: BinaryInteger>(lhs: inout Self, rhs: RHS)
}

----Swift.(file).BinaryInteger.<<infix(_:Self,_:RHS)
extension BinaryInteger {
  static func << <RHS: BinaryInteger>(lhs: Self, rhs: RHS) -> S
}

----Swift.(file).BinaryInteger.<<=infix(_:Self,_:RHS)
extension BinaryInteger {
  static func <<=<RHS: BinaryInteger>(lhs: inout Self, rhs: RHS)
}

----Swift.(file).BinaryInteger.quotientAndRemainder(dividingBy:Self)
extension BinaryInteger {
  func quotientAndRemainder(dividingBy rhs: Self)
    -> (quotient: Self, remainder: Self)
}

----Swift.(file).BinaryInteger.isMultiple(of:Self)
extension BinaryInteger {
  func isMultiple(of other: Self) -> B
}

----Swift.(file).BinaryInteger.signum()
extension BinaryInteger {
  func signum() -> S
}

----Swift.(file).BinaryInteger.init()
extension BinaryInteger  {
  public init() {
    self = 0
  }
}

----Swift.(file).BinaryInteger.signum()
extension BinaryInteger  {
  public func signum() -> Self {
    return (self > (0 as Self) ? 1 : 0) - (self < (0 as Self) ? 1 : 0)
  }
}

----Swift.(file).BinaryInteger.quotientAndRemainder(dividingBy:Self)
extension BinaryInteger  {
  public func quotientAndRemainder(dividingBy rhs: Self)
    -> (quotient: Self, remainder: Self) {
    return (self / rhs, self % rhs)
  }
}

----Swift.(file).BinaryInteger.isMultiple(of:Self)
extension BinaryInteger  {
  public func isMultiple(of other: Self) -> Bool {
    // Nothing but zero is a multiple of zero.
    if other == 0 { return self == 0 }
    // Do the test in terms of magnitude, which guarantees there are no other
    // edge cases. If we write this as `self % other` instead, it could trap
    // for types that are not symmetric around zero.
    return self.magnitude % other.magnitude == 0
  }
}

----Swift.(file).BinaryInteger.&infix(_:Self,_:Self)
extension BinaryInteger  {
  public static func & (lhs: Self, rhs: Self) -> Self {
    var lhs = lhs
    lhs &= rhs
    return lhs
  }
}

----Swift.(file).BinaryInteger.|infix(_:Self,_:Self)
extension BinaryInteger  {
  public static func | (lhs: Self, rhs: Self) -> Self {
    var lhs = lhs
    lhs |= rhs
    return lhs
  }
}

----Swift.(file).BinaryInteger.^infix(_:Self,_:Self)
extension BinaryInteger  {
  public static func ^ (lhs: Self, rhs: Self) -> Self {
    var lhs = lhs
    lhs ^= rhs
    return lhs
  }
}

----Swift.(file).BinaryInteger.>>infix(_:Self,_:RHS)
extension BinaryInteger  {
  public static func >> <RHS: BinaryInteger>(lhs: Self, rhs: RHS) -> Self {
    var r = lhs
    r >>= rhs
    return r
  }
}

----Swift.(file).BinaryInteger.<<infix(_:Self,_:RHS)
extension BinaryInteger  {
  public static func << <RHS: BinaryInteger>(lhs: Self, rhs: RHS) -> Self {
    var r = lhs
    r <<= rhs
    return r
  }
}

----Swift.(file).BinaryInteger.description
extension BinaryInteger  {
  public var description: String {
    return _description(radix: 10, uppercase: false)
  }
}

----Swift.(file).BinaryInteger.distance(to:Self)
extension BinaryInteger  {
  public func distance(to other: Self) -> Int {
    if !Self.isSigned {
      if self > other {
        if let result = Int(exactly: self - other) {
          return -result
        }
      } else {
        if let result = Int(exactly: other - self) {
          return result
        }
      }
    } else {
      let isNegative = self < (0 as Self)
      if isNegative == (other < (0 as Self)) {
        if let result = Int(exactly: other - self) {
          return result
        }
      } else {
        if let result = Int(exactly: self.magnitude + other.magnitude) {
          return isNegative ? result : -result
        }
      }
    }
    _preconditionFailure("Distance is not representable in Int")
  }
}

----Swift.(file).BinaryInteger.advanced(by:Int)
extension BinaryInteger  {
  public func advanced(by n: Int) -> Self {
    if !Self.isSigned {
      return n < (0 as Int)
        ? self - Self(-n)
        : self + Self(n)
    }
    if (self < (0 as Self)) == (n < (0 as Self)) {
      return self + Self(n)
    }
    return self.magnitude < n.magnitude
      ? Self(Int(self) + n)
      : self + Self(n)
  }
}

----Swift.(file).BinaryInteger.==infix(_:Self,_:Other)
extension BinaryInteger  {
  public static func == <
    Other : BinaryInteger
  >(lhs: Self, rhs: Other) -> Bool {
    let lhsNegative = Self.isSigned && lhs < (0 as Self)
    let rhsNegative = Other.isSigned && rhs < (0 as Other)

    if lhsNegative != rhsNegative { return false }

    // Here we know the values are of the same sign.
    //
    // There are a few possible scenarios from here:
    //
    // 1. Both values are negative
    //  - If one value is strictly wider than the other, then it is safe to
    //    convert to the wider type.
    //  - If the values are of the same width, it does not matter which type we
    //    choose to convert to as the values are already negative, and thus
    //    include the sign bit if two's complement representation already.
    // 2. Both values are non-negative
    //  - If one value is strictly wider than the other, then it is safe to
    //    convert to the wider type.
    //  - If the values are of the same width, than signedness matters, as not
    //    unsigned types are 'wider' in a sense they don't need to 'waste' the
    //    sign bit. Therefore it is safe to convert to the unsigned type.

    if lhs.bitWidth < rhs.bitWidth {
      return Other(truncatingIfNeeded: lhs) == rhs
    }
    if lhs.bitWidth > rhs.bitWidth {
      return lhs == Self(truncatingIfNeeded: rhs)
    }

    if Self.isSigned {
      return Other(truncatingIfNeeded: lhs) == rhs
    }
    return lhs == Self(truncatingIfNeeded: rhs)
  }
}

----Swift.(file).BinaryInteger.!=infix(_:Self,_:Other)
extension BinaryInteger  {
  public static func != <
    Other : BinaryInteger
  >(lhs: Self, rhs: Other) -> Bool {
    return !(lhs == rhs)
  }
}

----Swift.(file).BinaryInteger.<infix(_:Self,_:Other)
extension BinaryInteger  {
  public static func < <Other : BinaryInteger>(lhs: Self, rhs: Other) -> Bool {
    let lhsNegative = Self.isSigned && lhs < (0 as Self)
    let rhsNegative = Other.isSigned && rhs < (0 as Other)
    if lhsNegative != rhsNegative { return lhsNegative }

    if lhs == (0 as Self) && rhs == (0 as Other) { return false }

    // if we get here, lhs and rhs have the same sign. If they're negative,
    // then Self and Other are both signed types, and one of them can represent
    // values of the other type. Otherwise, lhs and rhs are positive, and one
    // of Self, Other may be signed and the other unsigned.

    let rhsAsSelf = Self(truncatingIfNeeded: rhs)
    let rhsAsSelfNegative = rhsAsSelf < (0 as Self)


    // Can we round-trip rhs through Other?
    if Other(truncatingIfNeeded: rhsAsSelf) == rhs &&
      // This additional check covers the `Int8.max < (128 as UInt8)` case.
      // Since the types are of the same width, init(truncatingIfNeeded:)
      // will result in a simple bitcast, so that rhsAsSelf would be -128, and
      // `lhs < rhsAsSelf` will return false.
      // We basically guard against that bitcast by requiring rhs and rhsAsSelf
      // to be the same sign.
      rhsNegative == rhsAsSelfNegative {
      return lhs < rhsAsSelf
    }

    return Other(truncatingIfNeeded: lhs) < rhs
  }
}

----Swift.(file).BinaryInteger.<=infix(_:Self,_:Other)
extension BinaryInteger  {
  public static func <= <Other : BinaryInteger>(lhs: Self, rhs: Other) -> Bool {
    return !(rhs < lhs)
  }
}

----Swift.(file).BinaryInteger.>=infix(_:Self,_:Other)
extension BinaryInteger  {
  public static func >= <Other : BinaryInteger>(lhs: Self, rhs: Other) -> Bool {
    return !(lhs < rhs)
  }
}

----Swift.(file).BinaryInteger.>infix(_:Self,_:Other)
extension BinaryInteger  {
  public static func > <Other : BinaryInteger>(lhs: Self, rhs: Other) -> Bool {
    return rhs < lhs
  }
}

----Swift.(file).BinaryInteger.!=infix(_:Self,_:Self)
extension BinaryInteger  {
  public static func != (lhs: Self, rhs: Self) -> Bool {
    return !(lhs == rhs)
  }
}

----Swift.(file).BinaryInteger.<=infix(_:Self,_:Self)
extension BinaryInteger  {
  public static func <= (lhs: Self, rhs: Self) -> Bool {
    return !(rhs < lhs)
  }
}

----Swift.(file).BinaryInteger.>=infix(_:Self,_:Self)
extension BinaryInteger  {
  public static func >= (lhs: Self, rhs: Self) -> Bool {
    return !(lhs < rhs)
  }
}

----Swift.(file).BinaryInteger.>infix(_:Self,_:Self)
extension BinaryInteger  {
  public static func > (lhs: Self, rhs: Self) -> Bool {
    return rhs < lhs
  }
}

----Swift.(file).FixedWidthInteger.bitWidth
extension FixedWidthInteger {
  static var bitWidth: Int { get }
}

----Swift.(file).FixedWidthInteger.max
extension FixedWidthInteger {
  static var max: Self { get }
}

----Swift.(file).FixedWidthInteger.min
extension FixedWidthInteger {
  static var min: Self { get }
}

----Swift.(file).FixedWidthInteger.addingReportingOverflow(_:Self)
extension FixedWidthInteger {
  func addingReportingOverflow(
    _ rhs: Self
  ) -> (partialValue: Self, overflow: Bool)
}

----Swift.(file).FixedWidthInteger.subtractingReportingOverflow(_:Self)
extension FixedWidthInteger {
  func subtractingReportingOverflow(
    _ rhs: Self
  ) -> (partialValue: Self, overflow: Bool)
}

----Swift.(file).FixedWidthInteger.multipliedReportingOverflow(by:Self)
extension FixedWidthInteger {
  func multipliedReportingOverflow(
    by rhs: Self
  ) -> (partialValue: Self, overflow: Bool)
}

----Swift.(file).FixedWidthInteger.dividedReportingOverflow(by:Self)
extension FixedWidthInteger {
  func dividedReportingOverflow(
    by rhs: Self
  ) -> (partialValue: Self, overflow: Bool)
}

----Swift.(file).FixedWidthInteger.remainderReportingOverflow(dividingBy:Self)
extension FixedWidthInteger {
  func remainderReportingOverflow(
    dividingBy rhs: Self
  ) -> (partialValue: Self, overflow: Bool)
}

----Swift.(file).FixedWidthInteger.multipliedFullWidth(by:Self)
extension FixedWidthInteger {
  func multipliedFullWidth(by other: Self) -> (high: Self, low: Self.Magnitude)
}

----Swift.(file).FixedWidthInteger.dividingFullWidth(_:(high: Self, low: Self.Magnitude))
extension FixedWidthInteger {
  func dividingFullWidth(_ dividend: (high: Self, low: Self.Magnitude))
    -> (quotient: Self, remainder: Self)
}

----Swift.(file).FixedWidthInteger.init(_truncatingBits:UInt)
extension FixedWidthInteger {
  init(_truncatingBits bits: UInt)
}

----Swift.(file).FixedWidthInteger.nonzeroBitCount
extension FixedWidthInteger {
  var nonzeroBitCount: Int { get }
}

----Swift.(file).FixedWidthInteger.leadingZeroBitCount
extension FixedWidthInteger {
  var leadingZeroBitCount: Int { get }
}

----Swift.(file).FixedWidthInteger.init(bigEndian:Self)
extension FixedWidthInteger {
  init(bigEndian value: Self)
}

----Swift.(file).FixedWidthInteger.init(littleEndian:Self)
extension FixedWidthInteger {
  init(littleEndian value: Self)
}

----Swift.(file).FixedWidthInteger.bigEndian
extension FixedWidthInteger {
  var bigEndian: Self { get }
}

----Swift.(file).FixedWidthInteger.littleEndian
extension FixedWidthInteger {
  var littleEndian: Self { get }
}

----Swift.(file).FixedWidthInteger.byteSwapped
extension FixedWidthInteger {
  var byteSwapped: Self { get }
}

----Swift.(file).FixedWidthInteger.&>>infix(_:Self,_:Self)
extension FixedWidthInteger {
  static func &>>(lhs: Self, rhs: Self) -> S
}

----Swift.(file).FixedWidthInteger.&>>=infix(_:Self,_:Self)
extension FixedWidthInteger {
  static func &>>=(lhs: inout Self, rhs: Self)
}

----Swift.(file).FixedWidthInteger.&<<infix(_:Self,_:Self)
extension FixedWidthInteger {
  static func &<<(lhs: Self, rhs: Self) -> S
}

----Swift.(file).FixedWidthInteger.&<<=infix(_:Self,_:Self)
extension FixedWidthInteger {
  static func &<<=(lhs: inout Self, rhs: Self)
}

----Swift.(file).FixedWidthInteger.bitWidth
extension FixedWidthInteger  {
  public var bitWidth: Int { return Self.bitWidth }
}

----Swift.(file).FixedWidthInteger.init(littleEndian:Self)
extension FixedWidthInteger  {
  public init(littleEndian value: Self) {
#if _endian(little)
    self = value
#else
    self = value.byteSwapped
#endif
  }
}

----Swift.(file).FixedWidthInteger.init(bigEndian:Self)
extension FixedWidthInteger  {
  public init(bigEndian value: Self) {
#if _endian(big)
    self = value
#else
    self = value.byteSwapped
#endif
  }
}

----Swift.(file).FixedWidthInteger.littleEndian
extension FixedWidthInteger  {
  public var littleEndian: Self {
#if _endian(little)
    return self
#else
    return byteSwapped
#endif
  }
}

----Swift.(file).FixedWidthInteger.bigEndian
extension FixedWidthInteger  {
  public var bigEndian: Self {
#if _endian(big)
    return self
#else
    return byteSwapped
#endif
  }
}

----Swift.(file).FixedWidthInteger.&>>infix(_:Self,_:Self)
extension FixedWidthInteger  {
  public static func &>> (lhs: Self, rhs: Self) -> Self {
    var lhs = lhs
    lhs &>>= rhs
    return lhs
  }
}

----Swift.(file).FixedWidthInteger.&>>infix(_:Self,_:Other)
extension FixedWidthInteger  {
  public static func &>> <
    Other : BinaryInteger
  >(lhs: Self, rhs: Other) -> Self {
    return lhs &>> Self(truncatingIfNeeded: rhs)
  }
}

----Swift.(file).FixedWidthInteger.&>>=infix(_:Self,_:Other)
extension FixedWidthInteger  {
  public static func &>>= <
    Other : BinaryInteger
  >(lhs: inout Self, rhs: Other) {
    lhs = lhs &>> rhs
  }
}

----Swift.(file).FixedWidthInteger.&<<infix(_:Self,_:Self)
extension FixedWidthInteger  {
  public static func &<< (lhs: Self, rhs: Self) -> Self {
    var lhs = lhs
    lhs &<<= rhs
    return lhs
  }
}

----Swift.(file).FixedWidthInteger.&<<infix(_:Self,_:Other)
extension FixedWidthInteger  {
  public static func &<< <
    Other : BinaryInteger
  >(lhs: Self, rhs: Other) -> Self {
    return lhs &<< Self(truncatingIfNeeded: rhs)
  }
}

----Swift.(file).FixedWidthInteger.&<<=infix(_:Self,_:Other)
extension FixedWidthInteger  {
  public static func &<<= <
    Other : BinaryInteger
  >(lhs: inout Self, rhs: Other) {
    lhs = lhs &<< rhs
  }
}

----Swift.(file).FixedWidthInteger.random(in:Range<Self>,using:T)
extension FixedWidthInteger  {
  public static func random<T: RandomNumberGenerator>(
    in range: Range<Self>,
    using generator: inout T
  ) -> Self {
    _precondition(
      !range.isEmpty,
      "Can't get random value with an empty range"
    )

    // Compute delta, the distance between the lower and upper bounds. This
    // value may not representable by the type Bound if Bound is signed, but
    // is always representable as Bound.Magnitude.
    let delta = Magnitude(truncatingIfNeeded: range.upperBound &- range.lowerBound)
    // The mathematical result we want is lowerBound plus a random value in
    // 0 ..< delta. We need to be slightly careful about how we do this
    // arithmetic; the Bound type cannot generally represent the random value,
    // so we use a wrapping addition on Bound.Magnitude. This will often
    // overflow, but produces the correct bit pattern for the result when
    // converted back to Bound.
    return Self(truncatingIfNeeded:
      Magnitude(truncatingIfNeeded: range.lowerBound) &+
      generator.next(upperBound: delta)
    )
  }
}

----Swift.(file).FixedWidthInteger.random(in:Range<Self>)
extension FixedWidthInteger  {
  public static func random(in range: Range<Self>) -> Self {
    var g = SystemRandomNumberGenerator()
    return Self.random(in: range, using: &g)
  }
}

----Swift.(file).FixedWidthInteger.random(in:ClosedRange<Self>,using:T)
extension FixedWidthInteger  {
  public static func random<T: RandomNumberGenerator>(
    in range: ClosedRange<Self>,
    using generator: inout T
  ) -> Self {
    _precondition(
      !range.isEmpty,
      "Can't get random value with an empty range"
    )

    // Compute delta, the distance between the lower and upper bounds. This
    // value may not representable by the type Bound if Bound is signed, but
    // is always representable as Bound.Magnitude.
    var delta = Magnitude(truncatingIfNeeded: range.upperBound &- range.lowerBound)
    // Subtle edge case: if the range is the whole set of representable values,
    // then adding one to delta to account for a closed range will overflow.
    // If we used &+ instead, the result would be zero, which isn't helpful,
    // so we actually need to handle this case separately.
    if delta == Magnitude.max {
      return Self(truncatingIfNeeded: generator.next() as Magnitude)
    }
    // Need to widen delta to account for the right-endpoint of a closed range.
    delta += 1
    // The mathematical result we want is lowerBound plus a random value in
    // 0 ..< delta. We need to be slightly careful about how we do this
    // arithmetic; the Bound type cannot generally represent the random value,
    // so we use a wrapping addition on Bound.Magnitude. This will often
    // overflow, but produces the correct bit pattern for the result when
    // converted back to Bound.
    return Self(truncatingIfNeeded:
      Magnitude(truncatingIfNeeded: range.lowerBound) &+
      generator.next(upperBound: delta)
    )
  }
}

----Swift.(file).FixedWidthInteger.random(in:ClosedRange<Self>)
extension FixedWidthInteger  {
  public static func random(in range: ClosedRange<Self>) -> Self {
    var g = SystemRandomNumberGenerator()
    return Self.random(in: range, using: &g)
  }
}

----Swift.(file).FixedWidthInteger.~prefix(_:Self)
extension FixedWidthInteger  {
  public static prefix func ~ (x: Self) -> Self {
    return 0 &- x &- 1
  }
}

----Swift.(file).FixedWidthInteger.>>infix(_:Self,_:Other)
extension FixedWidthInteger  {
  public static func >> <
    Other : BinaryInteger
  >(lhs: Self, rhs: Other) -> Self {
    var lhs = lhs
    _nonMaskingRightShiftGeneric(&lhs, rhs)
    return lhs
  }
}

----Swift.(file).FixedWidthInteger.>>=infix(_:Self,_:Other)
extension FixedWidthInteger  {
  public static func >>= <
    Other : BinaryInteger
  >(lhs: inout Self, rhs: Other) {
    _nonMaskingRightShiftGeneric(&lhs, rhs)
  }
}

----Swift.(file).FixedWidthInteger.<<infix(_:Self,_:Other)
extension FixedWidthInteger  {
  public static func << <
    Other : BinaryInteger
  >(lhs: Self, rhs: Other) -> Self {
    var lhs = lhs
    _nonMaskingLeftShiftGeneric(&lhs, rhs)
    return lhs
  }
}

----Swift.(file).FixedWidthInteger.<<=infix(_:Self,_:Other)
extension FixedWidthInteger  {
  public static func <<= <
    Other : BinaryInteger
  >(lhs: inout Self, rhs: Other) {
    _nonMaskingLeftShiftGeneric(&lhs, rhs)
  }
}

----Swift.(file).FixedWidthInteger.init(_:T)
extension FixedWidthInteger  {
  public init<T : BinaryFloatingPoint>(_ source: T) {
    guard let value = Self._convert(from: source).value else {
      fatalError("""
        \(T.self) value cannot be converted to \(Self.self) because it is \
        outside the representable range
        """)
    }
    self = value
  }
}

----Swift.(file).FixedWidthInteger.init(exactly:T)
extension FixedWidthInteger  {
  public init?<T : BinaryFloatingPoint>(exactly source: T) {
    let (temporary, exact) = Self._convert(from: source)
    guard exact, let value = temporary else {
      return nil
    }
    self = value
  }
}

----Swift.(file).FixedWidthInteger.init(clamping:Other)
extension FixedWidthInteger  {
  public init<Other : BinaryInteger>(clamping source: Other) {
    if _slowPath(source < Self.min) {
      self = Self.min
    }
    else if _slowPath(source > Self.max) {
      self = Self.max
    }
    else { self = Self(truncatingIfNeeded: source) }
  }
}

----Swift.(file).FixedWidthInteger.init(truncatingIfNeeded:T)
extension FixedWidthInteger  {
  public init<T : BinaryInteger>(truncatingIfNeeded source: T) {
    if Self.bitWidth <= Int.bitWidth {
      self = Self(_truncatingBits: source._lowWord)
    }
    else {
      let neg = source < (0 as T)
      var result: Self = neg ? ~0 : 0
      var shift: Self = 0
      let width = Self(_truncatingBits: Self.bitWidth._lowWord)
      for word in source.words {
        guard shift < width else { break }
        // Masking shift is OK here because we have already ensured
        // that shift < Self.bitWidth. Not masking results in
        // infinite recursion.
        result ^= Self(_truncatingBits: neg ? ~word : word) &<< shift
        shift += Self(_truncatingBits: Int.bitWidth._lowWord)
      }
      self = result
    }
  }
}

----Swift.(file).FixedWidthInteger.&+infix(_:Self,_:Self)
extension FixedWidthInteger  {
  public static func &+ (lhs: Self, rhs: Self) -> Self {
    return lhs.addingReportingOverflow(rhs).partialValue
  }
}

----Swift.(file).FixedWidthInteger.&+=infix(_:Self,_:Self)
extension FixedWidthInteger  {
  public static func &+= (lhs: inout Self, rhs: Self) {
    lhs = lhs &+ rhs
  }
}

----Swift.(file).FixedWidthInteger.&-infix(_:Self,_:Self)
extension FixedWidthInteger  {
  public static func &- (lhs: Self, rhs: Self) -> Self {
    return lhs.subtractingReportingOverflow(rhs).partialValue
  }
}

----Swift.(file).FixedWidthInteger.&-=infix(_:Self,_:Self)
extension FixedWidthInteger  {
  public static func &-= (lhs: inout Self, rhs: Self) {
    lhs = lhs &- rhs
  }
}

----Swift.(file).FixedWidthInteger.&*infix(_:Self,_:Self)
extension FixedWidthInteger  {
  public static func &* (lhs: Self, rhs: Self) -> Self {
    return lhs.multipliedReportingOverflow(by: rhs).partialValue
  }
}

----Swift.(file).FixedWidthInteger.&*=infix(_:Self,_:Self)
extension FixedWidthInteger  {
  public static func &*= (lhs: inout Self, rhs: Self) {
    lhs = lhs &* rhs
  }
}

----Swift.(file).UnsignedInteger.magnitude
extension UnsignedInteger  {
  public var magnitude: Self {
    @inline(__always)
    get { return self }
  }
}

----Swift.(file).UnsignedInteger.isSigned
extension UnsignedInteger  {
  public static var isSigned: Bool {
    @inline(__always)
    get { return false }
  }
}

----Swift.(file).UnsignedInteger.init(_:T)
extension UnsignedInteger where Self : FixedWidthInteger  {
  public init<T : BinaryInteger>(_ source: T) {
    // This check is potentially removable by the optimizer
    if T.isSigned {
      _precondition(source >= (0 as T), "Negative value is not representable")
    }
    // This check is potentially removable by the optimizer
    if source.bitWidth >= Self.bitWidth {
      _precondition(source <= Self.max,
        "Not enough bits to represent the passed value")
    }
    self.init(truncatingIfNeeded: source)
  }
}

----Swift.(file).UnsignedInteger.init(exactly:T)
extension UnsignedInteger where Self : FixedWidthInteger  {
  public init?<T : BinaryInteger>(exactly source: T) {
    // This check is potentially removable by the optimizer
    if T.isSigned && source < (0 as T) {
      return nil
    }
    // The width check can be eliminated by the optimizer
    if source.bitWidth >= Self.bitWidth &&
       source > Self.max {
      return nil
    }
    self.init(truncatingIfNeeded: source)
  }
}

----Swift.(file).UnsignedInteger.max
extension UnsignedInteger where Self : FixedWidthInteger  {
  public static var max: Self { return ~0 }
}

----Swift.(file).UnsignedInteger.min
extension UnsignedInteger where Self : FixedWidthInteger  {
  public static var min: Self { return 0 }
}

----Swift.(file).SignedInteger.isSigned
extension SignedInteger  {
  public static var isSigned: Bool {
    @inline(__always)
    get { return true }
  }
}

----Swift.(file).SignedInteger.init(_:T)
extension SignedInteger where Self : FixedWidthInteger  {
  public init<T : BinaryInteger>(_ source: T) {
    // This check is potentially removable by the optimizer
    if T.isSigned && source.bitWidth > Self.bitWidth {
      _precondition(source >= Self.min,
        "Not enough bits to represent a signed value")
    }
    // This check is potentially removable by the optimizer
    if (source.bitWidth > Self.bitWidth) ||
       (source.bitWidth == Self.bitWidth && !T.isSigned) {
      _precondition(source <= Self.max,
        "Not enough bits to represent the passed value")
    }
    self.init(truncatingIfNeeded: source)
  }
}

----Swift.(file).SignedInteger.init(exactly:T)
extension SignedInteger where Self : FixedWidthInteger  {
  public init?<T : BinaryInteger>(exactly source: T) {
    // This check is potentially removable by the optimizer
    if T.isSigned && source.bitWidth > Self.bitWidth && source < Self.min {
      return nil
    }
    // The width check can be eliminated by the optimizer
    if (source.bitWidth > Self.bitWidth ||
        (source.bitWidth == Self.bitWidth && !T.isSigned)) &&
       source > Self.max {
      return nil
    }
    self.init(truncatingIfNeeded: source)
  }
}

----Swift.(file).SignedInteger.max
extension SignedInteger where Self : FixedWidthInteger  {
  public static var max: Self { return ~min }
}

----Swift.(file).SignedInteger.min
extension SignedInteger where Self : FixedWidthInteger  {
  public static var min: Self {
    return (-1 as Self) &<< Self._highBitIndex
  }
}

----Swift.(file).SignedInteger.isMultiple(of:Self)
extension SignedInteger where Self : FixedWidthInteger  {
  public func isMultiple(of other: Self) -> Bool {
    // Nothing but zero is a multiple of zero.
    if other == 0 { return self == 0 }
    // Special case to avoid overflow on .min / -1 for signed types.
    if other == -1 { return true }
    // Having handled those special cases, this is safe.
    return self % other == 0
  }
}

----Swift.(file).numericCast(_:T)
public func numericCast<T : BinaryInteger, U : BinaryInteger>(_ x: T) -> U {
  return U(x)
}

----Swift.(file).FixedWidthInteger.>>infix(_:Self,_:Self)
extension FixedWidthInteger  {
  public static func >>(lhs: Self, rhs: Self) -> Self {
    var lhs = lhs
    _nonMaskingRightShiftGeneric(&lhs, rhs)
    return lhs
  }
}

----Swift.(file).FixedWidthInteger.>>=infix(_:Self,_:Self)
extension FixedWidthInteger  {
  public static func >>=(lhs: inout Self, rhs: Self) {
    _nonMaskingRightShiftGeneric(&lhs, rhs)
  }
}

----Swift.(file).FixedWidthInteger.<<infix(_:Self,_:Self)
extension FixedWidthInteger  {
  public static func <<(lhs: Self, rhs: Self) -> Self {
    var lhs = lhs
    _nonMaskingLeftShiftGeneric(&lhs, rhs)
    return lhs
  }
}

----Swift.(file).FixedWidthInteger.<<=infix(_:Self,_:Self)
extension FixedWidthInteger  {
  public static func <<=(lhs: inout Self, rhs: Self) {
    _nonMaskingLeftShiftGeneric(&lhs, rhs)
  }
}

----Swift.(file).FixedWidthInteger.addWithOverflow(_:Self,_:Self)
extension FixedWidthInteger  {
  public static func addWithOverflow(
    _ lhs: Self, _ rhs: Self
  ) -> (Self, overflow: Bool) {
    let (partialValue, overflow) =
      lhs.addingReportingOverflow( rhs)
    return (partialValue, overflow: overflow)
  }
}

----Swift.(file).FixedWidthInteger.subtractWithOverflow(_:Self,_:Self)
extension FixedWidthInteger  {
  public static func subtractWithOverflow(
    _ lhs: Self, _ rhs: Self
  ) -> (Self, overflow: Bool) {
    let (partialValue, overflow) =
      lhs.subtractingReportingOverflow( rhs)
    return (partialValue, overflow: overflow)
  }
}

----Swift.(file).FixedWidthInteger.multiplyWithOverflow(_:Self,_:Self)
extension FixedWidthInteger  {
  public static func multiplyWithOverflow(
    _ lhs: Self, _ rhs: Self
  ) -> (Self, overflow: Bool) {
    let (partialValue, overflow) =
      lhs.multipliedReportingOverflow(by: rhs)
    return (partialValue, overflow: overflow)
  }
}

----Swift.(file).FixedWidthInteger.divideWithOverflow(_:Self,_:Self)
extension FixedWidthInteger  {
  public static func divideWithOverflow(
    _ lhs: Self, _ rhs: Self
  ) -> (Self, overflow: Bool) {
    let (partialValue, overflow) =
      lhs.dividedReportingOverflow(by: rhs)
    return (partialValue, overflow: overflow)
  }
}

----Swift.(file).FixedWidthInteger.remainderWithOverflow(_:Self,_:Self)
extension FixedWidthInteger  {
  public static func remainderWithOverflow(
    _ lhs: Self, _ rhs: Self
  ) -> (Self, overflow: Bool) {
    let (partialValue, overflow) =
      lhs.remainderReportingOverflow(dividingBy: rhs)
    return (partialValue, overflow: overflow)
  }
}

----Swift.(file).BinaryInteger.addWithOverflow(_:Self,_:Self)
extension BinaryInteger  {
  public static func addWithOverflow(
    _ lhs: Self, _ rhs: Self
  ) -> (Self, overflow: Bool) {
    fatalError("Unavailable")
  }
}

----Swift.(file).BinaryInteger.subtractWithOverflow(_:Self,_:Self)
extension BinaryInteger  {
  public static func subtractWithOverflow(
    _ lhs: Self, _ rhs: Self
  ) -> (Self, overflow: Bool) {
    fatalError("Unavailable")
  }
}

----Swift.(file).BinaryInteger.multiplyWithOverflow(_:Self,_:Self)
extension BinaryInteger  {
  public static func multiplyWithOverflow(
    _ lhs: Self, _ rhs: Self
  ) -> (Self, overflow: Bool) {
    fatalError("Unavailable")
  }
}

----Swift.(file).BinaryInteger.divideWithOverflow(_:Self,_:Self)
extension BinaryInteger  {
  public static func divideWithOverflow(
    _ lhs: Self, _ rhs: Self
  ) -> (Self, overflow: Bool) {
    fatalError("Unavailable")
  }
}

----Swift.(file).BinaryInteger.remainderWithOverflow(_:Self,_:Self)
extension BinaryInteger  {
  public static func remainderWithOverflow(
    _ lhs: Self, _ rhs: Self
  ) -> (Self, overflow: Bool) {
    fatalError("Unavailable")
  }
}

----Swift.(file).SignedInteger.&+infix(_:Self,_:Self)
extension SignedInteger  {
  public static func &+ (lhs: Self, rhs: Self) -> Self {
    return _maskingAdd(lhs, rhs)
  }
}

----Swift.(file).SignedInteger.&-infix(_:Self,_:Self)
extension SignedInteger  {
  public static func &- (lhs: Self, rhs: Self) -> Self {
    return _maskingSubtract(lhs, rhs)
  }
}

----Swift.(file).SignedInteger.&+infix(_:Self,_:Self)
extension SignedInteger where Self : FixedWidthInteger  {
  public static func &+ (lhs: Self, rhs: Self) -> Self {
    return _maskingAdd(lhs, rhs)
  }
}

----Swift.(file).SignedInteger.&-infix(_:Self,_:Self)
extension SignedInteger where Self : FixedWidthInteger  {
  public static func &- (lhs: Self, rhs: Self) -> Self {
    return _maskingSubtract(lhs, rhs)
  }
}

----Swift.(file).JoinedSequence.Element
extension JoinedSequence {
  public typealias Element = Base.Element.E
}

----Swift.(file).JoinedSequence.init(base:Base,separator:Separator)
extension JoinedSequence {
  public init<Separator : Sequence>(base: Base, separator: Separator)
    where Separator.Element == Element {
    self._base = base
    self._separator = ContiguousArray(separator)
  }
}

----Swift.(file).JoinedSequence.Iterator.init(base:Base.Iterator,separator:Separator)
extension JoinedSequence.Iterator {
    public init<Separator: Sequence>(base: Base.Iterator, separator: Separator)
      where Separator.Element == Element {
      self._base = base
      self._separatorData = ContiguousArray(separator)
    }
}

----Swift.(file).JoinedSequence.Iterator.Element
extension JoinedSequence.Iterator: IteratorProtocol  {
  public typealias Element = Base.Element.E
}

----Swift.(file).JoinedSequence.Iterator.next()
extension JoinedSequence.Iterator: IteratorProtocol  {
  public mutating func next() -> Element? {
    while true {
      switch _state {
      case .start:
        if let nextSubSequence = _base.next() {
          _inner = nextSubSequence.makeIterator()
          _state = .generatingElements
        } else {
          _state = .end
          return nil
        }

      case .generatingElements:
        let result = _inner!.next()
        if _fastPath(result != nil) {
          return result
        }
        _inner = _base.next()?.makeIterator()
        if _inner == nil {
          _state = .end
          return nil
        }
        if !_separatorData.isEmpty {
          _separator = _separatorData.makeIterator()
          _state = .generatingSeparator
        }

      case .generatingSeparator:
        let result = _separator!.next()
        if _fastPath(result != nil) {
          return result
        }
        _state = .generatingElements

      case .end:
        return nil
      }
    }
  }
}

----Swift.(file).JoinedSequence.makeIterator()
extension JoinedSequence: Sequence  {
  public __consuming func makeIterator() -> Iterator {
    return Iterator(base: _base.makeIterator(), separator: _separator)
  }
}

----Swift.(file).Sequence.joined(separator:Separator)
extension Sequence where Element : Sequence  {
  public __consuming func joined<Separator : Sequence>(
    separator: Separator
  ) -> JoinedSequence<Self>
    where Separator.Element == Element.Element {
    return JoinedSequence(base: self, separator: separator)
  }
}

----Swift.(file).AnyKeyPath.rootType
extension AnyKeyPath {
  public static var rootType: Any.Type {
    return _rootAndValueType.root
  }
}

----Swift.(file).AnyKeyPath.valueType
extension AnyKeyPath {
  public static var valueType: Any.Type {
    return _rootAndValueType.value
  }
}

----Swift.(file).AnyKeyPath.hashValue
extension AnyKeyPath {
  final public var hashValue: Int {
    return _hashValue(for: self)
  }
}

----Swift.(file).AnyKeyPath.hash(into:Hasher)
extension AnyKeyPath {
  final public func hash(into hasher: inout Hasher) {
    ObjectIdentifier(type(of: self)).hash(into: &hasher)
    return withBuffer {
      var buffer = $0
      if buffer.data.isEmpty { return }
      while true {
        let (component, type) = buffer.next()
        hasher.combine(component.value)
        if let type = type {
          hasher.combine(unsafeBitCast(type, to: Int.self))
        } else {
          break
        }
      }
    }
  }
}

----Swift.(file).AnyKeyPath.==infix(_:AnyKeyPath,_:AnyKeyPath)
extension AnyKeyPath {
  public static func ==(a: AnyKeyPath, b: AnyKeyPath) -> Bool {
    // Fast-path identical objects
    if a === b {
      return true
    }
    // Short-circuit differently-typed key paths
    if type(of: a) != type(of: b) {
      return false
    }
    return a.withBuffer {
      var aBuffer = $0
      return b.withBuffer {
        var bBuffer = $0
        
        // Two equivalent key paths should have the same reference prefix
        if aBuffer.hasReferencePrefix != bBuffer.hasReferencePrefix {
          return false
        }
        
        // Identity is equal to identity
        if aBuffer.data.isEmpty {
          return bBuffer.data.isEmpty
        }

        while true {
          let (aComponent, aType) = aBuffer.next()
          let (bComponent, bType) = bBuffer.next()
        
          if aComponent.header.endOfReferencePrefix
              != bComponent.header.endOfReferencePrefix
            || aComponent.value != bComponent.value
            || aType != bType {
            return false
          }
          if aType == nil {
            return true
          }
        }
      }
    }
  }
}

----Swift.(file).AnyKeyPath.init()
extension AnyKeyPath {
  internal init() {
    _internalInvariantFailure("use _create(...)")
  }
}

----Swift.(file).AnyKeyPath.withBuffer(_:(KeyPathBuffer) throws -> T)
extension AnyKeyPath {
  internal func withBuffer<T>(_ f: (KeyPathBuffer) throws -> T) rethrows -> T {
    defer { _fixLifetime(self) }
    
    let base = UnsafeRawPointer(Builtin.projectTailElems(self, Int32.self))
    return try f(KeyPathBuffer(base: base))
  }
}

----Swift.(file).AnyKeyPath.deinit()
extension AnyKeyPath {
public class A
}

----Swift.(file).PartialKeyPath.init()
extension PartialKeyPath {
public class PartialKeyPath<Root>: AnyKeyPath {
}

----Swift.(file).PartialKeyPath.deinit()
extension PartialKeyPath {
public class P
}

----Swift.(file).KeyPath.Kind
extension KeyPath {
  internal typealias Kind = K
}

----Swift.(file).KeyPath.kind
extension KeyPath {
  internal class var kind: Kind { return .readOnly }
}

----Swift.(file).KeyPath.appendedType(with:KeyPath<Value, AppendedValue>.Type)
extension KeyPath {
  internal static func appendedType<AppendedValue>(
    with t: KeyPath<Value, AppendedValue>.Type
  ) -> KeyPath<Root, AppendedValue>.Type {
    let resultKind: Kind
    switch (self.kind, t.kind) {
    case (_, .reference):
      resultKind = .reference
    case (let x, .value):
      resultKind = x
    default:
      resultKind = .readOnly
    }
    
    switch resultKind {
    case .readOnly:
      return KeyPath<Root, AppendedValue>.self
    case .value:
      return WritableKeyPath.self
    case .reference:
      return ReferenceWritableKeyPath.self
    }
  }
}

----Swift.(file).KeyPath.deinit()
extension KeyPath {
  deinit {
    withBuffer { $0.destroy() }
  }
}

----Swift.(file).KeyPath.init()
extension KeyPath {
public class KeyPath<Root, Value>: PartialKeyPath<Root> {
}

----Swift.(file).WritableKeyPath.kind
extension WritableKeyPath {
  internal override class var kind: Kind { return .value }
}

----Swift.(file).WritableKeyPath.init()
extension WritableKeyPath {
public class WritableKeyPath<Root, Value>: KeyPath<Root, Value> {
}

----Swift.(file).WritableKeyPath.deinit()
extension WritableKeyPath {
public class W
}

----Swift.(file).ReferenceWritableKeyPath.kind
extension ReferenceWritableKeyPath {
  internal final override class var kind: Kind { return .reference }
}

----Swift.(file).ReferenceWritableKeyPath.init()
extension ReferenceWritableKeyPath {
> : WritableKeyPath<Root, Value> {
}

----Swift.(file).ReferenceWritableKeyPath.deinit()
extension ReferenceWritableKeyPath {
public class R
}

----Swift.(file).KeyPathComputedArgumentLayoutFn
internal typealias KeyPathComputedArgumentLayoutFn = @convention(thin)
  (_ patternArguments: UnsafeRawPointer?) -> (size: Int, alignmentMask: Int)

----Swift.(file).KeyPathComputedArgumentInitializerFn
internal typealias KeyPathComputedArgumentInitializerFn = @convention(thin)
  (_ patternArguments: UnsafeRawPointer?,
   _ instanceArguments: UnsafeMutableRawPointer) -> ()

----Swift.(file)._AppendKeyPath.appending(path:AnyKeyPath)
extension _AppendKeyPath where Self == AnyKeyPath  {
  public func appending(path: AnyKeyPath) -> AnyKeyPath? {
    return _tryToAppendKeyPaths(root: self, leaf: path)
  }
}

----Swift.(file)._AppendKeyPath.appending(path:AnyKeyPath)
extension _AppendKeyPath /* where Self == PartialKeyPath<T> */  {
  public func appending<Root>(path: AnyKeyPath) -> PartialKeyPath<Root>?
  where Self == PartialKeyPath<Root> {
    return _tryToAppendKeyPaths(root: self, leaf: path)
  }
}

----Swift.(file)._AppendKeyPath.appending(path:KeyPath<AppendedRoot, AppendedValue>)
extension _AppendKeyPath /* where Self == PartialKeyPath<T> */  {
  public func appending<Root, AppendedRoot, AppendedValue>(
    path: KeyPath<AppendedRoot, AppendedValue>
  ) -> KeyPath<Root, AppendedValue>?
  where Self == PartialKeyPath<Root> {
    return _tryToAppendKeyPaths(root: self, leaf: path)
  }
}

----Swift.(file)._AppendKeyPath.appending(path:ReferenceWritableKeyPath<AppendedRoot, AppendedValue>)
extension _AppendKeyPath /* where Self == PartialKeyPath<T> */  {
  public func appending<Root, AppendedRoot, AppendedValue>(
    path: ReferenceWritableKeyPath<AppendedRoot, AppendedValue>
  ) -> ReferenceWritableKeyPath<Root, AppendedValue>?
  where Self == PartialKeyPath<Root> {
    return _tryToAppendKeyPaths(root: self, leaf: path)
  }
}

----Swift.(file)._AppendKeyPath.appending(path:KeyPath<Value, AppendedValue>)
extension _AppendKeyPath /* where Self == KeyPath<T,U> */  {
  public func appending<Root, Value, AppendedValue>(
    path: KeyPath<Value, AppendedValue>
  ) -> KeyPath<Root, AppendedValue>
  where Self: KeyPath<Root, Value> {
    return _appendingKeyPaths(root: self, leaf: path)
  }
}

----Swift.(file)._AppendKeyPath.appending(path:ReferenceWritableKeyPath<Value, AppendedValue>)
extension _AppendKeyPath /* where Self == KeyPath<T,U> */  {
  public func appending<Root, Value, AppendedValue>(
    path: ReferenceWritableKeyPath<Value, AppendedValue>
  ) -> ReferenceWritableKeyPath<Root, AppendedValue>
  where Self == KeyPath<Root, Value> {
    return _appendingKeyPaths(root: self, leaf: path)
  }
}

----Swift.(file)._AppendKeyPath.appending(path:WritableKeyPath<Value, AppendedValue>)
extension _AppendKeyPath /* where Self == WritableKeyPath<T,U> */  {
  public func appending<Root, Value, AppendedValue>(
    path: WritableKeyPath<Value, AppendedValue>
  ) -> WritableKeyPath<Root, AppendedValue>
  where Self == WritableKeyPath<Root, Value> {
    return _appendingKeyPaths(root: self, leaf: path)
  }
}

----Swift.(file)._AppendKeyPath.appending(path:ReferenceWritableKeyPath<Value, AppendedValue>)
extension _AppendKeyPath /* where Self == WritableKeyPath<T,U> */  {
  public func appending<Root, Value, AppendedValue>(
    path: ReferenceWritableKeyPath<Value, AppendedValue>
  ) -> ReferenceWritableKeyPath<Root, AppendedValue>
  where Self == WritableKeyPath<Root, Value> {
    return _appendingKeyPaths(root: self, leaf: path)
  }
}

----Swift.(file)._AppendKeyPath.appending(path:WritableKeyPath<Value, AppendedValue>)
extension _AppendKeyPath /* where Self == ReferenceWritableKeyPath<T,U> */  {
  public func appending<Root, Value, AppendedValue>(
    path: WritableKeyPath<Value, AppendedValue>
  ) -> ReferenceWritableKeyPath<Root, AppendedValue>
  where Self == ReferenceWritableKeyPath<Root, Value> {
    return _appendingKeyPaths(root: self, leaf: path)
  }
}

----Swift.(file).keyPathObjectHeaderSize
internal var keyPathObjectHeaderSize: Int {
  return MemoryLayout<HeapObject>.size + MemoryLayout<Int>.size
}

----Swift.(file).keyPathPatternHeaderSize
internal var keyPathPatternHeaderSize: Int {
  return 16
}

----Swift.(file).MetadataReference
internal typealias MetadataReference = U

----Swift.(file).KeyValuePairs.init(dictionaryLiteral:[(Key, Value)])
extension KeyValuePairs {
  public init(dictionaryLiteral elements: (Key, Value)...) {
    self._elements = elements
  }
}

----Swift.(file).KeyValuePairs.Element
extension KeyValuePairs : RandomAccessCollection  {
  public typealias Element = (key: Key, value: Value)
}

----Swift.(file).KeyValuePairs.Index
extension KeyValuePairs : RandomAccessCollection  {
  public typealias Index = I
}

----Swift.(file).KeyValuePairs.Indices
extension KeyValuePairs : RandomAccessCollection  {
  public typealias Indices = Range<Int>
}

----Swift.(file).KeyValuePairs.SubSequence
extension KeyValuePairs : RandomAccessCollection  {
  public typealias SubSequence = Slice<KeyValuePairs>
}

----Swift.(file).KeyValuePairs.startIndex
extension KeyValuePairs : RandomAccessCollection  {
  public var startIndex: Index { return 0 }
}

----Swift.(file).KeyValuePairs.endIndex
extension KeyValuePairs : RandomAccessCollection  {
  public var endIndex: Index { return _elements.endIndex }
}

----Swift.(file).KeyValuePairs.subscript(_:KeyValuePairs<Key, Value>.Index)
extension KeyValuePairs : RandomAccessCollection  {
  public subscript(position: Index) -> Element {
    return _elements[position]
  }
}

----Swift.(file).KeyValuePairs.description
extension KeyValuePairs: CustomStringConvertible  {
  public var description: String {
    return _makeKeyValuePairDescription()
  }
}

----Swift.(file).KeyValuePairs.debugDescription
extension KeyValuePairs: CustomDebugStringConvertible  {
  public var debugDescription: String {
    return _makeKeyValuePairDescription()
  }
}

----Swift.(file).LazyCollectionProtocol.lazy
extension LazyCollectionProtocol  {
   public var lazy: LazyCollection<Elements> {		
     return elements.lazy		
   }
}

----Swift.(file).LazyCollectionProtocol.lazy
 extension LazyCollectionProtocol where Elements: LazyCollectionProtocol  {
   public var lazy: Elements {		
     return elements		
   }
}

----Swift.(file).LazyCollection
public typealias LazyCollection<T: Collection> = LazySequence<T>

----Swift.(file).LazyCollection.Index
extension LazyCollection : Collection  {
  public typealias Index = Base.I
}

----Swift.(file).LazyCollection.Indices
extension LazyCollection : Collection  {
  public typealias Indices = Base.I
}

----Swift.(file).LazyCollection.SubSequence
extension LazyCollection : Collection  {
  public typealias SubSequence = Slice<LazySequence>
}

----Swift.(file).LazyCollection.startIndex
extension LazyCollection : Collection  {
  public var startIndex: Index { return _base.startIndex }
}

----Swift.(file).LazyCollection.endIndex
extension LazyCollection : Collection  {
  public var endIndex: Index { return _base.endIndex }
}

----Swift.(file).LazyCollection.indices
extension LazyCollection : Collection  {
  public var indices: Indices { return _base.indices }
}

----Swift.(file).LazyCollection.index(after:LazySequence<Base>.Index)
extension LazyCollection : Collection  {
  public func index(after i: Index) -> Index {
    return _base.index(after: i)
  }
}

----Swift.(file).LazyCollection.subscript(_:LazySequence<Base>.Index)
extension LazyCollection : Collection  {
  public subscript(position: Index) -> Element {
    return _base[position]
  }
}

----Swift.(file).LazyCollection.isEmpty
extension LazyCollection : Collection  {
  public var isEmpty: Bool {
    return _base.isEmpty
  }
}

----Swift.(file).LazyCollection.count
extension LazyCollection : Collection  {
  public var count: Int {
    return _base.count
  }
}

----Swift.(file).LazyCollection.index(_:LazySequence<Base>.Index,offsetBy:Int)
extension LazyCollection : Collection  {
  public func index(_ i: Index, offsetBy n: Int) -> Index {
    return _base.index(i, offsetBy: n)
  }
}

----Swift.(file).LazyCollection.index(_:LazySequence<Base>.Index,offsetBy:Int,limitedBy:LazySequence<Base>.Index)
extension LazyCollection : Collection  {
  public func index(
    _ i: Index, offsetBy n: Int, limitedBy limit: Index
  ) -> Index? {
    return _base.index(i, offsetBy: n, limitedBy: limit)
  }
}

----Swift.(file).LazyCollection.distance(from:LazySequence<Base>.Index,to:LazySequence<Base>.Index)
extension LazyCollection : Collection  {
  public func distance(from start: Index, to end: Index) -> Int {
    return _base.distance(from:start, to: end)
  }
}

----Swift.(file).LazyCollection.index(before:LazySequence<Base>.Index)
extension LazyCollection : BidirectionalCollection
  where Base : BidirectionalCollection  {
  public func index(before i: Index) -> Index {
    return _base.index(before: i)
  }
}

----Swift.(file).LazySequenceProtocol.Elements
extension LazySequenceProtocol {
  associatedtype Elements: Sequence = Self where Elements.Element == E
}

----Swift.(file).LazySequenceProtocol.lazy
extension LazySequenceProtocol  {
  public var lazy: LazySequence<Elements> {
    return elements.lazy
  }
}

----Swift.(file).LazySequenceProtocol.lazy
extension LazySequenceProtocol where Elements: LazySequenceProtocol  {
  public var lazy: Elements {
    return elements
  }
}

----Swift.(file).LazySequence.init(_base:Base)
extension LazySequence {
  internal init(_base: Base) {
    self._base = _base
  }
}

----Swift.(file).LazySequence.Element
extension LazySequence: Sequence  {
  public typealias Element = Base.E
}

----Swift.(file).LazySequence.Iterator
extension LazySequence: Sequence  {
  public typealias Iterator = Base.I
}

----Swift.(file).LazySequence.makeIterator()
extension LazySequence: Sequence  {
  public __consuming func makeIterator() -> Iterator {
    return _base.makeIterator()
  }
}

----Swift.(file).LazySequence.underestimatedCount
extension LazySequence: Sequence  {
  public var underestimatedCount: Int {
    return _base.underestimatedCount
  }
}

----Swift.(file).LazySequence.Elements
extension LazySequence: LazySequenceProtocol  {
  public typealias Elements = B
}

----Swift.(file).Sequence.lazy
extension Sequence  {
  public var lazy: LazySequence<Self> {
    return LazySequence(_base: self)
  }
}

----Swift.(file).withExtendedLifetime(_:T,_:() throws -> Result)
public func withExtendedLifetime<T, Result>(
  _ x: T, _ body: () throws -> Result
) rethrows -> Result {
  defer { _fixLifetime(x) }
  return try body()
}

----Swift.(file).withExtendedLifetime(_:T,_:(T) throws -> Result)
public func withExtendedLifetime<T, Result>(
  _ x: T, _ body: (T) throws -> Result
) rethrows -> Result {
  defer { _fixLifetime(x) }
  return try body(x)
}

----Swift.(file).withUnsafeMutablePointer(to:T,_:(UnsafeMutablePointer<T>) throws -> Result)
public func withUnsafeMutablePointer<T, Result>(
  to value: inout T,
  _ body: (UnsafeMutablePointer<T>) throws -> Result
) rethrows -> Result
{
  return try body(UnsafeMutablePointer<T>(Builtin.addressof(&value)))
}

----Swift.(file).withUnsafePointer(to:T,_:(UnsafePointer<T>) throws -> Result)
public func withUnsafePointer<T, Result>(
  to value: T,
  _ body: (UnsafePointer<T>) throws -> Result
) rethrows -> Result
{
  return try body(UnsafePointer<T>(Builtin.addressOfBorrow(value)))
}

----Swift.(file).withUnsafePointer(to:T,_:(UnsafePointer<T>) throws -> Result)
public func withUnsafePointer<T, Result>(
  to value: inout T,
  _ body: (UnsafePointer<T>) throws -> Result
) rethrows -> Result
{
  return try body(UnsafePointer<T>(Builtin.addressof(&value)))
}

----Swift.(file).String.withCString(_:(UnsafePointer<Int8>) throws -> Result)
extension String  {
  public func withCString<Result>(
    _ body: (UnsafePointer<Int8>) throws -> Result
  ) rethrows -> Result {
    return try _guts.withCString(body)
  }
}

----Swift.(file).ManagedBuffer.header
extension ManagedBuffer {
  public final var h
}

----Swift.(file).ManagedBuffer.init(_doNotCallMe:())
extension ManagedBuffer {
  internal init(_doNotCallMe: ()) {
    _internalInvariantFailure("Only initialize these by calling create")
  }
}

----Swift.(file).ManagedBuffer.deinit()
extension ManagedBuffer {
open class M
}

----Swift.(file).ManagedBuffer.create(minimumCapacity:Int,makingHeaderWith:(ManagedBuffer<Header, Element>) throws -> Header)
extension ManagedBuffer  {
  public final class func create(
    minimumCapacity: Int,
    makingHeaderWith factory: (
      ManagedBuffer<Header, Element>) throws -> Header
  ) rethrows -> ManagedBuffer<Header, Element> {

    let p = Builtin.allocWithTailElems_1(
         self,
         minimumCapacity._builtinWordValue, Element.self)

    let initHeaderVal = try factory(p)
    p.headerAddress.initialize(to: initHeaderVal)
    // The _fixLifetime is not really needed, because p is used afterwards.
    // But let's be conservative and fix the lifetime after we use the
    // headerAddress.
    _fixLifetime(p)
    return p
  }
}

----Swift.(file).ManagedBuffer.capacity
extension ManagedBuffer  {
  public final var capacity: Int {
    let storageAddr = UnsafeMutableRawPointer(Builtin.bridgeToRawPointer(self))
    let endAddr = storageAddr + _swift_stdlib_malloc_size(storageAddr)
    let realCapacity = endAddr.assumingMemoryBound(to: Element.self) -
      firstElementAddress
    return realCapacity
  }
}

----Swift.(file).ManagedBuffer.firstElementAddress
extension ManagedBuffer  {
  internal final var firstElementAddress: UnsafeMutablePointer<Element> {
    return UnsafeMutablePointer(
      Builtin.projectTailElems(self, Element.self))
  }
}

----Swift.(file).ManagedBuffer.headerAddress
extension ManagedBuffer  {
  internal final var headerAddress: UnsafeMutablePointer<Header> {
    return UnsafeMutablePointer<Header>(Builtin.addressof(&header))
  }
}

----Swift.(file).ManagedBuffer.withUnsafeMutablePointerToHeader(_:(UnsafeMutablePointer<Header>) throws -> R)
extension ManagedBuffer  {
  public final func withUnsafeMutablePointerToHeader<R>(
    _ body: (UnsafeMutablePointer<Header>) throws -> R
  ) rethrows -> R {
    return try withUnsafeMutablePointers { (v, _) in return try body(v) }
  }
}

----Swift.(file).ManagedBuffer.withUnsafeMutablePointerToElements(_:(UnsafeMutablePointer<Element>) throws -> R)
extension ManagedBuffer  {
  public final func withUnsafeMutablePointerToElements<R>(
    _ body: (UnsafeMutablePointer<Element>) throws -> R
  ) rethrows -> R {
    return try withUnsafeMutablePointers { return try body($1) }
  }
}

----Swift.(file).ManagedBuffer.withUnsafeMutablePointers(_:(UnsafeMutablePointer<Header>, UnsafeMutablePointer<Element>) throws -> R)
extension ManagedBuffer  {
  public final func withUnsafeMutablePointers<R>(
    _ body: (UnsafeMutablePointer<Header>, UnsafeMutablePointer<Element>) throws -> R
  ) rethrows -> R {
    defer { _fixLifetime(self) }
    return try body(headerAddress, firstElementAddress)
  }
}

----Swift.(file).tryReallocateUniquelyReferenced(buffer:Buffer,newMinimumCapacity:Int)
public func tryReallocateUniquelyReferenced<Header, Element, Buffer: ManagedBuffer<Header, Element>>(
  buffer: inout Buffer,
  newMinimumCapacity: Int
) -> Bool {
  precondition(_isBitwiseTakable(Header.self))
  precondition(_isBitwiseTakable(Element.self))
  precondition(isKnownUniquelyReferenced(&buffer))

  let newSizeInBytes = MemoryLayout<Header>.stride
    + newMinimumCapacity * MemoryLayout<Element>.stride

  return withUnsafeMutablePointer(to: &buffer) {
    $0.withMemoryRebound(to: UnsafeMutableRawPointer.self, capacity: 1) {
      if let reallocdObject = _reallocObject($0.pointee, newSizeInBytes) {
        $0.pointee = reallocdObject
        return true
      } else {
        return false
      }
    }
  }
}

----Swift.(file).ManagedBufferPointer.init(bufferClass:AnyClass,minimumCapacity:Int,makingHeaderWith:(AnyObject, (AnyObject) -> Int) throws -> Header)
extension ManagedBufferPointer {
  public init(
    bufferClass: AnyClass,
    minimumCapacity: Int,
    makingHeaderWith factory:
      (_ buffer: AnyObject, _ capacity: (AnyObject) -> Int) throws -> Header
  ) rethrows {
    self = ManagedBufferPointer(
      bufferClass: bufferClass, minimumCapacity: minimumCapacity)

    // initialize the header field
    try withUnsafeMutablePointerToHeader {
      $0.initialize(to: 
        try factory(
          self.buffer,
          {
            ManagedBufferPointer(unsafeBufferObject: $0).capacity
          }))
    }
    // FIXME: workaround for <rdar://problem/18619176>.  If we don't
    // access header somewhere, its addressor gets linked away
    _ = header
  }
}

----Swift.(file).ManagedBufferPointer.init(unsafeBufferObject:AnyObject)
extension ManagedBufferPointer {
  public init(unsafeBufferObject buffer: AnyObject) {
    ManagedBufferPointer._checkValidBufferClass(type(of: buffer))

    self._nativeBuffer = Builtin.unsafeCastToNativeObject(buffer)
  }
}

----Swift.(file).ManagedBufferPointer.init(_uncheckedUnsafeBufferObject:AnyObject)
extension ManagedBufferPointer {
  internal init(_uncheckedUnsafeBufferObject buffer: AnyObject) {
    ManagedBufferPointer._internalInvariantValidBufferClass(type(of: buffer))
    self._nativeBuffer = Builtin.unsafeCastToNativeObject(buffer)
  }
}

----Swift.(file).ManagedBufferPointer.init(bufferClass:AnyClass,minimumCapacity:Int)
extension ManagedBufferPointer {
  internal init(
    bufferClass: AnyClass,
    minimumCapacity: Int
  ) {
    ManagedBufferPointer._checkValidBufferClass(bufferClass, creating: true)
    _precondition(
      minimumCapacity >= 0,
      "ManagedBufferPointer must have non-negative capacity")

    self.init(
      _uncheckedBufferClass: bufferClass, minimumCapacity: minimumCapacity)
  }
}

----Swift.(file).ManagedBufferPointer.init(_uncheckedBufferClass:AnyClass,minimumCapacity:Int)
extension ManagedBufferPointer {
  internal init(
    _uncheckedBufferClass: AnyClass,
    minimumCapacity: Int
  ) {
    ManagedBufferPointer._internalInvariantValidBufferClass(_uncheckedBufferClass, creating: true)
    _internalInvariant(
      minimumCapacity >= 0,
      "ManagedBufferPointer must have non-negative capacity")

    let totalSize = ManagedBufferPointer._elementOffset
      +  minimumCapacity * MemoryLayout<Element>.stride

    let newBuffer: AnyObject = _swift_bufferAllocate(
      bufferType: _uncheckedBufferClass,
      size: totalSize,
      alignmentMask: ManagedBufferPointer._alignmentMask)

    self._nativeBuffer = Builtin.unsafeCastToNativeObject(newBuffer)
  }
}

----Swift.(file).ManagedBufferPointer.init(_:ManagedBuffer<Header, Element>)
extension ManagedBufferPointer {
  internal init(_ buffer: ManagedBuffer<Header, Element>) {
    _nativeBuffer = Builtin.unsafeCastToNativeObject(buffer)
  }
}

----Swift.(file).ManagedBufferPointer.header
extension ManagedBufferPointer  {
  public var header: Header {
    _read {
      yield _headerPointer.pointee
    }
    _modify {
      yield &_headerPointer.pointee
    }
  }
}

----Swift.(file).ManagedBufferPointer.buffer
extension ManagedBufferPointer  {
  public var buffer: AnyObject {
    return Builtin.castFromNativeObject(_nativeBuffer)
  }
}

----Swift.(file).ManagedBufferPointer.capacity
extension ManagedBufferPointer  {
  public var capacity: Int {
    return (
      _capacityInBytes &- ManagedBufferPointer._elementOffset
    ) / MemoryLayout<Element>.stride
  }
}

----Swift.(file).ManagedBufferPointer.withUnsafeMutablePointerToHeader(_:(UnsafeMutablePointer<Header>) throws -> R)
extension ManagedBufferPointer  {
  public func withUnsafeMutablePointerToHeader<R>(
    _ body: (UnsafeMutablePointer<Header>) throws -> R
  ) rethrows -> R {
    return try withUnsafeMutablePointers { (v, _) in return try body(v) }
  }
}

----Swift.(file).ManagedBufferPointer.withUnsafeMutablePointerToElements(_:(UnsafeMutablePointer<Element>) throws -> R)
extension ManagedBufferPointer  {
  public func withUnsafeMutablePointerToElements<R>(
    _ body: (UnsafeMutablePointer<Element>) throws -> R
  ) rethrows -> R {
    return try withUnsafeMutablePointers { return try body($1) }
  }
}

----Swift.(file).ManagedBufferPointer.withUnsafeMutablePointers(_:(UnsafeMutablePointer<Header>, UnsafeMutablePointer<Element>) throws -> R)
extension ManagedBufferPointer  {
  public func withUnsafeMutablePointers<R>(
    _ body: (UnsafeMutablePointer<Header>, UnsafeMutablePointer<Element>) throws -> R
  ) rethrows -> R {
    defer { _fixLifetime(_nativeBuffer) }
    return try body(_headerPointer, _elementPointer)
  }
}

----Swift.(file).ManagedBufferPointer.isUniqueReference()
extension ManagedBufferPointer  {
  public mutating func isUniqueReference() -> Bool {
    return _isUnique(&_nativeBuffer)
  }
}

----Swift.(file).ManagedBufferPointer.==infix(_:ManagedBufferPointer<Header, Element>,_:ManagedBufferPointer<Header, Element>)
extension ManagedBufferPointer: Equatable  {
  public static func == (
    lhs: ManagedBufferPointer,
    rhs: ManagedBufferPointer
  ) -> Bool {
    return lhs._address == rhs._address
  }
}

----Swift.(file).isKnownUniquelyReferenced(_:T)
public func isKnownUniquelyReferenced<T : AnyObject>(_ object: inout T) -> Bool
{
  return _isUnique(&object)
}

----Swift.(file).isKnownUniquelyReferenced(_:T?)
public func isKnownUniquelyReferenced<T : AnyObject>(
  _ object: inout T?
) -> Bool {
  return _isUnique(&object)
}

----Swift.(file).LazyMapSequence.Elements
extension LazyMapSequence {
  public typealias Elements = L
}

----Swift.(file).LazyMapSequence.init(_base:Base,transform:(Base.Element) -> Element)
extension LazyMapSequence {
  internal init(_base: Base, transform: @escaping (Base.Element) -> Element) {
    self._base = _base
    self._transform = transform
  }
}

----Swift.(file).LazyMapSequence.Iterator.base
extension LazyMapSequence.Iterator {
    public var base: Base.Iterator { return _base }
}

----Swift.(file).LazyMapSequence.Iterator.init(_base:Base.Iterator,_transform:(Base.Element) -> Element)
extension LazyMapSequence.Iterator {
    internal init(
      _base: Base.Iterator, 
      _transform: @escaping (Base.Element) -> Element
    ) {
      self._base = _base
      self._transform = _transform
    }
}

----Swift.(file).LazyMapSequence.Iterator.next()
extension LazyMapSequence.Iterator: IteratorProtocol, Sequence  {
  public mutating func next() -> Element? {
    return _base.next().map(_transform)
  }
}

----Swift.(file).LazyMapSequence.makeIterator()
extension LazyMapSequence: LazySequenceProtocol  {
  public __consuming func makeIterator() -> Iterator {
    return Iterator(_base: _base.makeIterator(), _transform: _transform)
  }
}

----Swift.(file).LazyMapSequence.underestimatedCount
extension LazyMapSequence: LazySequenceProtocol  {
  public var underestimatedCount: Int {
    return _base.underestimatedCount
  }
}

----Swift.(file).LazyMapCollection
public typealias LazyMapCollection<T: Collection,U> = LazyMapSequence<T,U>

----Swift.(file).LazyMapCollection.Index
extension LazyMapCollection: Collection  {
  public typealias Index = Base.I
}

----Swift.(file).LazyMapCollection.Indices
extension LazyMapCollection: Collection  {
  public typealias Indices = Base.I
}

----Swift.(file).LazyMapCollection.SubSequence
extension LazyMapCollection: Collection  {
  public typealias SubSequence = LazyMapCollection<Base.SubSequence, Element>
}

----Swift.(file).LazyMapCollection.startIndex
extension LazyMapCollection: Collection  {
  public var startIndex: Base.Index { return _base.startIndex }
}

----Swift.(file).LazyMapCollection.endIndex
extension LazyMapCollection: Collection  {
  public var endIndex: Base.Index { return _base.endIndex }
}

----Swift.(file).LazyMapCollection.index(after:LazyMapSequence<Base, Element>.Index)
extension LazyMapCollection: Collection  {
  public func index(after i: Index) -> Index { return _base.index(after: i) }
}

----Swift.(file).LazyMapCollection.formIndex(after:LazyMapSequence<Base, Element>.Index)
extension LazyMapCollection: Collection  {
  public func formIndex(after i: inout Index) { _base.formIndex(after: &i) }
}

----Swift.(file).LazyMapCollection.subscript(_:Base.Index)
extension LazyMapCollection: Collection  {
  public subscript(position: Base.Index) -> Element {
    return _transform(_base[position])
  }
}

----Swift.(file).LazyMapCollection.subscript(_:Range<Base.Index>)
extension LazyMapCollection: Collection  {
  public subscript(bounds: Range<Base.Index>) -> SubSequence {
    return SubSequence(_base: _base[bounds], transform: _transform)
  }
}

----Swift.(file).LazyMapCollection.indices
extension LazyMapCollection: Collection  {
  public var indices: Indices {
    return _base.indices
  }
}

----Swift.(file).LazyMapCollection.isEmpty
extension LazyMapCollection: Collection  {
  public var isEmpty: Bool { return _base.isEmpty }
}

----Swift.(file).LazyMapCollection.count
extension LazyMapCollection: Collection  {
  public var count: Int {
    return _base.count
  }
}

----Swift.(file).LazyMapCollection.index(_:LazyMapSequence<Base, Element>.Index,offsetBy:Int)
extension LazyMapCollection: Collection  {
  public func index(_ i: Index, offsetBy n: Int) -> Index {
    return _base.index(i, offsetBy: n)
  }
}

----Swift.(file).LazyMapCollection.index(_:LazyMapSequence<Base, Element>.Index,offsetBy:Int,limitedBy:LazyMapSequence<Base, Element>.Index)
extension LazyMapCollection: Collection  {
  public func index(
    _ i: Index, offsetBy n: Int, limitedBy limit: Index
  ) -> Index? {
    return _base.index(i, offsetBy: n, limitedBy: limit)
  }
}

----Swift.(file).LazyMapCollection.distance(from:LazyMapSequence<Base, Element>.Index,to:LazyMapSequence<Base, Element>.Index)
extension LazyMapCollection: Collection  {
  public func distance(from start: Index, to end: Index) -> Int {
    return _base.distance(from: start, to: end)
  }
}

----Swift.(file).LazyMapCollection.index(before:LazyMapSequence<Base, Element>.Index)
extension LazyMapCollection : BidirectionalCollection
  where Base : BidirectionalCollection  {
  public func index(before i: Index) -> Index { return _base.index(before: i) }
}

----Swift.(file).LazyMapCollection.formIndex(before:LazyMapSequence<Base, Element>.Index)
extension LazyMapCollection : BidirectionalCollection
  where Base : BidirectionalCollection  {
  public func formIndex(before i: inout Index) {
    _base.formIndex(before: &i)
  }
}

----Swift.(file).LazySequenceProtocol.map(_:(Self.Element) -> U)
extension LazySequenceProtocol  {
  public func map<U>(
    _ transform: @escaping (Element) -> U
  ) -> LazyMapSequence<Elements, U> {
    return LazyMapSequence(_base: elements, transform: transform)
  }
}

----Swift.(file).LazyMapSequence.map(_:(Element) -> ElementOfResult)
extension LazyMapSequence  {
  public func map<ElementOfResult>(
    _ transform: @escaping (Element) -> ElementOfResult
  ) -> LazyMapSequence<Base, ElementOfResult> {
    return LazyMapSequence<Base, ElementOfResult>(
      _base: _base,
      transform: { transform(self._transform($0)) })
  }
}

----Swift.(file).LazyMapCollection.map(_:(Element) -> ElementOfResult)
extension LazyMapCollection  {
  public func map<ElementOfResult>(
    _ transform: @escaping (Element) -> ElementOfResult
  ) -> LazyMapCollection<Base, ElementOfResult> {
    return LazyMapCollection<Base, ElementOfResult>(
      _base: _base,
      transform: {transform(self._transform($0))})
  }
}

----Swift.(file).MemoryLayout.size
extension MemoryLayout {
  public static var size: Int {
    return Int(Builtin.sizeof(T.self))
  }
}

----Swift.(file).MemoryLayout.stride
extension MemoryLayout {
  public static var stride: Int {
    return Int(Builtin.strideof(T.self))
  }
}

----Swift.(file).MemoryLayout.alignment
extension MemoryLayout {
  public static var alignment: Int {
    return Int(Builtin.alignof(T.self))
  }
}

----Swift.(file).MemoryLayout.size(ofValue:T)
extension MemoryLayout  {
  public static func size(ofValue value: T) -> Int {
    return MemoryLayout.size
  }
}

----Swift.(file).MemoryLayout.stride(ofValue:T)
extension MemoryLayout  {
  public static func stride(ofValue value: T) -> Int {
    return MemoryLayout.stride
  }
}

----Swift.(file).MemoryLayout.alignment(ofValue:T)
extension MemoryLayout  {
  public static func alignment(ofValue value: T) -> Int {
    return MemoryLayout.alignment
  }
}

----Swift.(file).MemoryLayout.offset(of:PartialKeyPath<T>)
extension MemoryLayout  {
  public static func offset(of key: PartialKeyPath<T>) -> Int? {
    return key._storedInlineOffset
  }
}

----Swift.(file).BidirectionalIndexable
public typealias BidirectionalIndexable = B

----Swift.(file).IndexableBase
public typealias IndexableBase = C

----Swift.(file).Indexable
public typealias Indexable = C

----Swift.(file).MutableIndexable
public typealias MutableIndexable = M

----Swift.(file).RandomAccessIndexable
public typealias RandomAccessIndexable = R

----Swift.(file).RangeReplaceableIndexable
public typealias RangeReplaceableIndexable = R

----Swift.(file).EnumeratedIterator
public typealias EnumeratedIterator<T: Sequence> = EnumeratedSequence<T>.I

----Swift.(file).IteratorOverOne
public typealias IteratorOverOne<T> = CollectionOfOne<T>.I

----Swift.(file).EmptyIterator
public typealias EmptyIterator<T> = EmptyCollection<T>.I

----Swift.(file).LazyFilterIterator
public typealias LazyFilterIterator<T: Sequence> = LazyFilterSequence<T>.I

----Swift.(file).LazyFilterIndex
public typealias LazyFilterIndex<Base: Collection> = Base.I

----Swift.(file).LazyDropWhileIterator
public typealias LazyDropWhileIterator<T> = LazyDropWhileSequence<T>.Iterator where T: S

----Swift.(file).LazyDropWhileIndex
public typealias LazyDropWhileIndex<T> = LazyDropWhileCollection<T>.Index where T: C

----Swift.(file).LazyDropWhileBidirectionalCollection
public typealias LazyDropWhileBidirectionalCollection<T> = LazyDropWhileCollection<T> where T: B

----Swift.(file).LazyFilterBidirectionalCollection
public typealias LazyFilterBidirectionalCollection<T> = LazyFilterCollection<T> where T : B

----Swift.(file).LazyMapIterator
public typealias LazyMapIterator<T, E> = LazyMapSequence<T, E>.Iterator where T: S

----Swift.(file).LazyMapBidirectionalCollection
public typealias LazyMapBidirectionalCollection<T, E> = LazyMapCollection<T, E> where T : B

----Swift.(file).LazyMapRandomAccessCollection
public typealias LazyMapRandomAccessCollection<T, E> = LazyMapCollection<T, E> where T : R

----Swift.(file).LazyBidirectionalCollection
public typealias LazyBidirectionalCollection<T> = LazyCollection<T> where T : B

----Swift.(file).LazyRandomAccessCollection
public typealias LazyRandomAccessCollection<T> = LazyCollection<T> where T : R

----Swift.(file).FlattenCollectionIndex
public typealias FlattenCollectionIndex<T> = FlattenCollection<T>.Index where T : Collection, T.Element : C

----Swift.(file).FlattenBidirectionalCollectionIndex
public typealias FlattenBidirectionalCollectionIndex<T> = FlattenCollection<T>.Index where T : BidirectionalCollection, T.Element : B

----Swift.(file).FlattenBidirectionalCollection
public typealias FlattenBidirectionalCollection<T> = FlattenCollection<T> where T : BidirectionalCollection, T.Element : B

----Swift.(file).JoinedIterator
public typealias JoinedIterator<T: Sequence> = JoinedSequence<T>.Iterator where T.Element: S

----Swift.(file).Zip2Iterator
public typealias Zip2Iterator<T, U> = Zip2Sequence<T, U>.Iterator where T: Sequence, U: S

----Swift.(file).LazyPrefixWhileIterator
public typealias LazyPrefixWhileIterator<T> = LazyPrefixWhileSequence<T>.Iterator where T: S

----Swift.(file).LazyPrefixWhileIndex
public typealias LazyPrefixWhileIndex<T> = LazyPrefixWhileCollection<T>.Index where T: C

----Swift.(file).LazyPrefixWhileBidirectionalCollection
public typealias LazyPrefixWhileBidirectionalCollection<T> = LazyPrefixWhileCollection<T> where T: B

----Swift.(file).ReversedRandomAccessCollection
public typealias ReversedRandomAccessCollection<T: RandomAccessCollection> = ReversedCollection<T>

----Swift.(file).ReversedIndex
public typealias ReversedIndex<T: BidirectionalCollection> = ReversedCollection<T>

----Swift.(file).BidirectionalSlice
public typealias BidirectionalSlice<T> = Slice<T> where T : B

----Swift.(file).RandomAccessSlice
public typealias RandomAccessSlice<T> = Slice<T> where T : R

----Swift.(file).RangeReplaceableSlice
public typealias RangeReplaceableSlice<T> = Slice<T> where T : R

----Swift.(file).RangeReplaceableBidirectionalSlice
public typealias RangeReplaceableBidirectionalSlice<T> = Slice<T> where T : RangeReplaceableCollection & B

----Swift.(file).RangeReplaceableRandomAccessSlice
public typealias RangeReplaceableRandomAccessSlice<T> = Slice<T> where T : RangeReplaceableCollection & R

----Swift.(file).MutableSlice
public typealias MutableSlice<T> = Slice<T> where T : M

----Swift.(file).MutableBidirectionalSlice
public typealias MutableBidirectionalSlice<T> = Slice<T> where T : MutableCollection & B

----Swift.(file).MutableRandomAccessSlice
public typealias MutableRandomAccessSlice<T> = Slice<T> where T : MutableCollection & R

----Swift.(file).MutableRangeReplaceableSlice
public typealias MutableRangeReplaceableSlice<T> = Slice<T> where T : MutableCollection & R

----Swift.(file).MutableRangeReplaceableBidirectionalSlice
public typealias MutableRangeReplaceableBidirectionalSlice<T> = Slice<T> where T : MutableCollection & RangeReplaceableCollection & B

----Swift.(file).MutableRangeReplaceableRandomAccessSlice
public typealias MutableRangeReplaceableRandomAccessSlice<T> = Slice<T> where T : MutableCollection & RangeReplaceableCollection & R

----Swift.(file).DefaultBidirectionalIndices
public typealias DefaultBidirectionalIndices<T> = DefaultIndices<T> where T : B

----Swift.(file).DefaultRandomAccessIndices
public typealias DefaultRandomAccessIndices<T> = DefaultIndices<T> where T : R

----Swift.(file).NilLiteralConvertible
public typealias NilLiteralConvertible = E

----Swift.(file).IntegerLiteralConvertible
public typealias IntegerLiteralConvertible = E

----Swift.(file).FloatLiteralConvertible
public typealias FloatLiteralConvertible = E

----Swift.(file).BooleanLiteralConvertible
public typealias BooleanLiteralConvertible = E

----Swift.(file).UnicodeScalarLiteralConvertible
public typealias UnicodeScalarLiteralConvertible = E

----Swift.(file).ExtendedGraphemeClusterLiteralConvertible
public typealias ExtendedGraphemeClusterLiteralConvertible = E

----Swift.(file).StringLiteralConvertible
public typealias StringLiteralConvertible = E

----Swift.(file).ArrayLiteralConvertible
public typealias ArrayLiteralConvertible = E

----Swift.(file).DictionaryLiteralConvertible
public typealias DictionaryLiteralConvertible = E

----Swift.(file).StringInterpolationConvertible
public typealias StringInterpolationConvertible = E

----Swift.(file).ClosedRangeIndex
public typealias ClosedRangeIndex<T> = ClosedRange<T>.Index where T: Strideable, T.Stride: S

----Swift.(file).ImplicitlyUnwrappedOptional
public typealias ImplicitlyUnwrappedOptional<Wrapped> = Optional<Wrapped>

----Swift.(file).Range.init(_:Range<Bound>)
extension Range where Bound: Strideable, Bound.Stride : SignedInteger  {
  public init(_ other: Range<Bound>) {
    self = other
  }
}

----Swift.(file).ClosedRange.init(_:ClosedRange<Bound>)
extension ClosedRange where Bound: Strideable, Bound.Stride : SignedInteger  {
  public init(_ other: ClosedRange<Bound>) {
    self = other
  }
}

----Swift.(file).DictionaryLiteral
public typealias DictionaryLiteral<Key, Value> = KeyValuePairs<Key, Value>

----Swift.(file).LazySequenceProtocol.flatMap(_:(Self.Elements.Element) -> ElementOfResult?)
extension LazySequenceProtocol  {
  public func flatMap<ElementOfResult>(
    _ transform: @escaping (Elements.Element) -> ElementOfResult?
  ) -> LazyMapSequence<
    LazyFilterSequence<
      LazyMapSequence<Elements, ElementOfResult?>>,
    ElementOfResult
  > {
    return self.compactMap(transform)
  }
}

----Swift.(file).String.CharacterView
extension String  {
  public typealias CharacterView = S
}

----Swift.(file).String.characters
extension String  {
  public var characters: String {
    get { return self }
    set { self = newValue }
  }
}

----Swift.(file).String.withMutableCharacters(_:(inout String) -> R)
extension String  {
  public mutating func withMutableCharacters<R>(
    _ body: (inout String) -> R
  ) -> R {
    return body(&self)
  }
}

----Swift.(file).String.UnicodeScalarView.customPlaygroundQuickLook
extension String.UnicodeScalarView : _CustomPlaygroundQuickLookable  {
  public var customPlaygroundQuickLook: _PlaygroundQuickLook {
    return .text(description)
  }
}

----Swift.(file).String.UnicodeScalarView.subscript(_:Range<String.UnicodeScalarView.Index>)
extension String.UnicodeScalarView  {
  public subscript(bounds: Range<Index>) -> String.UnicodeScalarView {
    Builtin.unreachable()
  }
}

----Swift.(file).String.UnicodeScalarView.subscript(_:ClosedRange<String.UnicodeScalarView.Index>)
extension String.UnicodeScalarView  {
  public subscript(bounds: ClosedRange<Index>) -> String.UnicodeScalarView {
    Builtin.unreachable()
  }
}

----Swift.(file).UTF8
public typealias UTF8 = Unicode.U

----Swift.(file).UTF16
public typealias UTF16 = Unicode.U

----Swift.(file).UTF32
public typealias UTF32 = Unicode.U

----Swift.(file).UnicodeScalar
public typealias UnicodeScalar = Unicode.S

----Swift.(file).String.UTF16View.customPlaygroundQuickLook
extension String.UTF16View : _CustomPlaygroundQuickLookable  {
  public var customPlaygroundQuickLook: _PlaygroundQuickLook {
    return .text(description)
  }
}

----Swift.(file).String.UTF8View.customPlaygroundQuickLook
extension String.UTF8View : _CustomPlaygroundQuickLookable  {
  public var customPlaygroundQuickLook: _PlaygroundQuickLook {
    return .text(description)
  }
}

----Swift.(file).Substring.CharacterView
extension Substring  {
  public typealias CharacterView = S
}

----Swift.(file).Substring.characters
extension Substring  {
  public var characters: Substring {
    get {
      return self
    }
    set {
      self = newValue
    }
  }
}

----Swift.(file).Substring.withMutableCharacters(_:(inout Substring) -> R)
extension Substring  {
  public mutating func withMutableCharacters<R>(
    _ body: (inout Substring) -> R
  ) -> R {
    return body(&self)
  }
}

----Swift.(file).Substring.subscript(_:ClosedRange<Substring.Index>)
extension Substring  {
  public subscript(bounds: ClosedRange<Index>) -> String {
    Builtin.unreachable()
  }
}

----Swift.(file).Substring.customPlaygroundQuickLook
extension Substring : _CustomPlaygroundQuickLookable  {
  public var customPlaygroundQuickLook: _PlaygroundQuickLook {
    return String(self).customPlaygroundQuickLook
  }
}

----Swift.(file).Collection.Generator
extension Collection  {
  public typealias Generator = I
}

----Swift.(file).Collection.index(_:Self.Index,offsetBy:T)
extension Collection  {
  public func index<T: BinaryInteger>(_ i: Index, offsetBy n: T) -> Index {
    return index(i, offsetBy: Int(n))
  }
}

----Swift.(file).Collection.formIndex(_:Self.Index,offsetBy:T)
extension Collection  {
  public func formIndex<T: BinaryInteger>(_ i: inout Index, offsetBy n: T) {
    return formIndex(&i, offsetBy: Int(n))
  }
}

----Swift.(file).Collection.index(_:Self.Index,offsetBy:T,limitedBy:Self.Index)
extension Collection  {
  public func index<T: BinaryInteger>(_ i: Index, offsetBy n: T, limitedBy limit: Index) -> Index? {
    return index(i, offsetBy: Int(n), limitedBy: limit)
  }
}

----Swift.(file).Collection.formIndex(_:Self.Index,offsetBy:T,limitedBy:Self.Index)
extension Collection  {
  public func formIndex<T: BinaryInteger>(_ i: inout Index, offsetBy n: T, limitedBy limit: Index) -> Bool {
    return formIndex(&i, offsetBy: Int(n), limitedBy: limit)
  }
}

----Swift.(file).Collection.distance(from:Self.Index,to:Self.Index)
extension Collection  {
  public func distance<T: BinaryInteger>(from start: Index, to end: Index) -> T {
    return numericCast(distance(from: start, to: end) as Int)
  }
}

----Swift.(file).UnsafeMutablePointer.initialize(to:Pointee,count:Int)
extension UnsafeMutablePointer  {
  public func initialize(to newValue: Pointee, count: Int = 1) { 
    initialize(repeating: newValue, count: count)
  }
}

----Swift.(file).UnsafeMutablePointer.deinitialize()
extension UnsafeMutablePointer  {
  public func deinitialize() -> UnsafeMutableRawPointer {
    return deinitialize(count: 1)
  }
}

----Swift.(file).UnsafeMutablePointer.deallocate(capacity:Int)
extension UnsafeMutablePointer  {
  public func deallocate(capacity _: Int) { 
    self.deallocate()
  }
}

----Swift.(file).UnsafeMutablePointer.initialize(from:C)
extension UnsafeMutablePointer  {
  public func initialize<C : Collection>(from source: C)
    where C.Element == Pointee {
    let buf = UnsafeMutableBufferPointer(start: self, count: numericCast(source.count))
    var (remainders,writtenUpTo) = source._copyContents(initializing: buf)
    // ensure that exactly rhs.count elements were written
    _precondition(remainders.next() == nil, "rhs underreported its count")
    _precondition(writtenUpTo == buf.endIndex, "rhs overreported its count")
  }
}

----Swift.(file).UnsafeMutableRawPointer.init(_:UnsafeRawPointer)
extension UnsafeMutableRawPointer  {
  public init(_ from : UnsafeRawPointer) { Builtin.unreachable() }
}

----Swift.(file).UnsafeMutableRawPointer.init(_:UnsafeRawPointer?)
extension UnsafeMutableRawPointer  {
  public init?(_ from : UnsafeRawPointer?) { Builtin.unreachable() }
}

----Swift.(file).UnsafeMutableRawPointer.init(_:UnsafePointer<T>)
extension UnsafeMutableRawPointer  {
  public init<T>(_ from : UnsafePointer<T>) { Builtin.unreachable() }
}

----Swift.(file).UnsafeMutableRawPointer.init(_:UnsafePointer<T>?)
extension UnsafeMutableRawPointer  {
  public init?<T>(_ from : UnsafePointer<T>?) { Builtin.unreachable() }
}

----Swift.(file).UnsafeRawPointer.summary
extension UnsafeRawPointer : _CustomPlaygroundQuickLookable  {
  internal var summary: String {
    let ptrValue = UInt64(
      bitPattern: Int64(Int(Builtin.ptrtoint_Word(_rawValue))))
    return ptrValue == 0
    ? "UnsafeRawPointer(nil)"
    : "UnsafeRawPointer(0x\(_uint64ToString(ptrValue, radix:16, uppercase:true)))"
  }
}

----Swift.(file).UnsafeRawPointer.customPlaygroundQuickLook
extension UnsafeRawPointer : _CustomPlaygroundQuickLookable  {
  public var customPlaygroundQuickLook: _PlaygroundQuickLook {
    return .text(summary)
  }
}

----Swift.(file).UnsafeMutableRawPointer.summary
extension UnsafeMutableRawPointer : _CustomPlaygroundQuickLookable  {
  private var summary: String {
    let ptrValue = UInt64(
      bitPattern: Int64(Int(Builtin.ptrtoint_Word(_rawValue))))
    return ptrValue == 0
    ? "UnsafeMutableRawPointer(nil)"
    : "UnsafeMutableRawPointer(0x\(_uint64ToString(ptrValue, radix:16, uppercase:true)))"
  }
}

----Swift.(file).UnsafeMutableRawPointer.customPlaygroundQuickLook
extension UnsafeMutableRawPointer : _CustomPlaygroundQuickLookable  {
  public var customPlaygroundQuickLook: _PlaygroundQuickLook {
    return .text(summary)
  }
}

----Swift.(file).UnsafePointer.summary
extension UnsafePointer: _CustomPlaygroundQuickLookable  {
  private var summary: String {
    let ptrValue = UInt64(bitPattern: Int64(Int(Builtin.ptrtoint_Word(_rawValue))))
    return ptrValue == 0 
    ? "UnsafePointer(nil)" 
    : "UnsafePointer(0x\(_uint64ToString(ptrValue, radix:16, uppercase:true)))"
  }
}

----Swift.(file).UnsafePointer.customPlaygroundQuickLook
extension UnsafePointer: _CustomPlaygroundQuickLookable  {
  public var customPlaygroundQuickLook: PlaygroundQuickLook {
    return .text(summary)
  }
}

----Swift.(file).UnsafeMutablePointer.summary
extension UnsafeMutablePointer: _CustomPlaygroundQuickLookable  {
  private var summary: String {
    let ptrValue = UInt64(bitPattern: Int64(Int(Builtin.ptrtoint_Word(_rawValue))))
    return ptrValue == 0 
    ? "UnsafeMutablePointer(nil)" 
    : "UnsafeMutablePointer(0x\(_uint64ToString(ptrValue, radix:16, uppercase:true)))"
  }
}

----Swift.(file).UnsafeMutablePointer.customPlaygroundQuickLook
extension UnsafeMutablePointer: _CustomPlaygroundQuickLookable  {
  public var customPlaygroundQuickLook: PlaygroundQuickLook {
    return .text(summary)
  }
}

----Swift.(file).UnsafeBufferPointerIterator
public typealias UnsafeBufferPointerIterator<T> = UnsafeBufferPointer<T>.I

----Swift.(file).UnsafeRawBufferPointerIterator
public typealias UnsafeRawBufferPointerIterator<T> = UnsafeBufferPointer<T>.I

----Swift.(file).UnsafeMutableRawBufferPointerIterator
public typealias UnsafeMutableRawBufferPointerIterator<T> = UnsafeBufferPointer<T>.I

----Swift.(file).UnsafeMutableRawPointer.allocate(bytes:Int,alignedTo:Int)
extension UnsafeMutableRawPointer  {
  public static func allocate(
    bytes size: Int, alignedTo alignment: Int
  ) -> UnsafeMutableRawPointer {
    return UnsafeMutableRawPointer.allocate(byteCount: size, alignment: alignment)
  }
}

----Swift.(file).UnsafeMutableRawPointer.deallocate(bytes:Int,alignedTo:Int)
extension UnsafeMutableRawPointer  {
  public func deallocate(bytes _: Int, alignedTo _: Int) { 
    self.deallocate()
  }
}

----Swift.(file).UnsafeMutableRawPointer.copyBytes(from:UnsafeRawPointer,count:Int)
extension UnsafeMutableRawPointer  {
  public func copyBytes(from source: UnsafeRawPointer, count: Int) {
    copyMemory(from: source, byteCount: count)
  }
}

----Swift.(file).UnsafeMutableRawPointer.initializeMemory(as:T.Type,at:Int,count:Int,to:T)
extension UnsafeMutableRawPointer  {
  public func initializeMemory<T>(
    as type: T.Type, at offset: Int = 0, count: Int = 1, to repeatedValue: T
  ) -> UnsafeMutablePointer<T> { 
    return (self + offset * MemoryLayout<T>.stride).initializeMemory(
      as: type, repeating: repeatedValue, count: count)
  }
}

----Swift.(file).UnsafeMutableRawPointer.initializeMemory(as:C.Element.Type,from:C)
extension UnsafeMutableRawPointer  {
  public func initializeMemory<C : Collection>(
    as type: C.Element.Type, from source: C
  ) -> UnsafeMutablePointer<C.Element> {
    // TODO: Optimize where `C` is a `ContiguousArrayBuffer`.
    // Initialize and bind each element of the container.
    var ptr = self
    for element in source {
      ptr.initializeMemory(as: C.Element.self, repeating: element, count: 1)
      ptr += MemoryLayout<C.Element>.stride
    }
    return UnsafeMutablePointer(_rawValue)
  }
}

----Swift.(file).UnsafeMutableRawBufferPointer.allocate(count:Int)
extension UnsafeMutableRawBufferPointer  {
  public static func allocate(count: Int) -> UnsafeMutableRawBufferPointer { 
    return UnsafeMutableRawBufferPointer.allocate(
      byteCount: count, alignment: MemoryLayout<UInt>.alignment)
  }
}

----Swift.(file).UnsafeMutableRawBufferPointer.copyBytes(from:UnsafeRawBufferPointer)
extension UnsafeMutableRawBufferPointer  {
  public func copyBytes(from source: UnsafeRawBufferPointer) {
    copyMemory(from: source)
  }
}

----Swift.(file).Sequence.flatMap(_:(Self.Element) throws -> ElementOfResult?)
extension Sequence  {
  public func flatMap<ElementOfResult>(
    _ transform: (Element) throws -> ElementOfResult?
  ) rethrows -> [ElementOfResult] {
    return try _compactMap(transform)
  }
}

----Swift.(file).Sequence.flatMap(_:(Self.Element) throws -> String)
extension Sequence  {
  public func flatMap(
    _ transform: (Element) throws -> String
  ) rethrows -> [String] {
    return try map(transform)
  }
}

----Swift.(file).Collection.flatMap(_:(Self.Element) throws -> String?)
extension Collection  {
  public func flatMap(
    _ transform: (Element) throws -> String?
  ) rethrows -> [String] {
    return try _compactMap(transform)
  }
}

----Swift.(file).Collection.index(where:(Self.Element) throws -> Bool)
extension Collection  {
  public func index(
    where _predicate: (Element) throws -> Bool
  ) rethrows -> Index? {
    return try firstIndex(where: _predicate)
  }
}

----Swift.(file).Collection.index(of:Self.Element)
extension Collection where Element: Equatable  {
  public func index(of element: Element) -> Index? {
    return firstIndex(of: element)
  }
}

----Swift.(file).Zip2Sequence.Stream1
extension Zip2Sequence  {
  public typealias Stream1 = Sequence1.I
}

----Swift.(file).Zip2Sequence.Stream2
extension Zip2Sequence  {
  public typealias Stream2 = Sequence2.I
}

----Swift.(file).PlaygroundQuickLook
public typealias PlaygroundQuickLook = _

----Swift.(file)._PlaygroundQuickLook.init(reflecting:Any)
extension _PlaygroundQuickLook  {
  public init(reflecting subject: Any) {
    if let customized = subject as? _CustomPlaygroundQuickLookable {
      self = customized.customPlaygroundQuickLook
    }
    else if let customized = subject as? __DefaultCustomPlaygroundQuickLookable {
      self = customized._defaultCustomPlaygroundQuickLook
    }
    else {
      if let q = Mirror.quickLookObject(subject) {
        self = q
      }
      else {
        self = .text(String(reflecting: subject))
      }
    }
  }
}

----Swift.(file).CustomPlaygroundQuickLookable
public typealias CustomPlaygroundQuickLookable = _

----Swift.(file).MutableCollection.Element
extension MutableCollection {
  override associatedtype E
}

----Swift.(file).MutableCollection.Index
extension MutableCollection {
  override associatedtype I
}

----Swift.(file).MutableCollection.SubSequence
extension MutableCollection {
  override associatedtype S
}

----Swift.(file).MutableCollection.subscript(_:Self.Index)
extension MutableCollection {
  override subscript(position: Index) -> Element { get set }
}

----Swift.(file).MutableCollection.subscript(_:Range<Self.Index>)
extension MutableCollection {
  override subscript(bounds: Range<Index>) -> SubSequence { get set }
}

----Swift.(file).MutableCollection.partition(by:(Self.Element) throws -> Bool)
extension MutableCollection {
  mutating func partition(
    by belongsInSecondPartition: (Element) throws -> Bool
  ) rethrows -> I
}

----Swift.(file).MutableCollection.swapAt(_:Self.Index,_:Self.Index)
extension MutableCollection {
  mutating func swapAt(_ i: Index, _ j: Index)
}

----Swift.(file).MutableCollection.withContiguousMutableStorageIfAvailable(_:(inout UnsafeMutableBufferPointer<Self.Element>) throws -> R)
extension MutableCollection {
  mutating func withContiguousMutableStorageIfAvailable<R>(
    _ body: (inout UnsafeMutableBufferPointer<Element>) throws -> R
  ) rethrows -> R?
}

----Swift.(file).MutableCollection.withContiguousMutableStorageIfAvailable(_:(inout UnsafeMutableBufferPointer<Self.Element>) throws -> R)
extension MutableCollection  {
  public mutating func withContiguousMutableStorageIfAvailable<R>(
    _ body: (inout UnsafeMutableBufferPointer<Element>) throws -> R
  ) rethrows -> R? {
    return nil
  }
}

----Swift.(file).MutableCollection.subscript(_:Range<Self.Index>)
extension MutableCollection  {
  public subscript(bounds: Range<Index>) -> Slice<Self> {
    get {
      _failEarlyRangeCheck(bounds, bounds: startIndex..<endIndex)
      return Slice(base: self, bounds: bounds)
    }
    set {
      _writeBackMutableSlice(&self, bounds: bounds, slice: newValue)
    }
  }
}

----Swift.(file).MutableCollection.swapAt(_:Self.Index,_:Self.Index)
extension MutableCollection  {
  public mutating func swapAt(_ i: Index, _ j: Index) {
    guard i != j else { return }
    let tmp = self[i]
    self[i] = self[j]
    self[j] = tmp
  }
}

----Swift.(file).swap(_:T,_:T)
public func swap<T>(_ a: inout T, _ b: inout T) {
  // Semantically equivalent to (a, b) = (b, a).
  // Microoptimized to avoid retain/release traffic.
  let p1 = Builtin.addressof(&a)
  let p2 = Builtin.addressof(&b)
  _debugPrecondition(
    p1 != p2,
    "swapping a location with itself is not supported")

  // Take from P1.
  let tmp: T = Builtin.take(p1)
  // Transfer P2 into P1.
  Builtin.initialize(Builtin.take(p2) as T, p1)
  // Initialize P2.
  Builtin.initialize(tmp, p2)
}

----Swift.(file)._NativeDictionary.Bucket
extension _NativeDictionary  {
  internal typealias Bucket = _HashTable.B
}

----Swift.(file)._NativeDictionary.capacity
extension _NativeDictionary  {
  internal var capacity: Int {
    @inline(__always)
    get {
      return _assumeNonNegative(_storage._capacity)
    }
  }
}

----Swift.(file)._NativeDictionary.hashTable
extension _NativeDictionary  {
  internal var hashTable: _HashTable {
    @inline(__always) get {
      return _storage._hashTable
    }
  }
}

----Swift.(file)._NativeDictionary.age
extension _NativeDictionary  {
  internal var age: Int32 {
    @inline(__always) get {
      return _storage._age
    }
  }
}

----Swift.(file)._NativeDictionary.invalidateIndices()
extension _NativeDictionary  {
  internal func invalidateIndices() {
    _storage._age &+= 1
  }
}

----Swift.(file)._NativeDictionary.uncheckedKey(at:<<error type>>)
extension _NativeDictionary  {
  internal func uncheckedKey(at bucket: Bucket) -> Key {
    defer { _fixLifetime(self) }
    _internalInvariant(hashTable.isOccupied(bucket))
    return _keys[bucket.offset]
  }
}

----Swift.(file)._NativeDictionary.uncheckedValue(at:<<error type>>)
extension _NativeDictionary  {
  internal func uncheckedValue(at bucket: Bucket) -> Value {
    defer { _fixLifetime(self) }
    _internalInvariant(hashTable.isOccupied(bucket))
    return _values[bucket.offset]
  }
}

----Swift.(file)._NativeDictionary.uncheckedInitialize(at:<<error type>>,toKey:Key,value:Value)
extension _NativeDictionary  {
  internal func uncheckedInitialize(
    at bucket: Bucket,
    toKey key: __owned Key,
    value: __owned Value) {
    defer { _fixLifetime(self) }
    _internalInvariant(hashTable.isValid(bucket))
    (_keys + bucket.offset).initialize(to: key)
    (_values + bucket.offset).initialize(to: value)
  }
}

----Swift.(file)._NativeDictionary.uncheckedDestroy(at:<<error type>>)
extension _NativeDictionary  {
  internal func uncheckedDestroy(at bucket: Bucket) {
    defer { _fixLifetime(self) }
    _internalInvariant(hashTable.isValid(bucket))
    (_keys + bucket.offset).deinitialize(count: 1)
    (_values + bucket.offset).deinitialize(count: 1)
  }
}

----Swift.(file)._NativeDictionary.hashValue(for:Key)
extension _NativeDictionary  {
  internal func hashValue(for key: Key) -> Int {
    return key._rawHashValue(seed: _storage._seed)
  }
}

----Swift.(file)._NativeDictionary.find(_:Key)
extension _NativeDictionary  {
  internal func find(_ key: Key) -> (bucket: Bucket, found: Bool) {
    return find(key, hashValue: self.hashValue(for: key))
  }
}

----Swift.(file)._NativeDictionary.find(_:Key,hashValue:Int)
extension _NativeDictionary  {
  internal func find(
    _ key: Key,
    hashValue: Int
  ) -> (bucket: Bucket, found: Bool) {
    let hashTable = self.hashTable
    var bucket = hashTable.idealBucket(forHashValue: hashValue)
    while hashTable._isOccupied(bucket) {
      if uncheckedKey(at: bucket) == key {
        return (bucket, true)
      }
      bucket = hashTable.bucket(wrappedAfter: bucket)
    }
    return (bucket, false)
  }
}

----Swift.(file)._NativeDictionary.resize(capacity:Int)
extension _NativeDictionary  {
  internal mutating func resize(capacity: Int) {
    let capacity = Swift.max(capacity, self.capacity)
    let newStorage = _DictionaryStorage<Key, Value>.resize(
      original: _storage,
      capacity: capacity,
      move: true)
    let result = _NativeDictionary(newStorage)
    if count > 0 {
      for bucket in hashTable {
        let key = (_keys + bucket.offset).move()
        let value = (_values + bucket.offset).move()
        result._unsafeInsertNew(key: key, value: value)
      }
      // Clear out old storage, ensuring that its deinit won't overrelease the
      // elements we've just moved out.
      _storage._hashTable.clear()
      _storage._count = 0
    }
    _storage = result._storage
  }
}

----Swift.(file)._NativeDictionary.copyAndResize(capacity:Int)
extension _NativeDictionary  {
  internal mutating func copyAndResize(capacity: Int) {
    let capacity = Swift.max(capacity, self.capacity)
    let newStorage = _DictionaryStorage<Key, Value>.resize(
      original: _storage,
      capacity: capacity,
      move: false)
    let result = _NativeDictionary(newStorage)
    if count > 0 {
      for bucket in hashTable {
        result._unsafeInsertNew(
          key: self.uncheckedKey(at: bucket),
          value: self.uncheckedValue(at: bucket))
      }
    }
    _storage = result._storage
  }
}

----Swift.(file)._NativeDictionary.copy()
extension _NativeDictionary  {
  internal mutating func copy() {
    let newStorage = _DictionaryStorage<Key, Value>.copy(original: _storage)
    _internalInvariant(newStorage._scale == _storage._scale)
    _internalInvariant(newStorage._age == _storage._age)
    _internalInvariant(newStorage._seed == _storage._seed)
    let result = _NativeDictionary(newStorage)
    if count > 0 {
      result.hashTable.copyContents(of: hashTable)
      result._storage._count = self.count
      for bucket in hashTable {
        let key = uncheckedKey(at: bucket)
        let value = uncheckedValue(at: bucket)
        result.uncheckedInitialize(at: bucket, toKey: key, value: value)
      }
    }
    _storage = result._storage
  }
}

----Swift.(file)._NativeDictionary.ensureUnique(isUnique:Bool,capacity:Int)
extension _NativeDictionary  {
  internal mutating func ensureUnique(isUnique: Bool, capacity: Int) -> Bool {
    if _fastPath(capacity <= self.capacity && isUnique) {
      return false
    }
    if isUnique {
      resize(capacity: capacity)
      return true
    }
    if capacity <= self.capacity {
      copy()
      return false
    }
    copyAndResize(capacity: capacity)
    return true
  }
}

----Swift.(file)._NativeDictionary.reserveCapacity(_:Int,isUnique:Bool)
extension _NativeDictionary  {
  internal mutating func reserveCapacity(_ capacity: Int, isUnique: Bool) {
    _ = ensureUnique(isUnique: isUnique, capacity: capacity)
  }
}

----Swift.(file)._NativeDictionary.validatedBucket(for:<<error type>>)
extension _NativeDictionary  {
  func validatedBucket(for index: _HashTable.Index) -> Bucket {
    _precondition(hashTable.isOccupied(index.bucket) && index.age == age,
      "Attempting to access Dictionary elements using an invalid index")
    return index.bucket
  }
}

----Swift.(file)._NativeDictionary.validatedBucket(for:Dictionary<Key, Value>.Index)
extension _NativeDictionary  {
  func validatedBucket(for index: Dictionary<Key, Value>.Index) -> Bucket {
#if _runtime(_ObjC)
    guard index._isNative else {
      index._cocoaPath()
      // Accept Cocoa indices as long as they contain a key that exists in this
      // dictionary, and the address of their Cocoa object generates the same
      // age.
      let cocoa = index._asCocoa
      if cocoa.age == self.age {
        let key = _forceBridgeFromObjectiveC(cocoa.key, Key.self)
        let (bucket, found) = find(key)
        if found {
          return bucket
        }
      }
      _preconditionFailure(
        "Attempting to access Dictionary elements using an invalid index")
    }
#endif
    return validatedBucket(for: index._asNative)
  }
}

----Swift.(file)._NativeDictionary.Index
extension _NativeDictionary: _DictionaryBuffer  {
  internal typealias Index = Dictionary<Key, Value>.I
}

----Swift.(file)._NativeDictionary.startIndex
extension _NativeDictionary: _DictionaryBuffer  {
  internal var startIndex: Index {
    let bucket = hashTable.startBucket
    return Index(_native: _HashTable.Index(bucket: bucket, age: age))
  }
}

----Swift.(file)._NativeDictionary.endIndex
extension _NativeDictionary: _DictionaryBuffer  {
  internal var endIndex: Index {
    let bucket = hashTable.endBucket
    return Index(_native: _HashTable.Index(bucket: bucket, age: age))
  }
}

----Swift.(file)._NativeDictionary.index(after:_NativeDictionary<Key, Value>.Index)
extension _NativeDictionary: _DictionaryBuffer  {
  internal func index(after index: Index) -> Index {
#if _runtime(_ObjC)
    guard _fastPath(index._isNative) else {
      let _ = validatedBucket(for: index)
      let i = index._asCocoa
      return Index(_cocoa: i.dictionary.index(after: i))
    }
#endif
    let bucket = validatedBucket(for: index._asNative)
    let next = hashTable.occupiedBucket(after: bucket)
    return Index(_native: _HashTable.Index(bucket: next, age: age))
  }
}

----Swift.(file)._NativeDictionary.index(forKey:Key)
extension _NativeDictionary: _DictionaryBuffer  {
  internal func index(forKey key: Key) -> Index? {
    if count == 0 {
      // Fast path that avoids computing the hash of the key.
      return nil
    }
    let (bucket, found) = find(key)
    guard found else { return nil }
    return Index(_native: _HashTable.Index(bucket: bucket, age: age))
  }
}

----Swift.(file)._NativeDictionary.count
extension _NativeDictionary: _DictionaryBuffer  {
  internal var count: Int {
    @inline(__always) get {
      return _assumeNonNegative(_storage._count)
    }
  }
}

----Swift.(file)._NativeDictionary.contains(_:Key)
extension _NativeDictionary: _DictionaryBuffer  {
  func contains(_ key: Key) -> Bool {
    return find(key).found
  }
}

----Swift.(file)._NativeDictionary.lookup(_:Key)
extension _NativeDictionary: _DictionaryBuffer  {
  func lookup(_ key: Key) -> Value? {
    if count == 0 {
      // Fast path that avoids computing the hash of the key.
      return nil
    }
    let (bucket, found) = self.find(key)
    guard found else { return nil }
    return self.uncheckedValue(at: bucket)
  }
}

----Swift.(file)._NativeDictionary.lookup(_:_NativeDictionary<Key, Value>.Index)
extension _NativeDictionary: _DictionaryBuffer  {
  func lookup(_ index: Index) -> (key: Key, value: Value) {
    let bucket = validatedBucket(for: index)
    let key = self.uncheckedKey(at: bucket)
    let value = self.uncheckedValue(at: bucket)
    return (key, value)
  }
}

----Swift.(file)._NativeDictionary.key(at:_NativeDictionary<Key, Value>.Index)
extension _NativeDictionary: _DictionaryBuffer  {
  func key(at index: Index) -> Key {
    let bucket = validatedBucket(for: index)
    return self.uncheckedKey(at: bucket)
  }
}

----Swift.(file)._NativeDictionary.value(at:_NativeDictionary<Key, Value>.Index)
extension _NativeDictionary: _DictionaryBuffer  {
  func value(at index: Index) -> Value {
    let bucket = validatedBucket(for: index)
    return self.uncheckedValue(at: bucket)
  }
}

----Swift.(file)._NativeDictionary.subscript(_:Key,isUnique:Bool)
extension _NativeDictionary  {
  subscript(key: Key, isUnique isUnique: Bool) -> Value? {
    @inline(__always)
    get {
      // Dummy definition; don't use.
      return lookup(key)
    }
    @inline(__always)
    _modify {
      let (bucket, found) = mutatingFind(key, isUnique: isUnique)
      if found {
        // Move the old value out of storage, wrapping it into an optional
        // before yielding it.
        var value: Value? = (_values + bucket.offset).move()
        defer {
          // This is in a defer block because yield might throw, and we need to
          // preserve Dictionary's storage invariants when that happens.
          if let value = value {
            // **Mutation.** Initialize storage to new value.
            (_values + bucket.offset).initialize(to: value)
          } else {
            // **Removal.** We've already deinitialized the value; deinitialize
            // the key too and register the removal.
            (_keys + bucket.offset).deinitialize(count: 1)
            _delete(at: bucket)
          }
        }
        yield &value
      } else {
        var value: Value? = nil
        defer {
          // This is in a defer block because yield might throw, and we need to
          // preserve Dictionary invariants when that happens.
          if let value = value {
            // **Insertion.** Insert the new entry at the correct place.  Note
            // that `mutatingFind` already ensured that we have enough capacity.
            _insert(at: bucket, key: key, value: value)
          }
        }
        yield &value
      }
    }
  }
}

----Swift.(file).KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(_:Any.Type)
internal func KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(
  _ keyType: Any.Type
) -> Never {
  _assertionFailure(
    "Fatal error",
    """
    Duplicate keys of type '\(keyType)' were found in a Dictionary.
    This usually means either that the type violates Hashable's requirements, or
    that members of such a dictionary were mutated after insertion.
    """,
    flags: _fatalErrorFlags())
}

----Swift.(file)._NativeDictionary.insertNew(key:Key,value:Value)
extension _NativeDictionary  {
  internal mutating func insertNew(key: __owned Key, value: __owned Value) {
    _ = ensureUnique(isUnique: true, capacity: count + 1)
    _unsafeInsertNew(key: key, value: value)
  }
}

----Swift.(file)._NativeDictionary.mutatingFind(_:Key,isUnique:Bool)
extension _NativeDictionary  {
  internal mutating func mutatingFind(
    _ key: Key,
    isUnique: Bool
  ) -> (bucket: Bucket, found: Bool) {
    let (bucket, found) = find(key)

    // Prepare storage.
    // If `key` isn't in the dictionary yet, assume that this access will end
    // up inserting it. (If we guess wrong, we might needlessly expand
    // storage; that's fine.) Otherwise this can only be a removal or an
    // in-place mutation.
    let rehashed = ensureUnique(
      isUnique: isUnique,
      capacity: count + (found ? 0 : 1))
    guard rehashed else { return (bucket, found) }
    let (b, f) = find(key)
    if f != found {
      KEY_TYPE_OF_DICTIONARY_VIOLATES_HASHABLE_REQUIREMENTS(Key.self)
    }
    return (b, found)
  }
}

----Swift.(file)._NativeDictionary.updateValue(_:Value,forKey:Key,isUnique:Bool)
extension _NativeDictionary  {
  internal mutating func updateValue(
    _ value: __owned Value,
    forKey key: Key,
    isUnique: Bool
  ) -> Value? {
    let (bucket, found) = mutatingFind(key, isUnique: isUnique)
    if found {
      let oldValue = (_values + bucket.offset).move()
      (_values + bucket.offset).initialize(to: value)
      return oldValue
    }
    _insert(at: bucket, key: key, value: value)
    return nil
  }
}

----Swift.(file)._NativeDictionary.setValue(_:Value,forKey:Key,isUnique:Bool)
extension _NativeDictionary  {
  internal mutating func setValue(
    _ value: __owned Value,
    forKey key: Key,
    isUnique: Bool
  ) {
    let (bucket, found) = mutatingFind(key, isUnique: isUnique)
    if found {
      (_values + bucket.offset).pointee = value
    } else {
      _insert(at: bucket, key: key, value: value)
    }
  }
}

----Swift.(file)._NativeDictionary.swapValuesAt(_:<<error type>>,_:<<error type>>,isUnique:Bool)
extension _NativeDictionary  {
  internal mutating func swapValuesAt(
    _ a: Bucket,
    _ b: Bucket,
    isUnique: Bool
  ) {
    let rehashed = ensureUnique(isUnique: isUnique, capacity: capacity)
    _internalInvariant(!rehashed)
    _internalInvariant(hashTable.isOccupied(a) && hashTable.isOccupied(b))
    let value = (_values + a.offset).move()
    (_values + a.offset).moveInitialize(from: _values + b.offset, count: 1)
    (_values + b.offset).initialize(to: value)
  }
}

----Swift.(file)._NativeDictionary.isEqual(to:_NativeDictionary<Key, Value>)
extension _NativeDictionary where Value: Equatable  {
  func isEqual(to other: _NativeDictionary) -> Bool {
    if self._storage === other._storage { return true }
    if self.count != other.count { return false }

    for (key, value) in self {
      let (bucket, found) = other.find(key)
      guard found, other.uncheckedValue(at: bucket) == value else {
        return false
      }
    }
    return true
  }
}

----Swift.(file)._NativeDictionary.isEqual(to:<<error type>>)
extension _NativeDictionary where Value: Equatable  {
  func isEqual(to other: _CocoaDictionary) -> Bool {
    if self.count != other.count { return false }

    defer { _fixLifetime(self) }
    for bucket in self.hashTable {
      let key = self.uncheckedKey(at: bucket)
      let value = self.uncheckedValue(at: bucket)
      guard
        let cocoaValue = other.lookup(_bridgeAnythingToObjectiveC(key)),
        value == _forceBridgeFromObjectiveC(cocoaValue, Value.self)
      else {
        return false
      }
    }
    return true
  }
}

----Swift.(file)._NativeDictionary.hashValue(at:<<error type>>)
extension _NativeDictionary: _HashTableDelegate  {
  internal func hashValue(at bucket: Bucket) -> Int {
    return hashValue(for: uncheckedKey(at: bucket))
  }
}

----Swift.(file)._NativeDictionary.moveEntry(from:<<error type>>,to:<<error type>>)
extension _NativeDictionary: _HashTableDelegate  {
  internal func moveEntry(from source: Bucket, to target: Bucket) {
    _internalInvariant(hashTable.isValid(source))
    _internalInvariant(hashTable.isValid(target))
    (_keys + target.offset)
      .moveInitialize(from: _keys + source.offset, count: 1)
    (_values + target.offset)
      .moveInitialize(from: _values + source.offset, count: 1)
  }
}

----Swift.(file)._NativeDictionary.swapEntry(_:<<error type>>,with:<<error type>>)
extension _NativeDictionary: _HashTableDelegate  {
  internal func swapEntry(_ left: Bucket, with right: Bucket) {
    _internalInvariant(hashTable.isValid(left))
    _internalInvariant(hashTable.isValid(right))
    swap(&_keys[left.offset], &_keys[right.offset])
    swap(&_values[left.offset], &_values[right.offset])
  }
}

----Swift.(file)._NativeDictionary.uncheckedRemove(at:<<error type>>,isUnique:Bool)
extension _NativeDictionary  {
  internal mutating func uncheckedRemove(
    at bucket: Bucket,
    isUnique: Bool
  ) -> Element {
    _internalInvariant(hashTable.isOccupied(bucket))
    let rehashed = ensureUnique(isUnique: isUnique, capacity: capacity)
    _internalInvariant(!rehashed)
    let oldKey = (_keys + bucket.offset).move()
    let oldValue = (_values + bucket.offset).move()
    _delete(at: bucket)
    return (oldKey, oldValue)
  }
}

----Swift.(file)._NativeDictionary.removeAll(isUnique:Bool)
extension _NativeDictionary  {
  internal mutating func removeAll(isUnique: Bool) {
    guard isUnique else {
      let scale = self._storage._scale
      _storage = _DictionaryStorage<Key, Value>.allocate(
        scale: scale,
        age: nil,
        seed: nil)
      return
    }
    for bucket in hashTable {
      (_keys + bucket.offset).deinitialize(count: 1)
      (_values + bucket.offset).deinitialize(count: 1)
    }
    hashTable.clear()
    _storage._count = 0
    invalidateIndices()
  }
}

----Swift.(file)._NativeDictionary.mapValues(_:(Value) throws -> T)
extension _NativeDictionary  {
  internal func mapValues<T>(
    _ transform: (Value) throws -> T
  ) rethrows -> _NativeDictionary<Key, T> {
    let resultStorage = _DictionaryStorage<Key, T>.copy(original: _storage)
    _internalInvariant(resultStorage._seed == _storage._seed)
    let result = _NativeDictionary<Key, T>(resultStorage)
    // Because the current and new buffer have the same scale and seed, we can
    // initialize to the same locations in the new buffer, skipping hash value
    // recalculations.
    for bucket in hashTable {
      let key = self.uncheckedKey(at: bucket)
      let value = self.uncheckedValue(at: bucket)
      try result._insert(at: bucket, key: key, value: transform(value))
    }
    return result
  }
}

----Swift.(file)._NativeDictionary.merge(_:S,isUnique:Bool,uniquingKeysWith:(Value, Value) throws -> Value)
extension _NativeDictionary  {
  internal mutating func merge<S: Sequence>(
    _ keysAndValues: __owned S,
    isUnique: Bool,
    uniquingKeysWith combine: (Value, Value) throws -> Value
  ) rethrows where S.Element == (Key, Value) {
    var isUnique = isUnique
    for (key, value) in keysAndValues {
      let (bucket, found) = mutatingFind(key, isUnique: isUnique)
      isUnique = true
      if found {
        do {
          let newValue = try combine(uncheckedValue(at: bucket), value)
          _values[bucket.offset] = newValue
        } catch _MergeError.keyCollision {
          fatalError("Duplicate values for key: '\(key)'")
        }
      } else {
        _insert(at: bucket, key: key, value: value)
      }
    }
  }
}

----Swift.(file)._NativeDictionary.init(grouping:S,by:(S.Element) throws -> Key)
extension _NativeDictionary  {
  internal init<S: Sequence>(
    grouping values: __owned S,
    by keyForValue: (S.Element) throws -> Key
  ) rethrows where Value == [S.Element] {
    self.init()
    for value in values {
      let key = try keyForValue(value)
      let (bucket, found) = mutatingFind(key, isUnique: true)
      if found {
        _values[bucket.offset].append(value)
      } else {
        _insert(at: bucket, key: key, value: [value])
      }
    }
  }
}

----Swift.(file)._NativeDictionary.makeIterator()
extension _NativeDictionary: Sequence  {
  internal __consuming func makeIterator() -> Iterator {
    return Iterator(self)
  }
}

----Swift.(file)._NativeDictionary.Iterator.Element
extension _NativeDictionary.Iterator: IteratorProtocol  {
  internal typealias Element = (key: Key, value: Value)
}

----Swift.(file)._NativeDictionary.Iterator.nextKey()
extension _NativeDictionary.Iterator: IteratorProtocol  {
  internal mutating func nextKey() -> Key? {
    guard let index = iterator.next() else { return nil }
    return base.uncheckedKey(at: index)
  }
}

----Swift.(file)._NativeDictionary.Iterator.nextValue()
extension _NativeDictionary.Iterator: IteratorProtocol  {
  internal mutating func nextValue() -> Value? {
    guard let index = iterator.next() else { return nil }
    return base.uncheckedValue(at: index)
  }
}

----Swift.(file)._NativeDictionary.Iterator.next()
extension _NativeDictionary.Iterator: IteratorProtocol  {
  internal mutating func next() -> Element? {
    guard let index = iterator.next() else { return nil }
    let key = base.uncheckedKey(at: index)
    let value = base.uncheckedValue(at: index)
    return (key, value)
  }
}

----Swift.(file)._NativeSet.Bucket
extension _NativeSet  {
  internal typealias Bucket = _HashTable.B
}

----Swift.(file)._NativeSet.capacity
extension _NativeSet  {
  internal var capacity: Int {
    @inline(__always)
    get {
      return _assumeNonNegative(_storage._capacity)
    }
  }
}

----Swift.(file)._NativeSet.hashTable
extension _NativeSet  {
  internal var hashTable: _HashTable {
    @inline(__always) get {
      return _storage._hashTable
    }
  }
}

----Swift.(file)._NativeSet.age
extension _NativeSet  {
  internal var age: Int32 {
    @inline(__always) get {
      return _storage._age
    }
  }
}

----Swift.(file)._NativeSet.invalidateIndices()
extension _NativeSet  {
  internal func invalidateIndices() {
    _storage._age &+= 1
  }
}

----Swift.(file)._NativeSet.uncheckedElement(at:<<error type>>)
extension _NativeSet  {
  internal func uncheckedElement(at bucket: Bucket) -> Element {
    defer { _fixLifetime(self) }
    _internalInvariant(hashTable.isOccupied(bucket))
    return _elements[bucket.offset]
  }
}

----Swift.(file)._NativeSet.uncheckedInitialize(at:<<error type>>,to:Element)
extension _NativeSet  {
  internal func uncheckedInitialize(
    at bucket: Bucket,
    to element: __owned Element) {
    _internalInvariant(hashTable.isValid(bucket))
    (_elements + bucket.offset).initialize(to: element)
  }
}

----Swift.(file)._NativeSet.hashValue(for:Element)
extension _NativeSet  {
  internal func hashValue(for element: Element) -> Int {
    return element._rawHashValue(seed: _storage._seed)
  }
}

----Swift.(file)._NativeSet.find(_:Element)
extension _NativeSet  {
  internal func find(_ element: Element) -> (bucket: Bucket, found: Bool) {
    return find(element, hashValue: self.hashValue(for: element))
  }
}

----Swift.(file)._NativeSet.find(_:Element,hashValue:Int)
extension _NativeSet  {
  internal func find(
    _ element: Element,
    hashValue: Int
  ) -> (bucket: Bucket, found: Bool) {
    let hashTable = self.hashTable
    var bucket = hashTable.idealBucket(forHashValue: hashValue)
    while hashTable._isOccupied(bucket) {
      if uncheckedElement(at: bucket) == element {
        return (bucket, true)
      }
      bucket = hashTable.bucket(wrappedAfter: bucket)
    }
    return (bucket, false)
  }
}

----Swift.(file)._NativeSet.resize(capacity:Int)
extension _NativeSet  {
  internal mutating func resize(capacity: Int) {
    let capacity = Swift.max(capacity, self.capacity)
    let result = _NativeSet(_SetStorage<Element>.resize(
        original: _storage,
        capacity: capacity,
        move: true))
    if count > 0 {
      for bucket in hashTable {
        let element = (self._elements + bucket.offset).move()
        result._unsafeInsertNew(element)
      }
      // Clear out old storage, ensuring that its deinit won't overrelease the
      // elements we've just moved out.
      _storage._hashTable.clear()
      _storage._count = 0
    }
    _storage = result._storage
  }
}

----Swift.(file)._NativeSet.copyAndResize(capacity:Int)
extension _NativeSet  {
  internal mutating func copyAndResize(capacity: Int) {
    let capacity = Swift.max(capacity, self.capacity)
    let result = _NativeSet(_SetStorage<Element>.resize(
        original: _storage,
        capacity: capacity,
        move: false))
    if count > 0 {
      for bucket in hashTable {
        result._unsafeInsertNew(self.uncheckedElement(at: bucket))
      }
    }
    _storage = result._storage
  }
}

----Swift.(file)._NativeSet.copy()
extension _NativeSet  {
  internal mutating func copy() {
    let newStorage = _SetStorage<Element>.copy(original: _storage)
    _internalInvariant(newStorage._scale == _storage._scale)
    _internalInvariant(newStorage._age == _storage._age)
    _internalInvariant(newStorage._seed == _storage._seed)
    let result = _NativeSet(newStorage)
    if count > 0 {
      result.hashTable.copyContents(of: hashTable)
      result._storage._count = self.count
      for bucket in hashTable {
        let element = uncheckedElement(at: bucket)
        result.uncheckedInitialize(at: bucket, to: element)
      }
    }
    _storage = result._storage
  }
}

----Swift.(file)._NativeSet.ensureUnique(isUnique:Bool,capacity:Int)
extension _NativeSet  {
  internal mutating func ensureUnique(isUnique: Bool, capacity: Int) -> Bool {
    if _fastPath(capacity <= self.capacity && isUnique) {
      return false
    }
    if isUnique {
      resize(capacity: capacity)
      return true
    }
    if capacity <= self.capacity {
      copy()
      return false
    }
    copyAndResize(capacity: capacity)
    return true
  }
}

----Swift.(file)._NativeSet.reserveCapacity(_:Int,isUnique:Bool)
extension _NativeSet  {
  internal mutating func reserveCapacity(_ capacity: Int, isUnique: Bool) {
    _ = ensureUnique(isUnique: isUnique, capacity: capacity)
  }
}

----Swift.(file)._NativeSet.validatedBucket(for:<<error type>>)
extension _NativeSet  {
  func validatedBucket(for index: _HashTable.Index) -> Bucket {
    _precondition(hashTable.isOccupied(index.bucket) && index.age == age,
      "Attempting to access Set elements using an invalid index")
    return index.bucket
  }
}

----Swift.(file)._NativeSet.validatedBucket(for:Set<Element>.Index)
extension _NativeSet  {
  func validatedBucket(for index: Set<Element>.Index) -> Bucket {
#if _runtime(_ObjC)
    guard index._isNative else {
      index._cocoaPath()
      let cocoa = index._asCocoa
      // Accept Cocoa indices as long as they contain an element that exists in
      // this set, and the address of their Cocoa object generates the same age.
      if cocoa.age == self.age {
        let element = _forceBridgeFromObjectiveC(cocoa.element, Element.self)
        let (bucket, found) = find(element)
        if found {
          return bucket
        }
      }
      _preconditionFailure(
        "Attempting to access Set elements using an invalid index")
    }
#endif
    return validatedBucket(for: index._asNative)
  }
}

----Swift.(file)._NativeSet.Index
extension _NativeSet: _SetBuffer  {
  internal typealias Index = Set<Element>.I
}

----Swift.(file)._NativeSet.startIndex
extension _NativeSet: _SetBuffer  {
  internal var startIndex: Index {
    let bucket = hashTable.startBucket
    return Index(_native: _HashTable.Index(bucket: bucket, age: age))
  }
}

----Swift.(file)._NativeSet.endIndex
extension _NativeSet: _SetBuffer  {
  internal var endIndex: Index {
    let bucket = hashTable.endBucket
    return Index(_native: _HashTable.Index(bucket: bucket, age: age))
  }
}

----Swift.(file)._NativeSet.index(after:_NativeSet<Element>.Index)
extension _NativeSet: _SetBuffer  {
  internal func index(after index: Index) -> Index {
    // Note that _asNative forces this not to work on Cocoa indices.
    let bucket = validatedBucket(for: index._asNative)
    let next = hashTable.occupiedBucket(after: bucket)
    return Index(_native: _HashTable.Index(bucket: next, age: age))
  }
}

----Swift.(file)._NativeSet.index(for:Element)
extension _NativeSet: _SetBuffer  {
  internal func index(for element: Element) -> Index? {
    if count == 0 {
      // Fast path that avoids computing the hash of the key.
      return nil
    }
    let (bucket, found) = find(element)
    guard found else { return nil }
    return Index(_native: _HashTable.Index(bucket: bucket, age: age))
  }
}

----Swift.(file)._NativeSet.count
extension _NativeSet: _SetBuffer  {
  internal var count: Int {
    @inline(__always) get {
      return _assumeNonNegative(_storage._count)
    }
  }
}

----Swift.(file)._NativeSet.contains(_:Element)
extension _NativeSet: _SetBuffer  {
  internal func contains(_ member: Element) -> Bool {
    // Fast path: Don't calculate the hash if the set has no elements.
    if count == 0 { return false }
    return find(member).found
  }
}

----Swift.(file)._NativeSet.element(at:_NativeSet<Element>.Index)
extension _NativeSet: _SetBuffer  {
  internal func element(at index: Index) -> Element {
    let bucket = validatedBucket(for: index)
    return uncheckedElement(at: bucket)
  }
}

----Swift.(file).ELEMENT_TYPE_OF_SET_VIOLATES_HASHABLE_REQUIREMENTS(_:Any.Type)
internal func ELEMENT_TYPE_OF_SET_VIOLATES_HASHABLE_REQUIREMENTS(
  _ elementType: Any.Type
) -> Never {
  _assertionFailure(
    "Fatal error",
    """
    Duplicate elements of type '\(elementType)' were found in a Set.
    This usually means either that the type violates Hashable's requirements, or
    that members of such a set were mutated after insertion.
    """,
    flags: _fatalErrorFlags())
}

----Swift.(file)._NativeSet.insertNew(_:Element,isUnique:Bool)
extension _NativeSet  {
  internal mutating func insertNew(_ element: __owned Element, isUnique: Bool) {
    _ = ensureUnique(isUnique: isUnique, capacity: count + 1)
    _unsafeInsertNew(element)
  }
}

----Swift.(file)._NativeSet.insertNew(_:Element,at:<<error type>>,isUnique:Bool)
extension _NativeSet  {
  internal mutating func insertNew(
    _ element: __owned Element,
    at bucket: Bucket,
    isUnique: Bool
  ) {
    _internalInvariant(!hashTable.isOccupied(bucket))
    var bucket = bucket
    let rehashed = ensureUnique(isUnique: isUnique, capacity: count + 1)
    if rehashed {
      let (b, f) = find(element)
      if f {
        ELEMENT_TYPE_OF_SET_VIOLATES_HASHABLE_REQUIREMENTS(Element.self)
      }
      bucket = b
    }
    _unsafeInsertNew(element, at: bucket)
  }
}

----Swift.(file)._NativeSet.update(with:Element,isUnique:Bool)
extension _NativeSet  {
  internal mutating func update(
    with element: __owned Element,
    isUnique: Bool
  ) -> Element? {
    var (bucket, found) = find(element)
    let rehashed = ensureUnique(
      isUnique: isUnique,
      capacity: count + (found ? 0 : 1))
    if rehashed {
      let (b, f) = find(element)
      if f != found {
        ELEMENT_TYPE_OF_SET_VIOLATES_HASHABLE_REQUIREMENTS(Element.self)
      }
      bucket = b
    }
    if found {
      let old = (_elements + bucket.offset).move()
      uncheckedInitialize(at: bucket, to: element)
      return old
    }
    _unsafeInsertNew(element, at: bucket)
    return nil
  }
}

----Swift.(file)._NativeSet.isEqual(to:_NativeSet<Element>)
extension _NativeSet  {
  func isEqual(to other: _NativeSet) -> Bool {
    if self._storage === other._storage { return true }
    if self.count != other.count { return false }

    for member in self {
      guard other.find(member).found else { return false }
    }
    return true
  }
}

----Swift.(file)._NativeSet.isEqual(to:<<error type>>)
extension _NativeSet  {
  func isEqual(to other: _CocoaSet) -> Bool {
    if self.count != other.count { return false }

    defer { _fixLifetime(self) }
    for bucket in self.hashTable {
      let key = self.uncheckedElement(at: bucket)
      let bridgedKey = _bridgeAnythingToObjectiveC(key)
      guard other.contains(bridgedKey) else { return false }
    }
    return true
  }
}

----Swift.(file)._NativeSet.hashValue(at:<<error type>>)
extension _NativeSet: _HashTableDelegate  {
  internal func hashValue(at bucket: Bucket) -> Int {
    return hashValue(for: uncheckedElement(at: bucket))
  }
}

----Swift.(file)._NativeSet.moveEntry(from:<<error type>>,to:<<error type>>)
extension _NativeSet: _HashTableDelegate  {
  internal func moveEntry(from source: Bucket, to target: Bucket) {
    (_elements + target.offset)
      .moveInitialize(from: _elements + source.offset, count: 1)
  }
}

----Swift.(file)._NativeSet.uncheckedRemove(at:<<error type>>,isUnique:Bool)
extension _NativeSet  {
  internal mutating func uncheckedRemove(
    at bucket: Bucket,
    isUnique: Bool) -> Element {
    _internalInvariant(hashTable.isOccupied(bucket))
    let rehashed = ensureUnique(isUnique: isUnique, capacity: capacity)
    _internalInvariant(!rehashed)
    let old = (_elements + bucket.offset).move()
    _delete(at: bucket)
    return old
  }
}

----Swift.(file)._NativeSet.removeAll(isUnique:Bool)
extension _NativeSet  {
  internal mutating func removeAll(isUnique: Bool) {
    guard isUnique else {
      let scale = self._storage._scale
      _storage = _SetStorage<Element>.allocate(
        scale: scale,
        age: nil,
        seed: nil)
      return
    }
    for bucket in hashTable {
      (_elements + bucket.offset).deinitialize(count: 1)
    }
    hashTable.clear()
    _storage._count = 0
    invalidateIndices()
  }
}

----Swift.(file)._NativeSet.makeIterator()
extension _NativeSet: Sequence  {
  internal __consuming func makeIterator() -> Iterator {
    return Iterator(self)
  }
}

----Swift.(file)._NativeSet.Iterator.next()
extension _NativeSet.Iterator: IteratorProtocol  {
  internal mutating func next() -> Element? {
    guard let index = iterator.next() else { return nil }
    return base.uncheckedElement(at: index)
  }
}

----Swift.(file)._SwiftNewtypeWrapper.hashValue
extension _SwiftNewtypeWrapper where Self: Hashable, Self.RawValue: Hashable  {
  public var hashValue: Int {
    return rawValue.hashValue
  }
}

----Swift.(file)._SwiftNewtypeWrapper.hash(into:Hasher)
extension _SwiftNewtypeWrapper where Self: Hashable, Self.RawValue: Hashable  {
  public func hash(into hasher: inout Hasher) {
    hasher.combine(rawValue)
  }
}

----Swift.(file)._StringGuts.foreignHasNormalizationBoundary(before:String.Index)
extension _StringGuts  {
  internal func foreignHasNormalizationBoundary(
    before index: String.Index
  ) -> Bool {
    let offset = index.encodedOffset
    if offset == 0 || offset == count {
      return true
    }

    let scalar = foreignErrorCorrectedScalar(startingAt: index).0
    return scalar._hasNormalizationBoundaryBefore
  }
}

----Swift.(file).UnsafeBufferPointer.hasNormalizationBoundary(before:Int)
extension UnsafeBufferPointer where Element == UInt8  {
  internal func hasNormalizationBoundary(before index: Int) -> Bool {
    if index == 0 || index == count {
      return true
    }
    assert(!_isContinuation(self[_unchecked: index]))

    // Sub-300 latiny fast-path
    if self[_unchecked: index] < 0xCC { return true }

    let cu = _decodeScalar(self, startingAt: index).0
    return cu._hasNormalizationBoundaryBefore
  }
}

----Swift.(file)._SegmentSource.tryFill(into:<<error type>>)
extension _SegmentSource  {
  mutating func tryFill(
    into output: UnsafeMutablePointer<_Normalization._SegmentOutputBuffer>
  ) -> Int? {
    return tryFill(into: _castOutputBuffer(output))
  }
}

----Swift.(file)._NormalizedUTF8CodeUnitIterator_2.outputBufferThreshold
extension _NormalizedUTF8CodeUnitIterator_2  {
  private var outputBufferThreshold: Int {
    return outputBuffer.capacity - 4
  }
}

----Swift.(file)._NormalizedUTF8CodeUnitIterator_2.outputBufferEmpty
extension _NormalizedUTF8CodeUnitIterator_2  {
  private var outputBufferEmpty: Bool {
    return outputPosition == outputBufferCount
  }
}

----Swift.(file)._NormalizedUTF8CodeUnitIterator_2.outputBufferFull
extension _NormalizedUTF8CodeUnitIterator_2  {
  private var outputBufferFull: Bool {
    return outputBufferCount >= outputBufferThreshold
  }
}

----Swift.(file)._NormalizedUTF8CodeUnitIterator_2.inputBufferEmpty
extension _NormalizedUTF8CodeUnitIterator_2  {
  private var inputBufferEmpty: Bool {
    return gutsSlice.range.isEmpty
  }
}

----Swift.(file)._NormalizedUTF8CodeUnitIterator_2.fastPathFill()
extension _NormalizedUTF8CodeUnitIterator_2  {
  private mutating func fastPathFill() -> (numRead: Int, numWritten: Int) {
    // TODO: Additional fast-path: All CCC-ascending NFC_QC segments are NFC
    // TODO: Just freakin do normalization and don't bother with ICU
    var outputCount = 0
    let outputEnd = outputBufferThreshold
    var inputCount = 0
    let inputEnd = gutsSlice.count
    if _fastPath(gutsSlice.isFastUTF8) {
      gutsSlice.withFastUTF8 { utf8 in
        while inputCount < inputEnd && outputCount < outputEnd {
          // TODO: Slightly faster code-unit scan for latiny (<0xCC)

          // Check scalar-based fast-paths
          let (scalar, len) = _decodeScalar(utf8, startingAt: inputCount)
          _internalInvariant(inputCount &+ len <= inputEnd)

          if _slowPath(
               !utf8.hasNormalizationBoundary(before: inputCount &+ len)
            || !scalar._isNFCStarter
          ) {
            break 
          }
          inputCount &+= len

          for cu in UTF8.encode(scalar)._unsafelyUnwrappedUnchecked {
            outputBuffer[outputCount] = cu
            outputCount &+= 1
          }

          _internalInvariant(inputCount == outputCount,
            "non-normalizing UTF-8 fast path should be 1-to-1 in code units")
        }
      }
    } else { // Foreign
      while inputCount < inputEnd && outputCount < outputEnd {
        let startIdx = gutsSlice.range.lowerBound.encoded(
          offsetBy: inputCount)
        let (scalar, len) = gutsSlice.foreignErrorCorrectedScalar(
          startingAt: startIdx)
        _internalInvariant(inputCount &+ len <= inputEnd)

        if _slowPath(
             !gutsSlice.foreignHasNormalizationBoundary(
               before: startIdx.encoded(offsetBy: len))
          || !scalar._isNFCStarter
        ) {
          break 
        }
        inputCount &+= len

        for cu in UTF8.encode(scalar)._unsafelyUnwrappedUnchecked {
          outputBuffer[outputCount] = cu
          outputCount &+= 1
        }

        _internalInvariant(inputCount <= outputCount,
          "non-normalizing UTF-16 fast path shoule be 1-to-many in code units")
      }
    }
    return (inputCount, outputCount)
  }
}

----Swift.(file)._NormalizedUTF8CodeUnitIterator_2.fill()
extension _NormalizedUTF8CodeUnitIterator_2  {
  private mutating func fill() {
    _internalInvariant(outputBufferEmpty)

    let priorInputCount = gutsSlice._offsetRange.count

    outputPosition = 0
    let (inputCount, outputCount) = fastPathFill()
    self.outputBufferCount = outputCount

    // Check if we filled in any, and adjust our scanning range appropriately
    if inputCount > 0 {
      _internalInvariant(outputCount > 0)
      gutsSlice._offsetRange = Range(uncheckedBounds: (
        gutsSlice._offsetRange.lowerBound + inputCount,
        gutsSlice._offsetRange.upperBound))
      _internalInvariant(gutsSlice._offsetRange.count >= 0)
      return
    }

    let remaining: Int = gutsSlice.withNFCCodeUnitsIterator {
      var nfc = $0
      while !outputBufferFull, let cu = nfc.next() {
        outputBuffer[outputBufferCount] = cu
        outputBufferCount &+= 1
      }
      return nfc.utf16Iterator.source.remaining
    }

    if !(outputBufferCount == 0 || remaining < priorInputCount) {
      // TODO: _internalInvariant(outputBufferCount == 0 || remaining < priorInputCount)
    }

    gutsSlice._offsetRange = Range(uncheckedBounds: (
      gutsSlice._offsetRange.lowerBound + (priorInputCount - remaining),
      gutsSlice._offsetRange.upperBound))

    _internalInvariant(outputBufferFull || gutsSlice._offsetRange.isEmpty)
    _internalInvariant(gutsSlice._offsetRange.count >= 0)
  }
}

----Swift.(file)._NormalizedUTF8CodeUnitIterator_2.compare(with:_NormalizedUTF8CodeUnitIterator_2,expecting:<<error type>>)
extension _NormalizedUTF8CodeUnitIterator_2  {
  internal mutating func compare(
    with other: _NormalizedUTF8CodeUnitIterator_2,
    expecting: _StringComparisonResult
  ) -> Bool {
    var mutableOther = other

    for cu in self {
      guard let otherCU = mutableOther.next() else {
        // We have more code units, therefore we are greater
        return false
      }
      if cu == otherCU { continue }
      return expecting == .less ? cu < otherCU : false
    }

    // We have exhausted our code units. We are less if there's more remaining
    return mutableOther.next() == nil ? expecting == .equal : expecting == .less
  }
}

----Swift.(file).ObjectIdentifier.init(_:AnyObject)
extension ObjectIdentifier {
  public init(_ x: AnyObject) {
    self._value = Builtin.bridgeToRawPointer(x)
  }
}

----Swift.(file).ObjectIdentifier.init(_:Any.Type)
extension ObjectIdentifier {
  public init(_ x: Any.Type) {
    self._value = unsafeBitCast(x, to: Builtin.RawPointer.self)
  }
}

----Swift.(file).ObjectIdentifier.debugDescription
extension ObjectIdentifier : CustomDebugStringConvertible  {
  public var debugDescription: String {
    return "ObjectIdentifier(\(_rawPointerToString(_value)))"
  }
}

----Swift.(file).ObjectIdentifier.==infix(_:ObjectIdentifier,_:ObjectIdentifier)
extension ObjectIdentifier: Equatable  {
  public static func == (x: ObjectIdentifier, y: ObjectIdentifier) -> Bool {
    return Bool(Builtin.cmp_eq_RawPointer(x._value, y._value))
  }
}

----Swift.(file).ObjectIdentifier.<infix(_:ObjectIdentifier,_:ObjectIdentifier)
extension ObjectIdentifier: Comparable  {
  public static func < (lhs: ObjectIdentifier, rhs: ObjectIdentifier) -> Bool {
    return UInt(bitPattern: lhs) < UInt(bitPattern: rhs)
  }
}

----Swift.(file).ObjectIdentifier.hash(into:Hasher)
extension ObjectIdentifier: Hashable  {
  public func hash(into hasher: inout Hasher) {
    hasher.combine(Int(Builtin.ptrtoint_Word(_value)))
  }
}

----Swift.(file).UInt.init(bitPattern:ObjectIdentifier)
extension UInt  {
  public init(bitPattern objectID: ObjectIdentifier) {
    self.init(Builtin.ptrtoint_Word(objectID._value))
  }
}

----Swift.(file).Int.init(bitPattern:ObjectIdentifier)
extension Int  {
  public init(bitPattern objectID: ObjectIdentifier) {
    self.init(bitPattern: UInt(bitPattern: objectID))
  }
}

----Swift.(file).OptionSet.Element
extension OptionSet {
  associatedtype E
}

----Swift.(file).OptionSet.init(rawValue:Self.RawValue)
extension OptionSet {
  init(rawValue: RawValue)
}

----Swift.(file).OptionSet.union(_:Self)
extension OptionSet  {
  public func union(_ other: Self) -> Self {
    var r: Self = Self(rawValue: self.rawValue)
    r.formUnion(other)
    return r
  }
}

----Swift.(file).OptionSet.intersection(_:Self)
extension OptionSet  {
  public func intersection(_ other: Self) -> Self {
    var r = Self(rawValue: self.rawValue)
    r.formIntersection(other)
    return r
  }
}

----Swift.(file).OptionSet.symmetricDifference(_:Self)
extension OptionSet  {
  public func symmetricDifference(_ other: Self) -> Self {
    var r = Self(rawValue: self.rawValue)
    r.formSymmetricDifference(other)
    return r
  }
}

----Swift.(file).OptionSet.contains(_:Self)
extension OptionSet where Element == Self  {
  public func contains(_ member: Self) -> Bool {
    return self.isSuperset(of: member)
  }
}

----Swift.(file).OptionSet.insert(_:Self.Element)
extension OptionSet where Element == Self  {
  public mutating func insert(
    _ newMember: Element
  ) -> (inserted: Bool, memberAfterInsert: Element) {
    let oldMember = self.intersection(newMember)
    let shouldInsert = oldMember != newMember
    let result = (
      inserted: shouldInsert,
      memberAfterInsert: shouldInsert ? newMember : oldMember)
    if shouldInsert {
      self.formUnion(newMember)
    }
    return result
  }
}

----Swift.(file).OptionSet.remove(_:Self.Element)
extension OptionSet where Element == Self  {
  public mutating func remove(_ member: Element) -> Element? {
    let r = isSuperset(of: member) ? Optional(member) : nil
    self.subtract(member)
    return r
  }
}

----Swift.(file).OptionSet.update(with:Self.Element)
extension OptionSet where Element == Self  {
  public mutating func update(with newMember: Element) -> Element? {
    let r = self.intersection(newMember)
    self.formUnion(newMember)
    return r.isEmpty ? nil : r
  }
}

----Swift.(file).OptionSet.init()
extension OptionSet where RawValue : FixedWidthInteger  {
  public init() {
    self.init(rawValue: 0)
  }
}

----Swift.(file).OptionSet.formUnion(_:Self)
extension OptionSet where RawValue : FixedWidthInteger  {
  public mutating func formUnion(_ other: Self) {
    self = Self(rawValue: self.rawValue | other.rawValue)
  }
}

----Swift.(file).OptionSet.formIntersection(_:Self)
extension OptionSet where RawValue : FixedWidthInteger  {
  public mutating func formIntersection(_ other: Self) {
    self = Self(rawValue: self.rawValue & other.rawValue)
  }
}

----Swift.(file).OptionSet.formSymmetricDifference(_:Self)
extension OptionSet where RawValue : FixedWidthInteger  {
  public mutating func formSymmetricDifference(_ other: Self) {
    self = Self(rawValue: self.rawValue ^ other.rawValue)
  }
}

----Swift.(file).Optional.none
extension Optional {
  case n
}

----Swift.(file).Optional.some
extension Optional {
  case some(Wrapped)
}

----Swift.(file).Optional.init(_:Wrapped)
extension Optional {
  public init(_ some: Wrapped) { self = .some(some) }
}

----Swift.(file).Optional.map(_:(Wrapped) throws -> U)
extension Optional {
  public func map<U>(
    _ transform: (Wrapped) throws -> U
  ) rethrows -> U? {
    switch self {
    case .some(let y):
      return .some(try transform(y))
    case .none:
      return .none
    }
  }
}

----Swift.(file).Optional.flatMap(_:(Wrapped) throws -> U?)
extension Optional {
  public func flatMap<U>(
    _ transform: (Wrapped) throws -> U?
  ) rethrows -> U? {
    switch self {
    case .some(let y):
      return try transform(y)
    case .none:
      return .none
    }
  }
}

----Swift.(file).Optional.init(nilLiteral:())
extension Optional {
  public init(nilLiteral: ()) {
    self = .none
  }
}

----Swift.(file).Optional.unsafelyUnwrapped
extension Optional {
  public var unsafelyUnwrapped: Wrapped {
    @inline(__always)
    get {
      if let x = self {
        return x
      }
      _debugPreconditionFailure("unsafelyUnwrapped of nil optional")
    }
  }
}

----Swift.(file).Optional.debugDescription
extension Optional : CustomDebugStringConvertible  {
  public var debugDescription: String {
    switch self {
    case .some(let value):
      var result = "Optional("
      debugPrint(value, terminator: "", to: &result)
      result += ")"
      return result
    case .none:
      return "nil"
    }
  }
}

----Swift.(file).Optional.customMirror
extension Optional : CustomReflectable  {
  public var customMirror: Mirror {
    switch self {
    case .some(let value):
      return Mirror(
        self,
        children: [ "some": value ],
        displayStyle: .optional)
    case .none:
      return Mirror(self, children: [:], displayStyle: .optional)
    }
  }
}

----Swift.(file).Optional.==infix(_:Wrapped?,_:Wrapped?)
extension Optional : Equatable where Wrapped : Equatable  {
  public static func ==(lhs: Wrapped?, rhs: Wrapped?) -> Bool {
    switch (lhs, rhs) {
    case let (l?, r?):
      return l == r
    case (nil, nil):
      return true
    default:
      return false
    }
  }
}

----Swift.(file).Optional.hash(into:Hasher)
extension Optional: Hashable where Wrapped: Hashable  {
  public func hash(into hasher: inout Hasher) {
    switch self {
    case .none:
      hasher.combine(0 as UInt8)
    case .some(let wrapped):
      hasher.combine(1 as UInt8)
      hasher.combine(wrapped)
    }
  }
}

----Swift.(file).Optional.~=infix(_:_OptionalNilComparisonType,_:Wrapped?)
extension Optional  {
  public static func ~=(lhs: _OptionalNilComparisonType, rhs: Wrapped?) -> Bool {
    switch rhs {
    case .some:
      return false
    case .none:
      return true
    }
  }
}

----Swift.(file).Optional.==infix(_:Wrapped?,_:_OptionalNilComparisonType)
extension Optional  {
  public static func ==(lhs: Wrapped?, rhs: _OptionalNilComparisonType) -> Bool {
    switch lhs {
    case .some:
      return false
    case .none:
      return true
    }
  }
}

----Swift.(file).Optional.!=infix(_:Wrapped?,_:_OptionalNilComparisonType)
extension Optional  {
  public static func !=(lhs: Wrapped?, rhs: _OptionalNilComparisonType) -> Bool {
    switch lhs {
    case .some:
      return true
    case .none:
      return false
    }
  }
}

----Swift.(file).Optional.==infix(_:_OptionalNilComparisonType,_:Wrapped?)
extension Optional  {
  public static func ==(lhs: _OptionalNilComparisonType, rhs: Wrapped?) -> Bool {
    switch rhs {
    case .some:
      return false
    case .none:
      return true
    }
  }
}

----Swift.(file).Optional.!=infix(_:_OptionalNilComparisonType,_:Wrapped?)
extension Optional  {
  public static func !=(lhs: _OptionalNilComparisonType, rhs: Wrapped?) -> Bool {
    switch rhs {
    case .some:
      return true
    case .none:
      return false
    }
  }
}

----Swift.(file).??infix(_:T?,_:() throws -> T)
public func ?? <T>(optional: T?, defaultValue: @autoclosure () throws -> T)
    rethrows -> T {
  switch optional {
  case .some(let value):
    return value
  case .none:
    return try defaultValue()
  }
}

----Swift.(file).??infix(_:T?,_:() throws -> T?)
public func ?? <T>(optional: T?, defaultValue: @autoclosure () throws -> T?)
    rethrows -> T? {
  switch optional {
  case .some(let value):
    return value
  case .none:
    return try defaultValue()
  }
}

----Swift.(file).TextOutputStream.write(_:String)
extension TextOutputStream {
  mutating func write(_ string: String)
}

----Swift.(file).TextOutputStreamable.write(to:Target)
extension TextOutputStreamable {
  func write<Target : TextOutputStream>(to target: inout Target)
}

----Swift.(file).CustomStringConvertible.description
extension CustomStringConvertible {
  var description: String { get }
}

----Swift.(file).LosslessStringConvertible.init(_:String)
extension LosslessStringConvertible {
  init?(_ description: String)
}

----Swift.(file).CustomDebugStringConvertible.debugDescription
extension CustomDebugStringConvertible {
  var debugDescription: String { get }
}

----Swift.(file).String.write(_:String)
extension String : TextOutputStream  {
  public mutating func write(_ other: String) {
    self += other
  }
}

----Swift.(file).String.write(to:Target)
extension String : TextOutputStreamable  {
  public func write<Target : TextOutputStream>(to target: inout Target) {
    target.write(self)
  }
}

----Swift.(file).Character.write(to:Target)
extension Character : TextOutputStreamable  {
  public func write<Target : TextOutputStream>(to target: inout Target) {
    target.write(String(self))
  }
}

----Swift.(file).Unicode.Scalar.write(to:Target)
extension Unicode.Scalar : TextOutputStreamable  {
  public func write<Target : TextOutputStream>(to target: inout Target) {
    target.write(String(Character(self)))
  }
}

----Swift.(file)._Pointer.init(_:OpaquePointer)
extension _Pointer  {
  public init(_ from : OpaquePointer) {
    self.init(from._rawValue)
  }
}

----Swift.(file)._Pointer.init(_:OpaquePointer?)
extension _Pointer  {
  public init?(_ from : OpaquePointer?) {
    guard let unwrapped = from else { return nil }
    self.init(unwrapped)
  }
}

----Swift.(file)._Pointer.init(bitPattern:Int)
extension _Pointer  {
  public init?(bitPattern: Int) {
    if bitPattern == 0 { return nil }
    self.init(Builtin.inttoptr_Word(bitPattern._builtinWordValue))
  }
}

----Swift.(file)._Pointer.init(bitPattern:UInt)
extension _Pointer  {
  public init?(bitPattern: UInt) {
    if bitPattern == 0 { return nil }
    self.init(Builtin.inttoptr_Word(bitPattern._builtinWordValue))
  }
}

----Swift.(file)._Pointer.init(_:Self)
extension _Pointer  {
  public init(_ other: Self) {
    self.init(other._rawValue)
  }
}

----Swift.(file)._Pointer.init(_:Self?)
extension _Pointer  {
  public init?(_ other: Self?) {
    guard let unwrapped = other else { return nil }
    self.init(unwrapped._rawValue)
  }
}

----Swift.(file)._Pointer.init(_:UnsafeMutablePointer<T>)
extension _Pointer  {
  public init<T>(_ other: UnsafeMutablePointer<T>) {
    self.init(other._rawValue)
  }
}

----Swift.(file)._Pointer.init(_:UnsafeMutablePointer<T>?)
extension _Pointer  {
  public init?<T>(_ other: UnsafeMutablePointer<T>?) {
    guard let unwrapped = other else { return nil }
    self.init(unwrapped)
  }
}

----Swift.(file)._Pointer.==infix(_:Self,_:Self)
extension _Pointer /*: Equatable */  {
  public static func == (lhs: Self, rhs: Self) -> Bool {
    return Bool(Builtin.cmp_eq_RawPointer(lhs._rawValue, rhs._rawValue))
  }
}

----Swift.(file)._Pointer.<infix(_:Self,_:Self)
extension _Pointer /*: Comparable */  {
  public static func < (lhs: Self, rhs: Self) -> Bool {
    return Bool(Builtin.cmp_ult_RawPointer(lhs._rawValue, rhs._rawValue))
  }
}

----Swift.(file)._Pointer.successor()
extension _Pointer /*: Strideable*/  {
  public func successor() -> Self {
    return advanced(by: 1)
  }
}

----Swift.(file)._Pointer.predecessor()
extension _Pointer /*: Strideable*/  {
  public func predecessor() -> Self {
    return advanced(by: -1)
  }
}

----Swift.(file)._Pointer.distance(to:Self)
extension _Pointer /*: Strideable*/  {
  public func distance(to end: Self) -> Int {
    return
      Int(Builtin.sub_Word(Builtin.ptrtoint_Word(end._rawValue),
                           Builtin.ptrtoint_Word(_rawValue)))
      / MemoryLayout<Pointee>.stride
  }
}

----Swift.(file)._Pointer.advanced(by:Int)
extension _Pointer /*: Strideable*/  {
  public func advanced(by n: Int) -> Self {
    return Self(Builtin.gep_Word(
      self._rawValue, n._builtinWordValue, Pointee.self))
  }
}

----Swift.(file)._Pointer.hash(into:Hasher)
extension _Pointer /*: Hashable */  {
  public func hash(into hasher: inout Hasher) {
    hasher.combine(UInt(bitPattern: self))
  }
}

----Swift.(file)._Pointer.debugDescription
extension _Pointer /*: CustomDebugStringConvertible */  {
  public var debugDescription: String {
    return _rawPointerToString(_rawValue)
  }
}

----Swift.(file)._Pointer.customMirror
extension _Pointer /*: CustomReflectable */  {
  public var customMirror: Mirror {
    let ptrValue = UInt64(
      bitPattern: Int64(Int(Builtin.ptrtoint_Word(_rawValue))))
    return Mirror(self, children: ["pointerValue": ptrValue])
  }
}

----Swift.(file).Int.init(bitPattern:P?)
extension Int  {
  public init<P: _Pointer>(bitPattern pointer: P?) {
    if let pointer = pointer {
      self = Int(Builtin.ptrtoint_Word(pointer._rawValue))
    } else {
      self = 0
    }
  }
}

----Swift.(file).UInt.init(bitPattern:P?)
extension UInt  {
  public init<P: _Pointer>(bitPattern pointer: P?) {
    if let pointer = pointer {
      self = UInt(Builtin.ptrtoint_Word(pointer._rawValue))
    } else {
      self = 0
    }
  }
}

----Swift.(file).Strideable.+infix(_:Self,_:Self.Stride)
extension Strideable where Self : _Pointer  {
  public static func + (lhs: Self, rhs: Self.Stride) -> Self {
    return lhs.advanced(by: rhs)
  }
}

----Swift.(file).Strideable.+infix(_:Self.Stride,_:Self)
extension Strideable where Self : _Pointer  {
  public static func + (lhs: Self.Stride, rhs: Self) -> Self {
    return rhs.advanced(by: lhs)
  }
}

----Swift.(file).Strideable.-infix(_:Self,_:Self.Stride)
extension Strideable where Self : _Pointer  {
  public static func - (lhs: Self, rhs: Self.Stride) -> Self {
    return lhs.advanced(by: -rhs)
  }
}

----Swift.(file).Strideable.-infix(_:Self,_:Self)
extension Strideable where Self : _Pointer  {
  public static func - (lhs: Self, rhs: Self) -> Self.Stride {
    return rhs.distance(to: lhs)
  }
}

----Swift.(file).Strideable.+=infix(_:Self,_:Self.Stride)
extension Strideable where Self : _Pointer  {
  public static func += (lhs: inout Self, rhs: Self.Stride) {
    lhs = lhs.advanced(by: rhs)
  }
}

----Swift.(file).Strideable.-=infix(_:Self,_:Self.Stride)
extension Strideable where Self : _Pointer  {
  public static func -= (lhs: inout Self, rhs: Self.Stride) {
    lhs = lhs.advanced(by: -rhs)
  }
}

----Swift.(file).Never.<infix(_:Never,_:Never)
extension Never: Comparable  {
  public static func < (lhs: Never, rhs: Never) -> Bool {
  }
}

----Swift.(file).Void
public typealias Void = ()

----Swift.(file).Float32
public typealias Float32 = F

----Swift.(file).Float64
public typealias Float64 = D

----Swift.(file).IntegerLiteralType
public typealias IntegerLiteralType = I

----Swift.(file).FloatLiteralType
public typealias FloatLiteralType = D

----Swift.(file).BooleanLiteralType
public typealias BooleanLiteralType = B

----Swift.(file).UnicodeScalarType
public typealias UnicodeScalarType = S

----Swift.(file).ExtendedGraphemeClusterType
public typealias ExtendedGraphemeClusterType = S

----Swift.(file).StringLiteralType
public typealias StringLiteralType = S

----Swift.(file).AnyObject
public typealias AnyObject = Builtin.A

----Swift.(file).AnyClass
public typealias AnyClass = AnyObject.T

----Swift.(file).~=infix(_:T,_:T)
public func ~= <T : Equatable>(a: T, b: T) -> Bool {
  return a == b
}

----Swift.(file).LazyPrefixWhileSequence.Element
extension LazyPrefixWhileSequence {
  public typealias Element = Base.E
}

----Swift.(file).LazyPrefixWhileSequence.init(_base:Base,predicate:(LazyPrefixWhileSequence<Base>.Element) -> Bool)
extension LazyPrefixWhileSequence {
  internal init(_base: Base, predicate: @escaping (Element) -> Bool) {
    self._base = _base
    self._predicate = predicate
  }
}

----Swift.(file).LazyPrefixWhileSequence.Iterator.Element
extension LazyPrefixWhileSequence.Iterator {
    public typealias Element = Base.E
}

----Swift.(file).LazyPrefixWhileSequence.Iterator.init(_base:Base.Iterator,predicate:(LazyPrefixWhileSequence<Base>.Iterator.Element) -> Bool)
extension LazyPrefixWhileSequence.Iterator {
    internal init(_base: Base.Iterator, predicate: @escaping (Element) -> Bool) {
      self._base = _base
      self._predicate = predicate
    }
}

----Swift.(file).LazyPrefixWhileSequence.Iterator.next()
extension LazyPrefixWhileSequence.Iterator: IteratorProtocol, Sequence  {
  public mutating func next() -> Element? {
    // Return elements from the base iterator until one fails the predicate.
    if !_predicateHasFailed, let nextElement = _base.next() {
      if _predicate(nextElement) {
        return nextElement
      } else {
        _predicateHasFailed = true
      }
    }
    return nil
  }
}

----Swift.(file).LazyPrefixWhileSequence.makeIterator()
extension LazyPrefixWhileSequence: Sequence  {
  public __consuming func makeIterator() -> Iterator {
    return Iterator(_base: _base.makeIterator(), predicate: _predicate)
  }
}

----Swift.(file).LazyPrefixWhileSequence.Elements
extension LazyPrefixWhileSequence: LazySequenceProtocol  {
  public typealias Elements = L
}

----Swift.(file).LazySequenceProtocol.prefix(while:(Self.Elements.Element) -> Bool)
extension LazySequenceProtocol  {
  public __consuming func prefix(
    while predicate: @escaping (Elements.Element) -> Bool
  ) -> LazyPrefixWhileSequence<Self.Elements> {
    return LazyPrefixWhileSequence(_base: self.elements, predicate: predicate)
  }
}

----Swift.(file).LazyPrefixWhileCollection
public typealias LazyPrefixWhileCollection<T: Collection> = LazyPrefixWhileSequence<T>

----Swift.(file).LazyPrefixWhileCollection.Index.init(_:Base.Index)
extension LazyPrefixWhileCollection.Index {
    internal init(_ i: Base.Index) {
      self._value = .index(i)
    }
}

----Swift.(file).LazyPrefixWhileCollection.Index.init(endOf:Base)
extension LazyPrefixWhileCollection.Index {
    internal init(endOf: Base) {
      self._value = .pastEnd
    }
}

----Swift.(file).LazyPrefixWhileSequence.Index.==infix(_:LazyPrefixWhileCollection<Base>.Index,_:LazyPrefixWhileCollection<Base>.Index)
extension LazyPrefixWhileSequence.Index: Comparable where Base: Collection  {
  public static func == (
    lhs: LazyPrefixWhileCollection<Base>.Index, 
    rhs: LazyPrefixWhileCollection<Base>.Index
  ) -> Bool {
    switch (lhs._value, rhs._value) {
    case let (.index(l), .index(r)):
      return l == r
    case (.pastEnd, .pastEnd):
      return true
    case (.pastEnd, .index), (.index, .pastEnd):
      return false
    }
  }
}

----Swift.(file).LazyPrefixWhileSequence.Index.<infix(_:LazyPrefixWhileCollection<Base>.Index,_:LazyPrefixWhileCollection<Base>.Index)
extension LazyPrefixWhileSequence.Index: Comparable where Base: Collection  {
  public static func < (
    lhs: LazyPrefixWhileCollection<Base>.Index, 
    rhs: LazyPrefixWhileCollection<Base>.Index
  ) -> Bool {
    switch (lhs._value, rhs._value) {
    case let (.index(l), .index(r)):
      return l < r
    case (.index, .pastEnd):
      return true
    case (.pastEnd, _):
      return false
    }
  }
}

----Swift.(file).LazyPrefixWhileSequence.Index.hash(into:Hasher)
extension LazyPrefixWhileSequence.Index: Hashable where Base.Index: Hashable, Base: Collection  {
  public func hash(into hasher: inout Hasher) {
    switch _value {
    case .index(let value):
      hasher.combine(value)
    case .pastEnd:
      hasher.combine(Int.max)
    }
  }
}

----Swift.(file).LazyPrefixWhileCollection.SubSequence
extension LazyPrefixWhileCollection: Collection  {
  public typealias SubSequence = Slice<LazyPrefixWhileCollection<Base>>
}

----Swift.(file).LazyPrefixWhileCollection.startIndex
extension LazyPrefixWhileCollection: Collection  {
  public var startIndex: Index {
    return Index(_base.startIndex)
  }
}

----Swift.(file).LazyPrefixWhileCollection.endIndex
extension LazyPrefixWhileCollection: Collection  {
  public var endIndex: Index {
    // If the first element of `_base` satisfies the predicate, there is at
    // least one element in the lazy collection: Use the explicit `.pastEnd` index.
    if let first = _base.first, _predicate(first) {
      return Index(endOf: _base)
    }

    // `_base` is either empty or `_predicate(_base.first!) == false`. In either
    // case, the lazy collection is empty, so `endIndex == startIndex`.
    return startIndex
  }
}

----Swift.(file).LazyPrefixWhileCollection.index(after:LazyPrefixWhileSequence<Base>.Index)
extension LazyPrefixWhileCollection: Collection  {
  public func index(after i: Index) -> Index {
    _precondition(i != endIndex, "Can't advance past endIndex")
    guard case .index(let i) = i._value else {
      _preconditionFailure("Invalid index passed to index(after:)")
    }
    let nextIndex = _base.index(after: i)
    guard nextIndex != _base.endIndex && _predicate(_base[nextIndex]) else {
      return Index(endOf: _base)
    }
    return Index(nextIndex)
  }
}

----Swift.(file).LazyPrefixWhileCollection.subscript(_:LazyPrefixWhileSequence<Base>.Index)
extension LazyPrefixWhileCollection: Collection  {
  public subscript(position: Index) -> Element {
    switch position._value {
    case .index(let i):
      return _base[i]
    case .pastEnd:
      _preconditionFailure("Index out of range")
    }
  }
}

----Swift.(file).LazyPrefixWhileCollection.index(before:LazyPrefixWhileSequence<Base>.Index)
extension LazyPrefixWhileCollection: BidirectionalCollection
where Base: BidirectionalCollection  {
  public func index(before i: Index) -> Index {
    switch i._value {
    case .index(let i):
      _precondition(i != _base.startIndex, "Can't move before startIndex")
      return Index(_base.index(before: i))
    case .pastEnd:
      // Look for the position of the last element in a non-empty
      // prefix(while:) collection by searching forward for a predicate
      // failure.

      // Safe to assume that `_base.startIndex != _base.endIndex`; if they
      // were equal, `_base.startIndex` would be used as the `endIndex` of
      // this collection.
      _internalInvariant(!_base.isEmpty)
      var result = _base.startIndex
      while true {
        let next = _base.index(after: result)
        if next == _base.endIndex || !_predicate(_base[next]) {
          break
        }
        result = next
      }
      return Index(result)
    }
  }
}

----Swift.(file).print(_:[Any],separator:String,terminator:String)
public func print(
  _ items: Any...,
  separator: String = " ",
  terminator: String = "\n"
) {
  if let hook = _playgroundPrintHook {
    var output = _TeeStream(left: "", right: _Stdout())
    _print(items, separator: separator, terminator: terminator, to: &output)
    hook(output.left)
  }
  else {
    var output = _Stdout()
    _print(items, separator: separator, terminator: terminator, to: &output)
  }
}

----Swift.(file).debugPrint(_:[Any],separator:String,terminator:String)
public func debugPrint(
  _ items: Any...,
  separator: String = " ",
  terminator: String = "\n"
) {
  if let hook = _playgroundPrintHook {
    var output = _TeeStream(left: "", right: _Stdout())
    _debugPrint(items, separator: separator, terminator: terminator, to: &output)
    hook(output.left)
  }
  else {
    var output = _Stdout()
    _debugPrint(items, separator: separator, terminator: terminator, to: &output)
  }
}

----Swift.(file).print(_:[Any],separator:String,terminator:String,to:Target)
public func print<Target : TextOutputStream>(
  _ items: Any...,
  separator: String = " ",
  terminator: String = "\n",
  to output: inout Target
) {
  _print(items, separator: separator, terminator: terminator, to: &output)
}

----Swift.(file).debugPrint(_:[Any],separator:String,terminator:String,to:Target)
public func debugPrint<Target : TextOutputStream>(
  _ items: Any...,
  separator: String = " ",
  terminator: String = "\n",
  to output: inout Target
) {
  _debugPrint(items, separator: separator, terminator: terminator, to: &output)
}

----Swift.(file).RandomNumberGenerator.next()
extension RandomNumberGenerator {
  mutating func next() -> U
}

----Swift.(file).RandomNumberGenerator.next()
extension RandomNumberGenerator  {
  public mutating func next<T: FixedWidthInteger & UnsignedInteger>() -> T {
    return T._random(using: &self)
  }
}

----Swift.(file).RandomNumberGenerator.next(upperBound:T)
extension RandomNumberGenerator  {
  public mutating func next<T: FixedWidthInteger & UnsignedInteger>(
    upperBound: T
  ) -> T {
    _precondition(upperBound != 0, "upperBound cannot be zero.")
    let tmp = (T.max % upperBound) + 1
    let range = tmp == upperBound ? 0 : tmp
    var random: T = 0

    repeat {
      random = next()
    } while random < range

    return random % upperBound
  }
}

----Swift.(file).SystemRandomNumberGenerator.init()
extension SystemRandomNumberGenerator {
  public init() { }
}

----Swift.(file).SystemRandomNumberGenerator.next()
extension SystemRandomNumberGenerator {
  public mutating func next() -> UInt64 {
    var random: UInt64 = 0
    swift_stdlib_random(&random, MemoryLayout<UInt64>.size)
    return random
  }
}

----Swift.(file).RandomAccessCollection.Element
extension RandomAccessCollection {
  override associatedtype E
}

----Swift.(file).RandomAccessCollection.Index
extension RandomAccessCollection {
  override associatedtype I
}

----Swift.(file).RandomAccessCollection.SubSequence
extension RandomAccessCollection {
  override associatedtype S
}

----Swift.(file).RandomAccessCollection.Indices
extension RandomAccessCollection {
  override associatedtype I
}

----Swift.(file).RandomAccessCollection.indices
extension RandomAccessCollection {
  override var indices: Indices { get }
}

----Swift.(file).RandomAccessCollection.subscript(_:Range<Self.Index>)
extension RandomAccessCollection {
  override subscript(bounds: Range<Index>) -> SubSequence { get }
}

----Swift.(file).RandomAccessCollection.subscript(_:Self.Index)
extension RandomAccessCollection {
  override subscript(position: Index) -> Element { get }
}

----Swift.(file).RandomAccessCollection.startIndex
extension RandomAccessCollection {
  override var startIndex: Index { get }
}

----Swift.(file).RandomAccessCollection.endIndex
extension RandomAccessCollection {
  override var endIndex: Index { get }
}

----Swift.(file).RandomAccessCollection.index(before:Self.Index)
extension RandomAccessCollection {
  override func index(before i: Index) -> I
}

----Swift.(file).RandomAccessCollection.formIndex(before:Self.Index)
extension RandomAccessCollection {
  override func formIndex(before i: inout Index)
}

----Swift.(file).RandomAccessCollection.index(after:Self.Index)
extension RandomAccessCollection {
  override func index(after i: Index) -> I
}

----Swift.(file).RandomAccessCollection.formIndex(after:Self.Index)
extension RandomAccessCollection {
  override func formIndex(after i: inout Index)
}

----Swift.(file).RandomAccessCollection.index(_:Self.Index,offsetBy:Int)
extension RandomAccessCollection {
  @_nonoverride func index(_ i: Index, offsetBy distance: Int) -> I
}

----Swift.(file).RandomAccessCollection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)
extension RandomAccessCollection {
  @_nonoverride func index(
    _ i: Index, offsetBy distance: Int, limitedBy limit: Index
  ) -> Index?
}

----Swift.(file).RandomAccessCollection.distance(from:Self.Index,to:Self.Index)
extension RandomAccessCollection {
  @_nonoverride func distance(from start: Index, to end: Index) -> I
}

----Swift.(file).RandomAccessCollection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)
extension RandomAccessCollection  {
  public func index(
    _ i: Index, offsetBy distance: Int, limitedBy limit: Index
  ) -> Index? {
    // FIXME: swift-3-indexing-model: tests.
    let l = self.distance(from: i, to: limit)
    if distance > 0 ? l >= 0 && l < distance : l <= 0 && distance < l {
      return nil
    }
    return index(i, offsetBy: distance)
  }
}

----Swift.(file).RandomAccessCollection.indices
extension RandomAccessCollection
where Index : Strideable, 
      Index.Stride == Int,
      Indices == Range<Index>  {
  public var indices: Range<Index> {
    return startIndex..<endIndex
  }
}

----Swift.(file).RandomAccessCollection.index(after:Self.Index)
extension RandomAccessCollection
where Index : Strideable, 
      Index.Stride == Int,
      Indices == Range<Index>  {
  public func index(after i: Index) -> Index {
    // FIXME: swift-3-indexing-model: tests for the trap.
    _failEarlyRangeCheck(
      i, bounds: Range(uncheckedBounds: (startIndex, endIndex)))
    return i.advanced(by: 1)
  }
}

----Swift.(file).RandomAccessCollection.index(before:Self.Index)
extension RandomAccessCollection
where Index : Strideable, 
      Index.Stride == Int,
      Indices == Range<Index>  {
  public func index(before i: Index) -> Index {
    let result = i.advanced(by: -1)
    // FIXME: swift-3-indexing-model: tests for the trap.
    _failEarlyRangeCheck(
      result, bounds: Range(uncheckedBounds: (startIndex, endIndex)))
    return result
  }
}

----Swift.(file).RandomAccessCollection.index(_:Self.Index,offsetBy:Self.Index.Stride)
extension RandomAccessCollection
where Index : Strideable, 
      Index.Stride == Int,
      Indices == Range<Index>  {
  public func index(_ i: Index, offsetBy distance: Index.Stride) -> Index {
    let result = i.advanced(by: distance)
    // This range check is not precise, tighter bounds exist based on `n`.
    // Unfortunately, we would need to perform index manipulation to
    // compute those bounds, which is probably too slow in the general
    // case.
    // FIXME: swift-3-indexing-model: tests for the trap.
    _failEarlyRangeCheck(
      result, bounds: ClosedRange(uncheckedBounds: (startIndex, endIndex)))
    return result
  }
}

----Swift.(file).RandomAccessCollection.distance(from:Self.Index,to:Self.Index)
extension RandomAccessCollection
where Index : Strideable, 
      Index.Stride == Int,
      Indices == Range<Index>  {
  public func distance(from start: Index, to end: Index) -> Index.Stride {
    // FIXME: swift-3-indexing-model: tests for traps.
    _failEarlyRangeCheck(
      start, bounds: ClosedRange(uncheckedBounds: (startIndex, endIndex)))
    _failEarlyRangeCheck(
      end, bounds: ClosedRange(uncheckedBounds: (startIndex, endIndex)))
    return start.distance(to: end)
  }
}

----Swift.(file).RangeExpression.Bound
extension RangeExpression {
  associatedtype Bound: C
}

----Swift.(file).RangeExpression.relative(to:C)
extension RangeExpression {
  func relative<C: Collection>(
    to collection: C
  ) -> Range<Bound> where C.Index == B
}

----Swift.(file).RangeExpression.contains(_:Self.Bound)
extension RangeExpression {
  func contains(_ element: Bound) -> B
}

----Swift.(file).RangeExpression.~=infix(_:Self,_:Self.Bound)
extension RangeExpression  {
  public static func ~= (pattern: Self, value: Bound) -> Bool {
    return pattern.contains(value)
  }
}

----Swift.(file).Range.lowerBound
extension Range {
  public let l
}

----Swift.(file).Range.upperBound
extension Range {
  public let u
}

----Swift.(file).Range.init(uncheckedBounds:(lower: Bound, upper: Bound))
extension Range {
  public init(uncheckedBounds bounds: (lower: Bound, upper: Bound)) {
    self.lowerBound = bounds.lower
    self.upperBound = bounds.upper
  }
}

----Swift.(file).Range.contains(_:Bound)
extension Range {
  public func contains(_ element: Bound) -> Bool {
    return lowerBound <= element && element < upperBound
  }
}

----Swift.(file).Range.isEmpty
extension Range {
  public var isEmpty: Bool {
    return lowerBound == upperBound
  }
}

----Swift.(file).Range.Element
extension Range: Sequence
where Bound: Strideable, Bound.Stride : SignedInteger  {
  public typealias Element = B
}

----Swift.(file).Range.Iterator
extension Range: Sequence
where Bound: Strideable, Bound.Stride : SignedInteger  {
  public typealias Iterator = IndexingIterator<Range<Bound>>
}

----Swift.(file).Range.Index
extension Range: Collection, BidirectionalCollection, RandomAccessCollection
where Bound : Strideable, Bound.Stride : SignedInteger
 {
  public typealias Index = B
}

----Swift.(file).Range.Indices
extension Range: Collection, BidirectionalCollection, RandomAccessCollection
where Bound : Strideable, Bound.Stride : SignedInteger
 {
  public typealias Indices = Range<Bound>
}

----Swift.(file).Range.SubSequence
extension Range: Collection, BidirectionalCollection, RandomAccessCollection
where Bound : Strideable, Bound.Stride : SignedInteger
 {
  public typealias SubSequence = Range<Bound>
}

----Swift.(file).Range.startIndex
extension Range: Collection, BidirectionalCollection, RandomAccessCollection
where Bound : Strideable, Bound.Stride : SignedInteger
 {
  public var startIndex: Index { return lowerBound }
}

----Swift.(file).Range.endIndex
extension Range: Collection, BidirectionalCollection, RandomAccessCollection
where Bound : Strideable, Bound.Stride : SignedInteger
 {
  public var endIndex: Index { return upperBound }
}

----Swift.(file).Range.index(after:Range<Bound>.Index)
extension Range: Collection, BidirectionalCollection, RandomAccessCollection
where Bound : Strideable, Bound.Stride : SignedInteger
 {
  public func index(after i: Index) -> Index {
    _failEarlyRangeCheck(i, bounds: startIndex..<endIndex)

    return i.advanced(by: 1)
  }
}

----Swift.(file).Range.index(before:Range<Bound>.Index)
extension Range: Collection, BidirectionalCollection, RandomAccessCollection
where Bound : Strideable, Bound.Stride : SignedInteger
 {
  public func index(before i: Index) -> Index {
    _precondition(i > lowerBound)
    _precondition(i <= upperBound)

    return i.advanced(by: -1)
  }
}

----Swift.(file).Range.index(_:Range<Bound>.Index,offsetBy:Int)
extension Range: Collection, BidirectionalCollection, RandomAccessCollection
where Bound : Strideable, Bound.Stride : SignedInteger
 {
  public func index(_ i: Index, offsetBy n: Int) -> Index {
    let r = i.advanced(by: numericCast(n))
    _precondition(r >= lowerBound)
    _precondition(r <= upperBound)
    return r
  }
}

----Swift.(file).Range.distance(from:Range<Bound>.Index,to:Range<Bound>.Index)
extension Range: Collection, BidirectionalCollection, RandomAccessCollection
where Bound : Strideable, Bound.Stride : SignedInteger
 {
  public func distance(from start: Index, to end: Index) -> Int {
    return numericCast(start.distance(to: end))
  }
}

----Swift.(file).Range.subscript(_:Range<Range<Bound>.Index>)
extension Range: Collection, BidirectionalCollection, RandomAccessCollection
where Bound : Strideable, Bound.Stride : SignedInteger
 {
  public subscript(bounds: Range<Index>) -> Range<Bound> {
    return bounds
  }
}

----Swift.(file).Range.indices
extension Range: Collection, BidirectionalCollection, RandomAccessCollection
where Bound : Strideable, Bound.Stride : SignedInteger
 {
  public var indices: Indices {
    return self
  }
}

----Swift.(file).Range.subscript(_:Range<Bound>.Index)
extension Range: Collection, BidirectionalCollection, RandomAccessCollection
where Bound : Strideable, Bound.Stride : SignedInteger
 {
  public subscript(position: Index) -> Element {
    // FIXME: swift-3-indexing-model: tests for the range check.
    _debugPrecondition(self.contains(position), "Index out of range")
    return position
  }
}

----Swift.(file).Range.init(_:ClosedRange<Bound>)
extension Range where Bound: Strideable, Bound.Stride : SignedInteger  {
  public init(_ other: ClosedRange<Bound>) {
    let upperBound = other.upperBound.advanced(by: 1)
    self.init(uncheckedBounds: (lower: other.lowerBound, upper: upperBound))
  }
}

----Swift.(file).Range.relative(to:C)
extension Range: RangeExpression  {
  public func relative<C: Collection>(to collection: C) -> Range<Bound>
  where C.Index == Bound {
    return Range(uncheckedBounds: (lower: lowerBound, upper: upperBound))
  }
}

----Swift.(file).Range.clamped(to:Range<Bound>)
extension Range  {
  public func clamped(to limits: Range) -> Range {
    let lower =         
      limits.lowerBound > self.lowerBound ? limits.lowerBound
          : limits.upperBound < self.lowerBound ? limits.upperBound
          : self.lowerBound
    let upper =
      limits.upperBound < self.upperBound ? limits.upperBound
          : limits.lowerBound > self.upperBound ? limits.lowerBound
          : self.upperBound
    return Range(uncheckedBounds: (lower: lower, upper: upper))
  }
}

----Swift.(file).Range.description
extension Range : CustomStringConvertible  {
  public var description: String {
    return "\(lowerBound)..<\(upperBound)"
  }
}

----Swift.(file).Range.debugDescription
extension Range : CustomDebugStringConvertible  {
  public var debugDescription: String {
    return "Range(\(String(reflecting: lowerBound))"
    + "..<\(String(reflecting: upperBound)))"
  }
}

----Swift.(file).Range.customMirror
extension Range : CustomReflectable  {
  public var customMirror: Mirror {
    return Mirror(
      self, children: ["lowerBound": lowerBound, "upperBound": upperBound])
  }
}

----Swift.(file).Range.==infix(_:Range<Bound>,_:Range<Bound>)
extension Range: Equatable  {
  public static func == (lhs: Range<Bound>, rhs: Range<Bound>) -> Bool {
    return
      lhs.lowerBound == rhs.lowerBound &&
      lhs.upperBound == rhs.upperBound
  }
}

----Swift.(file).Range.hash(into:Hasher)
extension Range: Hashable where Bound: Hashable  {
  public func hash(into hasher: inout Hasher) {
    hasher.combine(lowerBound)
    hasher.combine(upperBound)
  }
}

----Swift.(file).PartialRangeUpTo.upperBound
extension PartialRangeUpTo {
  public let u
}

----Swift.(file).PartialRangeUpTo.init(_:Bound)
extension PartialRangeUpTo {
  public init(_ upperBound: Bound) { self.upperBound = upperBound }
}

----Swift.(file).PartialRangeUpTo.relative(to:C)
extension PartialRangeUpTo: RangeExpression  {
  public func relative<C: Collection>(to collection: C) -> Range<Bound>
  where C.Index == Bound {
    return collection.startIndex..<self.upperBound
  }
}

----Swift.(file).PartialRangeUpTo.contains(_:Bound)
extension PartialRangeUpTo: RangeExpression  {
  public func contains(_ element: Bound) -> Bool {
    return element < upperBound
  }
}

----Swift.(file).PartialRangeThrough.upperBound
extension PartialRangeThrough {
  public let u
}

----Swift.(file).PartialRangeThrough.init(_:Bound)
extension PartialRangeThrough {
  public init(_ upperBound: Bound) { self.upperBound = upperBound }
}

----Swift.(file).PartialRangeThrough.relative(to:C)
extension PartialRangeThrough: RangeExpression  {
  public func relative<C: Collection>(to collection: C) -> Range<Bound>
  where C.Index == Bound {
    return collection.startIndex..<collection.index(after: self.upperBound)
  }
}

----Swift.(file).PartialRangeThrough.contains(_:Bound)
extension PartialRangeThrough: RangeExpression  {
  public func contains(_ element: Bound) -> Bool {
    return element <= upperBound
  }
}

----Swift.(file).PartialRangeFrom.lowerBound
extension PartialRangeFrom {
  public let l
}

----Swift.(file).PartialRangeFrom.init(_:Bound)
extension PartialRangeFrom {
  public init(_ lowerBound: Bound) { self.lowerBound = lowerBound }
}

----Swift.(file).PartialRangeFrom.relative(to:C)
extension PartialRangeFrom: RangeExpression  {
  public func relative<C: Collection>(
    to collection: C
  ) -> Range<Bound> where C.Index == Bound {
    return self.lowerBound..<collection.endIndex
  }
}

----Swift.(file).PartialRangeFrom.contains(_:Bound)
extension PartialRangeFrom: RangeExpression  {
  public func contains(_ element: Bound) -> Bool {
    return lowerBound <= element
  }
}

----Swift.(file).PartialRangeFrom.Element
extension PartialRangeFrom: Sequence
  where Bound : Strideable, Bound.Stride : SignedInteger
 {
  public typealias Element = B
}

----Swift.(file).PartialRangeFrom.Iterator.init(_current:Bound)
extension PartialRangeFrom.Iterator {
    public init(_current: Bound) { self._current = _current }
}

----Swift.(file).PartialRangeFrom.Iterator.next()
extension PartialRangeFrom.Iterator {
    public mutating func next() -> Bound? {
      defer { _current = _current.advanced(by: 1) }
      return _current
    }
}

----Swift.(file).PartialRangeFrom.makeIterator()
extension PartialRangeFrom: Sequence
  where Bound : Strideable, Bound.Stride : SignedInteger
 {
  public __consuming func makeIterator() -> Iterator { 
    return Iterator(_current: lowerBound) 
  }
}

----Swift.(file).Comparable...<infix(_:Self,_:Self)
extension Comparable  {
  public static func ..< (minimum: Self, maximum: Self) -> Range<Self> {
    _precondition(minimum <= maximum,
      "Can't form Range with upperBound < lowerBound")
    return Range(uncheckedBounds: (lower: minimum, upper: maximum))
  }
}

----Swift.(file).Comparable...<prefix(_:Self)
extension Comparable  {
  public static prefix func ..< (maximum: Self) -> PartialRangeUpTo<Self> {
    return PartialRangeUpTo(maximum)
  }
}

----Swift.(file).Comparable....prefix(_:Self)
extension Comparable  {
  public static prefix func ... (maximum: Self) -> PartialRangeThrough<Self> {
    return PartialRangeThrough(maximum)
  }
}

----Swift.(file).Comparable....postfix(_:Self)
extension Comparable  {
  public static postfix func ... (minimum: Self) -> PartialRangeFrom<Self> {
    return PartialRangeFrom(minimum)
  }
}

----Swift.(file).UnboundedRange_....postfix(_:UnboundedRange_)
extension UnboundedRange_... {
  public static postfix func ... (_: UnboundedRange_) -> () {
    // This function is uncallable
  }
}

----Swift.(file).UnboundedRange
public typealias UnboundedRange = (UnboundedRange_)->()

----Swift.(file).Collection.subscript(_:R)
extension Collection  {
  public subscript<R: RangeExpression>(r: R)
  -> SubSequence where R.Bound == Index {
    return self[r.relative(to: self)]
  }
}

----Swift.(file).Collection.subscript(_:(UnboundedRange_) -> ())
extension Collection  {
  public subscript(x: UnboundedRange) -> SubSequence {
    return self[startIndex...]
  }
}

----Swift.(file).MutableCollection.subscript(_:R)
extension MutableCollection  {
  public subscript<R: RangeExpression>(r: R) -> SubSequence
  where R.Bound == Index {
    get {
      return self[r.relative(to: self)]
    }
    set {
      self[r.relative(to: self)] = newValue
    }
  }
}

----Swift.(file).MutableCollection.subscript(_:(UnboundedRange_) -> ())
extension MutableCollection  {
  public subscript(x: UnboundedRange) -> SubSequence {
    get {
      return self[startIndex...]
    }
    set {
      self[startIndex...] = newValue
    }
  }
}

----Swift.(file).Range.overlaps(_:Range<Bound>)
extension Range  {
  public func overlaps(_ other: Range<Bound>) -> Bool {
    return (!other.isEmpty && self.contains(other.lowerBound))
        || (!self.isEmpty && other.contains(self.lowerBound))
  }
}

----Swift.(file).Range.overlaps(_:ClosedRange<Bound>)
extension Range  {
  public func overlaps(_ other: ClosedRange<Bound>) -> Bool {
    return self.contains(other.lowerBound)
        || (!self.isEmpty && other.contains(self.lowerBound))
  }
}

----Swift.(file).CountableRange
public typealias CountableRange<Bound: Strideable> = Range<Bound>
  where Bound.Stride : S

----Swift.(file).CountablePartialRangeFrom
public typealias CountablePartialRangeFrom<Bound: Strideable> = PartialRangeFrom<Bound>
  where Bound.Stride : S

----Swift.(file).RangeReplaceableCollection.SubSequence
extension RangeReplaceableCollection {
  override associatedtype S
}

----Swift.(file).RangeReplaceableCollection.init()
extension RangeReplaceableCollection {
  init()
}

----Swift.(file).RangeReplaceableCollection.replaceSubrange(_:Range<Self.Index>,with:C)
extension RangeReplaceableCollection {
  mutating func replaceSubrange<C>(
    _ subrange: Range<Index>,
    with newElements: __owned C
  ) where C : Collection, C.Element == E
}

----Swift.(file).RangeReplaceableCollection.reserveCapacity(_:Int)
extension RangeReplaceableCollection {
  mutating func reserveCapacity(_ n: Int)
}

----Swift.(file).RangeReplaceableCollection.init(repeating:Self.Element,count:Int)
extension RangeReplaceableCollection {
  init(repeating repeatedValue: Element, count: Int)
}

----Swift.(file).RangeReplaceableCollection.init(_:S)
extension RangeReplaceableCollection {
  init<S : Sequence>(_ elements: S)
    where S.Element == E
}

----Swift.(file).RangeReplaceableCollection.append(_:Self.Element)
extension RangeReplaceableCollection {
  mutating func append(_ newElement: __owned Element)
}

----Swift.(file).RangeReplaceableCollection.append(contentsOf:S)
extension RangeReplaceableCollection {
  mutating func append<S : Sequence>(contentsOf newElements: __owned S)
    where S.Element == E
}

----Swift.(file).RangeReplaceableCollection.insert(_:Self.Element,at:Self.Index)
extension RangeReplaceableCollection {
  mutating func insert(_ newElement: __owned Element, at i: Index)
}

----Swift.(file).RangeReplaceableCollection.insert(contentsOf:S,at:Self.Index)
extension RangeReplaceableCollection {
  mutating func insert<S : Collection>(contentsOf newElements: __owned S, at i: Index)
    where S.Element == E
}

----Swift.(file).RangeReplaceableCollection.remove(at:Self.Index)
extension RangeReplaceableCollection {
  mutating func remove(at i: Index) -> E
}

----Swift.(file).RangeReplaceableCollection.removeSubrange(_:Range<Self.Index>)
extension RangeReplaceableCollection {
  mutating func removeSubrange(_ bounds: Range<Index>)
}

----Swift.(file).RangeReplaceableCollection.removeFirst()
extension RangeReplaceableCollection {
  mutating func removeFirst() -> E
}

----Swift.(file).RangeReplaceableCollection.removeFirst(_:Int)
extension RangeReplaceableCollection {
  mutating func removeFirst(_ k: Int)
}

----Swift.(file).RangeReplaceableCollection.removeAll(keepingCapacity:Bool)
extension RangeReplaceableCollection {
  mutating func removeAll(keepingCapacity keepCapacity: Bool /*= false*/)
}

----Swift.(file).RangeReplaceableCollection.removeAll(where:(Self.Element) throws -> Bool)
extension RangeReplaceableCollection {
  mutating func removeAll(
    where shouldBeRemoved: (Element) throws -> Bool) r
}

----Swift.(file).RangeReplaceableCollection.subscript(_:Self.Index)
extension RangeReplaceableCollection {
  override subscript(bounds: Index) -> Element { get }
}

----Swift.(file).RangeReplaceableCollection.subscript(_:Range<Self.Index>)
extension RangeReplaceableCollection {
  override subscript(bounds: Range<Index>) -> SubSequence { get }
}

----Swift.(file).RangeReplaceableCollection.init(repeating:Self.Element,count:Int)
extension RangeReplaceableCollection  {
  public init(repeating repeatedValue: Element, count: Int) {
    self.init()
    if count != 0 {
      let elements = Repeated(_repeating: repeatedValue, count: count)
      append(contentsOf: elements)
    }
  }
}

----Swift.(file).RangeReplaceableCollection.init(_:S)
extension RangeReplaceableCollection  {
  public init<S : Sequence>(_ elements: S)
    where S.Element == Element {
    self.init()
    append(contentsOf: elements)
  }
}

----Swift.(file).RangeReplaceableCollection.append(_:Self.Element)
extension RangeReplaceableCollection  {
  public mutating func append(_ newElement: __owned Element) {
    insert(newElement, at: endIndex)
  }
}

----Swift.(file).RangeReplaceableCollection.append(contentsOf:S)
extension RangeReplaceableCollection  {
  public mutating func append<S : Sequence>(contentsOf newElements: __owned S)
    where S.Element == Element {

    let approximateCapacity = self.count +
      numericCast(newElements.underestimatedCount)
    self.reserveCapacity(approximateCapacity)
    for element in newElements {
      append(element)
    }
  }
}

----Swift.(file).RangeReplaceableCollection.insert(_:Self.Element,at:Self.Index)
extension RangeReplaceableCollection  {
  public mutating func insert(
    _ newElement: __owned Element, at i: Index
  ) {
    replaceSubrange(i..<i, with: CollectionOfOne(newElement))
  }
}

----Swift.(file).RangeReplaceableCollection.insert(contentsOf:C,at:Self.Index)
extension RangeReplaceableCollection  {
  public mutating func insert<C : Collection>(
    contentsOf newElements: __owned C, at i: Index
  ) where C.Element == Element {
    replaceSubrange(i..<i, with: newElements)
  }
}

----Swift.(file).RangeReplaceableCollection.remove(at:Self.Index)
extension RangeReplaceableCollection  {
  public mutating func remove(at position: Index) -> Element {
    _precondition(!isEmpty, "Can't remove from an empty collection")
    let result: Element = self[position]
    replaceSubrange(position..<index(after: position), with: EmptyCollection())
    return result
  }
}

----Swift.(file).RangeReplaceableCollection.removeSubrange(_:Range<Self.Index>)
extension RangeReplaceableCollection  {
  public mutating func removeSubrange(_ bounds: Range<Index>) {
    replaceSubrange(bounds, with: EmptyCollection())
  }
}

----Swift.(file).RangeReplaceableCollection.removeFirst(_:Int)
extension RangeReplaceableCollection  {
  public mutating func removeFirst(_ k: Int) {
    if k == 0 { return }
    _precondition(k >= 0, "Number of elements to remove should be non-negative")
    _precondition(count >= k,
      "Can't remove more items from a collection than it has")
    let end = index(startIndex, offsetBy: k)
    removeSubrange(startIndex..<end)
  }
}

----Swift.(file).RangeReplaceableCollection.removeFirst()
extension RangeReplaceableCollection  {
  public mutating func removeFirst() -> Element {
    _precondition(!isEmpty,
      "Can't remove first element from an empty collection")
    let firstElement = first!
    removeFirst(1)
    return firstElement
  }
}

----Swift.(file).RangeReplaceableCollection.removeAll(keepingCapacity:Bool)
extension RangeReplaceableCollection  {
  public mutating func removeAll(keepingCapacity keepCapacity: Bool = false) {
    if !keepCapacity {
      self = Self()
    }
    else {
      replaceSubrange(startIndex..<endIndex, with: EmptyCollection())
    }
  }
}

----Swift.(file).RangeReplaceableCollection.reserveCapacity(_:Int)
extension RangeReplaceableCollection  {
  public mutating func reserveCapacity(_ n: Int) {}
}

----Swift.(file).RangeReplaceableCollection.removeFirst()
extension RangeReplaceableCollection where SubSequence == Self  {
  public mutating func removeFirst() -> Element {
    _precondition(!isEmpty, "Can't remove items from an empty collection")
    let element = first!
    self = self[index(after: startIndex)..<endIndex]
    return element
  }
}

----Swift.(file).RangeReplaceableCollection.removeFirst(_:Int)
extension RangeReplaceableCollection where SubSequence == Self  {
  public mutating func removeFirst(_ k: Int) {
    if k == 0 { return }
    _precondition(k >= 0, "Number of elements to remove should be non-negative")
    _precondition(count >= k,
      "Can't remove more items from a collection than it contains")
    self = self[index(startIndex, offsetBy: k)..<endIndex]
  }
}

----Swift.(file).RangeReplaceableCollection.replaceSubrange(_:R,with:C)
extension RangeReplaceableCollection  {
  public mutating func replaceSubrange<C: Collection, R: RangeExpression>(
    _ subrange: R,
    with newElements: __owned C
  ) where C.Element == Element, R.Bound == Index {
    self.replaceSubrange(subrange.relative(to: self), with: newElements)
  }
}

----Swift.(file).RangeReplaceableCollection.removeSubrange(_:R)
extension RangeReplaceableCollection  {
  public mutating func removeSubrange<R: RangeExpression>(
    _ bounds: R
  ) where R.Bound == Index  {
    removeSubrange(bounds.relative(to: self))
  }
}

----Swift.(file).RangeReplaceableCollection.popLast()
extension RangeReplaceableCollection where Self : BidirectionalCollection  {
  public mutating func popLast() -> Element? {
    if isEmpty { return nil }
    // duplicate of removeLast logic below, to avoid redundant precondition
    if let result = _customRemoveLast() { return result }
    return remove(at: index(before: endIndex))
  }
}

----Swift.(file).RangeReplaceableCollection.removeLast()
extension RangeReplaceableCollection where Self : BidirectionalCollection  {
  public mutating func removeLast() -> Element {
    _precondition(!isEmpty, "Can't remove last element from an empty collection")
    // NOTE if you change this implementation, change popLast above as well
    // AND change the tie-breaker implementations in the next extension
    if let result = _customRemoveLast() { return result }
    return remove(at: index(before: endIndex))
  }
}

----Swift.(file).RangeReplaceableCollection.removeLast(_:Int)
extension RangeReplaceableCollection where Self : BidirectionalCollection  {
  public mutating func removeLast(_ k: Int) {
    if k == 0 { return }
    _precondition(k >= 0, "Number of elements to remove should be non-negative")
    _precondition(count >= k,
      "Can't remove more items from a collection than it contains")
    if _customRemoveLast(k) {
      return
    }
    let end = endIndex
    removeSubrange(index(end, offsetBy: -k)..<end)
  }
}

----Swift.(file).RangeReplaceableCollection.popLast()
extension RangeReplaceableCollection
where Self : BidirectionalCollection, SubSequence == Self  {
  public mutating func popLast() -> Element? {
    if isEmpty { return nil }
    // duplicate of removeLast logic below, to avoid redundant precondition
    if let result = _customRemoveLast() { return result }
    return remove(at: index(before: endIndex))
  }
}

----Swift.(file).RangeReplaceableCollection.removeLast()
extension RangeReplaceableCollection
where Self : BidirectionalCollection, SubSequence == Self  {
  public mutating func removeLast() -> Element {
    _precondition(!isEmpty, "Can't remove last element from an empty collection")
    // NOTE if you change this implementation, change popLast above as well
    if let result = _customRemoveLast() { return result }
    return remove(at: index(before: endIndex))
  }
}

----Swift.(file).RangeReplaceableCollection.removeLast(_:Int)
extension RangeReplaceableCollection
where Self : BidirectionalCollection, SubSequence == Self  {
  public mutating func removeLast(_ k: Int) {
    if k == 0 { return }
    _precondition(k >= 0, "Number of elements to remove should be non-negative")
    _precondition(count >= k,
      "Can't remove more items from a collection than it contains")
    if _customRemoveLast(k) {
      return
    }
    let end = endIndex
    removeSubrange(index(end, offsetBy: -k)..<end)
  }
}

----Swift.(file).RangeReplaceableCollection.+infix(_:Self,_:Other)
extension RangeReplaceableCollection  {
  public static func + <
    Other : Sequence
  >(lhs: Self, rhs: Other) -> Self
  where Element == Other.Element {
    var lhs = lhs
    // FIXME: what if lhs is a reference type?  This will mutate it.
    lhs.append(contentsOf: rhs)
    return lhs
  }
}

----Swift.(file).RangeReplaceableCollection.+infix(_:Other,_:Self)
extension RangeReplaceableCollection  {
  public static func + <
    Other : Sequence
  >(lhs: Other, rhs: Self) -> Self
  where Element == Other.Element {
    var result = Self()
    result.reserveCapacity(rhs.count + numericCast(lhs.underestimatedCount))
    result.append(contentsOf: lhs)
    result.append(contentsOf: rhs)
    return result
  }
}

----Swift.(file).RangeReplaceableCollection.+=infix(_:Self,_:Other)
extension RangeReplaceableCollection  {
  public static func += <
    Other : Sequence
  >(lhs: inout Self, rhs: Other)
  where Element == Other.Element {
    lhs.append(contentsOf: rhs)
  }
}

----Swift.(file).RangeReplaceableCollection.+infix(_:Self,_:Other)
extension RangeReplaceableCollection  {
  public static func + <
    Other : RangeReplaceableCollection
  >(lhs: Self, rhs: Other) -> Self
  where Element == Other.Element {
    var lhs = lhs
    // FIXME: what if lhs is a reference type?  This will mutate it.
    lhs.append(contentsOf: rhs)
    return lhs
  }
}

----Swift.(file).RangeReplaceableCollection.filter(_:(Self.Element) throws -> Bool)
extension RangeReplaceableCollection  {
  public __consuming func filter(
    _ isIncluded: (Element) throws -> Bool
  ) rethrows -> Self {
    return try Self(self.lazy.filter(isIncluded))
  }
}

----Swift.(file).RangeReplaceableCollection.removeAll(where:(Self.Element) throws -> Bool)
extension RangeReplaceableCollection where Self: MutableCollection  {
  public mutating func removeAll(
    where shouldBeRemoved: (Element) throws -> Bool
  ) rethrows {
    let suffixStart = try _halfStablePartition(isSuffixElement: shouldBeRemoved)
    removeSubrange(suffixStart...)
  }
}

----Swift.(file).RangeReplaceableCollection.removeAll(where:(Self.Element) throws -> Bool)
extension RangeReplaceableCollection  {
  public mutating func removeAll(
    where shouldBeRemoved: (Element) throws -> Bool
  ) rethrows {
    // FIXME: Switch to using RRC.filter once stdlib is compiled for 4.0
    // self = try filter { try !predicate($0) }
    self = try Self(self.lazy.filter { try !shouldBeRemoved($0) })
  }
}

----Swift.(file).NameFreeFunc
internal typealias NameFreeFunc = @convention(c) (UnsafePointer<CChar>?) -> V

----Swift.(file).getChild(of:T,type:Any.Type,index:Int)
internal func getChild<T>(of value: T, type: Any.Type, index: Int) -> (label: String?, value: Any) {
  var nameC: UnsafePointer<CChar>? = nil
  var freeFunc: NameFreeFunc? = nil
  
  let value = _getChild(of: value, type: type, index: index, outName: &nameC, outFreeFunc: &freeFunc)
  
  let name = nameC.flatMap({ String(validatingUTF8: $0) })
  freeFunc?(nameC)
  return (name, value)
}

----Swift.(file).Mirror.init(internalReflecting:Any,subjectType:Any.Type?,customAncestor:Mirror?)
extension Mirror  {
  internal init(internalReflecting subject: Any,
              subjectType: Any.Type? = nil,
              customAncestor: Mirror? = nil)
  {
    let subjectType = subjectType ?? _getNormalizedType(subject, type: type(of: subject))
    
    let childCount = _getChildCount(subject, type: subjectType)
    let children = (0 ..< childCount).lazy.map({
      getChild(of: subject, type: subjectType, index: $0)
    })
    self.children = Children(children)
    
    self._makeSuperclassMirror = {
      guard let subjectClass = subjectType as? AnyClass,
            let superclass = _getSuperclass(subjectClass) else {
        return nil
      }
      
      // Handle custom ancestors. If we've hit the custom ancestor's subject type,
      // or descendants are suppressed, return it. Otherwise continue reflecting.
      if let customAncestor = customAncestor {
        if superclass == customAncestor.subjectType {
          return customAncestor
        }
        if customAncestor._defaultDescendantRepresentation == .suppressed {
          return customAncestor
        }
      }
      return Mirror(internalReflecting: subject,
                    subjectType: superclass,
                    customAncestor: customAncestor)
    }
    
    let rawDisplayStyle = _getDisplayStyle(subject)
    switch UnicodeScalar(Int(rawDisplayStyle)) {
    case "c": self.displayStyle = .class
    case "e": self.displayStyle = .enum
    case "s": self.displayStyle = .struct
    case "t": self.displayStyle = .tuple
    case "\0": self.displayStyle = nil
    default: preconditionFailure("Unknown raw display style '\(rawDisplayStyle)'")
    }
    
    self.subjectType = subjectType
    self._defaultDescendantRepresentation = .generated
  }
}

----Swift.(file).Mirror.quickLookObject(_:Any)
extension Mirror  {
  internal static func quickLookObject(_ subject: Any) -> _PlaygroundQuickLook? {
#if _runtime(_ObjC)
    let object = _getQuickLookObject(subject)
    return object.flatMap(_getClassPlaygroundQuickLook)
#else
    return nil
#endif
  }
}

----Swift.(file).Repeated.count
extension Repeated {
  public let c
}

----Swift.(file).Repeated.repeatedValue
extension Repeated {
  public let r
}

----Swift.(file).Repeated.init(count:Int,repeatedValue:Element)
extension Repeated {
public struct R
}

----Swift.(file).Repeated.Indices
extension Repeated: RandomAccessCollection  {
  public typealias Indices = Range<Int>
}

----Swift.(file).Repeated.Index
extension Repeated: RandomAccessCollection  {
  public typealias Index = I
}

----Swift.(file).Repeated.init(_repeating:Element,count:Int)
extension Repeated: RandomAccessCollection  {
  internal init(_repeating repeatedValue: Element, count: Int) {
    _precondition(count >= 0, "Repetition count should be non-negative")
    self.count = count
    self.repeatedValue = repeatedValue
  }
}

----Swift.(file).Repeated.startIndex
extension Repeated: RandomAccessCollection  {
  public var startIndex: Index {
    return 0
  }
}

----Swift.(file).Repeated.endIndex
extension Repeated: RandomAccessCollection  {
  public var endIndex: Index {
    return count
  }
}

----Swift.(file).Repeated.subscript(_:Int)
extension Repeated: RandomAccessCollection  {
  public subscript(position: Int) -> Element {
    _precondition(position >= 0 && position < count, "Index out of range")
    return repeatedValue
  }
}

----Swift.(file).repeatElement(_:T,count:Int)
public func repeatElement<T>(_ element: T, count n: Int) -> Repeated<T> {
  return Repeated(_repeating: element, count: n)
}

----Swift.(file).Result.success
extension Result {
  case success(Success)
}

----Swift.(file).Result.failure
extension Result {
  case failure(Failure)
}

----Swift.(file).Result.map(_:(Success) -> NewSuccess)
extension Result {
  public func map<NewSuccess>(
    _ transform: (Success) -> NewSuccess
  ) -> Result<NewSuccess, Failure> {
    switch self {
    case let .success(success):
      return .success(transform(success))
    case let .failure(failure):
      return .failure(failure)
    }
  }
}

----Swift.(file).Result.mapError(_:(Failure) -> NewFailure)
extension Result {
  public func mapError<NewFailure>(
    _ transform: (Failure) -> NewFailure
  ) -> Result<Success, NewFailure> {
    switch self {
    case let .success(success):
      return .success(success)
    case let .failure(failure):
      return .failure(transform(failure))
    }
  }
}

----Swift.(file).Result.flatMap(_:(Success) -> Result<NewSuccess, Failure>)
extension Result {
  public func flatMap<NewSuccess>(
    _ transform: (Success) -> Result<NewSuccess, Failure>
  ) -> Result<NewSuccess, Failure> {
    switch self {
    case let .success(success):
      return transform(success)
    case let .failure(failure):
      return .failure(failure)
    }
  }
}

----Swift.(file).Result.flatMapError(_:(Failure) -> Result<Success, NewFailure>)
extension Result {
  public func flatMapError<NewFailure>(
    _ transform: (Failure) -> Result<Success, NewFailure>
  ) -> Result<Success, NewFailure> {
    switch self {
    case let .success(success):
      return .success(success)
    case let .failure(failure):
      return transform(failure)
    }
  }
}

----Swift.(file).Result.get()
extension Result {
  public func get() throws -> Success {
    switch self {
    case let .success(success):
      return success
    case let .failure(failure):
      throw failure
    }
  }
}

----Swift.(file).Result.init(catching:() throws -> Success)
extension Result where Failure == Swift.Error  {
  public init(catching body: () throws -> Success) {
    do {
      self = .success(try body())
    } catch {
      self = .failure(error)
    }
  }
}

----Swift.(file).MutableCollection.reverse()
extension MutableCollection where Self: BidirectionalCollection  {
  public mutating func reverse() {
    if isEmpty { return }
    var f = startIndex
    var l = index(before: endIndex)
    while f < l {
      swapAt(f, l)
      formIndex(after: &f)
      formIndex(before: &l)
    }
  }
}

----Swift.(file).ReversedCollection.init(_base:Base)
extension ReversedCollection {
  internal init(_base: Base) {
    self._base = _base
  }
}

----Swift.(file).ReversedCollection.Iterator.init(_base:Base)
extension ReversedCollection.Iterator {
    init(_base: Base) {
      self._base = _base
      self._position = _base.endIndex
    }
}

----Swift.(file).ReversedCollection.Iterator.Element
extension ReversedCollection.Iterator: IteratorProtocol, Sequence  {
  public typealias Element = Base.E
}

----Swift.(file).ReversedCollection.Iterator.next()
extension ReversedCollection.Iterator: IteratorProtocol, Sequence  {
  public mutating func next() -> Element? {
    guard _fastPath(_position != _base.startIndex) else { return nil }
    _base.formIndex(before: &_position)
    return _base[_position]
  }
}

----Swift.(file).ReversedCollection.Element
extension ReversedCollection: Sequence  {
  public typealias Element = Base.E
}

----Swift.(file).ReversedCollection.makeIterator()
extension ReversedCollection: Sequence  {
  public __consuming func makeIterator() -> Iterator {
    return Iterator(_base: _base)
  }
}

----Swift.(file).ReversedCollection.Index.base
extension ReversedCollection.Index {
    public let b
}

----Swift.(file).ReversedCollection.Index.init(_:Base.Index)
extension ReversedCollection.Index {
    public init(_ base: Base.Index) {
      self.base = base
    }
}

----Swift.(file).ReversedCollection.Index.==infix(_:ReversedCollection<Base>.Index,_:ReversedCollection<Base>.Index)
extension ReversedCollection.Index: Comparable  {
  public static func == (
    lhs: ReversedCollection<Base>.Index,
    rhs: ReversedCollection<Base>.Index
  ) -> Bool {
    // Note ReversedIndex has inverted logic compared to base Base.Index
    return lhs.base == rhs.base
  }
}

----Swift.(file).ReversedCollection.Index.<infix(_:ReversedCollection<Base>.Index,_:ReversedCollection<Base>.Index)
extension ReversedCollection.Index: Comparable  {
  public static func < (
    lhs: ReversedCollection<Base>.Index,
    rhs: ReversedCollection<Base>.Index
  ) -> Bool {
    // Note ReversedIndex has inverted logic compared to base Base.Index
    return lhs.base > rhs.base
  }
}

----Swift.(file).ReversedCollection.Index.hash(into:Hasher)
extension ReversedCollection.Index: Hashable where Base.Index: Hashable  {
  public func hash(into hasher: inout Hasher) {
    hasher.combine(base)
  }
}

----Swift.(file).ReversedCollection.startIndex
extension ReversedCollection: BidirectionalCollection  {
  public var startIndex: Index {
    return Index(_base.endIndex)
  }
}

----Swift.(file).ReversedCollection.endIndex
extension ReversedCollection: BidirectionalCollection  {
  public var endIndex: Index {
    return Index(_base.startIndex)
  }
}

----Swift.(file).ReversedCollection.index(after:ReversedCollection<Base>.Index)
extension ReversedCollection: BidirectionalCollection  {
  public func index(after i: Index) -> Index {
    return Index(_base.index(before: i.base))
  }
}

----Swift.(file).ReversedCollection.index(before:ReversedCollection<Base>.Index)
extension ReversedCollection: BidirectionalCollection  {
  public func index(before i: Index) -> Index {
    return Index(_base.index(after: i.base))
  }
}

----Swift.(file).ReversedCollection.index(_:ReversedCollection<Base>.Index,offsetBy:Int)
extension ReversedCollection: BidirectionalCollection  {
  public func index(_ i: Index, offsetBy n: Int) -> Index {
    // FIXME: swift-3-indexing-model: `-n` can trap on Int.min.
    return Index(_base.index(i.base, offsetBy: -n))
  }
}

----Swift.(file).ReversedCollection.index(_:ReversedCollection<Base>.Index,offsetBy:Int,limitedBy:ReversedCollection<Base>.Index)
extension ReversedCollection: BidirectionalCollection  {
  public func index(
    _ i: Index, offsetBy n: Int, limitedBy limit: Index
  ) -> Index? {
    // FIXME: swift-3-indexing-model: `-n` can trap on Int.min.
    return _base.index(i.base, offsetBy: -n, limitedBy: limit.base)
                .map(Index.init)
  }
}

----Swift.(file).ReversedCollection.distance(from:ReversedCollection<Base>.Index,to:ReversedCollection<Base>.Index)
extension ReversedCollection: BidirectionalCollection  {
  public func distance(from start: Index, to end: Index) -> Int {
    return _base.distance(from: end.base, to: start.base)
  }
}

----Swift.(file).ReversedCollection.subscript(_:ReversedCollection<Base>.Index)
extension ReversedCollection: BidirectionalCollection  {
  public subscript(position: Index) -> Element {
    return _base[_base.index(before: position.base)]
  }
}

----Swift.(file).ReversedCollection.reversed()
extension ReversedCollection  {
  public __consuming func reversed() -> Base {
    return _base
  }
}

----Swift.(file).BidirectionalCollection.reversed()
extension BidirectionalCollection  {
  public __consuming func reversed() -> ReversedCollection<Self> {
    return ReversedCollection(_base: self)
  }
}

----Swift.(file).IteratorProtocol.Element
extension IteratorProtocol {
  associatedtype E
}

----Swift.(file).IteratorProtocol.next()
extension IteratorProtocol {
  mutating func next() -> Element?
}

----Swift.(file).Sequence.Element
extension Sequence {
  associatedtype E
}

----Swift.(file).Sequence.Iterator
extension Sequence {
  associatedtype Iterator : IteratorProtocol where Iterator.Element == E
}

----Swift.(file).Sequence.makeIterator()
extension Sequence {
  __consuming func makeIterator() -> I
}

----Swift.(file).Sequence.underestimatedCount
extension Sequence {
  var underestimatedCount: Int { get }
}

----Swift.(file).Sequence.withContiguousStorageIfAvailable(_:(UnsafeBufferPointer<Self.Element>) throws -> R)
extension Sequence {
  func withContiguousStorageIfAvailable<R>(
    _ body: (UnsafeBufferPointer<Element>) throws -> R
  ) rethrows -> R?
}

----Swift.(file).Sequence.makeIterator()
extension Sequence where Self.Iterator == Self  {
  public __consuming func makeIterator() -> Self {
    return self
  }
}

----Swift.(file).DropFirstSequence.init(_:Base,dropping:Int)
extension DropFirstSequence {
  public init(_ base: Base, dropping limit: Int) {
    _precondition(limit >= 0, 
      "Can't drop a negative number of elements from a sequence")
    _base = base
    _limit = limit
  }
}

----Swift.(file).DropFirstSequence.Element
extension DropFirstSequence: Sequence  {
  public typealias Element = Base.E
}

----Swift.(file).DropFirstSequence.Iterator
extension DropFirstSequence: Sequence  {
  public typealias Iterator = Base.I
}

----Swift.(file).DropFirstSequence.SubSequence
extension DropFirstSequence: Sequence  {
  public typealias SubSequence = AnySequence<Element>
}

----Swift.(file).DropFirstSequence.makeIterator()
extension DropFirstSequence: Sequence  {
  public __consuming func makeIterator() -> Iterator {
    var it = _base.makeIterator()
    var dropped = 0
    while dropped < _limit, it.next() != nil { dropped &+= 1 }
    return it
  }
}

----Swift.(file).DropFirstSequence.dropFirst(_:Int)
extension DropFirstSequence: Sequence  {
  public __consuming func dropFirst(_ k: Int) -> DropFirstSequence<Base> {
    // If this is already a _DropFirstSequence, we need to fold in
    // the current drop count and drop limit so no data is lost.
    //
    // i.e. [1,2,3,4].dropFirst(1).dropFirst(1) should be equivalent to
    // [1,2,3,4].dropFirst(2).
    return DropFirstSequence(_base, dropping: _limit + k)
  }
}

----Swift.(file).PrefixSequence.init(_:Base,maxLength:Int)
extension PrefixSequence {
  public init(_ base: Base, maxLength: Int) {
    _precondition(maxLength >= 0, "Can't take a prefix of negative length")
    _base = base
    _maxLength = maxLength
  }
}

----Swift.(file).PrefixSequence.Iterator.init(_:Base.Iterator,maxLength:Int)
extension PrefixSequence.Iterator {
    internal init(_ base: Base.Iterator, maxLength: Int) {
      _base = base
      _remaining = maxLength
    }
}

----Swift.(file).PrefixSequence.Iterator.Element
extension PrefixSequence.Iterator: IteratorProtocol  {
  public typealias Element = Base.E
}

----Swift.(file).PrefixSequence.Iterator.next()
extension PrefixSequence.Iterator: IteratorProtocol  {
  public mutating func next() -> Element? {
    if _remaining != 0 {
      _remaining &-= 1
      return _base.next()
    } else {
      return nil
    }
  }
}

----Swift.(file).PrefixSequence.makeIterator()
extension PrefixSequence: Sequence  {
  public __consuming func makeIterator() -> Iterator {
    return Iterator(_base.makeIterator(), maxLength: _maxLength)
  }
}

----Swift.(file).PrefixSequence.prefix(_:Int)
extension PrefixSequence: Sequence  {
  public __consuming func prefix(_ maxLength: Int) -> PrefixSequence<Base> {
    let length = Swift.min(maxLength, self._maxLength)
    return PrefixSequence(_base, maxLength: length)
  }
}

----Swift.(file).DropWhileSequence.Element
extension DropWhileSequence {
  public typealias Element = Base.E
}

----Swift.(file).DropWhileSequence.init(iterator:Base.Iterator,predicate:(Base.Element) throws -> Bool)
extension DropWhileSequence {
  internal init(iterator: Base.Iterator, predicate: (Element) throws -> Bool) rethrows {
    _iterator = iterator
    _nextElement = _iterator.next()
    
    while let x = _nextElement, try predicate(x) {
      _nextElement = _iterator.next()
    }
  }
}

----Swift.(file).DropWhileSequence.init(_:Base,predicate:(Base.Element) throws -> Bool)
extension DropWhileSequence {
  internal init(_ base: Base, predicate: (Element) throws -> Bool) rethrows {
    self = try DropWhileSequence(iterator: base.makeIterator(), predicate: predicate)
  }
}

----Swift.(file).DropWhileSequence.Iterator.init(_:Base.Iterator,nextElement:DropWhileSequence<Base>.Iterator.Element?)
extension DropWhileSequence.Iterator {
    internal init(_ iterator: Base.Iterator, nextElement: Element?) {
      _iterator = iterator
      _nextElement = nextElement
    }
}

----Swift.(file).DropWhileSequence.Iterator.Element
extension DropWhileSequence.Iterator: IteratorProtocol  {
  public typealias Element = Base.E
}

----Swift.(file).DropWhileSequence.Iterator.next()
extension DropWhileSequence.Iterator: IteratorProtocol  {
  public mutating func next() -> Element? {
    guard let next = _nextElement else { return nil }
    _nextElement = _iterator.next()
    return next
  }
}

----Swift.(file).DropWhileSequence.makeIterator()
extension DropWhileSequence: Sequence  {
  public func makeIterator() -> Iterator {
    return Iterator(_iterator, nextElement: _nextElement)
  }
}

----Swift.(file).DropWhileSequence.drop(while:(Base.Element) throws -> Bool)
extension DropWhileSequence: Sequence  {
  public __consuming func drop(
    while predicate: (Element) throws -> Bool
  ) rethrows -> DropWhileSequence<Base> {
    guard let x = _nextElement, try predicate(x) else { return self }
    return try DropWhileSequence(iterator: _iterator, predicate: predicate)
  }
}

----Swift.(file).Sequence.map(_:(Self.Element) throws -> T)
extension Sequence  {
  public func map<T>(
    _ transform: (Element) throws -> T
  ) rethrows -> [T] {
    let initialCapacity = underestimatedCount
    var result = ContiguousArray<T>()
    result.reserveCapacity(initialCapacity)

    var iterator = self.makeIterator()

    // Add elements up to the initial capacity without checking for regrowth.
    for _ in 0..<initialCapacity {
      result.append(try transform(iterator.next()!))
    }
    // Add remaining elements, if any.
    while let element = iterator.next() {
      result.append(try transform(element))
    }
    return Array(result)
  }
}

----Swift.(file).Sequence.filter(_:(Self.Element) throws -> Bool)
extension Sequence  {
  public __consuming func filter(
    _ isIncluded: (Element) throws -> Bool
  ) rethrows -> [Element] {
    return try _filter(isIncluded)
  }
}

----Swift.(file).Sequence.underestimatedCount
extension Sequence  {
  public var underestimatedCount: Int {
    return 0
  }
}

----Swift.(file).Sequence.forEach(_:(Self.Element) throws -> Void)
extension Sequence  {
  public func forEach(
    _ body: (Element) throws -> Void
  ) rethrows {
    for element in self {
      try body(element)
    }
  }
}

----Swift.(file).Sequence.first(where:(Self.Element) throws -> Bool)
extension Sequence  {
  public func first(
    where predicate: (Element) throws -> Bool
  ) rethrows -> Element? {
    for element in self  {
      if try predicate(element) {
        return element
      }
    }
    return nil
  }
}

----Swift.(file).Sequence.split(separator:Self.Element,maxSplits:Int,omittingEmptySubsequences:Bool)
extension Sequence where Element : Equatable  {
  public __consuming func split(
    separator: Element,
    maxSplits: Int = Int.max,
    omittingEmptySubsequences: Bool = true
  ) -> [ArraySlice<Element>] {
    return split(
      maxSplits: maxSplits,
      omittingEmptySubsequences: omittingEmptySubsequences,
      whereSeparator: { $0 == separator })
  }
}

----Swift.(file).Sequence.split(maxSplits:Int,omittingEmptySubsequences:Bool,whereSeparator:(Self.Element) throws -> Bool)
extension Sequence  {
  public __consuming func split(
    maxSplits: Int = Int.max,
    omittingEmptySubsequences: Bool = true,
    whereSeparator isSeparator: (Element) throws -> Bool
  ) rethrows -> [ArraySlice<Element>] {
    _precondition(maxSplits >= 0, "Must take zero or more splits")
    let whole = Array(self)
    return try whole.split(
                  maxSplits: maxSplits, 
                  omittingEmptySubsequences: omittingEmptySubsequences, 
                  whereSeparator: isSeparator)
  }
}

----Swift.(file).Sequence.suffix(_:Int)
extension Sequence  {
  public __consuming func suffix(_ maxLength: Int) -> [Element] {
    _precondition(maxLength >= 0, "Can't take a suffix of negative length from a sequence")
    guard maxLength != 0 else { return [] }

    // FIXME: <rdar://problem/21885650> Create reusable RingBuffer<T>
    // Put incoming elements into a ring buffer to save space. Once all
    // elements are consumed, reorder the ring buffer into an `Array`
    // and return it. This saves memory for sequences particularly longer
    // than `maxLength`.
    var ringBuffer: [Element] = []
    ringBuffer.reserveCapacity(Swift.min(maxLength, underestimatedCount))

    var i = 0

    for element in self {
      if ringBuffer.count < maxLength {
        ringBuffer.append(element)
      } else {
        ringBuffer[i] = element
        i += 1
        i %= maxLength
      }
    }

    if i != ringBuffer.startIndex {
      var rotated: [Element] = []
      rotated.reserveCapacity(ringBuffer.count)
      rotated += ringBuffer[i..<ringBuffer.endIndex]
      rotated += ringBuffer[0..<i]
      return rotated
    } else {      
      return ringBuffer
    }
  }
}

----Swift.(file).Sequence.dropFirst(_:Int)
extension Sequence  {
  public __consuming func dropFirst(_ k: Int = 1) -> DropFirstSequence<Self> {
    return DropFirstSequence(self, dropping: k)
  }
}

----Swift.(file).Sequence.dropLast(_:Int)
extension Sequence  {
  public __consuming func dropLast(_ k: Int = 1) -> [Element] {
    _precondition(k >= 0, "Can't drop a negative number of elements from a sequence")
    guard k != 0 else { return Array(self) }

    // FIXME: <rdar://problem/21885650> Create reusable RingBuffer<T>
    // Put incoming elements from this sequence in a holding tank, a ring buffer
    // of size <= k. If more elements keep coming in, pull them out of the
    // holding tank into the result, an `Array`. This saves
    // `k` * sizeof(Element) of memory, because slices keep the entire
    // memory of an `Array` alive.
    var result: [Element] = []
    var ringBuffer: [Element] = []
    var i = ringBuffer.startIndex

    for element in self {
      if ringBuffer.count < k {
        ringBuffer.append(element)
      } else {
        result.append(ringBuffer[i])
        ringBuffer[i] = element
        i += 1
        i %= k
      }
    }
    return result
  }
}

----Swift.(file).Sequence.drop(while:(Self.Element) throws -> Bool)
extension Sequence  {
  public __consuming func drop(
    while predicate: (Element) throws -> Bool
  ) rethrows -> DropWhileSequence<Self> {
    return try DropWhileSequence(self, predicate: predicate)
  }
}

----Swift.(file).Sequence.prefix(_:Int)
extension Sequence  {
  public __consuming func prefix(_ maxLength: Int) -> PrefixSequence<Self> {
    return PrefixSequence(self, maxLength: maxLength)
  }
}

----Swift.(file).Sequence.prefix(while:(Self.Element) throws -> Bool)
extension Sequence  {
  public __consuming func prefix(
    while predicate: (Element) throws -> Bool
  ) rethrows -> [Element] {
    var result: [Element] = []

    for element in self {
      guard try predicate(element) else {
        break
      }
      result.append(element)
    }
    return result
  }
}

----Swift.(file).Sequence.withContiguousStorageIfAvailable(_:(UnsafeBufferPointer<Self.Element>) throws -> R)
extension Sequence  {
  public func withContiguousStorageIfAvailable<R>(
    _ body: (UnsafeBufferPointer<Element>) throws -> R
  ) rethrows -> R? {
    return nil
  }
}

----Swift.(file).IteratorSequence.init(_:Base)
extension IteratorSequence {
  public init(_ base: Base) {
    _base = base
  }
}

----Swift.(file).IteratorSequence.next()
extension IteratorSequence: IteratorProtocol, Sequence  {
  public mutating func next() -> Base.Element? {
    return _base.next()
  }
}

----Swift.(file).Sequence.enumerated()
extension Sequence  {
  public func enumerated() -> EnumeratedSequence<Self> {
    return EnumeratedSequence(_base: self)
  }
}

----Swift.(file).Sequence.min(by:(Self.Element, Self.Element) throws -> Bool)
extension Sequence  {
  public func min(
    by areInIncreasingOrder: (Element, Element) throws -> Bool
  ) rethrows -> Element? {
    var it = makeIterator()
    guard var result = it.next() else { return nil }
    while let e = it.next() {
      if try areInIncreasingOrder(e, result) { result = e }
    }
    return result
  }
}

----Swift.(file).Sequence.max(by:(Self.Element, Self.Element) throws -> Bool)
extension Sequence  {
  public func max(
    by areInIncreasingOrder: (Element, Element) throws -> Bool
  ) rethrows -> Element? {
    var it = makeIterator()
    guard var result = it.next() else { return nil }
    while let e = it.next() {
      if try areInIncreasingOrder(result, e) { result = e }
    }
    return result
  }
}

----Swift.(file).Sequence.min()
extension Sequence where Element: Comparable  {
  public func min() -> Element? {
    return self.min(by: <)
  }
}

----Swift.(file).Sequence.max()
extension Sequence where Element: Comparable  {
  public func max() -> Element? {
    return self.max(by: <)
  }
}

----Swift.(file).Sequence.starts(with:PossiblePrefix,by:(Self.Element, PossiblePrefix.Element) throws -> Bool)
extension Sequence   {
  public func starts<PossiblePrefix: Sequence>(
    with possiblePrefix: PossiblePrefix,
    by areEquivalent: (Element, PossiblePrefix.Element) throws -> Bool
  ) rethrows -> Bool {
    var possiblePrefixIterator = possiblePrefix.makeIterator()
    for e0 in self {
      if let e1 = possiblePrefixIterator.next() {
        if try !areEquivalent(e0, e1) {
          return false
        }
      }
      else {
        return true
      }
    }
    return possiblePrefixIterator.next() == nil
  }
}

----Swift.(file).Sequence.starts(with:PossiblePrefix)
extension Sequence where Element: Equatable  {
  public func starts<PossiblePrefix: Sequence>(
    with possiblePrefix: PossiblePrefix
  ) -> Bool where PossiblePrefix.Element == Element {
    return self.starts(with: possiblePrefix, by: ==)
  }
}

----Swift.(file).Sequence.elementsEqual(_:OtherSequence,by:(Self.Element, OtherSequence.Element) throws -> Bool)
extension Sequence  {
  public func elementsEqual<OtherSequence: Sequence>(
    _ other: OtherSequence,
    by areEquivalent: (Element, OtherSequence.Element) throws -> Bool
  ) rethrows -> Bool {
    var iter1 = self.makeIterator()
    var iter2 = other.makeIterator()
    while true {
      switch (iter1.next(), iter2.next()) {
      case let (e1?, e2?):
        if try !areEquivalent(e1, e2) {
          return false
        }
      case (_?, nil), (nil, _?): return false
      case (nil, nil):           return true
      }
    }
  }
}

----Swift.(file).Sequence.elementsEqual(_:OtherSequence)
extension Sequence where Element : Equatable  {
  public func elementsEqual<OtherSequence: Sequence>(
    _ other: OtherSequence
  ) -> Bool where OtherSequence.Element == Element {
    return self.elementsEqual(other, by: ==)
  }
}

----Swift.(file).Sequence.lexicographicallyPrecedes(_:OtherSequence,by:(Self.Element, Self.Element) throws -> Bool)
extension Sequence  {
  public func lexicographicallyPrecedes<OtherSequence: Sequence>(
    _ other: OtherSequence,
    by areInIncreasingOrder: (Element, Element) throws -> Bool
  ) rethrows -> Bool 
  where OtherSequence.Element == Element {
    var iter1 = self.makeIterator()
    var iter2 = other.makeIterator()
    while true {
      if let e1 = iter1.next() {
        if let e2 = iter2.next() {
          if try areInIncreasingOrder(e1, e2) {
            return true
          }
          if try areInIncreasingOrder(e2, e1) {
            return false
          }
          continue // Equivalent
        }
        return false
      }

      return iter2.next() != nil
    }
  }
}

----Swift.(file).Sequence.lexicographicallyPrecedes(_:OtherSequence)
extension Sequence where Element : Comparable  {
  public func lexicographicallyPrecedes<OtherSequence: Sequence>(
    _ other: OtherSequence
  ) -> Bool where OtherSequence.Element == Element {
    return self.lexicographicallyPrecedes(other, by: <)
  }
}

----Swift.(file).Sequence.contains(where:(Self.Element) throws -> Bool)
extension Sequence  {
  public func contains(
    where predicate: (Element) throws -> Bool
  ) rethrows -> Bool {
    for e in self {
      if try predicate(e) {
        return true
      }
    }
    return false
  }
}

----Swift.(file).Sequence.allSatisfy(_:(Self.Element) throws -> Bool)
extension Sequence  {
  public func allSatisfy(
    _ predicate: (Element) throws -> Bool
  ) rethrows -> Bool {
    return try !contains { try !predicate($0) }
  }
}

----Swift.(file).Sequence.contains(_:Self.Element)
extension Sequence where Element : Equatable  {
  public func contains(_ element: Element) -> Bool {
    if let result = _customContainsEquatableElement(element) {
      return result
    } else {
      return self.contains { $0 == element }
    }
  }
}

----Swift.(file).Sequence.count(where:(Self.Element) throws -> Bool)
extension Sequence  {
  public func count(
    where predicate: (Element) throws -> Bool
  ) rethrows -> Int {
    var count = 0
    for e in self {
      if try predicate(e) {
        count += 1
      }
    }
    return count
  }
}

----Swift.(file).Sequence.reduce(_:Result,_:(Result, Self.Element) throws -> Result)
extension Sequence  {
  public func reduce<Result>(
    _ initialResult: Result,
    _ nextPartialResult:
      (_ partialResult: Result, Element) throws -> Result
  ) rethrows -> Result {
    var accumulator = initialResult
    for element in self {
      accumulator = try nextPartialResult(accumulator, element)
    }
    return accumulator
  }
}

----Swift.(file).Sequence.reduce(into:Result,_:(inout Result, Self.Element) throws -> ())
extension Sequence  {
  public func reduce<Result>(
    into initialResult: __owned Result,
    _ updateAccumulatingResult:
      (_ partialResult: inout Result, Element) throws -> ()
  ) rethrows -> Result {
    var accumulator = initialResult
    for element in self {
      try updateAccumulatingResult(&accumulator, element)
    }
    return accumulator
  }
}

----Swift.(file).Sequence.reversed()
extension Sequence  {
  public __consuming func reversed() -> [Element] {
    // FIXME(performance): optimize to 1 pass?  But Array(self) can be
    // optimized to a memcpy() sometimes.  Those cases are usually collections,
    // though.
    var result = Array(self)
    let count = result.count
    for i in 0..<count/2 {
      result.swapAt(i, count - ((i + 1) as Int))
    }
    return result
  }
}

----Swift.(file).Sequence.flatMap(_:(Self.Element) throws -> SegmentOfResult)
extension Sequence  {
  public func flatMap<SegmentOfResult : Sequence>(
    _ transform: (Element) throws -> SegmentOfResult
  ) rethrows -> [SegmentOfResult.Element] {
    var result: [SegmentOfResult.Element] = []
    for element in self {
      result.append(contentsOf: try transform(element))
    }
    return result
  }
}

----Swift.(file).Sequence.compactMap(_:(Self.Element) throws -> ElementOfResult?)
extension Sequence  {
  public func compactMap<ElementOfResult>(
    _ transform: (Element) throws -> ElementOfResult?
  ) rethrows -> [ElementOfResult] {
    return try _compactMap(transform)
  }
}

----Swift.(file).Set.init(minimumCapacity:Int)
extension Set {
  init(minimumCapacity: Int) {
    _variant = _Variant(native: _NativeSet(capacity: minimumCapacity))
  }
}

----Swift.(file).Set.init(_native:_NativeSet<Element>)
extension Set {
  internal init(_native: __owned _NativeSet<Element>) {
    _variant = _Variant(native: _native)
  }
}

----Swift.(file).SetAlgebra.Element
extension SetAlgebra {
  associatedtype E
}

----Swift.(file).SetAlgebra.init()
extension SetAlgebra {
  init()
}

----Swift.(file).SetAlgebra.contains(_:Self.Element)
extension SetAlgebra {
  func contains(_ member: Element) -> B
}

----Swift.(file).SetAlgebra.union(_:Self)
extension SetAlgebra {
  __consuming func union(_ other: __owned Self) -> S
}

----Swift.(file).SetAlgebra.intersection(_:Self)
extension SetAlgebra {
  __consuming func intersection(_ other: Self) -> S
}

----Swift.(file).SetAlgebra.symmetricDifference(_:Self)
extension SetAlgebra {
  __consuming func symmetricDifference(_ other: __owned Self) -> S
}

----Swift.(file).SetAlgebra.insert(_:Self.Element)
extension SetAlgebra {
  mutating func insert(
    _ newMember: __owned Element
  ) -> (inserted: Bool, memberAfterInsert: Element)
}

----Swift.(file).SetAlgebra.remove(_:Self.Element)
extension SetAlgebra {
  mutating func remove(_ member: Element) -> Element?
}

----Swift.(file).SetAlgebra.update(with:Self.Element)
extension SetAlgebra {
  mutating func update(with newMember: __owned Element) -> Element?
}

----Swift.(file).SetAlgebra.formUnion(_:Self)
extension SetAlgebra {
  mutating func formUnion(_ other: __owned Self)
}

----Swift.(file).SetAlgebra.formIntersection(_:Self)
extension SetAlgebra {
  mutating func formIntersection(_ other: Self)
}

----Swift.(file).SetAlgebra.formSymmetricDifference(_:Self)
extension SetAlgebra {
  mutating func formSymmetricDifference(_ other: __owned Self)
}

----Swift.(file).SetAlgebra.subtracting(_:Self)
extension SetAlgebra {
  __consuming func subtracting(_ other: Self) -> S
}

----Swift.(file).SetAlgebra.isSubset(of:Self)
extension SetAlgebra {
  func isSubset(of other: Self) -> B
}

----Swift.(file).SetAlgebra.isDisjoint(with:Self)
extension SetAlgebra {
  func isDisjoint(with other: Self) -> B
}

----Swift.(file).SetAlgebra.isSuperset(of:Self)
extension SetAlgebra {
  func isSuperset(of other: Self) -> B
}

----Swift.(file).SetAlgebra.isEmpty
extension SetAlgebra {
  var isEmpty: Bool { get }
}

----Swift.(file).SetAlgebra.init(_:S)
extension SetAlgebra {
  init<S : Sequence>(_ sequence: __owned S) where S.Element == E
}

----Swift.(file).SetAlgebra.subtract(_:Self)
extension SetAlgebra {
  mutating func subtract(_ other: Self)
}

----Swift.(file).SetAlgebra.init(_:S)
extension SetAlgebra  {
  public init<S : Sequence>(_ sequence: __owned S)
    where S.Element == Element {
    self.init()
    for e in sequence { insert(e) }
  }
}

----Swift.(file).SetAlgebra.subtract(_:Self)
extension SetAlgebra  {
  public mutating func subtract(_ other: Self) {
    self.formIntersection(self.symmetricDifference(other))
  }
}

----Swift.(file).SetAlgebra.isSubset(of:Self)
extension SetAlgebra  {
  public func isSubset(of other: Self) -> Bool {
    return self.intersection(other) == self
  }
}

----Swift.(file).SetAlgebra.isSuperset(of:Self)
extension SetAlgebra  {
  public func isSuperset(of other: Self) -> Bool {
    return other.isSubset(of: self)
  }
}

----Swift.(file).SetAlgebra.isDisjoint(with:Self)
extension SetAlgebra  {
  public func isDisjoint(with other: Self) -> Bool {
    return self.intersection(other).isEmpty
  }
}

----Swift.(file).SetAlgebra.subtracting(_:Self)
extension SetAlgebra  {
  public func subtracting(_ other: Self) -> Self {
    return self.intersection(self.symmetricDifference(other))
  }
}

----Swift.(file).SetAlgebra.isEmpty
extension SetAlgebra  {
  public var isEmpty: Bool {
    return self == Self()
  }
}

----Swift.(file).SetAlgebra.isStrictSuperset(of:Self)
extension SetAlgebra  {
  public func isStrictSuperset(of other: Self) -> Bool {
    return self.isSuperset(of: other) && self != other
  }
}

----Swift.(file).SetAlgebra.isStrictSubset(of:Self)
extension SetAlgebra  {
  public func isStrictSubset(of other: Self) -> Bool {
    return other.isStrictSuperset(of: self)
  }
}

----Swift.(file).SetAlgebra.init(arrayLiteral:[Self.Element])
extension SetAlgebra where Element == ArrayLiteralElement  {
  public init(arrayLiteral: Element...) {
    self.init(arrayLiteral)
  }
}

----Swift.(file).Set.insert(_:ConcreteElement)
extension Set where Element == AnyHashable  {
  public mutating func insert<ConcreteElement : Hashable>(
    _ newMember: __owned ConcreteElement
  ) -> (inserted: Bool, memberAfterInsert: ConcreteElement) {
    let (inserted, memberAfterInsert) =
      insert(AnyHashable(newMember))
    return (
      inserted: inserted,
      memberAfterInsert: memberAfterInsert.base as! ConcreteElement)
  }
}

----Swift.(file).Set.update(with:ConcreteElement)
extension Set where Element == AnyHashable  {
  public mutating func update<ConcreteElement : Hashable>(
    with newMember: __owned ConcreteElement
  ) -> ConcreteElement? {
    return update(with: AnyHashable(newMember))
      .map { $0.base as! ConcreteElement }
  }
}

----Swift.(file).Set.remove(_:ConcreteElement)
extension Set where Element == AnyHashable  {
  public mutating func remove<ConcreteElement : Hashable>(
    _ member: ConcreteElement
  ) -> ConcreteElement? {
    return remove(AnyHashable(member))
      .map { $0.base as! ConcreteElement }
  }
}

----Swift.(file)..(error_type).bridged()
extension _NativeSet  {
  internal __consuming func bridged() -> AnyObject {
    // We can zero-cost bridge if our keys are verbatim
    // or if we're the empty singleton.

    // Temporary var for SOME type safety.
    let nsSet: _NSSetCore

    if _storage === _RawSetStorage.empty || count == 0 {
      nsSet = _RawSetStorage.empty
    } else if _isBridgedVerbatimToObjectiveC(Element.self) {
      nsSet = unsafeDowncast(_storage, to: _SetStorage<Element>.self)
    } else {
      nsSet = _SwiftDeferredNSSet(self)
    }

    // Cast from "minimal NSSet" to "NSSet"
    // Note that if you actually ask Swift for this cast, it will fail.
    // Never trust a shadow protocol!
    return nsSet
  }
}

----Swift.(file)._CocoaSet.member(for:_CocoaSet.Index)
extension _CocoaSet  {
  internal func member(for index: Index) -> AnyObject {
    return index.element
  }
}

----Swift.(file)._CocoaSet.member(for:AnyObject)
extension _CocoaSet  {
  internal func member(for element: AnyObject) -> AnyObject? {
    let nss = unsafeBitCast(object, to: _NSSet.self)
    return nss.member(element)
  }
}

----Swift.(file)._CocoaSet.isEqual(to:_CocoaSet)
extension _CocoaSet  {
  internal func isEqual(to other: _CocoaSet) -> Bool {
    return _stdlib_NSObject_isEqual(self.object, other.object)
  }
}

----Swift.(file)._CocoaSet.Element
extension _CocoaSet: _SetBuffer  {
  internal typealias Element = A
}

----Swift.(file)._CocoaSet.startIndex
extension _CocoaSet: _SetBuffer  {
  internal var startIndex: Index {
    @_effects(releasenone)
    get {
      let allKeys = _stdlib_NSSet_allObjects(self.object)
      return Index(Index.Storage(self, allKeys), offset: 0)
    }
  }
}

----Swift.(file)._CocoaSet.endIndex
extension _CocoaSet: _SetBuffer  {
  internal var endIndex: Index {
    @_effects(releasenone)
    get {
      let allKeys = _stdlib_NSSet_allObjects(self.object)
      return Index(Index.Storage(self, allKeys), offset: allKeys.count)
    }
  }
}

----Swift.(file)._CocoaSet.index(after:_CocoaSet.Index)
extension _CocoaSet: _SetBuffer  {
  internal func index(after index: Index) -> Index {
    validate(index)
    var result = index
    result._offset += 1
    return result
  }
}

----Swift.(file)._CocoaSet.validate(_:_CocoaSet.Index)
extension _CocoaSet: _SetBuffer  {
  internal func validate(_ index: Index) {
    _precondition(index.storage.base.object === self.object,
      "Invalid index")
    _precondition(index._offset < index.storage.allKeys.count,
      "Attempt to access endIndex")
  }
}

----Swift.(file)._CocoaSet.formIndex(after:_CocoaSet.Index,isUnique:Bool)
extension _CocoaSet: _SetBuffer  {
  internal func formIndex(after index: inout Index, isUnique: Bool) {
    validate(index)
    index._offset += 1
  }
}

----Swift.(file)._CocoaSet.index(for:AnyObject)
extension _CocoaSet: _SetBuffer  {
  internal func index(for element: AnyObject) -> Index? {
    // Fast path that does not involve creating an array of all keys.  In case
    // the key is present, this lookup is a penalty for the slow path, but the
    // potential savings are significant: we could skip a memory allocation and
    // a linear search.
    if !contains(element) {
      return nil
    }

    let allKeys = _stdlib_NSSet_allObjects(object)
    for i in 0..<allKeys.count {
      if _stdlib_NSObject_isEqual(element, allKeys[i]) {
        return Index(Index.Storage(self, allKeys), offset: i)
      }
    }
    _internalInvariantFailure(
      "An NSSet member wasn't listed amongst its enumerated contents")
  }
}

----Swift.(file)._CocoaSet.count
extension _CocoaSet: _SetBuffer  {
  internal var count: Int {
    let nss = unsafeBitCast(object, to: _NSSet.self)
    return nss.count
  }
}

----Swift.(file)._CocoaSet.contains(_:AnyObject)
extension _CocoaSet: _SetBuffer  {
  internal func contains(_ element: AnyObject) -> Bool {
    let nss = unsafeBitCast(object, to: _NSSet.self)
    return nss.member(element) != nil
  }
}

----Swift.(file)._CocoaSet.element(at:_CocoaSet.Index)
extension _CocoaSet: _SetBuffer  {
  internal func element(at i: Index) -> AnyObject {
    let element: AnyObject? = i.element
    _internalInvariant(element != nil, "Item not found in underlying NSSet")
    return element!
  }
}

----Swift.(file)._CocoaSet.Index.handleBitPattern
extension _CocoaSet.Index  {
  internal var handleBitPattern: UInt {
    @_effects(readonly)
    get {
      return unsafeBitCast(storage, to: UInt.self)
    }
  }
}

----Swift.(file)._CocoaSet.Index.age
extension _CocoaSet.Index  {
  internal var age: Int32 {
    @_effects(releasenone)
    get {
      return _HashTable.age(for: storage.base.object)
    }
  }
}

----Swift.(file)._CocoaSet.Index.==infix(_:_CocoaSet.Index,_:_CocoaSet.Index)
extension _CocoaSet.Index: Equatable  {
  internal static func == (lhs: _CocoaSet.Index, rhs: _CocoaSet.Index) -> Bool {
    _precondition(lhs.storage.base.object === rhs.storage.base.object,
      "Comparing indexes from different sets")
    return lhs._offset == rhs._offset
  }
}

----Swift.(file)._CocoaSet.Index.<infix(_:_CocoaSet.Index,_:_CocoaSet.Index)
extension _CocoaSet.Index: Comparable  {
  internal static func < (lhs: _CocoaSet.Index, rhs: _CocoaSet.Index) -> Bool {
    _precondition(lhs.storage.base.object === rhs.storage.base.object,
      "Comparing indexes from different sets")
    return lhs._offset < rhs._offset
  }
}

----Swift.(file)._CocoaSet.makeIterator()
extension _CocoaSet: Sequence  {
  internal __consuming func makeIterator() -> Iterator {
    return Iterator(self)
  }
}

----Swift.(file)._CocoaSet.Iterator.Element
extension _CocoaSet.Iterator: IteratorProtocol  {
  internal typealias Element = A
}

----Swift.(file)._CocoaSet.Iterator.next()
extension _CocoaSet.Iterator: IteratorProtocol  {
  internal func next() -> Element? {
    if itemIndex < 0 {
      return nil
    }
    let base = self.base
    if itemIndex == itemCount {
      let stackBufCount = _fastEnumerationStackBuf.count
      // We can't use `withUnsafeMutablePointer` here to get pointers to
      // properties, because doing so might introduce a writeback storage, but
      // fast enumeration relies on the pointer identity of the enumeration
      // state struct.
      itemCount = base.object.countByEnumerating(
        with: _fastEnumerationStatePtr,
        objects: UnsafeMutableRawPointer(_fastEnumerationStackBufPtr)
          .assumingMemoryBound(to: AnyObject.self),
        count: stackBufCount)
      if itemCount == 0 {
        itemIndex = -1
        return nil
      }
      itemIndex = 0
    }
    let itemsPtrUP =
    UnsafeMutableRawPointer(_fastEnumerationState.itemsPtr!)
      .assumingMemoryBound(to: AnyObject.self)
    let itemsPtr = _UnmanagedAnyObjectArray(itemsPtrUP)
    let key: AnyObject = itemsPtr[itemIndex]
    itemIndex += 1
    return key
  }
}

----Swift.(file)._RawSetStorage.empty
extension _RawSetStorage  {
  internal static var empty: _EmptySetSingleton {
    return Builtin.bridgeFromRawPointer(
      Builtin.addressof(&_swiftEmptySetSingleton))
  }
}

----Swift.(file)._EmptySetSingleton.copy(with:<<error type>>)
extension _EmptySetSingleton: _NSSetCore  {
  internal func copy(with zone: _SwiftNSZone?) -> AnyObject {
    return self
  }
}

----Swift.(file)._EmptySetSingleton.count
extension _EmptySetSingleton: _NSSetCore  {
  internal var count: Int {
    return 0
  }
}

----Swift.(file)._EmptySetSingleton.member(_:AnyObject)
extension _EmptySetSingleton: _NSSetCore  {
  internal func member(_ object: AnyObject) -> AnyObject? {
    return nil
  }
}

----Swift.(file)._EmptySetSingleton.objectEnumerator()
extension _EmptySetSingleton: _NSSetCore  {
  internal func objectEnumerator() -> _NSEnumerator {
    return _SwiftEmptyNSEnumerator()
  }
}

----Swift.(file)._EmptySetSingleton.countByEnumerating(with:UnsafeMutablePointer<_SwiftNSFastEnumerationState>,objects:UnsafeMutablePointer<AnyObject>?,count:Int)
extension _EmptySetSingleton: _NSSetCore  {
  internal func countByEnumerating(
    with state: UnsafeMutablePointer<_SwiftNSFastEnumerationState>,
    objects: UnsafeMutablePointer<AnyObject>?, count: Int
  ) -> Int {
    // Even though we never do anything in here, we need to update the
    // state so that callers know we actually ran.
    var theState = state.pointee
    if theState.state == 0 {
      theState.state = 1 // Arbitrary non-zero value.
      theState.itemsPtr = AutoreleasingUnsafeMutablePointer(objects)
      theState.mutationsPtr = _fastEnumerationStorageMutationsPtr
    }
    state.pointee = theState
    return 0
  }
}

----Swift.(file)._SetStorage.copy(original:_RawSetStorage)
extension _SetStorage  {
  internal static func copy(original: _RawSetStorage) -> _SetStorage {
    return .allocate(
      scale: original._scale,
      age: original._age,
      seed: original._seed)
  }
}

----Swift.(file)._SetStorage.resize(original:_RawSetStorage,capacity:Int,move:Bool)
extension _SetStorage  {
  static internal func resize(
    original: _RawSetStorage,
    capacity: Int,
    move: Bool
  ) -> _SetStorage {
    let scale = _HashTable.scale(forCapacity: capacity)
    return allocate(scale: scale, age: nil, seed: nil)
  }
}

----Swift.(file)._SetStorage.allocate(capacity:Int)
extension _SetStorage  {
  static internal func allocate(capacity: Int) -> _SetStorage {
    let scale = _HashTable.scale(forCapacity: capacity)
    return allocate(scale: scale, age: nil, seed: nil)
  }
}

----Swift.(file)._SetStorage.convert(_:<<error type>>,capacity:Int)
extension _SetStorage  {
  static internal func convert(
    _ cocoa: _CocoaSet,
    capacity: Int
  ) -> _SetStorage {
    let scale = _HashTable.scale(forCapacity: capacity)
    let age = _HashTable.age(for: cocoa.object)
    return allocate(scale: scale, age: age, seed: nil)
  }
}

----Swift.(file)._SetStorage.allocate(scale:Int8,age:Int32?,seed:Int?)
extension _SetStorage  {
  static internal func allocate(
    scale: Int8,
    age: Int32?,
    seed: Int?
  ) -> _SetStorage {
    // The entry count must be representable by an Int value; hence the scale's
    // peculiar upper bound.
    _internalInvariant(scale >= 0 && scale < Int.bitWidth - 1)

    let bucketCount = (1 as Int) &<< scale
    let wordCount = _UnsafeBitset.wordCount(forCapacity: bucketCount)
    let storage = Builtin.allocWithTailElems_2(
      _SetStorage<Element>.self,
      wordCount._builtinWordValue, _HashTable.Word.self,
      bucketCount._builtinWordValue, Element.self)

    let metadataAddr = Builtin.projectTailElems(storage, _HashTable.Word.self)
    let elementsAddr = Builtin.getTailAddr_Word(
      metadataAddr, wordCount._builtinWordValue, _HashTable.Word.self,
      Element.self)
    storage._count = 0
    storage._capacity = _HashTable.capacity(forScale: scale)
    storage._scale = scale
    storage._reservedScale = 0
    storage._extra = 0

    if let age = age {
      storage._age = age
    } else {
      // The default mutation count is simply a scrambled version of the storage
      // address.
      storage._age = Int32(
        truncatingIfNeeded: ObjectIdentifier(storage).hashValue)
    }

    storage._seed = seed ?? _HashTable.hashSeed(for: storage, scale: scale)
    storage._rawElements = UnsafeMutableRawPointer(elementsAddr)

    // Initialize hash table metadata.
    storage._hashTable.clear()
    return storage
  }
}

----Swift.(file).Hasher._State.compress(_:UInt64)
extension Hasher._State  {
  internal mutating func compress(_ m: UInt64) {
    v3 ^= m
    _round()
    v0 ^= m
  }
}

----Swift.(file).Hasher._State.finalize(tailAndByteCount:UInt64)
extension Hasher._State  {
  internal mutating func finalize(tailAndByteCount: UInt64) -> UInt64 {
    compress(tailAndByteCount)
    v2 ^= 0xff
    for _ in 0..<3 {
      _round()
    }
    return _extract()
  }
}

----Swift.(file).Hasher._State.init()
extension Hasher._State  {
  internal init() {
    self.init(rawSeed: Hasher._executionSeed)
  }
}

----Swift.(file).Hasher._State.init(seed:Int)
extension Hasher._State  {
  internal init(seed: Int) {
    let executionSeed = Hasher._executionSeed
    // Prevent sign-extending the supplied seed; this makes testing slightly
    // easier.
    let seed = UInt(bitPattern: seed)
    self.init(rawSeed: (
        executionSeed.0 ^ UInt64(truncatingIfNeeded: seed),
        executionSeed.1))
  }
}

----Swift.(file).Slice.init(base:Base,bounds:Range<Base.Index>)
extension Slice {
  public init(base: Base, bounds: Range<Base.Index>) {
    self._base = base
    self._startIndex = bounds.lowerBound
    self._endIndex = bounds.upperBound
  }
}

----Swift.(file).Slice.base
extension Slice {
  public var base: Base {
    return _base
  }
}

----Swift.(file).Slice.Index
extension Slice: Collection  {
  public typealias Index = Base.I
}

----Swift.(file).Slice.Indices
extension Slice: Collection  {
  public typealias Indices = Base.I
}

----Swift.(file).Slice.Element
extension Slice: Collection  {
  public typealias Element = Base.E
}

----Swift.(file).Slice.SubSequence
extension Slice: Collection  {
  public typealias SubSequence = Slice<Base>
}

----Swift.(file).Slice.Iterator
extension Slice: Collection  {
  public typealias Iterator = IndexingIterator<Slice<Base>>
}

----Swift.(file).Slice.startIndex
extension Slice: Collection  {
  public var startIndex: Index {
    return _startIndex
  }
}

----Swift.(file).Slice.endIndex
extension Slice: Collection  {
  public var endIndex: Index {
    return _endIndex
  }
}

----Swift.(file).Slice.subscript(_:Slice<Base>.Index)
extension Slice: Collection  {
  public subscript(index: Index) -> Base.Element {
    get {
      _failEarlyRangeCheck(index, bounds: startIndex..<endIndex)
      return _base[index]
    }
  }
}

----Swift.(file).Slice.subscript(_:Range<Slice<Base>.Index>)
extension Slice: Collection  {
  public subscript(bounds: Range<Index>) -> Slice<Base> {
    get {
      _failEarlyRangeCheck(bounds, bounds: startIndex..<endIndex)
      return Slice(base: _base, bounds: bounds)
    }
  }
}

----Swift.(file).Slice.indices
extension Slice: Collection  {
  public var indices: Indices { 
    return _base.indices[_startIndex..<_endIndex]
  }
}

----Swift.(file).Slice.index(after:Slice<Base>.Index)
extension Slice: Collection  {
  public func index(after i: Index) -> Index {
    // FIXME: swift-3-indexing-model: range check.
    return _base.index(after: i)
  }
}

----Swift.(file).Slice.formIndex(after:Slice<Base>.Index)
extension Slice: Collection  {
  public func formIndex(after i: inout Index) {
    // FIXME: swift-3-indexing-model: range check.
    _base.formIndex(after: &i)
  }
}

----Swift.(file).Slice.index(_:Slice<Base>.Index,offsetBy:Int)
extension Slice: Collection  {
  public func index(_ i: Index, offsetBy n: Int) -> Index {
    // FIXME: swift-3-indexing-model: range check.
    return _base.index(i, offsetBy: n)
  }
}

----Swift.(file).Slice.index(_:Slice<Base>.Index,offsetBy:Int,limitedBy:Slice<Base>.Index)
extension Slice: Collection  {
  public func index(
    _ i: Index, offsetBy n: Int, limitedBy limit: Index
  ) -> Index? {
    // FIXME: swift-3-indexing-model: range check.
    return _base.index(i, offsetBy: n, limitedBy: limit)
  }
}

----Swift.(file).Slice.distance(from:Slice<Base>.Index,to:Slice<Base>.Index)
extension Slice: Collection  {
  public func distance(from start: Index, to end: Index) -> Int {
    // FIXME: swift-3-indexing-model: range check.
    return _base.distance(from: start, to: end)
  }
}

----Swift.(file).Slice.index(before:Slice<Base>.Index)
extension Slice: BidirectionalCollection where Base: BidirectionalCollection  {
  public func index(before i: Index) -> Index {
    // FIXME: swift-3-indexing-model: range check.
    return _base.index(before: i)
  }
}

----Swift.(file).Slice.formIndex(before:Slice<Base>.Index)
extension Slice: BidirectionalCollection where Base: BidirectionalCollection  {
  public func formIndex(before i: inout Index) {
    // FIXME: swift-3-indexing-model: range check.
    _base.formIndex(before: &i)
  }
}

----Swift.(file).Slice.subscript(_:Slice<Base>.Index)
extension Slice: MutableCollection where Base: MutableCollection  {
  public subscript(index: Index) -> Base.Element {
    get {
      _failEarlyRangeCheck(index, bounds: startIndex..<endIndex)
      return _base[index]
    }
    set {
      _failEarlyRangeCheck(index, bounds: startIndex..<endIndex)
      _base[index] = newValue
      // MutableSlice requires that the underlying collection's subscript
      // setter does not invalidate indices, so our `startIndex` and `endIndex`
      // continue to be valid.
    }
  }
}

----Swift.(file).Slice.subscript(_:Range<Slice<Base>.Index>)
extension Slice: MutableCollection where Base: MutableCollection  {
  public subscript(bounds: Range<Index>) -> Slice<Base> {
    get {
      _failEarlyRangeCheck(bounds, bounds: startIndex..<endIndex)
      return Slice(base: _base, bounds: bounds)
    }
    set {
      _writeBackMutableSlice(&self, bounds: bounds, slice: newValue)
    }
  }
}

----Swift.(file).Slice.init()
extension Slice: RangeReplaceableCollection
  where Base: RangeReplaceableCollection  {
  public init() {
    self._base = Base()
    self._startIndex = _base.startIndex
    self._endIndex = _base.endIndex
  }
}

----Swift.(file).Slice.init(repeating:Base.Element,count:Int)
extension Slice: RangeReplaceableCollection
  where Base: RangeReplaceableCollection  {
  public init(repeating repeatedValue: Base.Element, count: Int) {
    self._base = Base(repeating: repeatedValue, count: count)
    self._startIndex = _base.startIndex
    self._endIndex = _base.endIndex
  }
}

----Swift.(file).Slice.init(_:S)
extension Slice: RangeReplaceableCollection
  where Base: RangeReplaceableCollection  {
  public init<S>(_ elements: S) where S: Sequence, S.Element == Base.Element {
    self._base = Base(elements)
    self._startIndex = _base.startIndex
    self._endIndex = _base.endIndex
  }
}

----Swift.(file).Slice.replaceSubrange(_:Range<Slice<Base>.Index>,with:C)
extension Slice: RangeReplaceableCollection
  where Base: RangeReplaceableCollection  {
  public mutating func replaceSubrange<C>(
    _ subRange: Range<Index>, with newElements: C
  ) where C : Collection, C.Element == Base.Element {

    // FIXME: swift-3-indexing-model: range check.
    let sliceOffset =
      _base.distance(from: _base.startIndex, to: _startIndex)
    let newSliceCount =
      _base.distance(from: _startIndex, to: subRange.lowerBound)
      + _base.distance(from: subRange.upperBound, to: _endIndex)
      + (numericCast(newElements.count) as Int)
    _base.replaceSubrange(subRange, with: newElements)
    _startIndex = _base.index(_base.startIndex, offsetBy: sliceOffset)
    _endIndex = _base.index(_startIndex, offsetBy: newSliceCount)
  }
}

----Swift.(file).Slice.insert(_:Base.Element,at:Slice<Base>.Index)
extension Slice: RangeReplaceableCollection
  where Base: RangeReplaceableCollection  {
  public mutating func insert(_ newElement: Base.Element, at i: Index) {
    // FIXME: swift-3-indexing-model: range check.
    let sliceOffset = _base.distance(from: _base.startIndex, to: _startIndex)
    let newSliceCount = count + 1
    _base.insert(newElement, at: i)
    _startIndex = _base.index(_base.startIndex, offsetBy: sliceOffset)
    _endIndex = _base.index(_startIndex, offsetBy: newSliceCount)
  }
}

----Swift.(file).Slice.insert(contentsOf:S,at:Slice<Base>.Index)
extension Slice: RangeReplaceableCollection
  where Base: RangeReplaceableCollection  {
  public mutating func insert<S>(contentsOf newElements: S, at i: Index)
  where S: Collection, S.Element == Base.Element {

    // FIXME: swift-3-indexing-model: range check.
    let sliceOffset = _base.distance(from: _base.startIndex, to: _startIndex)
    let newSliceCount = count + newElements.count
    _base.insert(contentsOf: newElements, at: i)
    _startIndex = _base.index(_base.startIndex, offsetBy: sliceOffset)
    _endIndex = _base.index(_startIndex, offsetBy: newSliceCount)
  }
}

----Swift.(file).Slice.remove(at:Slice<Base>.Index)
extension Slice: RangeReplaceableCollection
  where Base: RangeReplaceableCollection  {
  public mutating func remove(at i: Index) -> Base.Element {
    // FIXME: swift-3-indexing-model: range check.
    let sliceOffset = _base.distance(from: _base.startIndex, to: _startIndex)
    let newSliceCount = count - 1
    let result = _base.remove(at: i)
    _startIndex = _base.index(_base.startIndex, offsetBy: sliceOffset)
    _endIndex = _base.index(_startIndex, offsetBy: newSliceCount)
    return result
  }
}

----Swift.(file).Slice.removeSubrange(_:Range<Slice<Base>.Index>)
extension Slice: RangeReplaceableCollection
  where Base: RangeReplaceableCollection  {
  public mutating func removeSubrange(_ bounds: Range<Index>) {
    // FIXME: swift-3-indexing-model: range check.
    let sliceOffset = _base.distance(from: _base.startIndex, to: _startIndex)
    let newSliceCount =
      count - distance(from: bounds.lowerBound, to: bounds.upperBound)
    _base.removeSubrange(bounds)
    _startIndex = _base.index(_base.startIndex, offsetBy: sliceOffset)
    _endIndex = _base.index(_startIndex, offsetBy: newSliceCount)
  }
}

----Swift.(file).Slice.replaceSubrange(_:Range<Slice<Base>.Index>,with:C)
extension Slice
  where Base: RangeReplaceableCollection, Base: BidirectionalCollection  {
  public mutating func replaceSubrange<C>(
    _ subRange: Range<Index>, with newElements: C
  ) where C : Collection, C.Element == Base.Element {
    // FIXME: swift-3-indexing-model: range check.
    if subRange.lowerBound == _base.startIndex {
      let newSliceCount =
        _base.distance(from: _startIndex, to: subRange.lowerBound)
        + _base.distance(from: subRange.upperBound, to: _endIndex)
        + (numericCast(newElements.count) as Int)
      _base.replaceSubrange(subRange, with: newElements)
      _startIndex = _base.startIndex
      _endIndex = _base.index(_startIndex, offsetBy: newSliceCount)
    } else {
      let shouldUpdateStartIndex = subRange.lowerBound == _startIndex
      let lastValidIndex = _base.index(before: subRange.lowerBound)
      let newEndIndexOffset =
        _base.distance(from: subRange.upperBound, to: _endIndex)
        + (numericCast(newElements.count) as Int) + 1
      _base.replaceSubrange(subRange, with: newElements)
      if shouldUpdateStartIndex {
        _startIndex = _base.index(after: lastValidIndex)
      }
      _endIndex = _base.index(lastValidIndex, offsetBy: newEndIndexOffset)
    }
  }
}

----Swift.(file).Slice.insert(_:Base.Element,at:Slice<Base>.Index)
extension Slice
  where Base: RangeReplaceableCollection, Base: BidirectionalCollection  {
  public mutating func insert(_ newElement: Base.Element, at i: Index) {
    // FIXME: swift-3-indexing-model: range check.
    if i == _base.startIndex {
      let newSliceCount = count + 1
      _base.insert(newElement, at: i)
      _startIndex = _base.startIndex
      _endIndex = _base.index(_startIndex, offsetBy: newSliceCount)
    } else {
      let shouldUpdateStartIndex = i == _startIndex
      let lastValidIndex = _base.index(before: i)
      let newEndIndexOffset = _base.distance(from: i, to: _endIndex) + 2
      _base.insert(newElement, at: i)
      if shouldUpdateStartIndex {
        _startIndex = _base.index(after: lastValidIndex)
      }
      _endIndex = _base.index(lastValidIndex, offsetBy: newEndIndexOffset)
    }
  }
}

----Swift.(file).Slice.insert(contentsOf:S,at:Slice<Base>.Index)
extension Slice
  where Base: RangeReplaceableCollection, Base: BidirectionalCollection  {
  public mutating func insert<S>(contentsOf newElements: S, at i: Index)
  where S : Collection, S.Element == Base.Element {
    // FIXME: swift-3-indexing-model: range check.
    if i == _base.startIndex {
      let newSliceCount = count + numericCast(newElements.count)
      _base.insert(contentsOf: newElements, at: i)
      _startIndex = _base.startIndex
      _endIndex = _base.index(_startIndex, offsetBy: newSliceCount)
    } else {
      let shouldUpdateStartIndex = i == _startIndex
      let lastValidIndex = _base.index(before: i)
      let newEndIndexOffset =
        _base.distance(from: i, to: _endIndex)
        + numericCast(newElements.count) + 1
      _base.insert(contentsOf: newElements, at: i)
      if shouldUpdateStartIndex {
        _startIndex = _base.index(after: lastValidIndex)
      }
      _endIndex = _base.index(lastValidIndex, offsetBy: newEndIndexOffset)
    }
  }
}

----Swift.(file).Slice.remove(at:Slice<Base>.Index)
extension Slice
  where Base: RangeReplaceableCollection, Base: BidirectionalCollection  {
  public mutating func remove(at i: Index) -> Base.Element {
    // FIXME: swift-3-indexing-model: range check.
    if i == _base.startIndex {
      let newSliceCount = count - 1
      let result = _base.remove(at: i)
      _startIndex = _base.startIndex
      _endIndex = _base.index(_startIndex, offsetBy: newSliceCount)
      return result
    } else {
      let shouldUpdateStartIndex = i == _startIndex
      let lastValidIndex = _base.index(before: i)
      let newEndIndexOffset = _base.distance(from: i, to: _endIndex)
      let result = _base.remove(at: i)
      if shouldUpdateStartIndex {
        _startIndex = _base.index(after: lastValidIndex)
      }
      _endIndex = _base.index(lastValidIndex, offsetBy: newEndIndexOffset)
      return result
    }
  }
}

----Swift.(file).Slice.removeSubrange(_:Range<Slice<Base>.Index>)
extension Slice
  where Base: RangeReplaceableCollection, Base: BidirectionalCollection  {
  public mutating func removeSubrange(_ bounds: Range<Index>) {
    // FIXME: swift-3-indexing-model: range check.
    if bounds.lowerBound == _base.startIndex {
      let newSliceCount =
        count - _base.distance(from: bounds.lowerBound, to: bounds.upperBound)
      _base.removeSubrange(bounds)
      _startIndex = _base.startIndex
      _endIndex = _base.index(_startIndex, offsetBy: newSliceCount)
    } else {
      let shouldUpdateStartIndex = bounds.lowerBound == _startIndex
      let lastValidIndex = _base.index(before: bounds.lowerBound)
      let newEndIndexOffset =
          _base.distance(from: bounds.lowerBound, to: _endIndex)
        - _base.distance(from: bounds.lowerBound, to: bounds.upperBound)
        + 1
      _base.removeSubrange(bounds)
      if shouldUpdateStartIndex {
        _startIndex = _base.index(after: lastValidIndex)
      }
      _endIndex = _base.index(lastValidIndex, offsetBy: newEndIndexOffset)
    }
  }
}

----Swift.(file)._SmallBuffer.stride
extension _SmallBuffer  {
  private var stride: Int { return MemoryLayout<T>.stride }
}

----Swift.(file)._SmallBuffer.byteCapacity
extension _SmallBuffer  {
  private var byteCapacity: Int {
    return MemoryLayout.stride(ofValue: _inlineStorage)
  }
}

----Swift.(file)._SmallBuffer.capacity
extension _SmallBuffer  {
  internal var capacity: Int { return byteCapacity / stride }
}

----Swift.(file)._SmallBuffer.subscript(_:Int)
extension _SmallBuffer  {
  internal subscript(i: Int) -> T {
    get {
      _internalInvariant(i >= 0 && i < capacity)
      let capacity = self.capacity
      return withUnsafeBytes(of: _inlineStorage) {
        let rawPtr = $0.baseAddress._unsafelyUnwrappedUnchecked
        let bufPtr = UnsafeBufferPointer(
          start: rawPtr.assumingMemoryBound(to: T.self), count: capacity)
        return bufPtr[_unchecked: i]
      }
    }
    set {
      _internalInvariant(i >= 0 && i < capacity)
      let capacity = self.capacity
      withUnsafeMutableBytes(of: &_inlineStorage) {
        let rawPtr = $0.baseAddress._unsafelyUnwrappedUnchecked
        let bufPtr = UnsafeMutableBufferPointer(
          start: rawPtr.assumingMemoryBound(to: T.self), count: capacity)
        bufPtr[_unchecked: i] = newValue
      }
    }
  }
}

----Swift.(file)._SmallString.capacity
extension _SmallString  {
  internal static var capacity: Int {
    @inline(__always) get {
#if arch(i386) || arch(arm)
      return 10
#else
      return 15
#endif
    }
  }
}

----Swift.(file)._SmallString.rawDiscriminatedObject
extension _SmallString  {
  internal var rawDiscriminatedObject: UInt64 {
    return _storage.1
  }
}

----Swift.(file)._SmallString.capacity
extension _SmallString  {
  internal var capacity: Int {
    @inline(__always) get {
      return _SmallString.capacity
    }
  }
}

----Swift.(file)._SmallString.count
extension _SmallString  {
  internal var count: Int {
    @inline(__always) get {
      return _StringObject.getSmallCount(fromRaw: rawDiscriminatedObject)
    }
  }
}

----Swift.(file)._SmallString.unusedCapacity
extension _SmallString  {
  internal var unusedCapacity: Int {
    @inline(__always) get { return capacity &- count }
  }
}

----Swift.(file)._SmallString.isASCII
extension _SmallString  {
  internal var isASCII: Bool {
    @inline(__always) get {
      return _StringObject.getSmallIsASCII(fromRaw: rawDiscriminatedObject)
    }
  }
}

----Swift.(file)._SmallString.zeroTerminatedRawCodeUnits
extension _SmallString  {
  internal var zeroTerminatedRawCodeUnits: RawBitPattern {
    let smallStringCodeUnitMask: UInt64 = 0x00FF_FFFF_FFFF_FFFF
    return (self._storage.0, self._storage.1 & smallStringCodeUnitMask)
  }
}

----Swift.(file)._SmallString.computeIsASCII()
extension _SmallString  {
  internal func computeIsASCII() -> Bool {
    let asciiMask: UInt64 = 0x8080_8080_8080_8080
    let raw = zeroTerminatedRawCodeUnits
    return (raw.0 | raw.1) & asciiMask == 0
  }
}

----Swift.(file)._SmallString.Index
extension _SmallString: RandomAccessCollection, MutableCollection  {
  internal typealias Index = I
}

----Swift.(file)._SmallString.Element
extension _SmallString: RandomAccessCollection, MutableCollection  {
  internal typealias Element = U
}

----Swift.(file)._SmallString.SubSequence
extension _SmallString: RandomAccessCollection, MutableCollection  {
  internal typealias SubSequence = _
}

----Swift.(file)._SmallString.startIndex
extension _SmallString: RandomAccessCollection, MutableCollection  {
  internal var startIndex: Int { @inline(__always) get { return 0 } }
}

----Swift.(file)._SmallString.endIndex
extension _SmallString: RandomAccessCollection, MutableCollection  {
  internal var endIndex: Int { @inline(__always) get { return count } }
}

----Swift.(file)._SmallString.subscript(_:Int)
extension _SmallString: RandomAccessCollection, MutableCollection  {
  internal subscript(_ idx: Int) -> UInt8 {
    @inline(__always) get {
      _internalInvariant(idx >= 0 && idx <= 15)
      if idx < 8 {
        return leadingRawBits._uncheckedGetByte(at: idx)
      } else {
        return trailingRawBits._uncheckedGetByte(at: idx &- 8)
      }
    }
    @inline(__always) set {
      _internalInvariant(idx >= 0 && idx <= 15)
      if idx < 8 {
        leadingRawBits._uncheckedSetByte(at: idx, to: newValue)
      } else {
        trailingRawBits._uncheckedSetByte(at: idx &- 8, to: newValue)
      }
    }
  }
}

----Swift.(file)._SmallString.subscript(_:Range<_SmallString.Index>)
extension _SmallString: RandomAccessCollection, MutableCollection  {
  internal subscript(_ bounds: Range<Index>) -> SubSequence {
    @inline(__always) get {
      // TODO(String performance): In-vector-register operation
      return self.withUTF8 { utf8 in
        let rebased = UnsafeBufferPointer(rebasing: utf8[bounds])
        return _SmallString(rebased)._unsafelyUnwrappedUnchecked
      }
    }
  }
}

----Swift.(file)._SmallString.withUTF8(_:(UnsafeBufferPointer<UInt8>) throws -> Result)
extension _SmallString  {
  internal func withUTF8<Result>(
    _ f: (UnsafeBufferPointer<UInt8>) throws -> Result
  ) rethrows -> Result {
    var raw = self.zeroTerminatedRawCodeUnits
    return try Swift.withUnsafeBytes(of: &raw) { rawBufPtr in
      let ptr = rawBufPtr.baseAddress._unsafelyUnwrappedUnchecked
        .assumingMemoryBound(to: UInt8.self)
      return try f(UnsafeBufferPointer(start: ptr, count: self.count))
    }
  }
}

----Swift.(file)._SmallString.withMutableCapacity(_:(UnsafeMutableBufferPointer<UInt8>) throws -> Int)
extension _SmallString  {
  internal mutating func withMutableCapacity(
    _ f: (UnsafeMutableBufferPointer<UInt8>) throws -> Int
  ) rethrows {
    let len = try withUnsafeMutableBytes(of: &self._storage) {
      (rawBufPtr: UnsafeMutableRawBufferPointer) -> Int in
      let ptr = rawBufPtr.baseAddress._unsafelyUnwrappedUnchecked
        .assumingMemoryBound(to: UInt8.self)
      return try f(UnsafeMutableBufferPointer(
        start: ptr, count: _SmallString.capacity))
    }
    _internalInvariant(len <= _SmallString.capacity)

    let (leading, trailing) = self.zeroTerminatedRawCodeUnits
    self = _SmallString(leading: leading, trailing: trailing, count: len)
  }
}

----Swift.(file)._SmallString.init(leading:UInt64,trailing:UInt64,count:Int)
extension _SmallString  {
  internal init(leading: UInt64, trailing: UInt64, count: Int) {
    _internalInvariant(count <= _SmallString.capacity)

    let isASCII = (leading | trailing) & 0x8080_8080_8080_8080 == 0
    let countAndDiscriminator = UInt64(truncatingIfNeeded: count) &<< 56
                              | _StringObject.Nibbles.small(isASCII: isASCII)
    _internalInvariant(trailing & countAndDiscriminator == 0)

    self.init(raw: (leading, trailing | countAndDiscriminator))
    _internalInvariant(self.count == count)
  }
}

----Swift.(file)._SmallString.init(_:UnsafeBufferPointer<UInt8>)
extension _SmallString  {
  internal init?(_ input: UnsafeBufferPointer<UInt8>) {
    let count = input.count
    guard count <= _SmallString.capacity else { return nil }

    // TODO(SIMD): The below can be replaced with just be a masked unaligned
    // vector load
    let ptr = input.baseAddress._unsafelyUnwrappedUnchecked
    let leading = _bytesToUInt64(ptr, Swift.min(input.count, 8))
    let trailing = count > 8 ? _bytesToUInt64(ptr + 8, count &- 8) : 0

    self.init(leading: leading, trailing: trailing, count: count)
  }
}

----Swift.(file)._SmallString.init(_:_SmallString,appending:_SmallString)
extension _SmallString  {
  internal init?(_ base: _SmallString, appending other: _SmallString) {
    let totalCount = base.count + other.count
    guard totalCount <= _SmallString.capacity else { return nil }

    // TODO(SIMD): The below can be replaced with just be a couple vector ops

    var result = base
    var writeIdx = base.count
    for readIdx in 0..<other.count {
      result[writeIdx] = other[readIdx]
      writeIdx &+= 1
    }
    _internalInvariant(writeIdx == totalCount)

    let (leading, trailing) = result.zeroTerminatedRawCodeUnits
    self.init(leading: leading, trailing: trailing, count: totalCount)
  }
}

----Swift.(file)._SmallString.init(taggedCocoa:AnyObject)
extension _SmallString  {
  internal init(taggedCocoa cocoa: AnyObject) {
    self.init()
    self.withMutableCapacity {
      let len = _bridgeTagged(cocoa, intoUTF8: $0)
      _internalInvariant(len != nil && len! < _SmallString.capacity,
        "Internal invariant violated: large tagged NSStrings")
      return len._unsafelyUnwrappedUnchecked
    }
    self._invariantCheck()
  }
}

----Swift.(file).Sequence.sorted()
extension Sequence where Element: Comparable  {
  public func sorted() -> [Element] {
    return sorted(by: <)
  }
}

----Swift.(file).Sequence.sorted(by:(Self.Element, Self.Element) throws -> Bool)
extension Sequence  {
  public func sorted(
    by areInIncreasingOrder:
      (Element, Element) throws -> Bool
  ) rethrows -> [Element] {
    var result = ContiguousArray(self)
    try result.sort(by: areInIncreasingOrder)
    return Array(result)
  }
}

----Swift.(file).MutableCollection.sort()
extension MutableCollection
where Self: RandomAccessCollection, Element: Comparable  {
  public mutating func sort() {
    sort(by: <)
  }
}

----Swift.(file).MutableCollection.sort(by:(Self.Element, Self.Element) throws -> Bool)
extension MutableCollection where Self: RandomAccessCollection  {
  public mutating func sort(
    by areInIncreasingOrder: (Element, Element) throws -> Bool
  ) rethrows {
    let didSortUnsafeBuffer = try _withUnsafeMutableBufferPointerIfSupported {
      buffer -> Void? in
        try buffer._stableSortImpl(by: areInIncreasingOrder)
    }
    if didSortUnsafeBuffer == nil {
      // Fallback since we can't use an unsafe buffer: sort into an outside
      // array, then copy elements back in.
      let sortedElements = try sorted(by: areInIncreasingOrder)
      for (i, j) in zip(indices, sortedElements.indices) {
        self[i] = sortedElements[j]
      }
    }
  }
}

----Swift.(file).StaticString.utf8Start
extension StaticString {
  public var utf8Start: UnsafePointer<UInt8> {
    _precondition(
      hasPointerRepresentation,
      "StaticString should have pointer representation")
    return UnsafePointer(bitPattern: UInt(_startPtrOrData))!
  }
}

----Swift.(file).StaticString.unicodeScalar
extension StaticString {
  public var unicodeScalar: Unicode.Scalar {
    _precondition(
      !hasPointerRepresentation,
      "StaticString should have Unicode scalar representation")
    return Unicode.Scalar(UInt32(UInt(_startPtrOrData)))!
  }
}

----Swift.(file).StaticString.utf8CodeUnitCount
extension StaticString {
  public var utf8CodeUnitCount: Int {
    _precondition(
      hasPointerRepresentation,
      "StaticString should have pointer representation")
    return Int(_utf8CodeUnitCount)
  }
}

----Swift.(file).StaticString.hasPointerRepresentation
extension StaticString {
  public var hasPointerRepresentation: Bool {
    return (UInt8(_flags) & 0x1) == 0
  }
}

----Swift.(file).StaticString.isASCII
extension StaticString {
  public var isASCII: Bool {
    return (UInt8(_flags) & 0x2) != 0
  }
}

----Swift.(file).StaticString.withUTF8Buffer(_:(UnsafeBufferPointer<UInt8>) -> R)
extension StaticString {
  public func withUTF8Buffer<R>(
    _ body: (UnsafeBufferPointer<UInt8>) -> R) -> R {
    if hasPointerRepresentation {
      return body(UnsafeBufferPointer(
        start: utf8Start, count: utf8CodeUnitCount))
    } else {
      var buffer: UInt64 = 0
      var i = 0
      let sink: (UInt8) -> Void = {
#if _endian(little)
        buffer = buffer | (UInt64($0) << (UInt64(i) * 8))
#else
        buffer = buffer | (UInt64($0) << (UInt64(7-i) * 8))
#endif
        i += 1
      }
      UTF8.encode(unicodeScalar, into: sink)
      return body(UnsafeBufferPointer(
        start: UnsafePointer(Builtin.addressof(&buffer)),
        count: i))
    }
  }
}

----Swift.(file).StaticString.init()
extension StaticString {
  public init() {
    self = ""
  }
}

----Swift.(file).StaticString.init(_start:<<error type>>,utf8CodeUnitCount:<<error type>>,isASCII:<<error type>>)
extension StaticString {
  internal init(
    _start: Builtin.RawPointer,
    utf8CodeUnitCount: Builtin.Word,
    isASCII: Builtin.Int1
  ) {
    // We don't go through UnsafePointer here to make things simpler for alias
    // analysis. A higher-level algorithm may be trying to make sure an
    // unrelated buffer is not accessed or freed.
    self._startPtrOrData = Builtin.ptrtoint_Word(_start)
    self._utf8CodeUnitCount = utf8CodeUnitCount
    self._flags = Bool(isASCII)
      ? (0x2 as UInt8)._value
      : (0x0 as UInt8)._value
  }
}

----Swift.(file).StaticString.init(unicodeScalar:<<error type>>)
extension StaticString {
  internal init(
    unicodeScalar: Builtin.Int32
  ) {
    self._startPtrOrData = UInt(UInt32(unicodeScalar))._builtinWordValue
    self._utf8CodeUnitCount = 0._builtinWordValue
    self._flags = Unicode.Scalar(_builtinUnicodeScalarLiteral: unicodeScalar).isASCII
      ? (0x3 as UInt8)._value
      : (0x1 as UInt8)._value
  }
}

----Swift.(file).StaticString.init(_builtinUnicodeScalarLiteral:<<error type>>)
extension StaticString {
  public init(_builtinUnicodeScalarLiteral value: Builtin.Int32) {
    self = StaticString(unicodeScalar: value)
  }
}

----Swift.(file).StaticString.init(unicodeScalarLiteral:StaticString)
extension StaticString {
  public init(unicodeScalarLiteral value: StaticString) {
    self = value
  }
}

----Swift.(file).StaticString.init(_builtinExtendedGraphemeClusterLiteral:<<error type>>,utf8CodeUnitCount:<<error type>>,isASCII:<<error type>>)
extension StaticString {
  public init(
    _builtinExtendedGraphemeClusterLiteral start: Builtin.RawPointer,
    utf8CodeUnitCount: Builtin.Word,
    isASCII: Builtin.Int1
  ) {
    self = StaticString(
      _builtinStringLiteral: start,
      utf8CodeUnitCount: utf8CodeUnitCount,
      isASCII: isASCII
    )
  }
}

----Swift.(file).StaticString.init(extendedGraphemeClusterLiteral:StaticString)
extension StaticString {
  public init(extendedGraphemeClusterLiteral value: StaticString) {
    self = value
  }
}

----Swift.(file).StaticString.init(_builtinStringLiteral:<<error type>>,utf8CodeUnitCount:<<error type>>,isASCII:<<error type>>)
extension StaticString {
  public init(
    _builtinStringLiteral start: Builtin.RawPointer,
    utf8CodeUnitCount: Builtin.Word,
    isASCII: Builtin.Int1
  ) {
    self = StaticString(
      _start: start,
      utf8CodeUnitCount: utf8CodeUnitCount,
      isASCII: isASCII)
  }
}

----Swift.(file).StaticString.init(stringLiteral:StaticString)
extension StaticString {
  public init(stringLiteral value: StaticString) {
    self = value
  }
}

----Swift.(file).StaticString.description
extension StaticString {
  public var description: String {
    return withUTF8Buffer { String._uncheckedFromUTF8($0) }
  }
}

----Swift.(file).StaticString.debugDescription
extension StaticString {
  public var debugDescription: String {
    return self.description.debugDescription
  }
}

----Swift.(file).StaticString.customMirror
extension StaticString  {
  public var customMirror: Mirror {
    return Mirror(reflecting: description)
  }
}

----Swift.(file).Strideable.Stride
extension Strideable {
  associatedtype Stride : SignedNumeric, C
}

----Swift.(file).Strideable.distance(to:Self)
extension Strideable {
  func distance(to other: Self) -> S
}

----Swift.(file).Strideable.advanced(by:Self.Stride)
extension Strideable {
  func advanced(by n: Stride) -> S
}

----Swift.(file).Strideable.<infix(_:Self,_:Self)
extension Strideable  {
  public static func < (x: Self, y: Self) -> Bool {
    return x.distance(to: y) > 0
  }
}

----Swift.(file).Strideable.==infix(_:Self,_:Self)
extension Strideable  {
  public static func == (x: Self, y: Self) -> Bool {
    return x.distance(to: y) == 0
  }
}

----Swift.(file).StrideToIterator.init(_start:Element,end:Element,stride:Element.Stride)
extension StrideToIterator {
  internal init(_start: Element, end: Element, stride: Element.Stride) {
    self._start = _start
    _end = end
    _stride = stride
    _current = (0, _start)
  }
}

----Swift.(file).StrideToIterator.next()
extension StrideToIterator: IteratorProtocol  {
  public mutating func next() -> Element? {
    let result = _current.value
    if _stride > 0 ? result >= _end : result <= _end {
      return nil
    }
    _current = Element._step(after: _current, from: _start, by: _stride)
    return result
  }
}

----Swift.(file).StrideTo.init(_start:Element,end:Element,stride:Element.Stride)
extension StrideTo {
  internal init(_start: Element, end: Element, stride: Element.Stride) {
    _precondition(stride != 0, "Stride size must not be zero")
    // At start, striding away from end is allowed; it just makes for an
    // already-empty Sequence.
    self._start = _start
    self._end = end
    self._stride = stride
  }
}

----Swift.(file).StrideTo.makeIterator()
extension StrideTo: Sequence  {
  public __consuming func makeIterator() -> StrideToIterator<Element> {
    return StrideToIterator(_start: _start, end: _end, stride: _stride)
  }
}

----Swift.(file).StrideTo.underestimatedCount
extension StrideTo: Sequence  {
  public var underestimatedCount: Int {
    var it = self.makeIterator()
    var count = 0
    while it.next() != nil {
      count += 1
    }
    return count
  }
}

----Swift.(file).StrideTo.customMirror
extension StrideTo: CustomReflectable  {
  public var customMirror: Mirror {
    return Mirror(self, children: ["from": _start, "to": _end, "by": _stride])
  }
}

----Swift.(file).stride(from:T,to:T,by:T.Stride)
public func stride<T>(
  from start: T, to end: T, by stride: T.Stride
) -> StrideTo<T> {
  return StrideTo(_start: start, end: end, stride: stride)
}

----Swift.(file).StrideThroughIterator.init(_start:Element,end:Element,stride:Element.Stride)
extension StrideThroughIterator {
  internal init(_start: Element, end: Element, stride: Element.Stride) {
    self._start = _start
    _end = end
    _stride = stride
    _current = (0, _start)
  }
}

----Swift.(file).StrideThroughIterator.next()
extension StrideThroughIterator: IteratorProtocol  {
  public mutating func next() -> Element? {
    let result = _current.value
    if _stride > 0 ? result >= _end : result <= _end {
      // This check is needed because if we just changed the above operators
      // to > and <, respectively, we might advance current past the end
      // and throw it out of bounds (e.g. above Int.max) unnecessarily.
      if result == _end && !_didReturnEnd {
        _didReturnEnd = true
        return result
      }
      return nil
    }
    _current = Element._step(after: _current, from: _start, by: _stride)
    return result
  }
}

----Swift.(file).StrideThrough.init(_start:Element,end:Element,stride:Element.Stride)
extension StrideThrough {
  internal init(_start: Element, end: Element, stride: Element.Stride) {
    _precondition(stride != 0, "Stride size must not be zero")
    self._start = _start
    self._end = end
    self._stride = stride
  }
}

----Swift.(file).StrideThrough.makeIterator()
extension StrideThrough: Sequence  {
  public __consuming func makeIterator() -> StrideThroughIterator<Element> {
    return StrideThroughIterator(_start: _start, end: _end, stride: _stride)
  }
}

----Swift.(file).StrideThrough.underestimatedCount
extension StrideThrough: Sequence  {
  public var underestimatedCount: Int {
    var it = self.makeIterator()
    var count = 0
    while it.next() != nil {
      count += 1
    }
    return count
  }
}

----Swift.(file).StrideThrough.customMirror
extension StrideThrough: CustomReflectable  {
  public var customMirror: Mirror {
    return Mirror(self,
      children: ["from": _start, "through": _end, "by": _stride])
  }
}

----Swift.(file).stride(from:T,through:T,by:T.Stride)
public func stride<T>(
  from start: T, through end: T, by stride: T.Stride
) -> StrideThrough<T> {
  return StrideThrough(_start: start, end: end, stride: stride)
}

----Swift.(file).unimplemented_utf8_32bit(_:String,file:StaticString,line:UInt)
internal func unimplemented_utf8_32bit(
  _ message: String = "",
  file: StaticString = #file, line: UInt = #line
) -> Never {
  fatalError("32-bit: Unimplemented for UTF-8 support", file: file, line: line)
}

----Swift.(file).String.init(_:_StringGuts)
extension String {
  internal init(_ _guts: _StringGuts) {
    self._guts = _guts
    _invariantCheck()
  }
}

----Swift.(file).String.init()
extension String {
  public init() { self.init(_StringGuts()) }
}

----Swift.(file).String.init(decoding:C,as:Encoding.Type)
extension String  {
  public init<C: Collection, Encoding: Unicode.Encoding>(
    decoding codeUnits: C, as sourceEncoding: Encoding.Type
  ) where C.Iterator.Element == Encoding.CodeUnit {
    if let contigBytes = codeUnits as? _HasContiguousBytes,
       sourceEncoding == UTF8.self,
       contigBytes._providesContiguousBytesNoCopy
    {
      self = contigBytes.withUnsafeBytes { rawBufPtr in
        let ptr = rawBufPtr.baseAddress._unsafelyUnwrappedUnchecked
        return String._fromUTF8Repairing(
          UnsafeBufferPointer(
            start: ptr.assumingMemoryBound(to: UInt8.self),
            count: rawBufPtr.count)).0
      }
      return
    }

    self = String._fromCodeUnits(
      codeUnits, encoding: sourceEncoding, repair: true)!.0
  }
}

----Swift.(file).String.withCString(encodedAs:TargetEncoding.Type,_:(UnsafePointer<TargetEncoding.CodeUnit>) throws -> Result)
extension String  {
  public func withCString<Result, TargetEncoding: Unicode.Encoding>(
    encodedAs targetEncoding: TargetEncoding.Type,
    _ body: (UnsafePointer<TargetEncoding.CodeUnit>) throws -> Result
  ) rethrows -> Result {
    if targetEncoding == UTF8.self {
      return try self.withCString {
        (cPtr: UnsafePointer<CChar>) -> Result  in
        _internalInvariant(UInt8.self == TargetEncoding.CodeUnit.self)
        let ptr = UnsafeRawPointer(cPtr).assumingMemoryBound(
          to: TargetEncoding.CodeUnit.self)
        return try body(ptr)
      }
    }
    return try _slowWithCString(encodedAs: targetEncoding, body)
  }
}

----Swift.(file).String.init(_builtinUnicodeScalarLiteral:<<error type>>)
extension String: _ExpressibleByBuiltinUnicodeScalarLiteral  {
  public init(_builtinUnicodeScalarLiteral value: Builtin.Int32) {
    self.init(Unicode.Scalar(_unchecked: UInt32(value)))
  }
}

----Swift.(file).String.init(_:Unicode.Scalar)
extension String: _ExpressibleByBuiltinUnicodeScalarLiteral  {
  public init(_ scalar: Unicode.Scalar) {
    self = scalar.withUTF8CodeUnits { String._uncheckedFromUTF8($0) }
  }
}

----Swift.(file).String.init(_builtinExtendedGraphemeClusterLiteral:<<error type>>,utf8CodeUnitCount:<<error type>>,isASCII:<<error type>>)
extension String: _ExpressibleByBuiltinExtendedGraphemeClusterLiteral  {
  public init(
    _builtinExtendedGraphemeClusterLiteral start: Builtin.RawPointer,
    utf8CodeUnitCount: Builtin.Word,
    isASCII: Builtin.Int1
  ) {
    self.init(
      _builtinStringLiteral: start,
      utf8CodeUnitCount: utf8CodeUnitCount,
      isASCII: isASCII)
  }
}

----Swift.(file).String.init(_builtinStringLiteral:<<error type>>,utf8CodeUnitCount:<<error type>>,isASCII:<<error type>>)
extension String: _ExpressibleByBuiltinStringLiteral  {
  public init(
    _builtinStringLiteral start: Builtin.RawPointer,
    utf8CodeUnitCount: Builtin.Word,
    isASCII: Builtin.Int1
    ) {
    let bufPtr = UnsafeBufferPointer(
      start: UnsafeRawPointer(start).assumingMemoryBound(to: UInt8.self),
      count: Int(utf8CodeUnitCount))
    if let smol = _SmallString(bufPtr) {
      self = String(_StringGuts(smol))
      return
    }
    self.init(_StringGuts(bufPtr, isASCII: Bool(isASCII)))
  }
}

----Swift.(file).String.init(stringLiteral:String)
extension String: ExpressibleByStringLiteral  {
  public init(stringLiteral value: String) {
    self = value
  }
}

----Swift.(file).String.debugDescription
extension String: CustomDebugStringConvertible  {
  public var debugDescription: String {
    var result = "\""
    for us in self.unicodeScalars {
      result += us.escaped(asASCII: false)
    }
    result += "\""
    return result
  }
}

----Swift.(file).String.+infix(_:String,_:String)
extension String  {
  public static func + (lhs: String, rhs: String) -> String {
    var result = lhs
    result.append(rhs)
    return result
  }
}

----Swift.(file).String.+=infix(_:String,_:String)
extension String  {
  public static func += (lhs: inout String, rhs: String) {
    lhs.append(rhs)
  }
}

----Swift.(file).Sequence.joined(separator:String)
extension Sequence where Element: StringProtocol  {
  public func joined(separator: String = "") -> String {
    return _joined(separator: separator)
  }
}

----Swift.(file).BidirectionalCollection.joined(separator:String)
extension BidirectionalCollection where Element == String  {
  public func joined(separator: String = "") -> String {
    return _joined(separator: separator)
  }
}

----Swift.(file).String.lowercased()
extension String  {
  public func lowercased() -> String {
    if _fastPath(_guts.isFastASCII) {
      return _guts.withFastUTF8 { utf8 in
        // TODO(String performance): We can directly call appendInPlace
        var result = String()
        result.reserveCapacity(utf8.count)
        for u8 in utf8 {
          result._guts.append(String(Unicode.Scalar(_lowercaseASCII(u8)))._guts)
        }
        return result
      }
    }

    // TODO(String performance): Try out incremental case-conversion rather than
    // make UTF-16 array beforehand
    let codeUnits = Array(self.utf16).withUnsafeBufferPointer {
      (uChars: UnsafeBufferPointer<UInt16>) -> Array<UInt16> in
      var result = Array<UInt16>(repeating: 0, count: uChars.count)
      let len = result.withUnsafeMutableBufferPointer {
        (output) -> Int in
        var err = __swift_stdlib_U_ZERO_ERROR
        return Int(truncatingIfNeeded:
          __swift_stdlib_u_strToLower(
            output.baseAddress._unsafelyUnwrappedUnchecked,
            Int32(output.count),
            uChars.baseAddress._unsafelyUnwrappedUnchecked,
            Int32(uChars.count),
            "",
            &err))
      }
      if len > uChars.count {
        var err = __swift_stdlib_U_ZERO_ERROR
        result = Array<UInt16>(repeating: 0, count: len)
        result.withUnsafeMutableBufferPointer {
          output -> Void in
          __swift_stdlib_u_strToLower(
            output.baseAddress._unsafelyUnwrappedUnchecked,
            Int32(output.count),
            uChars.baseAddress._unsafelyUnwrappedUnchecked,
            Int32(uChars.count),
            "",
            &err)
        }
      }
      return result
    }
    return codeUnits.withUnsafeBufferPointer { String._uncheckedFromUTF16($0) }
  }
}

----Swift.(file).String.uppercased()
extension String  {
  public func uppercased() -> String {
    if _fastPath(_guts.isFastASCII) {
      return _guts.withFastUTF8 { utf8 in
        // TODO(String performance): code-unit appendInPlace on guts
        var result = String()
        result.reserveCapacity(utf8.count)
        for u8 in utf8 {
          result._guts.append(String(Unicode.Scalar(_uppercaseASCII(u8)))._guts)
        }
        return result
      }
    }

    // TODO(String performance): Try out incremental case-conversion rather than
    // make UTF-16 array beforehand
    let codeUnits = Array(self.utf16).withUnsafeBufferPointer {
      (uChars: UnsafeBufferPointer<UInt16>) -> Array<UInt16> in
      var result = Array<UInt16>(repeating: 0, count: uChars.count)
      let len = result.withUnsafeMutableBufferPointer {
        (output) -> Int in
        var err = __swift_stdlib_U_ZERO_ERROR
        return Int(truncatingIfNeeded:
          __swift_stdlib_u_strToUpper(
            output.baseAddress._unsafelyUnwrappedUnchecked,
            Int32(output.count),
            uChars.baseAddress._unsafelyUnwrappedUnchecked,
            Int32(uChars.count),
            "",
            &err))
      }
      if len > uChars.count {
        var err = __swift_stdlib_U_ZERO_ERROR
        result = Array<UInt16>(repeating: 0, count: len)
        result.withUnsafeMutableBufferPointer {
          output -> Void in
          __swift_stdlib_u_strToUpper(
            output.baseAddress._unsafelyUnwrappedUnchecked,
            Int32(output.count),
            uChars.baseAddress._unsafelyUnwrappedUnchecked,
            Int32(uChars.count),
            "",
            &err)
        }
      }
      return result
    }
    return codeUnits.withUnsafeBufferPointer { String._uncheckedFromUTF16($0) }
  }
}

----Swift.(file).String.init(_:T)
extension String  {
  public init<T : LosslessStringConvertible>(_ value: T) {
    self = value.description
  }
}

----Swift.(file).String.description
extension String: CustomStringConvertible  {
  public var description: String { return self }
}

----Swift.(file)._StringBreadcrumbs.stride
extension _StringBreadcrumbs  {
  var stride: Int {
    @inline(__always) get { return _StringBreadcrumbs.breadcrumbStride }
  }
}

----Swift.(file)._StringBreadcrumbs.getBreadcrumb(forOffset:Int)
extension _StringBreadcrumbs  {
  internal func getBreadcrumb(
    forOffset offset: Int
  ) -> (lowerBound: String.Index, remaining: Int) {
    return (crumbs[offset / stride], offset % stride)
  }
}

----Swift.(file)._StringBreadcrumbs.getBreadcrumb(forIndex:String.Index)
extension _StringBreadcrumbs  {
  internal func getBreadcrumb(
    forIndex idx: String.Index
  ) -> (lowerBound: String.Index, offset: Int) {
    var lowerBound = idx.encodedOffset / 3 / stride
    var upperBound = Swift.min(1 + (idx.encodedOffset / stride), crumbs.count)
    _internalInvariant(crumbs[lowerBound] <= idx)
    _internalInvariant(upperBound == crumbs.count || crumbs[upperBound] >= idx)

    while (upperBound &- lowerBound) > 1 {
      let mid = lowerBound + ((upperBound &- lowerBound) / 2)
      if crumbs[mid] <= idx { lowerBound = mid } else { upperBound = mid }
    }

    let crumb = crumbs[lowerBound]
    _internalInvariant(crumb <= idx)
    _internalInvariant(lowerBound == crumbs.count-1 || crumbs[lowerBound+1] > idx)

    return (crumb, lowerBound &* stride)
  }
}

----Swift.(file)._StringGuts.getBreadcrumbsPtr()
extension _StringGuts  {
  internal func getBreadcrumbsPtr() -> UnsafePointer<_StringBreadcrumbs> {
    _internalInvariant(hasBreadcrumbs)

    let mutPtr: UnsafeMutablePointer<_StringBreadcrumbs?>
    if hasNativeStorage {
      mutPtr = _object.nativeStorage._breadcrumbsAddress
    } else {
      mutPtr = UnsafeMutablePointer(
        Builtin.addressof(&_object.sharedStorage._breadcrumbs))
    }

    if _slowPath(mutPtr.pointee == nil) {
      populateBreadcrumbs(mutPtr)
    }

    _internalInvariant(mutPtr.pointee != nil)
    return UnsafePointer(mutPtr)
  }
}

----Swift.(file)._StringGuts.populateBreadcrumbs(_:UnsafeMutablePointer<_StringBreadcrumbs?>)
extension _StringGuts  {
  internal func populateBreadcrumbs(
    _ mutPtr: UnsafeMutablePointer<_StringBreadcrumbs?>
  ) {
    // Thread-safe compare-and-swap
    let crumbs = _StringBreadcrumbs(String(self))
    _stdlib_atomicInitializeARCRef(
      object: UnsafeMutablePointer(mutPtr), desired: crumbs)
  }
}

----Swift.(file).kCFStringEncodingASCII
private var kCFStringEncodingASCII : _swift_shims_CFStringEncoding {
  @inline(__always) get { return 0x0600 }
}

----Swift.(file).kCFStringEncodingUTF8
private var kCFStringEncodingUTF8 : _swift_shims_CFStringEncoding {
  @inline(__always) get { return 0x8000100 }
}

----Swift.(file).String.init(_cocoaString:AnyObject)
extension String  {
  init(_cocoaString: AnyObject) {
    self._guts = _bridgeCocoaString(_cocoaString)
  }
}

----Swift.(file).String.IndexDistance
extension String: BidirectionalCollection  {
  public typealias IndexDistance = I
}

----Swift.(file).String.SubSequence
extension String: BidirectionalCollection  {
  public typealias SubSequence = S
}

----Swift.(file).String.Element
extension String: BidirectionalCollection  {
  public typealias Element = C
}

----Swift.(file).String.startIndex
extension String: BidirectionalCollection  {
  public var startIndex: Index {
    @inline(__always) get { return _guts.startIndex }
  }
}

----Swift.(file).String.endIndex
extension String: BidirectionalCollection  {
  public var endIndex: Index {
    @inline(__always) get { return _guts.endIndex }
  }
}

----Swift.(file).String.count
extension String: BidirectionalCollection  {
  public var count: Int {
    @inline(__always) get {
      return distance(from: startIndex, to: endIndex)
    }
  }
}

----Swift.(file).String.index(after:String.Index)
extension String: BidirectionalCollection  {
  public func index(after i: Index) -> Index {
    _precondition(i < endIndex, "String index is out of bounds")

    // TODO: known-ASCII fast path, single-scalar-grapheme fast path, etc.
    let stride = _characterStride(startingAt: i)
    let nextOffset = i.encodedOffset &+ stride
    let nextStride = _characterStride(
      startingAt: Index(encodedOffset: nextOffset))

    return Index(
      encodedOffset: nextOffset, characterStride: nextStride)
  }
}

----Swift.(file).String.index(before:String.Index)
extension String: BidirectionalCollection  {
  public func index(before i: Index) -> Index {
    _precondition(i > startIndex, "String index is out of bounds")

    // TODO: known-ASCII fast path, single-scalar-grapheme fast path, etc.
    let stride = _characterStride(endingAt: i)
    let priorOffset = i.encodedOffset &- stride
    return Index(encodedOffset: priorOffset, characterStride: stride)
  }
}

----Swift.(file).String.index(_:String.Index,offsetBy:String.IndexDistance)
extension String: BidirectionalCollection  {
  public func index(_ i: Index, offsetBy n: IndexDistance) -> Index {
    // TODO: known-ASCII and single-scalar-grapheme fast path, etc.
    return _index(i, offsetBy: n)
  }
}

----Swift.(file).String.index(_:String.Index,offsetBy:String.IndexDistance,limitedBy:String.Index)
extension String: BidirectionalCollection  {
  public func index(
    _ i: Index, offsetBy n: IndexDistance, limitedBy limit: Index
  ) -> Index? {
    // TODO: known-ASCII and single-scalar-grapheme fast path, etc.
    return _index(i, offsetBy: n, limitedBy: limit)
  }
}

----Swift.(file).String.distance(from:String.Index,to:String.Index)
extension String: BidirectionalCollection  {
  public func distance(from start: Index, to end: Index) -> IndexDistance {
    // TODO: known-ASCII and single-scalar-grapheme fast path, etc.
    return _distance(from: start, to: end)
  }
}

----Swift.(file).String.subscript(_:String.Index)
extension String: BidirectionalCollection  {
  public subscript(i: Index) -> Character {
    @inline(__always) get {
      _boundsCheck(i)

      let i = _guts.scalarAlign(i)
      let distance = _characterStride(startingAt: i)
      return _guts.errorCorrectedCharacter(
        startingAt: i.encodedOffset, endingAt: i.encodedOffset &+ distance)
    }
  }
}

----Swift.(file).String.Iterator.init(_:_StringGuts)
extension String.Iterator {
    internal init(_ guts: _StringGuts) {
      self._end = guts.count
      self._guts = guts
    }
}

----Swift.(file).String.Iterator.next()
extension String.Iterator {
    public mutating func next() -> Character? {
      guard _fastPath(_position < _end) else { return nil }

      let len = _guts._opaqueCharacterStride(startingAt: _position)
      let nextPosition = _position &+ len
      let result = _guts.errorCorrectedCharacter(
        startingAt: _position, endingAt: nextPosition)
      _position = nextPosition
      return result
    }
}

----Swift.(file).String.makeIterator()
extension String  {
  public __consuming func makeIterator() -> Iterator {
    return Iterator(_guts)
  }
}

----Swift.(file).StringProtocol.==infix(_:Self,_:RHS)
extension StringProtocol  {
  public static func == <RHS: StringProtocol>(lhs: Self, rhs: RHS) -> Bool {
    return _stringCompare(
      lhs._wholeGuts, lhs._offsetRange,
      rhs._wholeGuts, rhs._offsetRange,
      expecting: .equal)
  }
}

----Swift.(file).StringProtocol.!=infix(_:Self,_:RHS)
extension StringProtocol  {
  public static func != <RHS: StringProtocol>(lhs: Self, rhs: RHS) -> Bool {
    return !(lhs == rhs)
  }
}

----Swift.(file).StringProtocol.<infix(_:Self,_:RHS)
extension StringProtocol  {
  public static func < <RHS: StringProtocol>(lhs: Self, rhs: RHS) -> Bool {
    return _stringCompare(
      lhs._wholeGuts, lhs._offsetRange,
      rhs._wholeGuts, rhs._offsetRange,
      expecting: .less)
  }
}

----Swift.(file).StringProtocol.>infix(_:Self,_:RHS)
extension StringProtocol  {
  public static func > <RHS: StringProtocol>(lhs: Self, rhs: RHS) -> Bool {
    return rhs < lhs
  }
}

----Swift.(file).StringProtocol.<=infix(_:Self,_:RHS)
extension StringProtocol  {
  public static func <= <RHS: StringProtocol>(lhs: Self, rhs: RHS) -> Bool {
    return !(rhs < lhs)
  }
}

----Swift.(file).StringProtocol.>=infix(_:Self,_:RHS)
extension StringProtocol  {
  public static func >= <RHS: StringProtocol>(lhs: Self, rhs: RHS) -> Bool {
    return !(lhs < rhs)
  }
}

----Swift.(file).String.==infix(_:String,_:String)
extension String : Equatable  {
  public static func == (lhs: String, rhs: String) -> Bool {
    return _stringCompare(lhs._guts, rhs._guts, expecting: .equal)
  }
}

----Swift.(file).String.<infix(_:String,_:String)
extension String : Comparable  {
  public static func < (lhs: String, rhs: String) -> Bool {
    return _stringCompare(lhs._guts, rhs._guts, expecting: .less)
  }
}

----Swift.(file)..(error_type).withNFCCodeUnitsIterator(_:<<error type>>)
extension _StringGutsSlice  {
  internal func withNFCCodeUnitsIterator<R>(
    _ f: (_NormalizedUTF8CodeUnitIterator) throws -> R
  ) rethrows -> R {
    defer { _fixLifetime(self) }
    if self.isNFCFastUTF8 {
      return try self.withFastUTF8 {
        return try f(_NormalizedUTF8CodeUnitIterator($0, range: 0..<$0.count))
      }
    }
    if self.isFastUTF8 {
      return try self.withFastUTF8 {
        return try f(_NormalizedUTF8CodeUnitIterator($0, range: 0..<$0.count))
      }
    }
    return try f(_NormalizedUTF8CodeUnitIterator(
      foreign: self._guts, range: self.range))
  }
}

----Swift.(file)..(error_type).withNFCCodeUnitsIterator_2(_:<<error type>>)
extension _StringGutsSlice  {
  internal func withNFCCodeUnitsIterator_2<R>(
    _ f: (_NormalizedUTF8CodeUnitIterator_2) throws -> R
  ) rethrows -> R {
    defer { _fixLifetime(self) }
    return try f(_NormalizedUTF8CodeUnitIterator_2(self))
  }
}

----Swift.(file)..(error_type).compare(with:<<error type>>,expecting:_StringComparisonResult)
extension _StringGutsSlice  {
  internal func compare(
    with other: _StringGutsSlice, expecting: _StringComparisonResult
  ) -> Bool {
    if _fastPath(self.isFastUTF8 && other.isFastUTF8) {
      Builtin.onFastPath() // aggressively inline / optimize
      let isEqual = self.withFastUTF8 { utf8Self in
        return other.withFastUTF8 { utf8Other in
          return 0 == _binaryCompare(utf8Self, utf8Other)
        }
      }
      if isEqual { return expecting == .equal }
    }

    return _slowCompare(with: other, expecting: expecting)
  }
}

----Swift.(file)._StringGuts.isOnGraphemeClusterBoundary(_:String.Index)
extension _StringGuts  {
  internal func isOnGraphemeClusterBoundary(_ i: String.Index) -> Bool {
    guard i.transcodedOffset == 0 else { return false }

    let offset = i.encodedOffset
    if offset == 0 || offset == self.count { return true }

    guard isOnUnicodeScalarBoundary(i) else { return false }

    let str = String(self)
    return i == str.index(before: str.index(after: i))
  }
}

----Swift.(file)._StringGuts.rawBits
extension _StringGuts  {
  internal var rawBits: _StringObject.RawBitPattern {
    @inline(__always) get { return _object.rawBits }
  }
}

----Swift.(file)._StringGuts.init(_:<<error type>>)
extension _StringGuts  {
  internal init(_ smol: _SmallString) {
    self.init(_StringObject(smol))
  }
}

----Swift.(file)._StringGuts.init(_:UnsafeBufferPointer<UInt8>,isASCII:Bool)
extension _StringGuts  {
  internal init(_ bufPtr: UnsafeBufferPointer<UInt8>, isASCII: Bool) {
    self.init(_StringObject(immortal: bufPtr, isASCII: isASCII))
  }
}

----Swift.(file)._StringGuts.init(_:<<error type>>)
extension _StringGuts  {
  internal init(_ storage: _StringStorage) {
    self.init(_StringObject(storage))
  }
}

----Swift.(file)._StringGuts.init(_:<<error type>>)
extension _StringGuts  {
  internal init(_ storage: _SharedStringStorage) {
    self.init(_StringObject(storage))
  }
}

----Swift.(file)._StringGuts.init(cocoa:AnyObject,providesFastUTF8:Bool,isASCII:Bool,length:Int)
extension _StringGuts  {
  internal init(
    cocoa: AnyObject, providesFastUTF8: Bool, isASCII: Bool, length: Int
  ) {
    self.init(_StringObject(
      cocoa: cocoa,
      providesFastUTF8: providesFastUTF8,
      isASCII: isASCII,
      length: length))
  }
}

----Swift.(file)._StringGuts.count
extension _StringGuts  {
  internal var count: Int { @inline(__always) get { return _object.count } }
}

----Swift.(file)._StringGuts.isEmpty
extension _StringGuts  {
  internal var isEmpty: Bool { @inline(__always) get { return count == 0 } }
}

----Swift.(file)._StringGuts.isSmall
extension _StringGuts  {
  internal var isSmall: Bool {
    @inline(__always) get { return _object.isSmall }
  }
}

----Swift.(file)._StringGuts.isSmallASCII
extension _StringGuts  {
  internal var isSmallASCII: Bool {
    @inline(__always) get { return _object.isSmall && _object.smallIsASCII }
  }
}

----Swift.(file)._StringGuts.asSmall
extension _StringGuts  {
  internal var asSmall: _SmallString {
    @inline(__always) get { return _SmallString(_object) }
  }
}

----Swift.(file)._StringGuts.isASCII
extension _StringGuts  {
  internal var isASCII: Bool  {
    @inline(__always) get { return _object.isASCII }
  }
}

----Swift.(file)._StringGuts.isFastASCII
extension _StringGuts  {
  internal var isFastASCII: Bool  {
    @inline(__always) get { return isFastUTF8 && _object.isASCII }
  }
}

----Swift.(file)._StringGuts.isNFC
extension _StringGuts  {
  internal var isNFC: Bool { return _object.isNFC }
}

----Swift.(file)._StringGuts.isNFCFastUTF8
extension _StringGuts  {
  internal var isNFCFastUTF8: Bool {
    // TODO(String micro-performance): Consider a dedicated bit for this
    return _object.isNFC && isFastUTF8
  }
}

----Swift.(file)._StringGuts.hasNativeStorage
extension _StringGuts  {
  internal var hasNativeStorage: Bool { return _object.hasNativeStorage }
}

----Swift.(file)._StringGuts.hasSharedStorage
extension _StringGuts  {
  internal var hasSharedStorage: Bool { return _object.hasSharedStorage }
}

----Swift.(file)._StringGuts.hasBreadcrumbs
extension _StringGuts  {
  internal var hasBreadcrumbs: Bool {
    return hasNativeStorage || hasSharedStorage
  }
}

----Swift.(file)._StringGuts.isFastUTF8
extension _StringGuts  {
  internal var isFastUTF8: Bool { return _fastPath(_object.providesFastUTF8) }
}

----Swift.(file)._StringGuts.isForeign
extension _StringGuts  {
  internal var isForeign: Bool {
    @inline(__always) get { return _slowPath(_object.isForeign) }
  }
}

----Swift.(file)._StringGuts.withFastUTF8(_:(UnsafeBufferPointer<UInt8>) throws -> R)
extension _StringGuts  {
  internal func withFastUTF8<R>(
    _ f: (UnsafeBufferPointer<UInt8>) throws -> R
  ) rethrows -> R {
    _internalInvariant(isFastUTF8)

    if self.isSmall { return try _SmallString(_object).withUTF8(f) }

    defer { _fixLifetime(self) }
    return try f(_object.fastUTF8)
  }
}

----Swift.(file)._StringGuts.withFastUTF8(range:Range<Int>,_:(UnsafeBufferPointer<UInt8>) throws -> R)
extension _StringGuts  {
  internal func withFastUTF8<R>(
    range: Range<Int>,
    _ f: (UnsafeBufferPointer<UInt8>) throws -> R
  ) rethrows -> R {
    return try self.withFastUTF8 { wholeUTF8 in
      return try f(UnsafeBufferPointer(rebasing: wholeUTF8[range]))
    }
  }
}

----Swift.(file)._StringGuts.withFastCChar(_:(UnsafeBufferPointer<CChar>) throws -> R)
extension _StringGuts  {
  internal func withFastCChar<R>(
    _ f: (UnsafeBufferPointer<CChar>) throws -> R
  ) rethrows -> R {
    return try self.withFastUTF8 { utf8 in
      let ptr = utf8.baseAddress._unsafelyUnwrappedUnchecked._asCChar
      return try f(UnsafeBufferPointer(start: ptr, count: utf8.count))
    }
  }
}

----Swift.(file)._StringGuts.withCString(_:(UnsafePointer<Int8>) throws -> Result)
extension _StringGuts  {
  internal func withCString<Result>(
    _ body: (UnsafePointer<Int8>) throws -> Result
  ) rethrows -> Result {
    if _slowPath(!_object.isFastZeroTerminated) {
      return try _slowWithCString(body)
    }

    return try self.withFastCChar {
      return try body($0.baseAddress._unsafelyUnwrappedUnchecked)
    }
  }
}

----Swift.(file)._StringGuts.copyUTF8(into:UnsafeMutableBufferPointer<UInt8>)
extension _StringGuts  {
  internal func copyUTF8(into mbp: UnsafeMutableBufferPointer<UInt8>) -> Int? {
    let ptr = mbp.baseAddress._unsafelyUnwrappedUnchecked
    if _fastPath(self.isFastUTF8) {
      return self.withFastUTF8 { utf8 in
        guard utf8.count <= mbp.count else { return nil }

        let utf8Start = utf8.baseAddress._unsafelyUnwrappedUnchecked
        ptr.initialize(from: utf8Start, count: utf8.count)
        return utf8.count
      }
    }

    return _foreignCopyUTF8(into: mbp)
  }
}

----Swift.(file)._StringGuts.utf8Count
extension _StringGuts  {
  internal var utf8Count: Int {
    @inline(__always) get {
      if _fastPath(self.isFastUTF8) { return count }
      return String(self).utf8.count
    }
  }
}

----Swift.(file)._StringGuts.Index
extension _StringGuts  {
  internal typealias Index = String.I
}

----Swift.(file)._StringGuts.startIndex
extension _StringGuts  {
  internal var startIndex: String.Index {
    @inline(__always) get { return Index(encodedOffset: 0) }
  }
}

----Swift.(file)._StringGuts.endIndex
extension _StringGuts  {
  internal var endIndex: String.Index {
    @inline(__always) get { return Index(encodedOffset: self.count) }
  }
}

----Swift.(file)._StringGuts.startASCII
extension _StringGuts  {
  public var startASCII: UnsafeMutablePointer<UInt8> {
    return UnsafeMutablePointer(mutating: _object.fastUTF8.baseAddress!)
  }
}

----Swift.(file)._StringGuts.startUTF16
extension _StringGuts  {
  public var startUTF16: UnsafeMutablePointer<UTF16.CodeUnit> {
    fatalError("Not contiguous UTF-16")
  }
}

----Swift.(file)._StringGuts.nativeCapacity
extension _StringGuts  {
  internal var nativeCapacity: Int? {
      guard hasNativeStorage else { return nil }
      return _object.nativeStorage.capacity
  }
}

----Swift.(file)._StringGuts.nativeUnusedCapacity
extension _StringGuts  {
  internal var nativeUnusedCapacity: Int? {
      guard hasNativeStorage else { return nil }
      return _object.nativeStorage.unusedCapacity
  }
}

----Swift.(file)._StringGuts.uniqueNativeCapacity
extension _StringGuts  {
  internal var uniqueNativeCapacity: Int? {
    @inline(__always) mutating get {
      guard isUniqueNative else { return nil }
      return _object.nativeStorage.capacity
    }
  }
}

----Swift.(file)._StringGuts.uniqueNativeUnusedCapacity
extension _StringGuts  {
  internal var uniqueNativeUnusedCapacity: Int? {
    @inline(__always) mutating get {
      guard isUniqueNative else { return nil }
      return _object.nativeStorage.unusedCapacity
    }
  }
}

----Swift.(file)._StringGuts.isUniqueNative
extension _StringGuts  {
  internal var isUniqueNative: Bool {
    @inline(__always) mutating get {
      // Note: mutating so that self is `inout`.
      guard hasNativeStorage else { return false }
      defer { _fixLifetime(self) }
      var bits: UInt = _object.largeAddressBits
      return _isUnique_native(&bits)
    }
  }
}

----Swift.(file)._StringGuts.init(_initialCapacity:Int)
extension _StringGuts  {
  internal init(_initialCapacity capacity: Int) {
    self.init()
    if _slowPath(capacity > _SmallString.capacity) {
      self.grow(capacity)
    }
  }
}

----Swift.(file)._StringGuts.reserveCapacity(_:Int)
extension _StringGuts  {
  internal mutating func reserveCapacity(_ n: Int) {
    // Check if there's nothing to do
    if n <= _SmallString.capacity { return }
    if let currentCap = self.uniqueNativeCapacity, currentCap >= n { return }

    // Grow
    self.grow(n)
  }
}

----Swift.(file)._StringGuts.grow(_:Int)
extension _StringGuts  {
  internal mutating func grow(_ n: Int) {
    defer { self._invariantCheck() }

    _internalInvariant(
      self.uniqueNativeCapacity == nil || self.uniqueNativeCapacity! < n)

    let growthTarget = Swift.max(n, (self.uniqueNativeCapacity ?? 0) * 2)

    if _fastPath(isFastUTF8) {
      let isASCII = self.isASCII
      let storage = self.withFastUTF8 {
        _StringStorage.create(
          initializingFrom: $0, capacity: growthTarget, isASCII: isASCII)
      }

      self = _StringGuts(storage)
      return
    }

    _foreignGrow(growthTarget)
  }
}

----Swift.(file)._StringGuts.prepareForAppendInPlace(otherUTF8Count:Int)
extension _StringGuts  {
  private mutating func prepareForAppendInPlace(
    otherUTF8Count otherCount: Int
  ) {
    defer {
      _internalInvariant(self.uniqueNativeUnusedCapacity != nil,
        "growth should produce uniqueness")
      _internalInvariant(self.uniqueNativeUnusedCapacity! >= otherCount,
        "growth should produce enough capacity")
    }

    // See if we can accomodate without growing or copying. If we have
    // sufficient capacity, we do not need to grow, and we can skip the copy if
    // unique. Otherwise, growth is required.
    let sufficientCapacity: Bool
    if let unused = self.nativeUnusedCapacity, unused >= otherCount {
      sufficientCapacity = true
    } else {
      sufficientCapacity = false
    }
    if self.isUniqueNative && sufficientCapacity {
      return
    }

    let totalCount = self.utf8Count + otherCount

    // Non-unique storage: just make a copy of the appropriate size, otherwise
    // grow like an array.
    let growthTarget: Int
    if sufficientCapacity {
      growthTarget = totalCount
    } else {
      growthTarget = Swift.max(
        totalCount, _growArrayCapacity(nativeCapacity ?? 0))
    }
    self.grow(growthTarget)
  }
}

----Swift.(file)._StringGuts.append(_:_StringGuts)
extension _StringGuts  {
  internal mutating func append(_ other: _StringGuts) {
    if self.isSmall && other.isSmall {
      if let smol = _SmallString(self.asSmall, appending: other.asSmall) {
        self = _StringGuts(smol)
        return
      }
    }

    append(_StringGutsSlice(other))
  }
}

----Swift.(file)._StringGuts.append(_:<<error type>>)
extension _StringGuts  {
  internal mutating func append(_ slicedOther: _StringGutsSlice) {
    defer { self._invariantCheck() }

    if self.isSmall && slicedOther._guts.isSmall {
      // TODO: In-register slicing
      let smolSelf = self.asSmall
      if let smol = slicedOther.withFastUTF8({ otherUTF8 in
        return _SmallString(smolSelf, appending: _SmallString(otherUTF8)!)
      }) {
        self = _StringGuts(smol)
        return
      }
    }

    prepareForAppendInPlace(otherUTF8Count: slicedOther.utf8Count)

    if slicedOther.isFastUTF8 {
      let otherIsASCII = slicedOther.isASCII
      slicedOther.withFastUTF8 { otherUTF8 in
        self.appendInPlace(otherUTF8, isASCII: otherIsASCII)
      }
      return
    }

    _foreignAppendInPlace(slicedOther)
  }
}

----Swift.(file)._StringGuts.appendInPlace(_:UnsafeBufferPointer<UInt8>,isASCII:Bool)
extension _StringGuts  {
  internal mutating func appendInPlace(
    _ other: UnsafeBufferPointer<UInt8>, isASCII: Bool
  ) {
    self._object.nativeStorage.appendInPlace(other, isASCII: isASCII)

    // We re-initialize from the modified storage to pick up new count, flags,
    // etc.
    self = _StringGuts(self._object.nativeStorage)
  }
}

----Swift.(file)._StringGuts.clear()
extension _StringGuts  {
  internal mutating func clear() {
    guard isUniqueNative else {
      self = _StringGuts()
      return
    }

    // Reset the count
    _object.nativeStorage.clear()
    self = _StringGuts(_object.nativeStorage)
  }
}

----Swift.(file)._StringGuts.remove(from:<<error type>>,to:<<error type>>)
extension _StringGuts  {
  internal mutating func remove(from lower: Index, to upper: Index) {
    let lowerOffset = lower.encodedOffset
    let upperOffset = upper.encodedOffset
    _internalInvariant(lower.transcodedOffset == 0 && upper.transcodedOffset == 0)
    _internalInvariant(lowerOffset <= upperOffset && upperOffset <= self.count)

    if isUniqueNative {
      _object.nativeStorage.remove(from: lowerOffset, to: upperOffset)
      // We re-initialize from the modified storage to pick up new count, flags,
      // etc.
      self = _StringGuts(self._object.nativeStorage)
      return
    }

    // TODO(cleanup): Add append on guts taking range, use that
    var result = String()
    // FIXME: It should be okay to get rid of excess capacity
    // here. rdar://problem/45635432
    result.reserveCapacity(
      nativeCapacity ?? (count &- (upperOffset &- lowerOffset)))
    result.append(contentsOf: String(self)[..<lower])
    result.append(contentsOf: String(self)[upper...])
    self = result._guts
  }
}

----Swift.(file)._StringGuts.replaceSubrange(_:<<error type>>,with:C)
extension _StringGuts  {
  internal mutating func replaceSubrange<C>(
    _ bounds: Range<Index>,
    with newElements: C
  ) where C : Collection, C.Iterator.Element == Character {
    if isUniqueNative {
      if let replStr = newElements as? String, replStr._guts.isFastUTF8 {
        replStr._guts.withFastUTF8 {
          uniqueNativeReplaceSubrange(
            bounds, with: $0, isASCII: replStr._guts.isASCII)
        }
        return
      }
      uniqueNativeReplaceSubrange(
        bounds, with: newElements.lazy.flatMap { $0.utf8 })
      return
    }

    var result = String()
    // FIXME: It should be okay to get rid of excess capacity
    // here. rdar://problem/45635432
    if let capacity = self.nativeCapacity {
      result.reserveCapacity(capacity)
    }
    let selfStr = String(self)
    result.append(contentsOf: selfStr[..<bounds.lowerBound])
    result.append(contentsOf: newElements)
    result.append(contentsOf: selfStr[bounds.upperBound...])
    self = result._guts
  }
}

----Swift.(file)._StringGuts.uniqueNativeReplaceSubrange(_:<<error type>>,with:UnsafeBufferPointer<UInt8>,isASCII:Bool)
extension _StringGuts  {
  internal mutating func uniqueNativeReplaceSubrange(
    _ bounds: Range<Index>,
    with codeUnits: UnsafeBufferPointer<UInt8>,
    isASCII: Bool
  ) {
    let neededCapacity =
      bounds.lowerBound.encodedOffset
      + codeUnits.count + (self.count - bounds.upperBound.encodedOffset)
    reserveCapacity(neededCapacity)

    _internalInvariant(bounds.lowerBound.transcodedOffset == 0)
    _internalInvariant(bounds.upperBound.transcodedOffset == 0)

    _object.nativeStorage.replace(
      from: bounds.lowerBound.encodedOffset,
      to: bounds.upperBound.encodedOffset,
      with: codeUnits)
    self = _StringGuts(_object.nativeStorage)
  }
}

----Swift.(file)._StringGuts.uniqueNativeReplaceSubrange(_:<<error type>>,with:C)
extension _StringGuts  {
  internal mutating func uniqueNativeReplaceSubrange<C: Collection>(
    _ bounds: Range<Index>,
    with codeUnits: C
  ) where C.Element == UInt8 {
    let replCount = codeUnits.count

    let neededCapacity =
      bounds.lowerBound.encodedOffset
      + replCount + (self.count - bounds.upperBound.encodedOffset)
    reserveCapacity(neededCapacity)

    _internalInvariant(bounds.lowerBound.transcodedOffset == 0)
    _internalInvariant(bounds.upperBound.transcodedOffset == 0)

    _object.nativeStorage.replace(
      from: bounds.lowerBound.encodedOffset,
      to: bounds.upperBound.encodedOffset,
      with: codeUnits,
      replacementCount: replCount)
    self = _StringGuts(_object.nativeStorage)
  }
}

----Swift.(file).String.hash(into:Hasher)
extension String : Hashable  {
  public func hash(into hasher: inout Hasher) {
    if _fastPath(self._guts.isNFCFastUTF8) {
      self._guts.withFastUTF8 {
        hasher.combine(bytes: UnsafeRawBufferPointer($0))
      }
      hasher.combine(0xFF as UInt8) // terminator
      return
    }

    _gutsSlice._normalizedHash(into: &hasher)
  }
}

----Swift.(file).StringProtocol.hash(into:Hasher)
extension StringProtocol  {
  public func hash(into hasher: inout Hasher) {
    _gutsSlice._normalizedHash(into: &hasher)
  }
}

----Swift.(file).String.Index.init(_:UInt64)
extension String.Index {
    init(_ raw: UInt64) {
      self._rawBits = raw
      self._invariantCheck()
    }
}

----Swift.(file)..(error_type).orderingValue
extension String.Index  {
  internal var orderingValue: UInt64 {
    // TODO(String micro-performance): Consider mask instead of shift
    @inline(__always) get { return _rawBits &>> 14 }
  }
}

----Swift.(file)..(error_type).isZeroPosition
extension String.Index  {
  internal var isZeroPosition: Bool {
    @inline(__always) get { return orderingValue == 0 }
  }
}

----Swift.(file)..(error_type).encodedOffset
extension String.Index  {
  public var encodedOffset: Int {
    @inline(__always) get { return Int(truncatingIfNeeded: _rawBits &>> 16) }
  }
}

----Swift.(file)..(error_type).transcodedOffset
extension String.Index  {
  internal var transcodedOffset: Int {
    @inline(__always) get {
      return Int(truncatingIfNeeded: orderingValue & 0x3)
    }
  }
}

----Swift.(file)..(error_type).characterStride
extension String.Index  {
  internal var characterStride: Int? {
    let value = (_rawBits & 0x3F00) &>> 8
    return value > 0 ? Int(truncatingIfNeeded: value) : nil
  }
}

----Swift.(file)..(error_type).init(encodedOffset:Int,transcodedOffset:Int)
extension String.Index  {
  internal init(encodedOffset: Int, transcodedOffset: Int) {
    let pos = UInt64(truncatingIfNeeded: encodedOffset)
    let trans = UInt64(truncatingIfNeeded: transcodedOffset)
    _internalInvariant(pos == pos & 0x0000_FFFF_FFFF_FFFF)
    _internalInvariant(trans <= 3)

    self.init((pos &<< 16) | (trans &<< 14))
  }
}

----Swift.(file)..(error_type).init(encodedOffset:Int)
extension String.Index  {
  public init(encodedOffset: Int) {
    self.init(encodedOffset: encodedOffset, transcodedOffset: 0)
  }
}

----Swift.(file)..(error_type).init(encodedOffset:Int,transcodedOffset:Int,characterStride:Int)
extension String.Index  {
  internal init(
    encodedOffset: Int, transcodedOffset: Int, characterStride: Int
  ) {
    self.init(encodedOffset: encodedOffset, transcodedOffset: transcodedOffset)
    if _slowPath(characterStride > 63) { return }

    _internalInvariant(characterStride == characterStride & 0x3F)
    self._rawBits |= UInt64(truncatingIfNeeded: characterStride &<< 8)
    self._invariantCheck()
  }
}

----Swift.(file)..(error_type).init(encodedOffset:Int,characterStride:Int)
extension String.Index  {
  internal init(encodedOffset pos: Int, characterStride char: Int) {
    self.init(encodedOffset: pos, transcodedOffset: 0, characterStride: char)
  }
}

----Swift.(file)..(error_type).strippingTranscoding
extension String.Index  {
  internal var strippingTranscoding: String.Index {
    @inline(__always) get {
      return String.Index(encodedOffset: self.encodedOffset)
    }
  }
}

----Swift.(file)..(error_type).nextEncoded
extension String.Index  {
  internal var nextEncoded: String.Index {
    @inline(__always) get {
      _internalInvariant(self.transcodedOffset == 0)
      return String.Index(encodedOffset: self.encodedOffset &+ 1)
    }
  }
}

----Swift.(file)..(error_type).priorEncoded
extension String.Index  {
  internal var priorEncoded: String.Index {
    @inline(__always) get {
      _internalInvariant(self.transcodedOffset == 0)
      return String.Index(encodedOffset: self.encodedOffset &- 1)
    }
  }
}

----Swift.(file)..(error_type).nextTranscoded
extension String.Index  {
  internal var nextTranscoded: String.Index {
    @inline(__always) get {
      return String.Index(
        encodedOffset: self.encodedOffset,
        transcodedOffset: self.transcodedOffset &+ 1)
    }
  }
}

----Swift.(file)..(error_type).priorTranscoded
extension String.Index  {
  internal var priorTranscoded: String.Index {
    @inline(__always) get {
      return String.Index(
        encodedOffset: self.encodedOffset,
        transcodedOffset: self.transcodedOffset &- 1)
    }
  }
}

----Swift.(file)..(error_type).encoded(offsetBy:Int)
extension String.Index  {
  internal func encoded(offsetBy n: Int) -> String.Index {
    return String.Index(encodedOffset: self.encodedOffset &+ n)
  }
}

----Swift.(file)..(error_type).transcoded(withOffset:Int)
extension String.Index  {
  internal func transcoded(withOffset n: Int) -> String.Index {
    _internalInvariant(self.transcodedOffset == 0)
    return String.Index(encodedOffset: self.encodedOffset, transcodedOffset: n)
  }
}

----Swift.(file)..(error_type).==infix(_:<<error type>>,_:<<error type>>)
extension String.Index: Equatable  {
  public static func == (lhs: String.Index, rhs: String.Index) -> Bool {
    return lhs.orderingValue == rhs.orderingValue
  }
}

----Swift.(file)..(error_type).<infix(_:<<error type>>,_:<<error type>>)
extension String.Index: Comparable  {
  public static func < (lhs: String.Index, rhs: String.Index) -> Bool {
    return lhs.orderingValue < rhs.orderingValue
  }
}

----Swift.(file)..(error_type).hash(into:Hasher)
extension String.Index: Hashable  {
  public func hash(into hasher: inout Hasher) {
    hasher.combine(orderingValue)
  }
}

----Swift.(file).String.Index.init(_:String.Index,within:String)
extension String.Index  {
  public init?(
    _ sourcePosition: String.Index,
    within target: String
  ) {
    guard target._guts.isOnGraphemeClusterBoundary(sourcePosition) else {
      return nil
    }
    self = sourcePosition
  }
}

----Swift.(file).String.Index.samePosition(in:String.UTF8View)
extension String.Index  {
  public func samePosition(
    in utf8: String.UTF8View
    ) -> String.UTF8View.Index? {
    return String.UTF8View.Index(self, within: utf8)
  }
}

----Swift.(file).String.Index.samePosition(in:String.UTF16View)
extension String.Index  {
  public func samePosition(
    in utf16: String.UTF16View
  ) -> String.UTF16View.Index? {
    return String.UTF16View.Index(self, within: utf16)
  }
}

----Swift.(file).DefaultStringInterpolation.init(literalCapacity:Int,interpolationCount:Int)
extension DefaultStringInterpolation {
  public init(literalCapacity: Int, interpolationCount: Int) {
    let capacityPerInterpolation = 2
    let initialCapacity = literalCapacity +
      interpolationCount * capacityPerInterpolation
    _storage = String(_StringGuts(_initialCapacity: initialCapacity))
  }
}

----Swift.(file).DefaultStringInterpolation.appendLiteral(_:String)
extension DefaultStringInterpolation {
  public mutating func appendLiteral(_ literal: String) {
    literal.write(to: &self)
  }
}

----Swift.(file).DefaultStringInterpolation.appendInterpolation(_:T)
extension DefaultStringInterpolation {
  public mutating func appendInterpolation<T>(_ value: T)
    where T: TextOutputStreamable, T: CustomStringConvertible
  {
    value.write(to: &self)
  }
}

----Swift.(file).DefaultStringInterpolation.appendInterpolation(_:T)
extension DefaultStringInterpolation {
  public mutating func appendInterpolation<T>(_ value: T)
    where T: TextOutputStreamable
  {
    value.write(to: &self)
  }
}

----Swift.(file).DefaultStringInterpolation.appendInterpolation(_:T)
extension DefaultStringInterpolation {
  public mutating func appendInterpolation<T>(_ value: T)
    where T: CustomStringConvertible
  {
    value.description.write(to: &self)
  }
}

----Swift.(file).DefaultStringInterpolation.appendInterpolation(_:T)
extension DefaultStringInterpolation {
  public mutating func appendInterpolation<T>(_ value: T) {
    _print_unlocked(value, &self)
  }
}

----Swift.(file).DefaultStringInterpolation.make()
extension DefaultStringInterpolation {
  internal __consuming func make() -> String {
    return _storage
  }
}

----Swift.(file).DefaultStringInterpolation.description
extension DefaultStringInterpolation: CustomStringConvertible  {
  public var description: String {
    return _storage
  }
}

----Swift.(file).DefaultStringInterpolation.write(_:String)
extension DefaultStringInterpolation: TextOutputStream  {
  public mutating func write(_ string: String) {
    _storage.append(string)
  }
}

----Swift.(file).String.init(stringInterpolation:DefaultStringInterpolation)
extension String  {
  public init(stringInterpolation: DefaultStringInterpolation) {
    self = stringInterpolation.make()
  }
}

----Swift.(file).Substring.init(stringInterpolation:DefaultStringInterpolation)
extension Substring  {
  public init(stringInterpolation: DefaultStringInterpolation) {
    self.init(stringInterpolation.make())
  }
}

----Swift.(file).String.init(repeating:String,count:Int)
extension String  {
  public init(repeating repeatedValue: String, count: Int) {
    precondition(count >= 0, "Negative count not allowed")
    guard count > 1 else {
      self = count == 0 ? "" : repeatedValue
      return
    }

    // TODO(String performance): We can directly call appendInPlace
    var result = String()
    result.reserveCapacity(repeatedValue._guts.count &* count)
    for _ in 0..<count {
      result += repeatedValue
    }
    self = result
  }
}

----Swift.(file).String.isEmpty
extension String  {
  public var isEmpty: Bool {
    @inline(__always) get { return _guts.isEmpty }
  }
}

----Swift.(file).StringProtocol.hasPrefix(_:Prefix)
extension StringProtocol  {
  public func hasPrefix<Prefix: StringProtocol>(_ prefix: Prefix) -> Bool {
    return self.starts(with: prefix)
  }
}

----Swift.(file).StringProtocol.hasSuffix(_:Suffix)
extension StringProtocol  {
  public func hasSuffix<Suffix: StringProtocol>(_ suffix: Suffix) -> Bool {
    return self.reversed().starts(with: suffix.reversed())
  }
}

----Swift.(file).String.hasPrefix(_:String)
extension String  {
  public func hasPrefix(_ prefix: String) -> Bool {
    if _fastPath(self._guts.isNFCFastUTF8 && prefix._guts.isNFCFastUTF8) {
      guard prefix._guts.count <= self._guts.count else { return false }
      return prefix._guts.withFastUTF8 { nfcPrefix in
        let prefixEnd = nfcPrefix.count
        return self._guts.withFastUTF8(range: 0..<prefixEnd) { nfcSlicedSelf in
          return _binaryCompare(nfcSlicedSelf, nfcPrefix) == 0
        }
      }
    }

    return starts(with: prefix)
  }
}

----Swift.(file).String.hasSuffix(_:String)
extension String  {
  public func hasSuffix(_ suffix: String) -> Bool {
    if _fastPath(self._guts.isNFCFastUTF8 && suffix._guts.isNFCFastUTF8) {
      guard suffix._guts.count <= self._guts.count else { return false }
      return suffix._guts.withFastUTF8 { nfcSuffix in
        let suffixStart = self._guts.count - nfcSuffix.count
        return self._guts.withFastUTF8(range: suffixStart..<self._guts.count) {
          nfcSlicedSelf in return _binaryCompare(nfcSlicedSelf, nfcSuffix) == 0
        }
      }
    }

    return self.reversed().starts(with: suffix.reversed())
  }
}

----Swift.(file).String.init(_:T,radix:Int,uppercase:Bool)
extension String  {
  public init<T : BinaryInteger>(
    _ value: T, radix: Int = 10, uppercase: Bool = false
  ) {
    self = value._description(radix: radix, uppercase: uppercase)
  }
}

----Swift.(file)._StringObject.RawBitPattern
extension _StringObject  {
  internal typealias RawBitPattern = (UInt64, UInt64)
}

----Swift.(file)._StringObject.rawBits
extension _StringObject  {
  internal var rawBits: RawBitPattern {
    @inline(__always) get {
      return (_countAndFlagsBits, discriminatedObjectRawBits)
    }
  }
}

----Swift.(file)._StringObject.init(bridgeObject:<<error type>>,countAndFlags:_StringObject.CountAndFlags)
extension _StringObject  {
  internal init(
    bridgeObject: Builtin.BridgeObject, countAndFlags: CountAndFlags
  ) {
    self._object = bridgeObject
    self._countAndFlagsBits = countAndFlags._storage
    _invariantCheck()
  }
}

----Swift.(file)._StringObject.init(object:AnyObject,discriminator:UInt64,countAndFlags:_StringObject.CountAndFlags)
extension _StringObject  {
  internal init(
    object: AnyObject, discriminator: UInt64, countAndFlags: CountAndFlags
  ) {
    let builtinRawObject: Builtin.Int64 = Builtin.reinterpretCast(object)
    let builtinDiscrim: Builtin.Int64 = discriminator._value
    self.init(
      bridgeObject: Builtin.reinterpretCast(
        Builtin.stringObjectOr_Int64(builtinRawObject, builtinDiscrim)),
      countAndFlags: countAndFlags)
  }
}

----Swift.(file)._StringObject.init(pointerBits:UInt64,discriminator:UInt64,countAndFlags:_StringObject.CountAndFlags)
extension _StringObject  {
  internal init(
    pointerBits: UInt64, discriminator: UInt64, countAndFlags: CountAndFlags
  ) {
    let builtinValueBits: Builtin.Int64 = pointerBits._value
    let builtinDiscrim: Builtin.Int64 = discriminator._value
    self.init(
      bridgeObject: Builtin.valueToBridgeObject(Builtin.stringObjectOr_Int64(
        builtinValueBits, builtinDiscrim)),
      countAndFlags: countAndFlags)
  }
}

----Swift.(file)._StringObject.init(rawUncheckedValue:_StringObject.RawBitPattern)
extension _StringObject  {
  internal init(rawUncheckedValue bits: RawBitPattern) {
    self.init(zero:())
    self._countAndFlagsBits = bits.0
    self._object = Builtin.valueToBridgeObject(bits.1._value)
    _internalInvariant(self.rawBits == bits)
  }
}

----Swift.(file)._StringObject.init(rawValue:_StringObject.RawBitPattern)
extension _StringObject  {
  internal init(rawValue bits: RawBitPattern) {
    self.init(rawUncheckedValue: bits)
    _invariantCheck()
  }
}

----Swift.(file)._StringObject.discriminatedObjectRawBits
extension _StringObject  {
  internal var discriminatedObjectRawBits: UInt64 {
#if arch(i386) || arch(arm)
    let low32: UInt
    switch _variant {
    case .immortal(let bitPattern):
      low32 = bitPattern
    case .native(let storage):
      low32 = Builtin.reinterpretCast(storage)
    case .bridged(let object):
      low32 = Builtin.reinterpretCast(object)
    }

    return UInt64(truncatingIfNeeded: _discriminator) &<< 56
         | UInt64(truncatingIfNeeded: low32)
#else
    return Builtin.reinterpretCast(_object)
#endif
  }
}

----Swift.(file)._StringObject.CountAndFlags.RawBitPattern
extension _StringObject.CountAndFlags  {
  internal typealias RawBitPattern = U
}

----Swift.(file)._StringObject.CountAndFlags.rawBits
extension _StringObject.CountAndFlags  {
  internal var rawBits: RawBitPattern {
   return _storage
  }
}

----Swift.(file)._StringObject.CountAndFlags.init(rawUnchecked:_StringObject.CountAndFlags.RawBitPattern)
extension _StringObject.CountAndFlags  {
  internal init(rawUnchecked bits: RawBitPattern) {
    self._storage = bits
  }
}

----Swift.(file)._StringObject.CountAndFlags.init(raw:_StringObject.CountAndFlags.RawBitPattern)
extension _StringObject.CountAndFlags  {
  internal init(raw bits: RawBitPattern) {
    self.init(rawUnchecked: bits)
    _invariantCheck()
  }
}

----Swift.(file)._StringObject.Nibbles.emptyString
extension _StringObject.Nibbles  {
  internal static var emptyString: UInt64 {
    @inline(__always) get { return _StringObject.Nibbles.small(isASCII: true) }
  }
}

----Swift.(file)._StringObject.Nibbles.largeAddressMask
extension _StringObject.Nibbles  {
  static internal var largeAddressMask: UInt64 { return 0x0FFF_FFFF_FFFF_FFFF }
}

----Swift.(file)._StringObject.Nibbles.discriminatorMask
extension _StringObject.Nibbles  {
  static internal var discriminatorMask: UInt64 { return ~largeAddressMask }
}

----Swift.(file)._StringObject.Nibbles.small(isASCII:Bool)
extension _StringObject.Nibbles  {
  internal static func small(isASCII: Bool) -> UInt64 {
    return isASCII ? 0xE000_0000_0000_0000 : 0xA000_0000_0000_0000
  }
}

----Swift.(file)._StringObject.Nibbles.small(withCount:Int,isASCII:Bool)
extension _StringObject.Nibbles  {
  internal static func small(withCount count: Int, isASCII: Bool) -> UInt64 {
    _internalInvariant(count <= _SmallString.capacity)
    return small(isASCII: isASCII) | UInt64(truncatingIfNeeded: count) &<< 56
  }
}

----Swift.(file)._StringObject.Nibbles.largeImmortal()
extension _StringObject.Nibbles  {
  internal static func largeImmortal() -> UInt64 {
    return 0x8000_0000_0000_0000
  }
}

----Swift.(file)._StringObject.Nibbles.largeMortal()
extension _StringObject.Nibbles  {
  internal static func largeMortal() -> UInt64 {
    return 0x0000_0000_0000_0000
  }
}

----Swift.(file)._StringObject.Nibbles.largeCocoa(providesFastUTF8:Bool)
extension _StringObject.Nibbles  {
  internal static func largeCocoa(providesFastUTF8: Bool) -> UInt64 {
    return providesFastUTF8 ? 0x4000_0000_0000_0000 : 0x5000_0000_0000_0000
  }
}

----Swift.(file)._StringObject.nativeBias
extension _StringObject  {
  internal static var nativeBias: UInt {
    @inline(__always) get {
#if arch(i386) || arch(arm)
      return 20
#else
      return 32
#endif
    }
  }
}

----Swift.(file)._StringObject.isImmortal
extension _StringObject  {
  internal var isImmortal: Bool {
    @inline(__always) get {
      return (discriminatedObjectRawBits & 0x8000_0000_0000_0000) != 0
    }
  }
}

----Swift.(file)._StringObject.isMortal
extension _StringObject  {
  internal var isMortal: Bool {
    @inline(__always) get { return !isImmortal }
  }
}

----Swift.(file)._StringObject.isSmall
extension _StringObject  {
  internal var isSmall: Bool {
    @inline(__always) get {
      return (discriminatedObjectRawBits & 0x2000_0000_0000_0000) != 0
    }
  }
}

----Swift.(file)._StringObject.isLarge
extension _StringObject  {
  internal var isLarge: Bool { @inline(__always) get { return !isSmall } }
}

----Swift.(file)._StringObject.providesFastUTF8
extension _StringObject  {
  internal var providesFastUTF8: Bool {
    @inline(__always) get {
      return (discriminatedObjectRawBits & 0x1000_0000_0000_0000) == 0
    }
  }
}

----Swift.(file)._StringObject.isForeign
extension _StringObject  {
  internal var isForeign: Bool {
    @inline(__always) get { return !providesFastUTF8 }
  }
}

----Swift.(file)._StringObject.hasStorage
extension _StringObject  {
  internal var hasStorage: Bool {
    return (discriminatedObjectRawBits & 0xF000_0000_0000_0000) == 0
  }
}

----Swift.(file)._StringObject.hasNativeStorage
extension _StringObject  {
  internal var hasNativeStorage: Bool {
    // b61 on the object means isSmall, and on countAndFlags means
    // isNativelyStored. We just need to check that b61 is 0 on the object and 1
    // on countAndFlags.
    let bits = ~discriminatedObjectRawBits & self._countAndFlagsBits
    let result = bits & 0x2000_0000_0000_0000 != 0
    _internalInvariant(!result || hasStorage, "native storage needs storage")
    return result
  }
}

----Swift.(file)._StringObject.hasSharedStorage
extension _StringObject  {
  internal var hasSharedStorage: Bool { return hasStorage && !hasNativeStorage }
}

----Swift.(file)._StringObject.largeFastIsTailAllocated
extension _StringObject  {
  internal var largeFastIsTailAllocated: Bool {
    _internalInvariant(isLarge && providesFastUTF8)
    return _countAndFlags.isTailAllocated
  }
}

----Swift.(file)._StringObject.largeFastIsShared
extension _StringObject  {
  internal var largeFastIsShared: Bool { return !largeFastIsTailAllocated }
}

----Swift.(file)._StringObject.largeIsCocoa
extension _StringObject  {
  internal var largeIsCocoa: Bool {
    _internalInvariant(isLarge)
    return (discriminatedObjectRawBits & 0x4000_0000_0000_0000) != 0
  }
}

----Swift.(file)._StringObject.init(_:<<error type>>)
extension _StringObject  {
  internal init(_ small: _SmallString) {
    self.init(rawValue: small.rawBits)
    _internalInvariant(isSmall)
  }
}

----Swift.(file)._StringObject.getSmallCount(fromRaw:UInt64)
extension _StringObject  {
  internal static func getSmallCount(fromRaw x: UInt64) -> Int {
    return Int(truncatingIfNeeded: (x & 0x0F00_0000_0000_0000) &>> 56)
  }
}

----Swift.(file)._StringObject.smallCount
extension _StringObject  {
  internal var smallCount: Int {
    @inline(__always)
    get {
      _internalInvariant(isSmall)
      return _StringObject.getSmallCount(fromRaw: discriminatedObjectRawBits)
    }
  }
}

----Swift.(file)._StringObject.getSmallIsASCII(fromRaw:UInt64)
extension _StringObject  {
  internal static func getSmallIsASCII(fromRaw x: UInt64) -> Bool {
    return x & 0x4000_0000_0000_0000 != 0
  }
}

----Swift.(file)._StringObject.smallIsASCII
extension _StringObject  {
  internal var smallIsASCII: Bool {
    @inline(__always)
    get {
      _internalInvariant(isSmall)
      return _StringObject.getSmallIsASCII(fromRaw: discriminatedObjectRawBits)
    }
  }
}

----Swift.(file)._StringObject.init(empty:())
extension _StringObject  {
  internal init(empty:()) {
    // Canonical empty pattern: small zero-length string
#if arch(i386) || arch(arm)
    self.init(
      count: 0,
      variant: .immortal(0),
      discriminator: Nibbles.emptyString,
      flags: 0)
#else
    self._countAndFlagsBits = 0
    self._object = Builtin.valueToBridgeObject(Nibbles.emptyString._value)
#endif
    _internalInvariant(self.smallCount == 0)
    _invariantCheck()
  }
}

----Swift.(file)._StringObject.CountAndFlags.countMask
extension _StringObject.CountAndFlags  {
  internal static var countMask: UInt64 { return 0x0000_FFFF_FFFF_FFFF }
}

----Swift.(file)._StringObject.CountAndFlags.flagsMask
extension _StringObject.CountAndFlags  {
  internal static var flagsMask: UInt64 { return ~countMask }
}

----Swift.(file)._StringObject.CountAndFlags.isASCIIMask
extension _StringObject.CountAndFlags  {
  internal static var isASCIIMask: UInt64 { return 0x8000_0000_0000_0000 }
}

----Swift.(file)._StringObject.CountAndFlags.isNFCMask
extension _StringObject.CountAndFlags  {
  internal static var isNFCMask: UInt64 { return 0x4000_0000_0000_0000 }
}

----Swift.(file)._StringObject.CountAndFlags.isNativelyStoredMask
extension _StringObject.CountAndFlags  {
  internal static var isNativelyStoredMask: UInt64 {
    return 0x2000_0000_0000_0000
  }
}

----Swift.(file)._StringObject.CountAndFlags.isTailAllocatedMask
extension _StringObject.CountAndFlags  {
  internal static var isTailAllocatedMask: UInt64 {
    return 0x1000_0000_0000_0000
  }
}

----Swift.(file)._StringObject.CountAndFlags.init(count:Int,isASCII:Bool,isNFC:Bool,isNativelyStored:Bool,isTailAllocated:Bool)
extension _StringObject.CountAndFlags  {
  internal init(
    count: Int,
    isASCII: Bool,
    isNFC: Bool,
    isNativelyStored: Bool,
    isTailAllocated: Bool
  ) {
    var rawBits = UInt64(truncatingIfNeeded: count)
    _internalInvariant(rawBits <= _StringObject.CountAndFlags.countMask)

    if isASCII {
      _internalInvariant(isNFC)
      rawBits |= _StringObject.CountAndFlags.isASCIIMask
    }

    if isNFC {
      rawBits |= _StringObject.CountAndFlags.isNFCMask
    }

    if isNativelyStored {
      _internalInvariant(isTailAllocated)
      rawBits |= _StringObject.CountAndFlags.isNativelyStoredMask
    }

    if isTailAllocated {
      rawBits |= _StringObject.CountAndFlags.isTailAllocatedMask
    }

    self.init(raw: rawBits)
    _internalInvariant(count == self.count)
    _internalInvariant(isASCII == self.isASCII)
    _internalInvariant(isNFC == self.isNFC)
    _internalInvariant(isNativelyStored == self.isNativelyStored)
    _internalInvariant(isTailAllocated == self.isTailAllocated)
  }
}

----Swift.(file)._StringObject.CountAndFlags.init(count:Int,flags:UInt16)
extension _StringObject.CountAndFlags  {
  internal init(count: Int, flags: UInt16) {
    // Currently, we only use top 4 flags
    _internalInvariant(flags & 0xF000 == flags)

    let rawBits = UInt64(truncatingIfNeeded: flags) &<< 48
                | UInt64(truncatingIfNeeded: count)
    self.init(raw: rawBits)
    _internalInvariant(self.count == count && self.flags == flags)
  }
}

----Swift.(file)._StringObject.CountAndFlags.init(immortalCount:Int,isASCII:Bool)
extension _StringObject.CountAndFlags  {
  internal init(immortalCount: Int, isASCII: Bool) {
    self.init(
      count: immortalCount,
      isASCII: isASCII,
      isNFC: isASCII,
      isNativelyStored: false,
      isTailAllocated: true)
  }
}

----Swift.(file)._StringObject.CountAndFlags.init(mortalCount:Int,isASCII:Bool)
extension _StringObject.CountAndFlags  {
  internal init(mortalCount: Int, isASCII: Bool) {
    self.init(
      count: mortalCount,
      isASCII: isASCII,
      isNFC: isASCII,
      isNativelyStored: true,
      isTailAllocated: true)
  }
}

----Swift.(file)._StringObject.CountAndFlags.init(sharedCount:Int,isASCII:Bool)
extension _StringObject.CountAndFlags  {
  internal init(sharedCount: Int, isASCII: Bool) {
    self.init(
      count: sharedCount,
      isASCII: isASCII,
      isNFC: isASCII,
      isNativelyStored: false,
      isTailAllocated: false)
  }
}

----Swift.(file)._StringObject.CountAndFlags.count
extension _StringObject.CountAndFlags  {
  internal var count: Int {
    return Int(
      truncatingIfNeeded: _storage & _StringObject.CountAndFlags.countMask)
  }
}

----Swift.(file)._StringObject.CountAndFlags.flags
extension _StringObject.CountAndFlags  {
  internal var flags: UInt16 {
    return UInt16(truncatingIfNeeded: _storage &>> 48)
  }
}

----Swift.(file)._StringObject.CountAndFlags.isASCII
extension _StringObject.CountAndFlags  {
  internal var isASCII: Bool {
    return 0 != _storage & _StringObject.CountAndFlags.isASCIIMask
  }
}

----Swift.(file)._StringObject.CountAndFlags.isNFC
extension _StringObject.CountAndFlags  {
  internal var isNFC: Bool {
    return 0 != _storage & _StringObject.CountAndFlags.isNFCMask
  }
}

----Swift.(file)._StringObject.CountAndFlags.isNativelyStored
extension _StringObject.CountAndFlags  {
  internal var isNativelyStored: Bool {
    return 0 != _storage & _StringObject.CountAndFlags.isNativelyStoredMask
  }
}

----Swift.(file)._StringObject.CountAndFlags.isTailAllocated
extension _StringObject.CountAndFlags  {
  internal var isTailAllocated: Bool {
    return 0 != _storage & _StringObject.CountAndFlags.isTailAllocatedMask
  }
}

----Swift.(file)._StringObject.largeCount
extension _StringObject  {
  internal var largeCount: Int {
    _internalInvariant(isLarge)
    return _countAndFlags.count
  }
}

----Swift.(file)._StringObject.largeAddressBits
extension _StringObject  {
  internal var largeAddressBits: UInt {
    @inline(__always) get {
      _internalInvariant(isLarge)
      return UInt(truncatingIfNeeded:
        discriminatedObjectRawBits & Nibbles.largeAddressMask)
    }
  }
}

----Swift.(file)._StringObject.nativeUTF8Start
extension _StringObject  {
  internal var nativeUTF8Start: UnsafePointer<UInt8> {
    @inline(__always) get {
      _internalInvariant(largeFastIsTailAllocated)
      return UnsafePointer(
        bitPattern: largeAddressBits &+ _StringObject.nativeBias
      )._unsafelyUnwrappedUnchecked
    }
  }
}

----Swift.(file)._StringObject.nativeUTF8
extension _StringObject  {
  internal var nativeUTF8: UnsafeBufferPointer<UInt8> {
    @inline(__always) get {
      _internalInvariant(largeFastIsTailAllocated)
      return UnsafeBufferPointer(start: nativeUTF8Start, count: largeCount)
    }
  }
}

----Swift.(file)._StringObject.getSharedUTF8Start()
extension _StringObject  {
  internal func getSharedUTF8Start() -> UnsafePointer<UInt8> {
    _internalInvariant(largeFastIsShared)
#if _runtime(_ObjC)
    if largeIsCocoa {
      return _cocoaUTF8Pointer(cocoaObject)._unsafelyUnwrappedUnchecked
    }
#endif

    return sharedStorage.start
  }
}

----Swift.(file)._StringObject.sharedUTF8
extension _StringObject  {
  internal var sharedUTF8: UnsafeBufferPointer<UInt8> {
    @_effects(releasenone) @inline(never) get {
      _internalInvariant(largeFastIsShared)
      let start = self.getSharedUTF8Start()
      return UnsafeBufferPointer(start: start, count: largeCount)
    }
  }
}

----Swift.(file)._StringObject.nativeStorage
extension _StringObject  {
  internal var nativeStorage: _StringStorage {
    @inline(__always) get {
#if arch(i386) || arch(arm)
      guard case .native(let storage) = _variant else {
        _internalInvariantFailure()
      }
      return _unsafeUncheckedDowncast(storage, to: _StringStorage.self)
#else
      _internalInvariant(hasNativeStorage)
      return Builtin.reinterpretCast(largeAddressBits)
#endif
    }
  }
}

----Swift.(file)._StringObject.sharedStorage
extension _StringObject  {
  internal var sharedStorage: _SharedStringStorage {
    @inline(__always) get {
#if arch(i386) || arch(arm)
      guard case .native(let storage) = _variant else {
        _internalInvariantFailure()
      }
      return _unsafeUncheckedDowncast(storage, to: _SharedStringStorage.self)
#else
      _internalInvariant(largeFastIsShared && !largeIsCocoa)
      _internalInvariant(hasSharedStorage)
      return Builtin.reinterpretCast(largeAddressBits)
#endif
    }
  }
}

----Swift.(file)._StringObject.cocoaObject
extension _StringObject  {
  internal var cocoaObject: AnyObject {
    @inline(__always) get {
#if arch(i386) || arch(arm)
      guard case .bridged(let object) = _variant else {
        _internalInvariantFailure()
      }
      return object
#else
      _internalInvariant(largeIsCocoa && !isImmortal)
      return Builtin.reinterpretCast(largeAddressBits)
#endif
    }
  }
}

----Swift.(file)._StringObject.count
extension _StringObject  {
  internal var count: Int {
    @inline(__always) get { return isSmall ? smallCount : largeCount }
  }
}

----Swift.(file)._StringObject.isASCII
extension _StringObject  {
  internal var isASCII: Bool {
    @inline(__always) get {
      if isSmall { return smallIsASCII }
      return _countAndFlags.isASCII
    }
  }
}

----Swift.(file)._StringObject.isNFC
extension _StringObject  {
  internal var isNFC: Bool {
    if isSmall {
      // TODO(String performance): Worth implementing more sophisiticated
      // check, or else performing normalization on- construction. For now,
      // approximate it with isASCII
      return smallIsASCII
    }
    return _countAndFlags.isNFC
  }
}

----Swift.(file)._StringObject.fastUTF8
extension _StringObject  {
  internal var fastUTF8: UnsafeBufferPointer<UInt8> {
    _internalInvariant(self.isLarge && self.providesFastUTF8)
    guard _fastPath(self.largeFastIsTailAllocated) else {
      return sharedUTF8
    }
    return UnsafeBufferPointer(
      start: self.nativeUTF8Start, count: self.largeCount)
  }
}

----Swift.(file)._StringObject.hasObjCBridgeableObject
extension _StringObject  {
  internal var hasObjCBridgeableObject: Bool {
    @_effects(releasenone) get {
      // Currently, all mortal objects can zero-cost bridge
      return !self.isImmortal
    }
  }
}

----Swift.(file)._StringObject.objCBridgeableObject
extension _StringObject  {
  internal var objCBridgeableObject: AnyObject {
    _internalInvariant(hasObjCBridgeableObject)
    return Builtin.reinterpretCast(largeAddressBits)
  }
}

----Swift.(file)._StringObject.isFastZeroTerminated
extension _StringObject  {
  internal var isFastZeroTerminated: Bool {
    if _slowPath(!providesFastUTF8) { return false }

    // Small strings nul-terminate when spilling for contiguous access
    if isSmall { return true }

    // TODO(String performance): Use performance flag, which could be more
    // inclusive. For now, we only know native strings and small strings (when
    // accessed) are. We could also know about some shared strings.

    return largeFastIsTailAllocated
  }
}

----Swift.(file)._StringObject.init(immortal:UnsafeBufferPointer<UInt8>,isASCII:Bool)
extension _StringObject  {
  internal init(immortal bufPtr: UnsafeBufferPointer<UInt8>, isASCII: Bool) {
    let countAndFlags = CountAndFlags(
      immortalCount: bufPtr.count, isASCII: isASCII)
#if arch(i386) || arch(arm)
    self.init(
      variant: .immortal(start: bufPtr.baseAddress._unsafelyUnwrappedUnchecked),
      discriminator: Nibbles.largeImmortal(),
      countAndFlags: countAndFlags)
#else
    // We bias to align code paths for mortal and immortal strings
    let biasedAddress = UInt(
      bitPattern: bufPtr.baseAddress._unsafelyUnwrappedUnchecked
    ) &- _StringObject.nativeBias

    self.init(
      pointerBits: UInt64(truncatingIfNeeded: biasedAddress),
      discriminator: Nibbles.largeImmortal(),
      countAndFlags: countAndFlags)
#endif
  }
}

----Swift.(file)._StringObject.init(_:<<error type>>)
extension _StringObject  {
  internal init(_ storage: _StringStorage) {
#if arch(i386) || arch(arm)
    self.init(
      variant: .native(storage),
      discriminator: Nibbles.largeMortal(),
      countAndFlags: storage._countAndFlags)
#else
    self.init(
      object: storage,
      discriminator: Nibbles.largeMortal(),
      countAndFlags: storage._countAndFlags)
#endif
  }
}

----Swift.(file)._StringObject.init(_:<<error type>>)
extension _StringObject  {
  internal init(_ storage: _SharedStringStorage) {
#if arch(i386) || arch(arm)
    self.init(
      variant: .native(storage),
      discriminator: Nibbles.largeMortal(),
      countAndFlags: storage._countAndFlags)
#else
    self.init(
      object: storage,
      discriminator: Nibbles.largeMortal(),
      countAndFlags: storage._countAndFlags)
#endif
  }
}

----Swift.(file)._StringObject.init(cocoa:AnyObject,providesFastUTF8:Bool,isASCII:Bool,length:Int)
extension _StringObject  {
  internal init(
    cocoa: AnyObject, providesFastUTF8: Bool, isASCII: Bool, length: Int
  ) {
    let countAndFlags = CountAndFlags(sharedCount: length, isASCII: isASCII)
    let discriminator = Nibbles.largeCocoa(providesFastUTF8: providesFastUTF8)
#if arch(i386) || arch(arm)
    self.init(
      variant: .bridged(cocoa),
      discriminator: discriminator,
      countAndFlags: countAndFlags)
#else
    self.init(
      object: cocoa, discriminator: discriminator, countAndFlags: countAndFlags)
    _internalInvariant(self.largeAddressBits == Builtin.reinterpretCast(cocoa))
    _internalInvariant(self.providesFastUTF8 == providesFastUTF8)
    _internalInvariant(self.largeCount == length)
#endif
  }
}

----Swift.(file).StringProtocol.UTF8View
extension StringProtocol {
  associatedtype UTF8View : /*Bidirectional*/Collection
  where UTF8View.Element == UInt8, // Unicode.UTF8.CodeUnit
        UTF8View.Index == I
}

----Swift.(file).StringProtocol.UTF16View
extension StringProtocol {
  associatedtype UTF16View : BidirectionalCollection
  where UTF16View.Element == UInt16, // Unicode.UTF16.CodeUnit
        UTF16View.Index == I
}

----Swift.(file).StringProtocol.UnicodeScalarView
extension StringProtocol {
  associatedtype UnicodeScalarView : BidirectionalCollection
  where UnicodeScalarView.Element == Unicode.Scalar,
        UnicodeScalarView.Index == I
}

----Swift.(file).StringProtocol.SubSequence
extension StringProtocol {
  associatedtype S
}

----Swift.(file).StringProtocol.utf8
extension StringProtocol {
  var utf8: UTF8View { get }
}

----Swift.(file).StringProtocol.utf16
extension StringProtocol {
  var utf16: UTF16View { get }
}

----Swift.(file).StringProtocol.unicodeScalars
extension StringProtocol {
  var unicodeScalars: UnicodeScalarView { get }
}

----Swift.(file).StringProtocol.hasPrefix(_:String)
extension StringProtocol {
  func hasPrefix(_ prefix: String) -> B
}

----Swift.(file).StringProtocol.hasSuffix(_:String)
extension StringProtocol {
  func hasSuffix(_ prefix: String) -> B
}

----Swift.(file).StringProtocol.lowercased()
extension StringProtocol {
  func lowercased() -> S
}

----Swift.(file).StringProtocol.uppercased()
extension StringProtocol {
  func uppercased() -> S
}

----Swift.(file).StringProtocol.init(decoding:C,as:Encoding.Type)
extension StringProtocol {
  init<C: Collection, Encoding: Unicode.Encoding>(
    decoding codeUnits: C, as sourceEncoding: Encoding.Type
  )
    where C.Iterator.Element == Encoding.C
}

----Swift.(file).StringProtocol.init(cString:UnsafePointer<CChar>)
extension StringProtocol {
  init(cString nullTerminatedUTF8: UnsafePointer<CChar>)
}

----Swift.(file).StringProtocol.init(decodingCString:UnsafePointer<Encoding.CodeUnit>,as:Encoding.Type)
extension StringProtocol {
  init<Encoding: Unicode.Encoding>(
    decodingCString nullTerminatedCodeUnits: UnsafePointer<Encoding.CodeUnit>,
    as sourceEncoding: Encoding.Type)
}

----Swift.(file).StringProtocol.withCString(_:(UnsafePointer<CChar>) throws -> Result)
extension StringProtocol {
  func withCString<Result>(
    _ body: (UnsafePointer<CChar>) throws -> Result) rethrows -> R
}

----Swift.(file).StringProtocol.withCString(encodedAs:Encoding.Type,_:(UnsafePointer<Encoding.CodeUnit>) throws -> Result)
extension StringProtocol {
  func withCString<Result, Encoding: Unicode.Encoding>(
    encodedAs targetEncoding: Encoding.Type,
    _ body: (UnsafePointer<Encoding.CodeUnit>) throws -> Result
  ) rethrows -> R
}

----Swift.(file).String.init(repeating:Character,count:Int)
extension String: RangeReplaceableCollection  {
  public init(repeating repeatedValue: Character, count: Int) {
    self.init(repeating: repeatedValue._str, count: count)
  }
}

----Swift.(file).String.init(_:S)
extension String: RangeReplaceableCollection  {
  public init<S : Sequence & LosslessStringConvertible>(_ other: S)
  where S.Element == Character {
    if let str = other as? String {
      self = str
      return
    }
    self = other.description
  }
}

----Swift.(file).String.init(_:S)
extension String: RangeReplaceableCollection  {
  public init<S : Sequence>(_ characters: S)
  where S.Iterator.Element == Character {
    if let str = characters as? String {
      self = str
      return
    }
    if let subStr = characters as? Substring {
      self.init(subStr)
      return
    }
    self = ""
    self.append(contentsOf: characters)
  }
}

----Swift.(file).String.reserveCapacity(_:Int)
extension String: RangeReplaceableCollection  {
  public mutating func reserveCapacity(_ n: Int) {
    self._guts.reserveCapacity(n)
  }
}

----Swift.(file).String.append(_:String)
extension String: RangeReplaceableCollection  {
  public mutating func append(_ other: String) {
    if self.isEmpty && !_guts.hasNativeStorage {
      self = other
      return
    }
    self._guts.append(other._guts)
  }
}

----Swift.(file).String.append(_:Character)
extension String: RangeReplaceableCollection  {
  public mutating func append(_ c: Character) {
    self.append(c._str)
  }
}

----Swift.(file).String.append(contentsOf:String)
extension String: RangeReplaceableCollection  {
  public mutating func append(contentsOf newElements: String) {
    self.append(newElements)
  }
}

----Swift.(file).String.append(contentsOf:Substring)
extension String: RangeReplaceableCollection  {
  public mutating func append(contentsOf newElements: Substring) {
    self._guts.append(newElements._gutsSlice)
  }
}

----Swift.(file).String.append(contentsOf:S)
extension String: RangeReplaceableCollection  {
  public mutating func append<S : Sequence>(contentsOf newElements: S)
  where S.Iterator.Element == Character {
    if let str = newElements as? String {
      self.append(str)
      return
    }
    if let substr = newElements as? Substring {
      self.append(contentsOf: substr)
      return
    }
    for c in newElements {
      self.append(c._str)
    }
  }
}

----Swift.(file).String.replaceSubrange(_:Range<String.Index>,with:C)
extension String: RangeReplaceableCollection  {
  public mutating func replaceSubrange<C>(
    _ bounds: Range<Index>,
    with newElements: C
  ) where C : Collection, C.Iterator.Element == Character {
    _guts.replaceSubrange(bounds, with: newElements)
  }
}

----Swift.(file).String.insert(_:Character,at:String.Index)
extension String: RangeReplaceableCollection  {
  public mutating func insert(_ newElement: Character, at i: Index) {
    self.replaceSubrange(i..<i, with: newElement._str)
  }
}

----Swift.(file).String.insert(contentsOf:S,at:String.Index)
extension String: RangeReplaceableCollection  {
  public mutating func insert<S : Collection>(
    contentsOf newElements: S, at i: Index
  ) where S.Element == Character {
    self.replaceSubrange(i..<i, with: newElements)
  }
}

----Swift.(file).String.remove(at:String.Index)
extension String: RangeReplaceableCollection  {
  public mutating func remove(at i: Index) -> Character {
    let result = self[i]
    _guts.remove(from: i, to: self.index(after: i))
    return result
  }
}

----Swift.(file).String.removeSubrange(_:Range<String.Index>)
extension String: RangeReplaceableCollection  {
  public mutating func removeSubrange(_ bounds: Range<Index>) {
    _guts.remove(from: bounds.lowerBound, to: bounds.upperBound)
  }
}

----Swift.(file).String.removeAll(keepingCapacity:Bool)
extension String: RangeReplaceableCollection  {
  public mutating func removeAll(keepingCapacity keepCapacity: Bool = false) {
    guard keepCapacity else {
      self = ""
      return
    }
    _guts.clear()
  }
}

----Swift.(file).String.max(_:T,_:T)
extension String  {
  public func max<T : Comparable>(_ x: T, _ y: T) -> T {
    return Swift.max(x,y)
  }
}

----Swift.(file).String.min(_:T,_:T)
extension String  {
  public func min<T : Comparable>(_ x: T, _ y: T) -> T {
    return Swift.min(x,y)
  }
}

----Swift.(file).Sequence.+infix(_:Self,_:String)
extension Sequence where Element == String  {
  public static func + (lhs: Self, rhs: String) -> Never {
    fatalError()
  }
}

----Swift.(file).Sequence.+infix(_:String,_:Self)
extension Sequence where Element == String  {
  public static func + (lhs: String, rhs: Self) -> Never {
    fatalError()
  }
}

----Swift.(file).CountAndFlags
private typealias CountAndFlags = _StringObject.C

----Swift.(file).determineCodeUnitCapacity(_:Int)
private func determineCodeUnitCapacity(_ desiredCapacity: Int) -> Int {
#if arch(i386) || arch(arm)
  // FIXME: Adapt to actual 32-bit allocator. For now, let's arrange things so
  // that the instance size will be a multiple of 4.
  let bias = Int(bitPattern: _StringObject.nativeBias)
  let minimum = bias + desiredCapacity + 1
  let size = (minimum + 3) & ~3
  _internalInvariant(size % 4 == 0)
  let capacity = size - bias
  _internalInvariant(capacity > desiredCapacity)
  return capacity
#else
  // Bigger than _SmallString, and we need 1 extra for nul-terminator.
  let minCap = 1 + Swift.max(desiredCapacity, _SmallString.capacity)
  _internalInvariant(minCap < 0x1_0000_0000_0000, "max 48-bit length")

  // Round up to the nearest multiple of 8 that isn't also a multiple of 16.
  let capacity = ((minCap + 7) & -16) + 8
  _internalInvariant(
    capacity > desiredCapacity && capacity % 8 == 0 && capacity % 16 != 0)
  return capacity
#endif
}

----Swift.(file)._StringStorage.create(realCodeUnitCapacity:Int,countAndFlags:<<error type>>)
extension _StringStorage  {
  private static func create(
    realCodeUnitCapacity: Int, countAndFlags: CountAndFlags
  ) -> _StringStorage {
    let storage = Builtin.allocWithTailElems_2(
      _StringStorage.self,
      realCodeUnitCapacity._builtinWordValue, UInt8.self,
      1._builtinWordValue, Optional<_StringBreadcrumbs>.self)
#if arch(i386) || arch(arm)
    storage._realCapacity = realCodeUnitCapacity
    storage._count = countAndFlags.count
    storage._flags = countAndFlags.flags
#else
    storage._realCapacityAndFlags =
      UInt64(truncatingIfNeeded: realCodeUnitCapacity)
    storage._countAndFlags = countAndFlags
#endif

    storage._breadcrumbsAddress.initialize(to: nil)
    storage.terminator.pointee = 0 // nul-terminated

    // NOTE: We can't _invariantCheck() now, because code units have not been
    // initialized. But, _StringGuts's initializer will.
    return storage
  }
}

----Swift.(file)._StringStorage.create(capacity:Int,countAndFlags:<<error type>>)
extension _StringStorage  {
  private static func create(
    capacity: Int, countAndFlags: CountAndFlags
  ) -> _StringStorage {
    _internalInvariant(capacity >= countAndFlags.count)

    let realCapacity = determineCodeUnitCapacity(capacity)
    _internalInvariant(realCapacity > capacity)
    return _StringStorage.create(
      realCodeUnitCapacity: realCapacity, countAndFlags: countAndFlags)
  }
}

----Swift.(file)._StringStorage.create(initializingFrom:UnsafeBufferPointer<UInt8>,capacity:Int,isASCII:Bool)
extension _StringStorage  {
  internal static func create(
    initializingFrom bufPtr: UnsafeBufferPointer<UInt8>,
    capacity: Int,
    isASCII: Bool
  ) -> _StringStorage {
    let countAndFlags = CountAndFlags(
      mortalCount: bufPtr.count, isASCII: isASCII)
    _internalInvariant(capacity >= bufPtr.count)
    let storage = _StringStorage.create(
      capacity: capacity, countAndFlags: countAndFlags)
    let addr = bufPtr.baseAddress._unsafelyUnwrappedUnchecked
    storage.mutableStart.initialize(from: addr, count: bufPtr.count)
    storage._invariantCheck()
    return storage
  }
}

----Swift.(file)._StringStorage.create(initializingFrom:UnsafeBufferPointer<UInt8>,isASCII:Bool)
extension _StringStorage  {
  internal static func create(
    initializingFrom bufPtr: UnsafeBufferPointer<UInt8>, isASCII: Bool
  ) -> _StringStorage {
    return _StringStorage.create(
      initializingFrom: bufPtr, capacity: bufPtr.count, isASCII: isASCII)
  }
}

----Swift.(file)._StringStorage.mutableStart
extension _StringStorage  {
  private var mutableStart: UnsafeMutablePointer<UInt8> {
    return UnsafeMutablePointer(Builtin.projectTailElems(self, UInt8.self))
  }
}

----Swift.(file)._StringStorage.mutableEnd
extension _StringStorage  {
  private var mutableEnd: UnsafeMutablePointer<UInt8> {
    @inline(__always) get { return mutableStart + count }
  }
}

----Swift.(file)._StringStorage.start
extension _StringStorage  {
  internal var start: UnsafePointer<UInt8> {
     return UnsafePointer(mutableStart)
  }
}

----Swift.(file)._StringStorage.end
extension _StringStorage  {
  private final var end: UnsafePointer<UInt8> {
    @inline(__always) get { return UnsafePointer(mutableEnd) }
  }
}

----Swift.(file)._StringStorage.terminator
extension _StringStorage  {
  private final var terminator: UnsafeMutablePointer<UInt8> {
    @inline(__always) get { return mutableEnd }
  }
}

----Swift.(file)._StringStorage.codeUnits
extension _StringStorage  {
  private var codeUnits: UnsafeBufferPointer<UInt8> {
    @inline(__always) get {
      return UnsafeBufferPointer(start: start, count: count)
    }
  }
}

----Swift.(file)._StringStorage.capacity
extension _StringStorage  {
  internal var capacity: Int {
    return _realCapacity &- 1
  }
}

----Swift.(file)._StringStorage.unusedStorage
extension _StringStorage  {
  private var unusedStorage: UnsafeMutableBufferPointer<UInt8> {
    @inline(__always) get {
      return UnsafeMutableBufferPointer(
        start: mutableEnd, count: unusedCapacity)
    }
  }
}

----Swift.(file)._StringStorage.unusedCapacity
extension _StringStorage  {
  internal var unusedCapacity: Int {
    get { return _realCapacity &- count &- 1 }
  }
}

----Swift.(file)._StringStorage.appendInPlace(_:UnsafeBufferPointer<UInt8>,isASCII:Bool)
extension _StringStorage  {
  internal func appendInPlace(
    _ other: UnsafeBufferPointer<UInt8>, isASCII: Bool
  ) {
    _internalInvariant(self.capacity >= other.count)
    let srcAddr = other.baseAddress._unsafelyUnwrappedUnchecked
    let srcCount = other.count
    self.mutableEnd.initialize(from: srcAddr, count: srcCount)
    _postAppendAdjust(appendedCount: srcCount, appendedIsASCII: isASCII)
  }
}

----Swift.(file)._StringStorage.appendInPlace(_:Iter,isASCII:Bool)
extension _StringStorage  {
  internal func appendInPlace<Iter: IteratorProtocol>(
    _ other: inout Iter, isASCII: Bool
  ) where Iter.Element == UInt8 {
    var srcCount = 0
    while let cu = other.next() {
      _internalInvariant(self.unusedCapacity >= 1)
      unusedStorage[srcCount] = cu
      srcCount += 1
    }
    _postAppendAdjust(appendedCount: srcCount, appendedIsASCII: isASCII)
  }
}

----Swift.(file)._StringStorage.clear()
extension _StringStorage  {
  internal func clear() {
    _postRRCAdjust(newCount: 0, newIsASCII: true)
  }
}

----Swift.(file)._StringStorage.remove(from:Int,to:Int)
extension _StringStorage  {
  internal func remove(from lower: Int, to upper: Int) {
    _internalInvariant(lower <= upper)

    let lowerPtr = mutableStart + lower
    let upperPtr = mutableStart + upper
    let tailCount = mutableEnd - upperPtr
    lowerPtr.moveInitialize(from: upperPtr, count: tailCount)

    _postRRCAdjust(
      newCount: self.count &- (upper &- lower), newIsASCII: self.isASCII)
  }
}

----Swift.(file)._StringStorage.replace(from:Int,to:Int,with:UnsafeBufferPointer<UInt8>)
extension _StringStorage  {
  internal func replace(
    from lower: Int, to upper: Int, with replacement: UnsafeBufferPointer<UInt8>
  ) {
    _internalInvariant(lower <= upper)
    let replCount = replacement.count
    _internalInvariant(replCount - (upper - lower) <= unusedCapacity)

    // Position the tail.
    let lowerPtr = mutableStart + lower
    let tailCount = _slideTail(
      src: mutableStart + upper, dst: lowerPtr + replCount)

    // Copy in the contents.
    lowerPtr.moveInitialize(
      from: UnsafeMutablePointer(
        mutating: replacement.baseAddress._unsafelyUnwrappedUnchecked),
      count: replCount)

    let isASCII = self.isASCII && _allASCII(replacement)
    _postRRCAdjust(newCount: lower + replCount + tailCount, newIsASCII: isASCII)
  }
}

----Swift.(file)._StringStorage.replace(from:Int,to:Int,with:C,replacementCount:Int)
extension _StringStorage  {
  internal func replace<C: Collection>(
    from lower: Int,
    to upper: Int,
    with replacement: C,
    replacementCount replCount: Int
  ) where C.Element == UInt8 {
    _internalInvariant(lower <= upper)
    _internalInvariant(replCount - (upper - lower) <= unusedCapacity)

    // Position the tail.
    let lowerPtr = mutableStart + lower
    let tailCount = _slideTail(
      src: mutableStart + upper, dst: lowerPtr + replCount)

    // Copy in the contents.
    var isASCII = self.isASCII
    var srcCount = 0
    for cu in replacement {
      if cu >= 0x80 { isASCII = false }
      lowerPtr[srcCount] = cu
      srcCount += 1
    }
    _internalInvariant(srcCount == replCount)

    _postRRCAdjust(
      newCount: lower + replCount + tailCount, newIsASCII: isASCII)
  }
}

----Swift.(file).String.UTF16View.init(_:_StringGuts)
extension String.UTF16View {
    internal init(_ guts: _StringGuts) {
      self._guts = guts
      _invariantCheck()
    }
}

----Swift.(file)..(error_type).Index
extension String.UTF16View: BidirectionalCollection  {
  public typealias Index = String.I
}

----Swift.(file)..(error_type).startIndex
extension String.UTF16View: BidirectionalCollection  {
  public var startIndex: Index {
    @inline(__always) get { return _guts.startIndex }
  }
}

----Swift.(file)..(error_type).endIndex
extension String.UTF16View: BidirectionalCollection  {
  public var endIndex: Index {
    @inline(__always) get { return _guts.endIndex }
  }
}

----Swift.(file)..(error_type).index(after:String.UTF16View.Index)
extension String.UTF16View: BidirectionalCollection  {
  public func index(after i: Index) -> Index {
    if _slowPath(_guts.isForeign) { return _foreignIndex(after: i) }
    if _guts.isASCII { return i.nextEncoded }

    // For a BMP scalar (1-3 UTF-8 code units), advance past it. For a non-BMP
    // scalar, use a transcoded offset first.
    let len = _guts.fastUTF8ScalarLength(startingAt: i.encodedOffset)
    if len == 4 && i.transcodedOffset == 0 {
      return i.nextTranscoded
    }
    return i.strippingTranscoding.encoded(offsetBy: len)
  }
}

----Swift.(file)..(error_type).index(before:String.UTF16View.Index)
extension String.UTF16View: BidirectionalCollection  {
  public func index(before i: Index) -> Index {
    precondition(!i.isZeroPosition)
    if _slowPath(_guts.isForeign) { return _foreignIndex(before: i) }
    if _guts.isASCII { return i.priorEncoded }

    if i.transcodedOffset != 0 {
      _internalInvariant(i.transcodedOffset == 1)
      return i.strippingTranscoding
    }

    let len = _guts.fastUTF8ScalarLength(endingAt: i.encodedOffset)
    if len == 4 {
      // 2 UTF-16 code units comprise this scalar; advance to the beginning and
      // start mid-scalar transcoding
      return i.encoded(offsetBy: -len).nextTranscoded
    }

    // Single UTF-16 code unit
    _internalInvariant((1...3) ~= len)
    return i.encoded(offsetBy: -len)
  }
}

----Swift.(file)..(error_type).index(_:String.UTF16View.Index,offsetBy:Int)
extension String.UTF16View: BidirectionalCollection  {
  public func index(_ i: Index, offsetBy n: Int) -> Index {
    if _slowPath(_guts.isForeign) {
      return _foreignIndex(i, offsetBy: n)
    }

    let lowerOffset = _nativeGetOffset(for: i)
    let result = _nativeGetIndex(for: lowerOffset + n)
    return result
  }
}

----Swift.(file)..(error_type).index(_:String.UTF16View.Index,offsetBy:Int,limitedBy:String.UTF16View.Index)
extension String.UTF16View: BidirectionalCollection  {
  public func index(
    _ i: Index, offsetBy n: Int, limitedBy limit: Index
  ) -> Index? {
    if _slowPath(_guts.isForeign) {
      return _foreignIndex(i, offsetBy: n, limitedBy: limit)
    }

    let iOffset = _nativeGetOffset(for: i)
    let limitOffset = _nativeGetOffset(for: limit)

    // If distance < 0, limit has no effect if it is greater than i.
    if _slowPath(n < 0 && limit <= i && limitOffset > iOffset + n) {
      return nil
    }
    // If distance > 0, limit has no effect if it is less than i.
    if _slowPath(n >= 0 && limit >= i && limitOffset < iOffset + n) {
      return nil
    }

    let result = _nativeGetIndex(for: iOffset + n)
    return result
  }
}

----Swift.(file)..(error_type).distance(from:String.UTF16View.Index,to:String.UTF16View.Index)
extension String.UTF16View: BidirectionalCollection  {
  public func distance(from start: Index, to end: Index) -> Int {
    if _slowPath(_guts.isForeign) {
      return _foreignDistance(from: start, to: end)
    }

    let lower = _nativeGetOffset(for: start)
    let upper = _nativeGetOffset(for: end)
    return upper &- lower
  }
}

----Swift.(file)..(error_type).count
extension String.UTF16View: BidirectionalCollection  {
  public var count: Int {
    if _slowPath(_guts.isForeign) {
      return _foreignCount()
    }
    return _nativeGetOffset(for: endIndex)
  }
}

----Swift.(file)..(error_type).subscript(_:String.UTF16View.Index)
extension String.UTF16View: BidirectionalCollection  {
  public subscript(i: Index) -> UTF16.CodeUnit {
    @inline(__always) get {
      String(_guts)._boundsCheck(i)

      if _fastPath(_guts.isFastUTF8) {
        let scalar = _guts.fastUTF8Scalar(
          startingAt: _guts.scalarAlign(i).encodedOffset)
        if scalar.value <= 0xFFFF {
          return UInt16(truncatingIfNeeded: scalar.value)
        }
        return scalar.utf16[i.transcodedOffset]
      }

      return _foreignSubscript(position: i)
    }
  }
}

----Swift.(file)..(error_type).Iterator.init(_:_StringGuts)
extension  {
    internal init(_ guts: _StringGuts) {
      self._end = guts.count
      self._guts = guts
    }
}

----Swift.(file)..(error_type).Iterator.next()
extension  {
    public mutating func next() -> UInt16? {
      if _slowPath(_nextIsTrailingSurrogate != nil) {
        let trailing = self._nextIsTrailingSurrogate._unsafelyUnwrappedUnchecked
        self._nextIsTrailingSurrogate = nil
        return trailing
      }
      guard _fastPath(_position < _end) else { return nil }

      let (scalar, len) = _guts.errorCorrectedScalar(startingAt: _position)
      _position &+= len

      if _slowPath(scalar.value > UInt16.max) {
        self._nextIsTrailingSurrogate = scalar.utf16[1]
        return scalar.utf16[0]
      }
      return UInt16(truncatingIfNeeded: scalar.value)
    }
}

----Swift.(file)..(error_type).makeIterator()
extension String.UTF16View  {
  public __consuming func makeIterator() -> Iterator {
    return Iterator(_guts)
  }
}

----Swift.(file)..(error_type).description
extension String.UTF16View: CustomStringConvertible  {
  public var description: String {
    @inline(__always) get { return String(_guts) }
  }
}

----Swift.(file)..(error_type).debugDescription
extension String.UTF16View: CustomDebugStringConvertible  {
  public var debugDescription: String {
    return "StringUTF16(\(self.description.debugDescription))"
  }
}

----Swift.(file).String.utf16
extension String  {
  public var utf16: UTF16View {
    @inline(__always) get { return UTF16View(_guts) }
    @inline(__always) set { self = String(newValue._guts) }
  }
}

----Swift.(file).String.init(_:<<error type>>)
extension String  {
  public init(_ utf16: UTF16View) {
    self.init(utf16._guts)
  }
}

----Swift.(file)..(error_type).init(_:String.Index,within:<<error type>>)
extension String.UTF16View.Index  {
  public init?(
    _ idx: String.Index, within target: String.UTF16View
  ) {
    if _slowPath(target._guts.isForeign) {
      guard idx._foreignIsWithin(target) else { return nil }
    } else {
      guard target._guts.isOnUnicodeScalarBoundary(idx) else { return nil }
    }

    self = idx
  }
}

----Swift.(file)..(error_type).samePosition(in:String.UnicodeScalarView)
extension String.UTF16View.Index  {
  public func samePosition(
    in unicodeScalars: String.UnicodeScalarView
  ) -> String.UnicodeScalarIndex? {
    return String.UnicodeScalarIndex(self, within: unicodeScalars)
  }
}

----Swift.(file)..(error_type).customMirror
extension String.UTF16View : CustomReflectable  {
  public var customMirror: Mirror {
    return Mirror(self, unlabeledChildren: self)
  }
}

----Swift.(file)..(error_type).SubSequence
extension String.UTF16View  {
  public typealias SubSequence = Substring.U
}

----Swift.(file)..(error_type).subscript(_:Range<String.UTF16View.Index>)
extension String.UTF16View  {
  public subscript(r: Range<Index>) -> Substring.UTF16View {
    return Substring.UTF16View(self, _bounds: r)
  }
}

----Swift.(file).validateUTF8(_:UnsafeBufferPointer<UInt8>)
internal func validateUTF8(_ buf: UnsafeBufferPointer<UInt8>) -> UTF8ValidationResult {
  var iter = buf.makeIterator()
  var lastValidIndex = buf.startIndex

  @inline(__always) func guaranteeIn(_ f: (UInt8) -> Bool) throws {
    guard let cu = iter.next() else { throw UTF8ValidationError() }
    guard f(cu) else { throw UTF8ValidationError() }
  }
  @inline(__always) func guaranteeContinuation() throws {
    try guaranteeIn(_isContinuation)
  }

  func _legacyInvalidLengthCalculation(_ _buffer: (_storage: UInt32, ())) -> Int {
    // function body copied from UTF8.ForwardParser._invalidLength
    if _buffer._storage               & 0b0__1100_0000__1111_0000
                                     == 0b0__1000_0000__1110_0000 {
      // 2-byte prefix of 3-byte sequence. The top 5 bits of the decoded result
      // must be nonzero and not a surrogate
      let top5Bits = _buffer._storage & 0b0__0010_0000__0000_1111
      if top5Bits != 0 && top5Bits   != 0b0__0010_0000__0000_1101 { return 2 }
    }
    else if _buffer._storage                & 0b0__1100_0000__1111_1000
                                           == 0b0__1000_0000__1111_0000
    {
      // Prefix of 4-byte sequence. The top 5 bits of the decoded result
      // must be nonzero and no greater than 0b0__0100_0000
      let top5bits = UInt16(_buffer._storage & 0b0__0011_0000__0000_0111)
      if top5bits != 0 && top5bits.byteSwapped <= 0b0__0000_0100__0000_0000 {
        return _buffer._storage   & 0b0__1100_0000__0000_0000__0000_0000
                                 == 0b0__1000_0000__0000_0000__0000_0000 ? 3 : 2
      }
    }
    return 1
  }

  func _legacyNarrowIllegalRange(buf: Slice<UnsafeBufferPointer<UInt8>>) -> Range<Int> {
    var reversePacked: UInt32 = 0
    if let third = buf.dropFirst(2).first {
      reversePacked |= UInt32(third)
      reversePacked <<= 8
    }
    if let second = buf.dropFirst().first {
      reversePacked |= UInt32(second)
      reversePacked <<= 8
    }
    reversePacked |= UInt32(buf.first!)
    let _buffer: (_storage: UInt32, x: ()) = (reversePacked, ())
    let invalids = _legacyInvalidLengthCalculation(_buffer)
    return buf.startIndex ..< buf.startIndex + invalids
  }

  func findInvalidRange(_ buf: Slice<UnsafeBufferPointer<UInt8>>) -> Range<Int> {
    var endIndex = buf.startIndex
    var iter = buf.makeIterator()
    _ = iter.next()
    while let cu = iter.next(), !_isASCII(cu) && !_isUTF8MultiByteLeading(cu) {
      endIndex += 1
    }
    let illegalRange = Range(buf.startIndex...endIndex)
    _internalInvariant(illegalRange.clamped(to: (buf.startIndex..<buf.endIndex)) == illegalRange,
                 "illegal range out of full range")
    // FIXME: Remove the call to `_legacyNarrowIllegalRange` and return `illegalRange` directly
    return _legacyNarrowIllegalRange(buf: buf[illegalRange])
  }

  do {
    var isASCII = true
    while let cu = iter.next() {
      if _isASCII(cu) { lastValidIndex &+= 1; continue }
      isASCII = false
      if _slowPath(!_isUTF8MultiByteLeading(cu)) {
        throw UTF8ValidationError()
      }
      switch cu {
      case 0xC2...0xDF:
        try guaranteeContinuation()
        lastValidIndex &+= 2
      case 0xE0:
        try guaranteeIn(_isNotOverlong_E0)
        try guaranteeContinuation()
        lastValidIndex &+= 3
      case 0xE1...0xEC:
        try guaranteeContinuation()
        try guaranteeContinuation()
        lastValidIndex &+= 3
      case 0xED:
        try guaranteeIn(_isNotOverlong_ED)
        try guaranteeContinuation()
        lastValidIndex &+= 3
      case 0xEE...0xEF:
        try guaranteeContinuation()
        try guaranteeContinuation()
        lastValidIndex &+= 3
      case 0xF0:
        try guaranteeIn(_isNotOverlong_F0)
        try guaranteeContinuation()
        try guaranteeContinuation()
        lastValidIndex &+= 4
      case 0xF1...0xF3:
        try guaranteeContinuation()
        try guaranteeContinuation()
        try guaranteeContinuation()
        lastValidIndex &+= 4
      case 0xF4:
        try guaranteeIn(_isNotOverlong_F4)
        try guaranteeContinuation()
        try guaranteeContinuation()
        lastValidIndex &+= 4
      default:
        Builtin.unreachable()
      }
    }
    return .success(UTF8ExtraInfo(isASCII: isASCII))
  } catch {
    return .error(toBeReplaced: findInvalidRange(buf[lastValidIndex...]))
  }
}

----Swift.(file).repairUTF8(_:UnsafeBufferPointer<UInt8>,firstKnownBrokenRange:Range<Int>)
internal func repairUTF8(_ input: UnsafeBufferPointer<UInt8>, firstKnownBrokenRange: Range<Int>) -> String {
  _internalInvariant(input.count > 0, "empty input doesn't need to be repaired")
  _internalInvariant(firstKnownBrokenRange.clamped(to: input.indices) == firstKnownBrokenRange)
  // During this process, `remainingInput` contains the remaining bytes to process. It's split into three
  // non-overlapping sub-regions:
  //
  //  1. `goodChunk` (may be empty) containing bytes that are known good UTF-8 and can be copied into the output String
  //  2. `brokenRange` (never empty) the next range of broken bytes,
  //  3. the remainder (implicit, will become the next `remainingInput`)
  //
  // At the beginning of the process, the `goodChunk` starts at the beginning and extends to just before the first
  // known broken byte. The known broken bytes are covered in the `brokenRange` and everything following that is
  // the remainder.
  // We then copy the `goodChunk` into the target buffer and append a UTF8 replacement character. `brokenRange` is
  // skipped (replaced by the replacement character) and we restart the same process. This time, `goodChunk` extends
  // from the byte after the previous `brokenRange` to the next `brokenRange`.
  var result = _StringGuts()
  let replacementCharacterCount = Unicode.Scalar._replacementCharacter.withUTF8CodeUnits { $0.count }
  result.reserveCapacity(input.count + 5 * replacementCharacterCount) // extra space for some replacement characters

  var brokenRange: Range<Int> = firstKnownBrokenRange
  var remainingInput = input
  repeat {
    _internalInvariant(brokenRange.count > 0, "broken range empty")
    _internalInvariant(remainingInput.count > 0, "empty remaining input doesn't need to be repaired")
    let goodChunk = remainingInput[..<brokenRange.startIndex]

    // very likely this capacity reservation does not actually do anything because we reserved space for the entire
    // input plus up to five replacement characters up front
    result.reserveCapacity(result.count + remainingInput.count + replacementCharacterCount)

    // we can now safely append the next known good bytes and a replacement character
    result.appendInPlace(UnsafeBufferPointer(rebasing: goodChunk),
                         isASCII: false /* appending replacement character anyway, so let's not bother */)
    Unicode.Scalar._replacementCharacter.withUTF8CodeUnits {
      result.appendInPlace($0, isASCII: false)
    }

    remainingInput = UnsafeBufferPointer(rebasing: remainingInput[brokenRange.endIndex...])
    switch validateUTF8(remainingInput) {
    case .success:
      result.appendInPlace(remainingInput, isASCII: false)
      return String(result)
    case .error(let newBrokenRange):
      brokenRange = newBrokenRange
    }
  } while remainingInput.count > 0
  return String(result)
}

----Swift.(file).String.UTF8View.init(_:_StringGuts)
extension String.UTF8View {
    internal init(_ guts: _StringGuts) {
      self._guts = guts
      _invariantCheck()
    }
}

----Swift.(file)..(error_type).Index
extension String.UTF8View: BidirectionalCollection  {
  public typealias Index = String.I
}

----Swift.(file)..(error_type).Element
extension String.UTF8View: BidirectionalCollection  {
  public typealias Element = UTF8.C
}

----Swift.(file)..(error_type).startIndex
extension String.UTF8View: BidirectionalCollection  {
  public var startIndex: Index {
    @inline(__always) get { return _guts.startIndex }
  }
}

----Swift.(file)..(error_type).endIndex
extension String.UTF8View: BidirectionalCollection  {
  public var endIndex: Index {
    @inline(__always) get { return _guts.endIndex }
  }
}

----Swift.(file)..(error_type).index(after:String.UTF8View.Index)
extension String.UTF8View: BidirectionalCollection  {
  public func index(after i: Index) -> Index {
    if _fastPath(_guts.isFastUTF8) {
      return i.nextEncoded
    }

    return _foreignIndex(after: i)
  }
}

----Swift.(file)..(error_type).index(before:String.UTF8View.Index)
extension String.UTF8View: BidirectionalCollection  {
  public func index(before i: Index) -> Index {
    precondition(!i.isZeroPosition)
    if _fastPath(_guts.isFastUTF8) {
      return i.priorEncoded
    }

    return _foreignIndex(before: i)
  }
}

----Swift.(file)..(error_type).index(_:String.UTF8View.Index,offsetBy:Int)
extension String.UTF8View: BidirectionalCollection  {
  public func index(_ i: Index, offsetBy n: Int) -> Index {
    if _fastPath(_guts.isFastUTF8) {
      _precondition(n + i.encodedOffset <= _guts.count)
      return i.encoded(offsetBy: n)
    }

    return _foreignIndex(i, offsetBy: n)
  }
}

----Swift.(file)..(error_type).index(_:String.UTF8View.Index,offsetBy:Int,limitedBy:String.UTF8View.Index)
extension String.UTF8View: BidirectionalCollection  {
  public func index(
    _ i: Index, offsetBy n: Int, limitedBy limit: Index
  ) -> Index? {
    if _fastPath(_guts.isFastUTF8) {
      // Check the limit: ignore limit if it precedes `i` (in the correct
      // direction), otherwise must not be beyond limit (in the correct
      // direction).
      let iOffset = i.encodedOffset
      let result = iOffset + n
      let limitOffset = limit.encodedOffset
      if n >= 0 {
        guard limitOffset < iOffset || result <= limitOffset else { return nil }
      } else {
        guard limitOffset > iOffset || result >= limitOffset else { return nil }
      }
      return Index(encodedOffset: result)
    }

    return _foreignIndex(i, offsetBy: n, limitedBy: limit)
  }
}

----Swift.(file)..(error_type).distance(from:String.UTF8View.Index,to:String.UTF8View.Index)
extension String.UTF8View: BidirectionalCollection  {
  public func distance(from i: Index, to j: Index) -> Int {
    if _fastPath(_guts.isFastUTF8) {
      return j.encodedOffset &- i.encodedOffset
    }
    return _foreignDistance(from: i, to: j)
  }
}

----Swift.(file)..(error_type).subscript(_:String.UTF8View.Index)
extension String.UTF8View: BidirectionalCollection  {
  public subscript(i: Index) -> UTF8.CodeUnit {
    @inline(__always) get {
      String(_guts)._boundsCheck(i)
      if _fastPath(_guts.isFastUTF8) {
        return _guts.withFastUTF8 { utf8 in utf8[_unchecked: i.encodedOffset] }
      }

      return _foreignSubscript(position: i)
    }
  }
}

----Swift.(file)..(error_type).description
extension String.UTF8View: CustomStringConvertible  {
 public var description: String {
   @inline(__always) get { return String(String(_guts)) }
 }
}

----Swift.(file)..(error_type).debugDescription
extension String.UTF8View: CustomDebugStringConvertible  {
 public var debugDescription: String {
   return "UTF8View(\(self.description.debugDescription))"
 }
}

----Swift.(file).String.utf8
extension String  {
  public var utf8: UTF8View {
    @inline(__always) get { return UTF8View(self._guts) }
    set {
      // TODO(String testing): test suite doesn't currenlty exercise this code at
      // all, test it.
      self = String(utf8._guts)
    }
  }
}

----Swift.(file).String.utf8CString
extension String  {
  public var utf8CString: ContiguousArray<CChar> {
    if _fastPath(_guts.isFastUTF8) {
      var result = _guts.withFastCChar { ContiguousArray($0) }
      result.append(0)
      return result
    }

    return _slowUTF8CString()
  }
}

----Swift.(file).String.init(_:<<error type>>)
extension String  {
  public init(_ utf8: UTF8View) {
    self = String(utf8._guts)
  }
}

----Swift.(file)..(error_type).count
extension String.UTF8View  {
  public var count: Int {
    @inline(__always) get {
      if _fastPath(_guts.isFastUTF8) {
        return _guts.count
      }
      return _foreignCount()
    }
  }
}

----Swift.(file)..(error_type).init(_:String.Index,within:<<error type>>)
extension String.UTF8View.Index  {
  public init?(_ idx: String.Index, within target: String.UTF8View) {
    if _slowPath(target._guts.isForeign) {
      guard idx._foreignIsWithin(target) else { return nil }
    } else {
      // All indices, except sub-scalar UTF-16 indices pointing at trailing
      // surrogates, are valid.
      guard idx.transcodedOffset == 0 else { return nil }
    }

    self = idx
  }
}

----Swift.(file)..(error_type).customMirror
extension String.UTF8View : CustomReflectable  {
  public var customMirror: Mirror {
    return Mirror(self, unlabeledChildren: self)
  }
}

----Swift.(file)..(error_type).SubSequence
extension String.UTF8View  {
  public typealias SubSequence = Substring.U
}

----Swift.(file)..(error_type).subscript(_:Range<String.UTF8View.Index>)
extension String.UTF8View  {
  public subscript(r: Range<Index>) -> String.UTF8View.SubSequence {
    return Substring.UTF8View(self, _bounds: r)
  }
}

----Swift.(file)..(error_type).withContiguousStorageIfAvailable(_:(UnsafeBufferPointer<String.UTF8View.Element>) throws -> R)
extension String.UTF8View  {
  public func withContiguousStorageIfAvailable<R>(
    _ body: (UnsafeBufferPointer<Element>) throws -> R
  ) rethrows -> R? {
    guard _guts.isFastUTF8 else { return nil }
    return try _guts.withFastUTF8(body)
  }
}

----Swift.(file).String.UnicodeScalarView.init(_:_StringGuts)
extension String.UnicodeScalarView {
    internal init(_ _guts: _StringGuts) {
      self._guts = _guts
      _invariantCheck()
    }
}

----Swift.(file)..(error_type).Index
extension String.UnicodeScalarView: BidirectionalCollection  {
  public typealias Index = String.I
}

----Swift.(file)..(error_type).startIndex
extension String.UnicodeScalarView: BidirectionalCollection  {
  public var startIndex: Index {
    @inline(__always) get { return _guts.startIndex }
  }
}

----Swift.(file)..(error_type).endIndex
extension String.UnicodeScalarView: BidirectionalCollection  {
  public var endIndex: Index {
    @inline(__always) get { return _guts.endIndex }
  }
}

----Swift.(file)..(error_type).index(after:String.UnicodeScalarView.Index)
extension String.UnicodeScalarView: BidirectionalCollection  {
  public func index(after i: Index) -> Index {
    _internalInvariant(i < endIndex)
    // TODO(String performance): isASCII fast-path

    if _fastPath(_guts.isFastUTF8) {
      let len = _guts.fastUTF8ScalarLength(startingAt: i.encodedOffset)
      return i.encoded(offsetBy: len)
    }

    return _foreignIndex(after: i)
  }
}

----Swift.(file)..(error_type).index(before:String.UnicodeScalarView.Index)
extension String.UnicodeScalarView: BidirectionalCollection  {
  public func index(before i: Index) -> Index {
    precondition(i.encodedOffset > 0)
    // TODO(String performance): isASCII fast-path

    if _fastPath(_guts.isFastUTF8) {
      let len = _guts.withFastUTF8 { utf8 -> Int in
        return _utf8ScalarLength(utf8, endingAt: i.encodedOffset)
      }
      _internalInvariant(len <= 4, "invalid UTF8")
      return i.encoded(offsetBy: -len)
    }

    return _foreignIndex(before: i)
  }
}

----Swift.(file)..(error_type).subscript(_:String.UnicodeScalarView.Index)
extension String.UnicodeScalarView: BidirectionalCollection  {
  public subscript(position: Index) -> Unicode.Scalar {
    @inline(__always) get {
      String(_guts)._boundsCheck(position)
      let i = _guts.scalarAlign(position)
      return _guts.errorCorrectedScalar(startingAt: i.encodedOffset).0
    }
  }
}

----Swift.(file)..(error_type).Iterator.init(_:_StringGuts)
extension  {
    internal init(_ guts: _StringGuts) {
      self._end = guts.count
      self._guts = guts
    }
}

----Swift.(file)..(error_type).Iterator.next()
extension  {
    public mutating func next() -> Unicode.Scalar? {
      guard _fastPath(_position < _end) else { return nil }

      let (result, len) = _guts.errorCorrectedScalar(startingAt: _position)
      _position &+= len
      return result
    }
}

----Swift.(file)..(error_type).makeIterator()
extension String.UnicodeScalarView  {
  public __consuming func makeIterator() -> Iterator {
    return Iterator(_guts)
  }
}

----Swift.(file)..(error_type).description
extension String.UnicodeScalarView: CustomStringConvertible  {
 public var description: String {
   @inline(__always) get { return String(_guts) }
 }
}

----Swift.(file)..(error_type).debugDescription
extension String.UnicodeScalarView: CustomDebugStringConvertible  {
 public var debugDescription: String {
   return "StringUnicodeScalarView(\(self.description.debugDescription))"
 }
}

----Swift.(file).String.init(_:<<error type>>)
extension String  {
  public init(_ unicodeScalars: UnicodeScalarView) {
    self.init(unicodeScalars._guts)
  }
}

----Swift.(file).String.UnicodeScalarIndex
extension String  {
  public typealias UnicodeScalarIndex = UnicodeScalarView.I
}

----Swift.(file).String.unicodeScalars
extension String  {
  public var unicodeScalars: UnicodeScalarView {
    @inline(__always) get { return UnicodeScalarView(_guts) }
    @inline(__always) set { _guts = newValue._guts }
  }
}

----Swift.(file)..(error_type).init()
extension String.UnicodeScalarView : RangeReplaceableCollection  {
  public init() {
    self.init(_StringGuts())
  }
}

----Swift.(file)..(error_type).reserveCapacity(_:Int)
extension String.UnicodeScalarView : RangeReplaceableCollection  {
  public mutating func reserveCapacity(_ n: Int) {
    self._guts.reserveCapacity(n)
  }
}

----Swift.(file)..(error_type).append(_:Unicode.Scalar)
extension String.UnicodeScalarView : RangeReplaceableCollection  {
  public mutating func append(_ c: Unicode.Scalar) {
    self._guts.append(String(c)._guts)
  }
}

----Swift.(file)..(error_type).append(contentsOf:S)
extension String.UnicodeScalarView : RangeReplaceableCollection  {
  public mutating func append<S : Sequence>(contentsOf newElements: S)
  where S.Element == Unicode.Scalar {
    // TODO(String performance): Skip extra String allocation
    let scalars = String(decoding: newElements.map { $0.value }, as: UTF32.self)
    self = (String(self._guts) + scalars).unicodeScalars
  }
}

----Swift.(file)..(error_type).replaceSubrange(_:Range<String.UnicodeScalarView.Index>,with:C)
extension String.UnicodeScalarView : RangeReplaceableCollection  {
  public mutating func replaceSubrange<C>(
    _ bounds: Range<Index>,
    with newElements: C
  ) where C : Collection, C.Element == Unicode.Scalar {
    // TODO(String performance): Skip extra String and Array allocation

    let utf8Replacement = newElements.flatMap { String($0).utf8 }
    let replacement = utf8Replacement.withUnsafeBufferPointer {
      return String._uncheckedFromUTF8($0)
    }
    var copy = String(_guts)
    copy.replaceSubrange(bounds, with: replacement)
    self = copy.unicodeScalars
  }
}

----Swift.(file)..(error_type).init(_:String.Index,within:<<error type>>)
extension String.UnicodeScalarIndex  {
  public init?(
    _ sourcePosition: String.Index,
    within unicodeScalars: String.UnicodeScalarView
  ) {
    guard unicodeScalars._guts.isOnUnicodeScalarBoundary(sourcePosition) else {
      return nil
    }
    self = sourcePosition
  }
}

----Swift.(file)..(error_type).samePosition(in:String)
extension String.UnicodeScalarIndex  {
  public func samePosition(in characters: String) -> String.Index? {
    return String.Index(self, within: characters)
  }
}

----Swift.(file)..(error_type).customMirror
extension String.UnicodeScalarView : CustomReflectable  {
  public var customMirror: Mirror {
    return Mirror(self, unlabeledChildren: self)
  }
}

----Swift.(file)..(error_type).SubSequence
extension String.UnicodeScalarView  {
  public typealias SubSequence = Substring.U
}

----Swift.(file)..(error_type).subscript(_:Range<String.UnicodeScalarView.Index>)
extension String.UnicodeScalarView  {
  public subscript(r: Range<Index>) -> String.UnicodeScalarView.SubSequence {
    return String.UnicodeScalarView.SubSequence(self, _bounds: r)
  }
}

----Swift.(file).String.init(_:Substring)
extension String  {
  public init(_ substring: __shared Substring) {
    self = String._fromSubstring(substring)
  }
}

----Swift.(file).Substring.init(_:Slice<String>)
extension Substring {
  internal init(_ slice: Slice<String>) {
    self._slice = slice
    _invariantCheck()
  }
}

----Swift.(file).Substring.init(_:<<error type>>)
extension Substring {
  internal init(_ slice: _StringGutsSlice) {
    self.init(String(slice._guts)[slice.range])
  }
}

----Swift.(file).Substring.init()
extension Substring {
  public init() {
    self.init(Slice())
  }
}

----Swift.(file).Substring.Index
extension Substring: StringProtocol  {
  public typealias Index = String.I
}

----Swift.(file).Substring.SubSequence
extension Substring: StringProtocol  {
  public typealias SubSequence = S
}

----Swift.(file).Substring.startIndex
extension Substring: StringProtocol  {
  public var startIndex: Index {
    @inline(__always) get { return _slice.startIndex }
  }
}

----Swift.(file).Substring.endIndex
extension Substring: StringProtocol  {
  public var endIndex: Index {
    @inline(__always) get { return _slice.endIndex }
  }
}

----Swift.(file).Substring.index(after:Substring.Index)
extension Substring: StringProtocol  {
  public func index(after i: Index) -> Index {
    _precondition(i < endIndex, "Cannot increment beyond endIndex")
    _precondition(i >= startIndex, "Cannot increment an invalid index")
    return _slice.index(after: i)
  }
}

----Swift.(file).Substring.index(before:Substring.Index)
extension Substring: StringProtocol  {
  public func index(before i: Index) -> Index {
    _precondition(i <= endIndex, "Cannot decrement an invalid index")
    _precondition(i > startIndex, "Cannot decrement beyond startIndex")
    return _slice.index(before: i)
  }
}

----Swift.(file).Substring.index(_:Substring.Index,offsetBy:Int)
extension Substring: StringProtocol  {
  public func index(_ i: Index, offsetBy n: Int) -> Index {
    let result = _slice.index(i, offsetBy: n)
    _precondition(
      (_slice._startIndex ... _slice.endIndex).contains(result),
      "Operation results in an invalid index")
    return result
  }
}

----Swift.(file).Substring.index(_:Substring.Index,offsetBy:Int,limitedBy:Substring.Index)
extension Substring: StringProtocol  {
  public func index(
    _ i: Index, offsetBy n: Int, limitedBy limit: Index
  ) -> Index? {
    let result = _slice.index(i, offsetBy: n, limitedBy: limit)
    _precondition(result.map {
        (_slice._startIndex ... _slice.endIndex).contains($0)
      } ?? true,
      "Operation results in an invalid index")
    return result
  }
}

----Swift.(file).Substring.distance(from:Substring.Index,to:Substring.Index)
extension Substring: StringProtocol  {
  public func distance(from start: Index, to end: Index) -> Int {
    return _slice.distance(from: start, to: end)
  }
}

----Swift.(file).Substring.subscript(_:Substring.Index)
extension Substring: StringProtocol  {
  public subscript(i: Index) -> Character {
    return _slice[i]
  }
}

----Swift.(file).Substring.replaceSubrange(_:Range<Substring.Index>,with:C)
extension Substring: StringProtocol  {
  public mutating func replaceSubrange<C>(
    _ bounds: Range<Index>,
    with newElements: C
  ) where C : Collection, C.Iterator.Element == Iterator.Element {
    _slice.replaceSubrange(bounds, with: newElements)
  }
}

----Swift.(file).Substring.replaceSubrange(_:Range<Substring.Index>,with:Substring)
extension Substring: StringProtocol  {
  public mutating func replaceSubrange(
    _ bounds: Range<Index>, with newElements: Substring
  ) {
    replaceSubrange(bounds, with: newElements._slice)
  }
}

----Swift.(file).Substring.init(decoding:C,as:Encoding.Type)
extension Substring: StringProtocol  {
  public init<C: Collection, Encoding: _UnicodeEncoding>(
    decoding codeUnits: C, as sourceEncoding: Encoding.Type
  ) where C.Iterator.Element == Encoding.CodeUnit {
    self.init(String(decoding: codeUnits, as: sourceEncoding))
  }
}

----Swift.(file).Substring.init(cString:UnsafePointer<CChar>)
extension Substring: StringProtocol  {
  public init(cString nullTerminatedUTF8: UnsafePointer<CChar>) {
    self.init(String(cString: nullTerminatedUTF8))
  }
}

----Swift.(file).Substring.init(decodingCString:UnsafePointer<Encoding.CodeUnit>,as:Encoding.Type)
extension Substring: StringProtocol  {
  public init<Encoding: _UnicodeEncoding>(
    decodingCString nullTerminatedCodeUnits: UnsafePointer<Encoding.CodeUnit>,
    as sourceEncoding: Encoding.Type
  ) {
    self.init(
      String(decodingCString: nullTerminatedCodeUnits, as: sourceEncoding))
  }
}

----Swift.(file).Substring.withCString(_:(UnsafePointer<CChar>) throws -> Result)
extension Substring: StringProtocol  {
  public func withCString<Result>(
    _ body: (UnsafePointer<CChar>) throws -> Result) rethrows -> Result {
    // TODO(String performance): Detect when we cover the rest of a nul-
    // terminated String, and thus can avoid a copy.
    return try String(self).withCString(body)
  }
}

----Swift.(file).Substring.withCString(encodedAs:TargetEncoding.Type,_:(UnsafePointer<TargetEncoding.CodeUnit>) throws -> Result)
extension Substring: StringProtocol  {
  public func withCString<Result, TargetEncoding: _UnicodeEncoding>(
    encodedAs targetEncoding: TargetEncoding.Type,
    _ body: (UnsafePointer<TargetEncoding.CodeUnit>) throws -> Result
  ) rethrows -> Result {
    // TODO(String performance): Detect when we cover the rest of a nul-
    // terminated String, and thus can avoid a copy.
    return try String(self).withCString(encodedAs: targetEncoding, body)
  }
}

----Swift.(file).Substring.customMirror
extension Substring : CustomReflectable  {
 public var customMirror: Mirror { return String(self).customMirror }
}

----Swift.(file).Substring.description
extension Substring : CustomStringConvertible  {
  public var description: String {
    @inline(__always) get { return String(self) }
  }
}

----Swift.(file).Substring.debugDescription
extension Substring : CustomDebugStringConvertible  {
  public var debugDescription: String { return String(self).debugDescription }
}

----Swift.(file).Substring.init(_:String)
extension Substring : LosslessStringConvertible  {
  public init(_ content: String) {
    self = content[...]
  }
}

----Swift.(file).Substring.UTF8View.init(_slice:Slice<String.UTF8View>)
extension Substring.UTF8View {
  public struct U
}

----Swift.(file).Substring.UTF8View.Index
extension Substring.UTF8View : BidirectionalCollection  {
  public typealias Index = String.UTF8View.I
}

----Swift.(file).Substring.UTF8View.Indices
extension Substring.UTF8View : BidirectionalCollection  {
  public typealias Indices = String.UTF8View.I
}

----Swift.(file).Substring.UTF8View.Element
extension Substring.UTF8View : BidirectionalCollection  {
  public typealias Element = String.UTF8View.E
}

----Swift.(file).Substring.UTF8View.SubSequence
extension Substring.UTF8View : BidirectionalCollection  {
  public typealias SubSequence = Substring.U
}

----Swift.(file).Substring.UTF8View.init(_:String.UTF8View,_bounds:Range<Substring.UTF8View.Index>)
extension Substring.UTF8View : BidirectionalCollection  {
  internal init(_ base: String.UTF8View, _bounds: Range<Index>) {
    _slice = Slice(
      base: String(base._guts).utf8,
      bounds: _bounds)
  }
}

----Swift.(file).Substring.UTF8View.startIndex
extension Substring.UTF8View : BidirectionalCollection  {
  public var startIndex: Index { return _slice.startIndex }
}

----Swift.(file).Substring.UTF8View.endIndex
extension Substring.UTF8View : BidirectionalCollection  {
  public var endIndex: Index { return _slice.endIndex }
}

----Swift.(file).Substring.UTF8View.subscript(_:Substring.UTF8View.Index)
extension Substring.UTF8View : BidirectionalCollection  {
  public subscript(index: Index) -> Element { return _slice[index] }
}

----Swift.(file).Substring.UTF8View.indices
extension Substring.UTF8View : BidirectionalCollection  {
  public var indices: Indices { return _slice.indices }
}

----Swift.(file).Substring.UTF8View.index(after:Substring.UTF8View.Index)
extension Substring.UTF8View : BidirectionalCollection  {
  public func index(after i: Index) -> Index { return _slice.index(after: i) }
}

----Swift.(file).Substring.UTF8View.formIndex(after:Substring.UTF8View.Index)
extension Substring.UTF8View : BidirectionalCollection  {
  public func formIndex(after i: inout Index) {
    _slice.formIndex(after: &i)
  }
}

----Swift.(file).Substring.UTF8View.index(_:Substring.UTF8View.Index,offsetBy:Int)
extension Substring.UTF8View : BidirectionalCollection  {
  public func index(_ i: Index, offsetBy n: Int) -> Index {
    return _slice.index(i, offsetBy: n)
  }
}

----Swift.(file).Substring.UTF8View.index(_:Substring.UTF8View.Index,offsetBy:Int,limitedBy:Substring.UTF8View.Index)
extension Substring.UTF8View : BidirectionalCollection  {
  public func index(
    _ i: Index, offsetBy n: Int, limitedBy limit: Index
  ) -> Index? {
    return _slice.index(i, offsetBy: n, limitedBy: limit)
  }
}

----Swift.(file).Substring.UTF8View.distance(from:Substring.UTF8View.Index,to:Substring.UTF8View.Index)
extension Substring.UTF8View : BidirectionalCollection  {
  public func distance(from start: Index, to end: Index) -> Int {
    return _slice.distance(from: start, to: end)
  }
}

----Swift.(file).Substring.UTF8View.index(before:Substring.UTF8View.Index)
extension Substring.UTF8View : BidirectionalCollection  {
  public func index(before i: Index) -> Index { return _slice.index(before: i) }
}

----Swift.(file).Substring.UTF8View.formIndex(before:Substring.UTF8View.Index)
extension Substring.UTF8View : BidirectionalCollection  {
  public func formIndex(before i: inout Index) {
    _slice.formIndex(before: &i)
  }
}

----Swift.(file).Substring.UTF8View.subscript(_:Range<Substring.UTF8View.Index>)
extension Substring.UTF8View : BidirectionalCollection  {
  public subscript(r: Range<Index>) -> Substring.UTF8View {
    // FIXME(strings): tests.
    _precondition(r.lowerBound >= startIndex && r.upperBound <= endIndex,
      "UTF8View index range out of bounds")
    return Substring.UTF8View(_slice.base, _bounds: r)
  }
}

----Swift.(file).Substring.utf8
extension Substring  {
  public var utf8: UTF8View {
    get {
      return _wholeString.utf8[startIndex..<endIndex]
    }
    set {
      self = Substring(newValue)
    }
  }
}

----Swift.(file).Substring.init(_:Substring.UTF8View)
extension Substring  {
  public init(_ content: UTF8View) {
    self = String(
      content._slice.base._guts
    )[content.startIndex..<content.endIndex]
  }
}

----Swift.(file).String.init(_:Substring.UTF8View)
extension String  {
  public init?(_ codeUnits: Substring.UTF8View) {
    let guts = codeUnits._slice.base._guts
    guard guts.isOnUnicodeScalarBoundary(codeUnits._slice.startIndex),
          guts.isOnUnicodeScalarBoundary(codeUnits._slice.endIndex) else {
      return nil
    }

    self = String(Substring(codeUnits))
  }
}

----Swift.(file).Substring.UTF16View.init(_slice:Slice<String.UTF16View>)
extension Substring.UTF16View {
  public struct U
}

----Swift.(file).Substring.UTF16View.Index
extension Substring.UTF16View : BidirectionalCollection  {
  public typealias Index = String.UTF16View.I
}

----Swift.(file).Substring.UTF16View.Indices
extension Substring.UTF16View : BidirectionalCollection  {
  public typealias Indices = String.UTF16View.I
}

----Swift.(file).Substring.UTF16View.Element
extension Substring.UTF16View : BidirectionalCollection  {
  public typealias Element = String.UTF16View.E
}

----Swift.(file).Substring.UTF16View.SubSequence
extension Substring.UTF16View : BidirectionalCollection  {
  public typealias SubSequence = Substring.U
}

----Swift.(file).Substring.UTF16View.init(_:String.UTF16View,_bounds:Range<Substring.UTF16View.Index>)
extension Substring.UTF16View : BidirectionalCollection  {
  internal init(_ base: String.UTF16View, _bounds: Range<Index>) {
    _slice = Slice(
      base: String(base._guts).utf16,
      bounds: _bounds)
  }
}

----Swift.(file).Substring.UTF16View.startIndex
extension Substring.UTF16View : BidirectionalCollection  {
  public var startIndex: Index { return _slice.startIndex }
}

----Swift.(file).Substring.UTF16View.endIndex
extension Substring.UTF16View : BidirectionalCollection  {
  public var endIndex: Index { return _slice.endIndex }
}

----Swift.(file).Substring.UTF16View.subscript(_:Substring.UTF16View.Index)
extension Substring.UTF16View : BidirectionalCollection  {
  public subscript(index: Index) -> Element { return _slice[index] }
}

----Swift.(file).Substring.UTF16View.indices
extension Substring.UTF16View : BidirectionalCollection  {
  public var indices: Indices { return _slice.indices }
}

----Swift.(file).Substring.UTF16View.index(after:Substring.UTF16View.Index)
extension Substring.UTF16View : BidirectionalCollection  {
  public func index(after i: Index) -> Index { return _slice.index(after: i) }
}

----Swift.(file).Substring.UTF16View.formIndex(after:Substring.UTF16View.Index)
extension Substring.UTF16View : BidirectionalCollection  {
  public func formIndex(after i: inout Index) {
    _slice.formIndex(after: &i)
  }
}

----Swift.(file).Substring.UTF16View.index(_:Substring.UTF16View.Index,offsetBy:Int)
extension Substring.UTF16View : BidirectionalCollection  {
  public func index(_ i: Index, offsetBy n: Int) -> Index {
    return _slice.index(i, offsetBy: n)
  }
}

----Swift.(file).Substring.UTF16View.index(_:Substring.UTF16View.Index,offsetBy:Int,limitedBy:Substring.UTF16View.Index)
extension Substring.UTF16View : BidirectionalCollection  {
  public func index(
    _ i: Index, offsetBy n: Int, limitedBy limit: Index
  ) -> Index? {
    return _slice.index(i, offsetBy: n, limitedBy: limit)
  }
}

----Swift.(file).Substring.UTF16View.distance(from:Substring.UTF16View.Index,to:Substring.UTF16View.Index)
extension Substring.UTF16View : BidirectionalCollection  {
  public func distance(from start: Index, to end: Index) -> Int {
    return _slice.distance(from: start, to: end)
  }
}

----Swift.(file).Substring.UTF16View.index(before:Substring.UTF16View.Index)
extension Substring.UTF16View : BidirectionalCollection  {
  public func index(before i: Index) -> Index { return _slice.index(before: i) }
}

----Swift.(file).Substring.UTF16View.formIndex(before:Substring.UTF16View.Index)
extension Substring.UTF16View : BidirectionalCollection  {
  public func formIndex(before i: inout Index) {
    _slice.formIndex(before: &i)
  }
}

----Swift.(file).Substring.UTF16View.subscript(_:Range<Substring.UTF16View.Index>)
extension Substring.UTF16View : BidirectionalCollection  {
  public subscript(r: Range<Index>) -> Substring.UTF16View {
    return Substring.UTF16View(_slice.base, _bounds: r)
  }
}

----Swift.(file).Substring.utf16
extension Substring  {
  public var utf16: UTF16View {
    get {
      return _wholeString.utf16[startIndex..<endIndex]
    }
    set {
      self = Substring(newValue)
    }
  }
}

----Swift.(file).Substring.init(_:Substring.UTF16View)
extension Substring  {
  public init(_ content: UTF16View) {
    self = String(
      content._slice.base._guts
    )[content.startIndex..<content.endIndex]
  }
}

----Swift.(file).String.init(_:Substring.UTF16View)
extension String  {
  public init?(_ codeUnits: Substring.UTF16View) {
    let guts = codeUnits._slice.base._guts
    guard guts.isOnUnicodeScalarBoundary(codeUnits._slice.startIndex),
          guts.isOnUnicodeScalarBoundary(codeUnits._slice.endIndex) else {
      return nil
    }

    self = String(Substring(codeUnits))
  }
}

----Swift.(file).Substring.UnicodeScalarView.init(_slice:Slice<String.UnicodeScalarView>)
extension Substring.UnicodeScalarView {
  public struct U
}

----Swift.(file).Substring.UnicodeScalarView.Index
extension Substring.UnicodeScalarView : BidirectionalCollection  {
  public typealias Index = String.UnicodeScalarView.I
}

----Swift.(file).Substring.UnicodeScalarView.Indices
extension Substring.UnicodeScalarView : BidirectionalCollection  {
  public typealias Indices = String.UnicodeScalarView.I
}

----Swift.(file).Substring.UnicodeScalarView.Element
extension Substring.UnicodeScalarView : BidirectionalCollection  {
  public typealias Element = String.UnicodeScalarView.E
}

----Swift.(file).Substring.UnicodeScalarView.SubSequence
extension Substring.UnicodeScalarView : BidirectionalCollection  {
  public typealias SubSequence = Substring.U
}

----Swift.(file).Substring.UnicodeScalarView.init(_:String.UnicodeScalarView,_bounds:Range<Substring.UnicodeScalarView.Index>)
extension Substring.UnicodeScalarView : BidirectionalCollection  {
  internal init(_ base: String.UnicodeScalarView, _bounds: Range<Index>) {
    _slice = Slice(
      base: String(base._guts).unicodeScalars,
      bounds: _bounds)
  }
}

----Swift.(file).Substring.UnicodeScalarView.startIndex
extension Substring.UnicodeScalarView : BidirectionalCollection  {
  public var startIndex: Index { return _slice.startIndex }
}

----Swift.(file).Substring.UnicodeScalarView.endIndex
extension Substring.UnicodeScalarView : BidirectionalCollection  {
  public var endIndex: Index { return _slice.endIndex }
}

----Swift.(file).Substring.UnicodeScalarView.subscript(_:Substring.UnicodeScalarView.Index)
extension Substring.UnicodeScalarView : BidirectionalCollection  {
  public subscript(index: Index) -> Element { return _slice[index] }
}

----Swift.(file).Substring.UnicodeScalarView.indices
extension Substring.UnicodeScalarView : BidirectionalCollection  {
  public var indices: Indices { return _slice.indices }
}

----Swift.(file).Substring.UnicodeScalarView.index(after:Substring.UnicodeScalarView.Index)
extension Substring.UnicodeScalarView : BidirectionalCollection  {
  public func index(after i: Index) -> Index { return _slice.index(after: i) }
}

----Swift.(file).Substring.UnicodeScalarView.formIndex(after:Substring.UnicodeScalarView.Index)
extension Substring.UnicodeScalarView : BidirectionalCollection  {
  public func formIndex(after i: inout Index) {
    _slice.formIndex(after: &i)
  }
}

----Swift.(file).Substring.UnicodeScalarView.index(_:Substring.UnicodeScalarView.Index,offsetBy:Int)
extension Substring.UnicodeScalarView : BidirectionalCollection  {
  public func index(_ i: Index, offsetBy n: Int) -> Index {
    return _slice.index(i, offsetBy: n)
  }
}

----Swift.(file).Substring.UnicodeScalarView.index(_:Substring.UnicodeScalarView.Index,offsetBy:Int,limitedBy:Substring.UnicodeScalarView.Index)
extension Substring.UnicodeScalarView : BidirectionalCollection  {
  public func index(
    _ i: Index, offsetBy n: Int, limitedBy limit: Index
  ) -> Index? {
    return _slice.index(i, offsetBy: n, limitedBy: limit)
  }
}

----Swift.(file).Substring.UnicodeScalarView.distance(from:Substring.UnicodeScalarView.Index,to:Substring.UnicodeScalarView.Index)
extension Substring.UnicodeScalarView : BidirectionalCollection  {
  public func distance(from start: Index, to end: Index) -> Int {
    return _slice.distance(from: start, to: end)
  }
}

----Swift.(file).Substring.UnicodeScalarView.index(before:Substring.UnicodeScalarView.Index)
extension Substring.UnicodeScalarView : BidirectionalCollection  {
  public func index(before i: Index) -> Index { return _slice.index(before: i) }
}

----Swift.(file).Substring.UnicodeScalarView.formIndex(before:Substring.UnicodeScalarView.Index)
extension Substring.UnicodeScalarView : BidirectionalCollection  {
  public func formIndex(before i: inout Index) {
    _slice.formIndex(before: &i)
  }
}

----Swift.(file).Substring.UnicodeScalarView.subscript(_:Range<Substring.UnicodeScalarView.Index>)
extension Substring.UnicodeScalarView : BidirectionalCollection  {
  public subscript(r: Range<Index>) -> Substring.UnicodeScalarView {
    return Substring.UnicodeScalarView(_slice.base, _bounds: r)
  }
}

----Swift.(file).Substring.unicodeScalars
extension Substring  {
  public var unicodeScalars: UnicodeScalarView {
    get {
      return _wholeString.unicodeScalars[startIndex..<endIndex]
    }
    set {
      self = Substring(newValue)
    }
  }
}

----Swift.(file).Substring.init(_:Substring.UnicodeScalarView)
extension Substring  {
  public init(_ content: UnicodeScalarView) {
    self = String(
      content._slice.base._guts
    )[content.startIndex..<content.endIndex]
  }
}

----Swift.(file).String.init(_:Substring.UnicodeScalarView)
extension String  {
  public init(_ content: Substring.UnicodeScalarView) {
    self = String(Substring(content))
  }
}

----Swift.(file).Substring.UnicodeScalarView.init()
extension Substring.UnicodeScalarView : RangeReplaceableCollection  {
  public init() { _slice = Slice.init() }
}

----Swift.(file).Substring.UnicodeScalarView.replaceSubrange(_:Range<Substring.UnicodeScalarView.Index>,with:C)
extension Substring.UnicodeScalarView : RangeReplaceableCollection  {
  public mutating func replaceSubrange<C : Collection>(
    _ target: Range<Index>, with replacement: C
  ) where C.Element == Element {
    _slice.replaceSubrange(target, with: replacement)
  }
}

----Swift.(file).Substring.init(_:S)
extension Substring : RangeReplaceableCollection  {
  public init<S : Sequence>(_ elements: S)
  where S.Element == Character {
    if let str = elements as? String {
      self = str[...]
      return
    }
    if let subStr = elements as? Substring {
      self = subStr
      return
    }
    self = String(elements)[...]
  }
}

----Swift.(file).Substring.append(contentsOf:S)
extension Substring : RangeReplaceableCollection  {
  public mutating func append<S : Sequence>(contentsOf elements: S)
  where S.Element == Character {
    var string = String(self)
    self = Substring() // Keep unique storage if possible
    string.append(contentsOf: elements)
    self = Substring(string)
  }
}

----Swift.(file).Substring.lowercased()
extension Substring  {
  public func lowercased() -> String {
    return String(self).lowercased()
  }
}

----Swift.(file).Substring.uppercased()
extension Substring  {
  public func uppercased() -> String {
    return String(self).uppercased()
  }
}

----Swift.(file).Substring.filter(_:(Substring.Element) throws -> Bool)
extension Substring  {
  public func filter(
    _ isIncluded: (Element) throws -> Bool
  ) rethrows -> String {
    return try String(self.lazy.filter(isIncluded))
  }
}

----Swift.(file).Substring.write(_:String)
extension Substring : TextOutputStream  {
  public mutating func write(_ other: String) {
    append(contentsOf: other)
  }
}

----Swift.(file).Substring.write(to:Target)
extension Substring : TextOutputStreamable  {
  public func write<Target : TextOutputStream>(to target: inout Target) {
    target.write(String(self))
  }
}

----Swift.(file).Substring.init(unicodeScalarLiteral:String)
extension Substring : ExpressibleByUnicodeScalarLiteral  {
  public init(unicodeScalarLiteral value: String) {
     self.init(value)
  }
}

----Swift.(file).Substring.init(extendedGraphemeClusterLiteral:String)
extension Substring : ExpressibleByExtendedGraphemeClusterLiteral  {
  public init(extendedGraphemeClusterLiteral value: String) {
     self.init(value)
  }
}

----Swift.(file).Substring.init(stringLiteral:String)
extension Substring : ExpressibleByStringLiteral  {
  public init(stringLiteral value: String) {
     self.init(value)
  }
}

----Swift.(file).String.subscript(_:Range<String.Index>)
extension String  {
  public subscript(r: Range<Index>) -> Substring {
    _boundsCheck(r)
    return Substring(Slice(base: self, bounds: r))
  }
}

----Swift.(file).Substring.subscript(_:Range<Substring.Index>)
extension Substring  {
  public subscript(r: Range<Index>) -> Substring {
    return Substring(_slice[r])
  }
}

----Swift.(file).__SwiftNativeNSArrayWithContiguousStorage.count
extension __SwiftNativeNSArrayWithContiguousStorage : _NSArrayCore  {
  @objc internal var count: Int {
    return withUnsafeBufferOfObjects { $0.count }
  }
}

----Swift.(file).__SwiftNativeNSArrayWithContiguousStorage.objectAt(_:Int)
extension __SwiftNativeNSArrayWithContiguousStorage : _NSArrayCore  {
  internal func objectAt(_ index: Int) -> AnyObject {
    return withUnsafeBufferOfObjects {
      objects in
      _precondition(
        _isValidArraySubscript(index, count: objects.count),
        "Array index out of range")
      return objects[index]
    }
  }
}

----Swift.(file).__SwiftNativeNSArrayWithContiguousStorage.getObjects(_:UnsafeMutablePointer<AnyObject>,range:_SwiftNSRange)
extension __SwiftNativeNSArrayWithContiguousStorage : _NSArrayCore  {
  @objc internal func getObjects(
    _ aBuffer: UnsafeMutablePointer<AnyObject>, range: _SwiftNSRange
  ) {
    return withUnsafeBufferOfObjects {
      objects in
      _precondition(
        _isValidArrayIndex(range.location, count: objects.count),
        "Array index out of range")

      _precondition(
        _isValidArrayIndex(
          range.location + range.length, count: objects.count),
        "Array index out of range")

      if objects.isEmpty { return }

      // These objects are "returned" at +0, so treat them as pointer values to
      // avoid retains. Copy bytes via a raw pointer to circumvent reference
      // counting while correctly aliasing with all other pointer types.
      UnsafeMutableRawPointer(aBuffer).copyMemory(
        from: objects.baseAddress! + range.location,
        byteCount: range.length * MemoryLayout<AnyObject>.stride)
    }
  }
}

----Swift.(file).__SwiftNativeNSArrayWithContiguousStorage.countByEnumerating(with:UnsafeMutablePointer<_SwiftNSFastEnumerationState>,objects:UnsafeMutablePointer<AnyObject>?,count:Int)
extension __SwiftNativeNSArrayWithContiguousStorage : _NSArrayCore  {
  internal func countByEnumerating(
    with state: UnsafeMutablePointer<_SwiftNSFastEnumerationState>,
    objects: UnsafeMutablePointer<AnyObject>?, count: Int
  ) -> Int {
    var enumerationState = state.pointee

    if enumerationState.state != 0 {
      return 0
    }

    return withUnsafeBufferOfObjects {
      objects in
      enumerationState.mutationsPtr = _fastEnumerationStorageMutationsPtr
      enumerationState.itemsPtr =
        AutoreleasingUnsafeMutablePointer(objects.baseAddress)
      enumerationState.state = 1
      state.pointee = enumerationState
      return objects.count
    }
  }
}

----Swift.(file).__SwiftNativeNSArrayWithContiguousStorage.copy(with:<<error type>>)
extension __SwiftNativeNSArrayWithContiguousStorage : _NSArrayCore  {
  internal func copy(with _: _SwiftNSZone?) -> AnyObject {
    return self
  }
}

----Swift.(file)._UIntBuffer.SubSequence
extension _UIntBuffer : Sequence  {
  public typealias SubSequence = Slice<_UIntBuffer>
}

----Swift.(file)._UIntBuffer.Iterator.init(_:_UIntBuffer<Element>)
extension _UIntBuffer.Iterator {
    public init(_ x: _UIntBuffer) { _impl = x }
}

----Swift.(file)._UIntBuffer.Iterator.next()
extension _UIntBuffer.Iterator {
    public mutating func next() -> Element? {
      if _impl._bitCount == 0 { return nil }
      defer {
        _impl._storage = _impl._storage &>> Element.bitWidth
        _impl._bitCount = _impl._bitCount &- _impl._elementWidth
      }
      return Element(truncatingIfNeeded: _impl._storage)
    }
}

----Swift.(file)._UIntBuffer.makeIterator()
extension _UIntBuffer : Sequence  {
  public func makeIterator() -> Iterator {
    return Iterator(self)
  }
}

----Swift.(file)._UIntBuffer.Index.bitOffset
extension _UIntBuffer.Index {
    internal var b
}

----Swift.(file)._UIntBuffer.Index.init(bitOffset:UInt8)
extension _UIntBuffer.Index {
    internal init(bitOffset: UInt8) { self.bitOffset = bitOffset }
}

----Swift.(file)._UIntBuffer.Index.==infix(_:_UIntBuffer<Element>.Index,_:_UIntBuffer<Element>.Index)
extension _UIntBuffer.Index {
    public static func == (lhs: Index, rhs: Index) -> Bool {
      return lhs.bitOffset == rhs.bitOffset
    }
}

----Swift.(file)._UIntBuffer.Index.<infix(_:_UIntBuffer<Element>.Index,_:_UIntBuffer<Element>.Index)
extension _UIntBuffer.Index {
    public static func < (lhs: Index, rhs: Index) -> Bool {
      return lhs.bitOffset < rhs.bitOffset
    }
}

----Swift.(file)._UIntBuffer.startIndex
extension _UIntBuffer : Collection  {
  public var startIndex : Index {
    @inline(__always)
    get { return Index(bitOffset: 0) }
  }
}

----Swift.(file)._UIntBuffer.endIndex
extension _UIntBuffer : Collection  {
  public var endIndex : Index {
    @inline(__always)
    get { return Index(bitOffset: _bitCount) }
  }
}

----Swift.(file)._UIntBuffer.index(after:_UIntBuffer<Element>.Index)
extension _UIntBuffer : Collection  {
  public func index(after i: Index) -> Index {
    return Index(bitOffset: i.bitOffset &+ _elementWidth)
  }
}

----Swift.(file)._UIntBuffer.subscript(_:_UIntBuffer<Element>.Index)
extension _UIntBuffer : Collection  {
  public subscript(i: Index) -> Element {
    @inline(__always)
    get {
      return Element(truncatingIfNeeded: _storage &>> i.bitOffset)
    }
  }
}

----Swift.(file)._UIntBuffer.index(before:_UIntBuffer<Element>.Index)
extension _UIntBuffer : BidirectionalCollection  {
  public func index(before i: Index) -> Index {
    return Index(bitOffset: i.bitOffset &- _elementWidth)
  }
}

----Swift.(file)._UIntBuffer.Indices
extension _UIntBuffer : RandomAccessCollection  {
  public typealias Indices = DefaultIndices<_UIntBuffer>
}

----Swift.(file)._UIntBuffer.index(_:_UIntBuffer<Element>.Index,offsetBy:Int)
extension _UIntBuffer : RandomAccessCollection  {
  public func index(_ i: Index, offsetBy n: Int) -> Index {
    let x = Int(i.bitOffset) &+ n &* Element.bitWidth
    return Index(bitOffset: UInt8(truncatingIfNeeded: x))
  }
}

----Swift.(file)._UIntBuffer.distance(from:_UIntBuffer<Element>.Index,to:_UIntBuffer<Element>.Index)
extension _UIntBuffer : RandomAccessCollection  {
  public func distance(from i: Index, to j: Index) -> Int {
    return (Int(j.bitOffset) &- Int(i.bitOffset)) / Element.bitWidth
  }
}

----Swift.(file)._UIntBuffer.init()
extension _UIntBuffer : RangeReplaceableCollection  {
  public init() {
    _storage = 0
    _bitCount = 0
  }
}

----Swift.(file)._UIntBuffer.capacity
extension _UIntBuffer : RangeReplaceableCollection  {
  public var capacity: Int {
    return Storage.bitWidth / Element.bitWidth
  }
}

----Swift.(file)._UIntBuffer.append(_:Element)
extension _UIntBuffer : RangeReplaceableCollection  {
  public mutating func append(_ newElement: Element) {
    _debugPrecondition(count + 1 <= capacity)
    _storage &= ~(Storage(Element.max) &<< _bitCount)
    _storage |= Storage(newElement) &<< _bitCount
    _bitCount = _bitCount &+ _elementWidth
  }
}

----Swift.(file)._UIntBuffer.removeFirst()
extension _UIntBuffer : RangeReplaceableCollection  {
  public mutating func removeFirst() -> Element {
    _debugPrecondition(!isEmpty)
    let result = Element(truncatingIfNeeded: _storage)
    _bitCount = _bitCount &- _elementWidth
    _storage = _storage._fullShiftRight(_elementWidth)
    return result
  }
}

----Swift.(file)._UIntBuffer.replaceSubrange(_:Range<_UIntBuffer<Element>.Index>,with:C)
extension _UIntBuffer : RangeReplaceableCollection  {
  public mutating func replaceSubrange<C: Collection>(
    _ target: Range<Index>, with replacement: C
  ) where C.Element == Element {
    _debugPrecondition(
      (0..<_bitCount)._contains_(
        target.lowerBound.bitOffset..<target.upperBound.bitOffset))
    
    let replacement1 = _UIntBuffer(replacement)

    let targetCount = distance(
      from: target.lowerBound, to: target.upperBound)
    let growth = replacement1.count &- targetCount
    _debugPrecondition(count + growth <= capacity)

    let headCount = distance(from: startIndex, to: target.lowerBound)
    let tailOffset = distance(from: startIndex, to: target.upperBound)

    let w = Element.bitWidth
    let headBits = _storage & ._lowBits(headCount &* w)
    let tailBits = _storage._fullShiftRight(tailOffset &* w)

    _storage = headBits
    _storage |= replacement1._storage &<< (headCount &* w)
    _storage |= tailBits &<< ((tailOffset &+ growth) &* w)
    _bitCount = UInt8(
      truncatingIfNeeded: Int(_bitCount) &+ growth &* w)
  }
}

----Swift.(file)..(error_type).CodeUnit
extension Unicode.UTF16 : Unicode.Encoding  {
  public typealias CodeUnit = U
}

----Swift.(file)..(error_type).EncodedScalar
extension Unicode.UTF16 : Unicode.Encoding  {
  public typealias EncodedScalar = _UIntBuffer<UInt16>
}

----Swift.(file)..(error_type).encodedReplacementCharacter
extension Unicode.UTF16 : Unicode.Encoding  {
  public static var encodedReplacementCharacter : EncodedScalar {
    return EncodedScalar(_storage: 0xFFFD, _bitCount: 16)
  }
}

----Swift.(file)..(error_type).decode(_:Unicode.UTF16.EncodedScalar)
extension Unicode.UTF16 : Unicode.Encoding  {
  public static func decode(_ source: EncodedScalar) -> Unicode.Scalar {
    let bits = source._storage
    if _fastPath(source._bitCount == 16) {
      return Unicode.Scalar(_unchecked: bits & 0xffff)
    }
    _internalInvariant(source._bitCount == 32)
    let lower: UInt32 = bits >> 16 & 0x03ff
    let upper: UInt32 = (bits & 0x03ff) << 10
    let value = 0x10000 + (lower | upper)
    return Unicode.Scalar(_unchecked: value)
  }
}

----Swift.(file)..(error_type).encode(_:Unicode.Scalar)
extension Unicode.UTF16 : Unicode.Encoding  {
  public static func encode(
    _ source: Unicode.Scalar
  ) -> EncodedScalar? {
    let x = source.value
    if _fastPath(x < ((1 as UInt32) << 16)) {
      return EncodedScalar(_storage: x, _bitCount: 16)
    }
    let x1 = x - ((1 as UInt32) << 16)
    var r = (0xdc00 + (x1 & 0x3ff))
    r &<<= 16
    r |= (0xd800 + (x1 &>> 10 & 0x3ff))
    return EncodedScalar(_storage: r, _bitCount: 32)
  }
}

----Swift.(file)..(error_type).transcode(_:FromEncoding.EncodedScalar,from:FromEncoding.Type)
extension Unicode.UTF16 : Unicode.Encoding  {
  public static func transcode<FromEncoding : Unicode.Encoding>(
    _ content: FromEncoding.EncodedScalar, from _: FromEncoding.Type
  ) -> EncodedScalar? {
    if _fastPath(FromEncoding.self == UTF8.self) {
      let c = _identityCast(content, to: UTF8.EncodedScalar.self)
      var b = c.count
      b = b &- 1
      if _fastPath(b == 0) {
        return EncodedScalar(
          _storage: (c._biasedBits &- 0x1) & 0b0__111_1111, _bitCount: 16)
      }
      var s = c._biasedBits &- 0x01010101
      var r = s
      r &<<= 6
      s &>>= 8
      r |= s & 0b0__11_1111
      b = b &- 1
      
      if _fastPath(b == 0) {
        return EncodedScalar(_storage: r & 0b0__111_1111_1111, _bitCount: 16)
      }
      r &<<= 6
      s &>>= 8
      r |= s & 0b0__11_1111
      b = b &- 1
      
      if _fastPath(b == 0) {
        return EncodedScalar(_storage: r & 0xFFFF, _bitCount: 16)
      }
      
      r &<<= 6
      s &>>= 8
      r |= s & 0b0__11_1111
      r &= (1 &<< 21) - 1
      return encode(Unicode.Scalar(_unchecked: r))
    }
    else if _fastPath(FromEncoding.self == UTF16.self) {
      return unsafeBitCast(content, to: UTF16.EncodedScalar.self)
    }
    return encode(FromEncoding.decode(content))
  }
}

----Swift.(file)..(error_type).ForwardParser.init()
extension  {
    public init() { _buffer = _Buffer() }
}

----Swift.(file)..(error_type).ReverseParser.init()
extension  {
    public init() { _buffer = _Buffer() }
}

----Swift.(file).UTF16.ReverseParser.Encoding
extension UTF16.ReverseParser : Unicode.Parser, _UTFParser  {
  public typealias Encoding = Unicode.U
}

----Swift.(file)..(error_type).Encoding
extension Unicode.UTF16.ForwardParser : Unicode.Parser, _UTFParser  {
  public typealias Encoding = Unicode.U
}

----Swift.(file)..(error_type).CodeUnit
extension Unicode.UTF32 : Unicode.Encoding  {
  public typealias CodeUnit = U
}

----Swift.(file)..(error_type).EncodedScalar
extension Unicode.UTF32 : Unicode.Encoding  {
  public typealias EncodedScalar = CollectionOfOne<UInt32>
}

----Swift.(file)..(error_type).encodedReplacementCharacter
extension Unicode.UTF32 : Unicode.Encoding  {
  public static var encodedReplacementCharacter : EncodedScalar {
    return EncodedScalar(_replacementCodeUnit)
  }
}

----Swift.(file)..(error_type).decode(_:Unicode.UTF32.EncodedScalar)
extension Unicode.UTF32 : Unicode.Encoding  {
  public static func decode(_ source: EncodedScalar) -> Unicode.Scalar {
    return Unicode.Scalar(_unchecked: source.first!)
  }
}

----Swift.(file)..(error_type).encode(_:Unicode.Scalar)
extension Unicode.UTF32 : Unicode.Encoding  {
  public static func encode(
    _ source: Unicode.Scalar
  ) -> EncodedScalar? {
    return EncodedScalar(source.value)
  }
}

----Swift.(file)..(error_type).Parser.init()
extension  {
    public init() { }
}

----Swift.(file)..(error_type).ForwardParser
extension Unicode.UTF32 : Unicode.Encoding  {
  public typealias ForwardParser = P
}

----Swift.(file)..(error_type).ReverseParser
extension Unicode.UTF32 : Unicode.Encoding  {
  public typealias ReverseParser = P
}

----Swift.(file).UTF32.Parser.Encoding
extension UTF32.Parser : Unicode.Parser  {
  public typealias Encoding = Unicode.U
}

----Swift.(file).UTF32.Parser.parseScalar(from:I)
extension UTF32.Parser : Unicode.Parser  {
  public mutating func parseScalar<I : IteratorProtocol>(
    from input: inout I
  ) -> Unicode.ParseResult<Encoding.EncodedScalar>
  where I.Element == Encoding.CodeUnit {
    let n = input.next()
    if _fastPath(n != nil), let x = n {
      // Check code unit is valid: not surrogate-reserved and within range.
      guard _fastPath((x &>> 11) != 0b1101_1 && x <= 0x10ffff)
      else { return .error(length: 1) }
      
      // x is a valid scalar.
      return .valid(UTF32.EncodedScalar(x))
    }
    return .emptyInput
  }
}

----Swift.(file)..(error_type).CodeUnit
extension Unicode.UTF8 : _UnicodeEncoding  {
  public typealias CodeUnit = U
}

----Swift.(file)..(error_type).EncodedScalar
extension Unicode.UTF8 : _UnicodeEncoding  {
  public typealias EncodedScalar = _
}

----Swift.(file)..(error_type).encodedReplacementCharacter
extension Unicode.UTF8 : _UnicodeEncoding  {
  public static var encodedReplacementCharacter : EncodedScalar {
    return EncodedScalar.encodedReplacementCharacter
  }
}

----Swift.(file)..(error_type).decode(_:Unicode.UTF8.EncodedScalar)
extension Unicode.UTF8 : _UnicodeEncoding  {
  public static func decode(_ source: EncodedScalar) -> Unicode.Scalar {
    switch source.count {
    case 1:
      return Unicode.Scalar(_unchecked: source._biasedBits &- 0x01)
    case 2:
      let bits = source._biasedBits &- 0x0101
      var value = (bits & 0b0_______________________11_1111__0000_0000) &>> 8
      value    |= (bits & 0b0________________________________0001_1111) &<< 6
      return Unicode.Scalar(_unchecked: value)
    case 3:
      let bits = source._biasedBits &- 0x010101
      var value = (bits & 0b0____________11_1111__0000_0000__0000_0000) &>> 16
      value    |= (bits & 0b0_______________________11_1111__0000_0000) &>> 2
      value    |= (bits & 0b0________________________________0000_1111) &<< 12
      return Unicode.Scalar(_unchecked: value)
    default:
      _internalInvariant(source.count == 4)
      let bits = source._biasedBits &- 0x01010101
      var value = (bits & 0b0_11_1111__0000_0000__0000_0000__0000_0000) &>> 24
      value    |= (bits & 0b0____________11_1111__0000_0000__0000_0000) &>> 10
      value    |= (bits & 0b0_______________________11_1111__0000_0000) &<< 4
      value    |= (bits & 0b0________________________________0000_0111) &<< 18
      return Unicode.Scalar(_unchecked: value)
    }
  }
}

----Swift.(file)..(error_type).encode(_:Unicode.Scalar)
extension Unicode.UTF8 : _UnicodeEncoding  {
  public static func encode(
    _ source: Unicode.Scalar
  ) -> EncodedScalar? {
    var c = source.value
    if _fastPath(c < (1&<<7)) {
      return EncodedScalar(_containing: UInt8(c))
    }
    var o = c & 0b0__0011_1111
    c &>>= 6
    o &<<= 8
    if _fastPath(c < (1&<<5)) {
      return EncodedScalar(_biasedBits: (o | c) &+ 0b0__1000_0001__1100_0001)
    }
    o |= c & 0b0__0011_1111
    c &>>= 6
    o &<<= 8
    if _fastPath(c < (1&<<4)) {
      return EncodedScalar(
        _biasedBits: (o | c) &+ 0b0__1000_0001__1000_0001__1110_0001)
    }
    o |= c & 0b0__0011_1111
    c &>>= 6
    o &<<= 8
    return EncodedScalar(
      _biasedBits: (o | c ) &+ 0b0__1000_0001__1000_0001__1000_0001__1111_0001)
  }
}

----Swift.(file)..(error_type).transcode(_:FromEncoding.EncodedScalar,from:FromEncoding.Type)
extension Unicode.UTF8 : _UnicodeEncoding  {
  public static func transcode<FromEncoding : _UnicodeEncoding>(
    _ content: FromEncoding.EncodedScalar, from _: FromEncoding.Type
  ) -> EncodedScalar? {
    if _fastPath(FromEncoding.self == UTF16.self) {
      let c = _identityCast(content, to: UTF16.EncodedScalar.self)
      var u0 = UInt16(truncatingIfNeeded: c._storage) 
      if _fastPath(u0 < 0x80) {
        return EncodedScalar(_containing: UInt8(truncatingIfNeeded: u0))
      }
      var r = UInt32(u0 & 0b0__11_1111)
      r &<<= 8
      u0 &>>= 6
      if _fastPath(u0 < (1&<<5)) {
        return EncodedScalar(
          _biasedBits: (UInt32(u0) | r) &+ 0b0__1000_0001__1100_0001)
      }
      r |= UInt32(u0 & 0b0__11_1111)
      r &<<= 8
      if _fastPath(u0 & (0xF800 &>> 6) != (0xD800 &>> 6)) {
        u0 &>>= 6
        return EncodedScalar(
          _biasedBits: (UInt32(u0) | r) &+ 0b0__1000_0001__1000_0001__1110_0001)
      }
    }
    else if _fastPath(FromEncoding.self == UTF8.self) {
      return _identityCast(content, to: UTF8.EncodedScalar.self)
    }
    return encode(FromEncoding.decode(content))
  }
}

----Swift.(file)..(error_type).ForwardParser.init()
extension  {
    public init() { _buffer = _Buffer() }
}

----Swift.(file)..(error_type).ReverseParser.init()
extension  {
    public init() { _buffer = _Buffer() }
}

----Swift.(file).UTF8.ReverseParser.Encoding
extension UTF8.ReverseParser : Unicode.Parser, _UTFParser  {
  public typealias Encoding = Unicode.U
}

----Swift.(file)..(error_type).Encoding
extension Unicode.UTF8.ForwardParser : Unicode.Parser, _UTFParser  {
  public typealias Encoding = Unicode.U
}

----Swift.(file)._UTFParser.parseScalar(from:I)
extension _UTFParser
where Encoding.EncodedScalar : RangeReplaceableCollection  {
  public mutating func parseScalar<I : IteratorProtocol>(
    from input: inout I
  ) -> Unicode.ParseResult<Encoding.EncodedScalar>
    where I.Element == Encoding.CodeUnit {

    // Bufferless single-scalar fastpath.
    if _fastPath(_buffer.isEmpty) {
      guard let codeUnit = input.next() else { return .emptyInput }
      // ASCII, return immediately.
      if Encoding._isScalar(codeUnit) {
        return .valid(Encoding.EncodedScalar(CollectionOfOne(codeUnit)))
      }
      // Non-ASCII, proceed to buffering mode.
      _buffer.append(codeUnit)
    } else if Encoding._isScalar(
      Encoding.CodeUnit(truncatingIfNeeded: _buffer._storage)
    ) {
      // ASCII in _buffer.  We don't refill the buffer so we can return
      // to bufferless mode once we've exhausted it.
      let codeUnit = Encoding.CodeUnit(truncatingIfNeeded: _buffer._storage)
      _buffer.remove(at: _buffer.startIndex)
      return .valid(Encoding.EncodedScalar(CollectionOfOne(codeUnit)))
    }
    // Buffering mode.
    // Fill buffer back to 4 bytes (or as many as are left in the iterator).
    repeat {
      if let codeUnit = input.next() {
        _buffer.append(codeUnit)
      } else {
        if _buffer.isEmpty { return .emptyInput }
        break // We still have some bytes left in our buffer.
      }
    } while _buffer.count < _buffer.capacity

    // Find one unicode scalar.
    let (isValid, scalarBitCount) = _parseMultipleCodeUnits()
    _internalInvariant(scalarBitCount % numericCast(Encoding.CodeUnit.bitWidth) == 0)
    _internalInvariant(1...4 ~= scalarBitCount / 8)
    _internalInvariant(scalarBitCount <= _buffer._bitCount)
    
    // Consume the decoded bytes (or maximal subpart of ill-formed sequence).
    let encodedScalar = _bufferedScalar(bitCount: scalarBitCount)
    
    _buffer._storage = UInt32(
      // widen to 64 bits so that we can empty the buffer in the 4-byte case
      truncatingIfNeeded: UInt64(_buffer._storage) &>> scalarBitCount)
      
    _buffer._bitCount = _buffer._bitCount &- scalarBitCount

    if _fastPath(isValid) {
      return .valid(encodedScalar)
    }
    return .error(
      length: Int(scalarBitCount / numericCast(Encoding.CodeUnit.bitWidth)))
  }
}

----Swift.(file).UnicodeDecodingResult.scalarValue
extension UnicodeDecodingResult {
  case scalarValue(Unicode.Scalar)
}

----Swift.(file).UnicodeDecodingResult.emptyInput
extension UnicodeDecodingResult {
  case e
}

----Swift.(file).UnicodeDecodingResult.error
extension UnicodeDecodingResult {
  case e
}

----Swift.(file).UnicodeDecodingResult.==infix(_:UnicodeDecodingResult,_:UnicodeDecodingResult)
extension UnicodeDecodingResult {
  public static func == (
    lhs: UnicodeDecodingResult,
    rhs: UnicodeDecodingResult
  ) -> Bool {
    switch (lhs, rhs) {
    case (.scalarValue(let lhsScalar), .scalarValue(let rhsScalar)):
      return lhsScalar == rhsScalar
    case (.emptyInput, .emptyInput):
      return true
    case (.error, .error):
      return true
    default:
      return false
    }
  }
}

----Swift.(file).UnicodeCodec.init()
extension UnicodeCodec {
  init()
}

----Swift.(file).UnicodeCodec.decode(_:I)
extension UnicodeCodec {
  mutating func decode<I : IteratorProtocol>(
    _ input: inout I
  ) -> UnicodeDecodingResult where I.Element == C
}

----Swift.(file).UnicodeCodec.encode(_:<<error type>>,into:<<error type>>)
extension UnicodeCodec {
  static func encode(
    _ input: Unicode.Scalar,
    into processCodeUnit: (CodeUnit) -> Void
  )
}

----Swift.(file)..(error_type).init()
extension Unicode.UTF8 : UnicodeCodec  {
  public init() { self = ._swift3Buffer(ForwardParser()) }
}

----Swift.(file)..(error_type).decode(_:I)
extension Unicode.UTF8 : UnicodeCodec  {
  public mutating func decode<I : IteratorProtocol>(
    _ input: inout I
  ) -> UnicodeDecodingResult where I.Element == CodeUnit {
    guard case ._swift3Buffer(var parser) = self else {
      Builtin.unreachable()
    }
    defer { self = ._swift3Buffer(parser) }

    switch parser.parseScalar(from: &input) {
    case .valid(let s): return .scalarValue(UTF8.decode(s))
    case .error: return .error
    case .emptyInput: return .emptyInput
    }
  }
}

----Swift.(file)..(error_type).encode(_:<<error type>>,into:<<error type>>)
extension Unicode.UTF8 : UnicodeCodec  {
  public static func encode(
    _ input: Unicode.Scalar,
    into processCodeUnit: (CodeUnit) -> Void
  ) {
    var s = encode(input)!._biasedBits
    processCodeUnit(UInt8(truncatingIfNeeded: s) &- 0x01)
    s &>>= 8
    if _fastPath(s == 0) { return }
    processCodeUnit(UInt8(truncatingIfNeeded: s) &- 0x01)
    s &>>= 8
    if _fastPath(s == 0) { return }
    processCodeUnit(UInt8(truncatingIfNeeded: s) &- 0x01)
    s &>>= 8
    if _fastPath(s == 0) { return }
    processCodeUnit(UInt8(truncatingIfNeeded: s) &- 0x01)
  }
}

----Swift.(file)..(error_type).isContinuation(_:<<error type>>)
extension Unicode.UTF8 : UnicodeCodec  {
  public static func isContinuation(_ byte: CodeUnit) -> Bool {
    return byte & 0b11_00__0000 == 0b10_00__0000
  }
}

----Swift.(file)..(error_type).init()
extension Unicode.UTF16 : UnicodeCodec  {
  public init() { self = ._swift3Buffer(ForwardParser()) }
}

----Swift.(file)..(error_type).decode(_:I)
extension Unicode.UTF16 : UnicodeCodec  {
  public mutating func decode<I : IteratorProtocol>(
    _ input: inout I
  ) -> UnicodeDecodingResult where I.Element == CodeUnit {
    guard case ._swift3Buffer(var parser) = self else {
      Builtin.unreachable()
    }
    defer { self = ._swift3Buffer(parser) }
    switch parser.parseScalar(from: &input) {
    case .valid(let s): return .scalarValue(UTF16.decode(s))
    case .error: return .error
    case .emptyInput: return .emptyInput
    }
  }
}

----Swift.(file)..(error_type).encode(_:<<error type>>,into:<<error type>>)
extension Unicode.UTF16 : UnicodeCodec  {
  public static func encode(
    _ input: Unicode.Scalar,
    into processCodeUnit: (CodeUnit) -> Void
  ) {
    var s = encode(input)!._storage
    processCodeUnit(UInt16(truncatingIfNeeded: s))
    s &>>= 16
    if _fastPath(s == 0) { return }
    processCodeUnit(UInt16(truncatingIfNeeded: s))
  }
}

----Swift.(file)..(error_type).init()
extension Unicode.UTF32 : UnicodeCodec  {
  public init() { self = ._swift3Codec }
}

----Swift.(file)..(error_type).decode(_:I)
extension Unicode.UTF32 : UnicodeCodec  {
  public mutating func decode<I : IteratorProtocol>(
    _ input: inout I
  ) -> UnicodeDecodingResult where I.Element == CodeUnit {
    var parser = ForwardParser()
    
    switch parser.parseScalar(from: &input) {
    case .valid(let s): return .scalarValue(UTF32.decode(s))
    case .error:      return .error
    case .emptyInput:   return .emptyInput
    }
  }
}

----Swift.(file)..(error_type).encode(_:<<error type>>,into:<<error type>>)
extension Unicode.UTF32 : UnicodeCodec  {
  public static func encode(
    _ input: Unicode.Scalar,
    into processCodeUnit: (CodeUnit) -> Void
  ) {
    processCodeUnit(UInt32(input))
  }
}

----Swift.(file).transcode(_:Input,from:InputEncoding.Type,to:OutputEncoding.Type,stoppingOnError:Bool,into:<<error type>>)
public func transcode<
  Input : IteratorProtocol,
  InputEncoding : Unicode.Encoding,
  OutputEncoding : Unicode.Encoding
>(
  _ input: Input,
  from inputEncoding: InputEncoding.Type,
  to outputEncoding: OutputEncoding.Type,
  stoppingOnError stopOnError: Bool,
  into processCodeUnit: (OutputEncoding.CodeUnit) -> Void
) -> Bool
  where InputEncoding.CodeUnit == Input.Element {
  var input = input

  // NB.  It is not possible to optimize this routine to a memcpy if
  // InputEncoding == OutputEncoding.  The reason is that memcpy will not
  // substitute U+FFFD replacement characters for ill-formed sequences.

  var p = InputEncoding.ForwardParser()
  var hadError = false
  loop:
  while true {
    switch p.parseScalar(from: &input) {
    case .valid(let s):
      let t = OutputEncoding.transcode(s, from: inputEncoding)
      guard _fastPath(t != nil), let s = t else { break }
      s.forEach(processCodeUnit)
      continue loop
    case .emptyInput:
      return hadError
    case .error:
      if _slowPath(stopOnError) { return true }
      hadError = true
    }
    OutputEncoding.encodedReplacementCharacter.forEach(processCodeUnit)
  }
}

----Swift.(file).UTF16.width(_:<<error type>>)
extension UTF16  {
  public static func width(_ x: Unicode.Scalar) -> Int {
    return x.value <= 0xFFFF ? 1 : 2
  }
}

----Swift.(file).UTF16.leadSurrogate(_:<<error type>>)
extension UTF16  {
  public static func leadSurrogate(_ x: Unicode.Scalar) -> UTF16.CodeUnit {
    _precondition(width(x) == 2)
    return 0xD800 + UTF16.CodeUnit(truncatingIfNeeded:
      (x.value - 0x1_0000) &>> (10 as UInt32))
  }
}

----Swift.(file).UTF16.trailSurrogate(_:<<error type>>)
extension UTF16  {
  public static func trailSurrogate(_ x: Unicode.Scalar) -> UTF16.CodeUnit {
    _precondition(width(x) == 2)
    return 0xDC00 + UTF16.CodeUnit(truncatingIfNeeded:
      (x.value - 0x1_0000) & (((1 as UInt32) &<< 10) - 1))
  }
}

----Swift.(file).UTF16.isLeadSurrogate(_:Unicode.UTF16.CodeUnit)
extension UTF16  {
  public static func isLeadSurrogate(_ x: CodeUnit) -> Bool {
    return (x & 0xFC00) == 0xD800
  }
}

----Swift.(file).UTF16.isTrailSurrogate(_:Unicode.UTF16.CodeUnit)
extension UTF16  {
  public static func isTrailSurrogate(_ x: CodeUnit) -> Bool {
    return (x & 0xFC00) == 0xDC00
  }
}

----Swift.(file).UTF16.transcodedLength(of:Input,decodedAs:Encoding.Type,repairingIllFormedSequences:Bool)
extension UTF16  {
  public static func transcodedLength<
    Input : IteratorProtocol,
    Encoding : Unicode.Encoding
  >(
    of input: Input,
    decodedAs sourceEncoding: Encoding.Type,
    repairingIllFormedSequences: Bool
  ) -> (count: Int, isASCII: Bool)?
    where Encoding.CodeUnit == Input.Element {

    var utf16Count = 0
    var i = input
    var d = Encoding.ForwardParser()

    // Fast path for ASCII in a UTF8 buffer
    if sourceEncoding == Unicode.UTF8.self {
      var peek: Encoding.CodeUnit = 0
      while let u = i.next() {
        peek = u
        guard _fastPath(peek < 0x80) else { break }
        utf16Count = utf16Count + 1
      }
      if _fastPath(peek < 0x80) { return (utf16Count, true) }
      
      var d1 = UTF8.ForwardParser()
      d1._buffer.append(numericCast(peek))
      d = _identityCast(d1, to: Encoding.ForwardParser.self)
    }
    
    var utf16BitUnion: CodeUnit = 0
    while true {
      let s = d.parseScalar(from: &i)
      if _fastPath(s._valid != nil), let scalarContent = s._valid {
        let utf16 = transcode(scalarContent, from: sourceEncoding)
          ._unsafelyUnwrappedUnchecked
        utf16Count += utf16.count
        for x in utf16 { utf16BitUnion |= x }
      }
      else if let _ = s._error {
        guard _fastPath(repairingIllFormedSequences) else { return nil }
        utf16Count += 1
        utf16BitUnion |= UTF16._replacementCodeUnit
      }
      else {
        return (utf16Count, utf16BitUnion < 0x80)
      }
    }
  }
}

----Swift.(file)..(error_type).init(_unchecked:UInt32)
extension Unicode.Scalar  {
  internal init(_unchecked value: UInt32) {
    _internalInvariant(value < 0xD800 || value > 0xDFFF,
      "high- and low-surrogate code points are not valid Unicode scalar values")
    _internalInvariant(value <= 0x10FFFF, "value is outside of Unicode codespace")

    self._value = value
  }
}

----Swift.(file).transcode(_:InputEncoding.Type,_:OutputEncoding.Type,_:Input,_:<<error type>>,stopOnError:Bool)
public func transcode<Input, InputEncoding, OutputEncoding>(
  _ inputEncoding: InputEncoding.Type, _ outputEncoding: OutputEncoding.Type,
  _ input: Input, _ output: (OutputEncoding.CodeUnit) -> Void,
  stopOnError: Bool
) -> Bool
  where
  Input : IteratorProtocol,
  InputEncoding : UnicodeCodec,
  OutputEncoding : UnicodeCodec,
  InputEncoding.CodeUnit == Input.Element {
  Builtin.unreachable()
}

----Swift.(file)._UnicodeEncoding.transcode(_:<<error type>>,from:FromEncoding.Type)
extension _UnicodeEncoding  {
  public static func transcode<FromEncoding : Unicode.Encoding>(
    _ content: FromEncoding.EncodedScalar, from _: FromEncoding.Type
  ) -> EncodedScalar? {
    return encode(FromEncoding.decode(content))
  }
}

----Swift.(file).Unicode.Encoding
extension Unicode  {
  public typealias Encoding = _
}

----Swift.(file)._StringGuts.scalarAlign(_:<<error type>>)
extension _StringGuts  {
  internal func scalarAlign(_ idx: Index) -> Index {
    // TODO(String performance): isASCII check

    if _slowPath(idx.transcodedOffset != 0 || idx.encodedOffset == 0) {
      // Transcoded indices are already scalar aligned
      return String.Index(encodedOffset: idx.encodedOffset)
    }
    if _slowPath(self.isForeign) {
      return foreignScalarAlign(idx)
    }

    return self.withFastUTF8 { utf8 in
      let i = _scalarAlign(utf8, idx.encodedOffset)

      // If no alignment is performed, keep grapheme cache
      if i == idx.encodedOffset {
        return idx
      }

      return Index(encodedOffset: i)
    }
  }
}

----Swift.(file)._StringGuts.fastUTF8ScalarLength(startingAt:Int)
extension _StringGuts  {
  internal func fastUTF8ScalarLength(startingAt i: Int) -> Int {
    _internalInvariant(isFastUTF8)
    let len = _utf8ScalarLength(self.withFastUTF8 { $0[i] })
    _internalInvariant((1...4) ~= len)
    return len
  }
}

----Swift.(file)._StringGuts.fastUTF8ScalarLength(endingAt:Int)
extension _StringGuts  {
  internal func fastUTF8ScalarLength(endingAt i: Int) -> Int {
    _internalInvariant(isFastUTF8)

    return self.withFastUTF8 { utf8 in
      _internalInvariant(i == utf8.count || !_isContinuation(utf8[i]))
      var len = 1
      while _isContinuation(utf8[i &- len]) {
        _internalInvariant(i &- len > 0)
        len += 1
      }
      _internalInvariant(len <= 4)
      return len
    }
  }
}

----Swift.(file)._StringGuts.fastUTF8Scalar(startingAt:Int)
extension _StringGuts  {
  internal func fastUTF8Scalar(startingAt i: Int) -> Unicode.Scalar {
    _internalInvariant(isFastUTF8)
    return self.withFastUTF8 { _decodeScalar($0, startingAt: i).0 }
  }
}

----Swift.(file)._StringGuts.isOnUnicodeScalarBoundary(_:String.Index)
extension _StringGuts  {
  internal func isOnUnicodeScalarBoundary(_ i: String.Index) -> Bool {
    // TODO(String micro-performance): check isASCII

    // Beginning and end are always scalar aligned; mid-scalar never is
    guard i.transcodedOffset == 0 else { return false }
    if i == self.startIndex || i == self.endIndex { return true }

    if _fastPath(isFastUTF8) {
      return self.withFastUTF8 { return !_isContinuation($0[i.encodedOffset]) }
    }

    return i == foreignScalarAlign(i)
  }
}

----Swift.(file)._StringGuts.foreignErrorCorrectedScalar(startingAt:String.Index)
extension _StringGuts  {
  internal func foreignErrorCorrectedScalar(
    startingAt idx: String.Index
  ) -> (Unicode.Scalar, scalarLength: Int) {
    _internalInvariant(idx.transcodedOffset == 0)
    _internalInvariant(idx.encodedOffset < self.count)

    let start = idx.encodedOffset
    let leading = _getForeignCodeUnit(at: start)

    if _fastPath(!_isSurrogate(leading)) {
      return (Unicode.Scalar(_unchecked: UInt32(leading)), 1)
    }

    // Validate foreign strings on-read: trailing surrogates are invalid,
    // leading need following trailing
    //
    // TODO(String performance): Consider having a valid performance flag
    // available to check, and assert it's not set in the condition here.
    let nextOffset = start &+ 1
    if _slowPath(_isTrailingSurrogate(leading) || nextOffset == self.count) {
      return (Unicode.Scalar._replacementCharacter, 1)
    }
    let trailing = _getForeignCodeUnit(at: nextOffset)
    if _slowPath(!_isTrailingSurrogate(trailing)) {
      return (Unicode.Scalar._replacementCharacter, 1)
    }

    return (Unicode.Scalar(
      _unchecked: _decodeSurrogatePair(leading: leading, trailing: trailing)),
      2)
  }
}

----Swift.(file)._StringGuts.foreignErrorCorrectedScalar(endingAt:String.Index)
extension _StringGuts  {
  internal func foreignErrorCorrectedScalar(
    endingAt idx: String.Index
  ) -> (Unicode.Scalar, scalarLength: Int) {
    _internalInvariant(idx.transcodedOffset == 0)
    _internalInvariant(idx.encodedOffset <= self.count)
    _internalInvariant(idx.encodedOffset > 0)

    let end = idx.encodedOffset
    let trailing = _getForeignCodeUnit(at: end &- 1)
    if _fastPath(!_isSurrogate(trailing)) {
      return (Unicode.Scalar(_unchecked: UInt32(trailing)), 1)
    }

    // Validate foreign strings on-read: trailing surrogates are invalid,
    // leading need following trailing
    //
    // TODO(String performance): Consider having a valid performance flag
    // available to check, and assert it's not set in the condition here.
    let priorOffset = end &- 2
    if _slowPath(_isLeadingSurrogate(trailing) || priorOffset < 0) {
      return (Unicode.Scalar._replacementCharacter, 1)
    }
    let leading = _getForeignCodeUnit(at: priorOffset)
    if _slowPath(!_isLeadingSurrogate(leading)) {
      return (Unicode.Scalar._replacementCharacter, 1)
    }

    return (Unicode.Scalar(
      _unchecked: _decodeSurrogatePair(leading: leading, trailing: trailing)),
      2)
  }
}

----Swift.(file)._StringGuts.foreignErrorCorrectedUTF16CodeUnit(at:String.Index)
extension _StringGuts  {
  internal func foreignErrorCorrectedUTF16CodeUnit(
    at idx: String.Index
  ) -> UInt16 {
    _internalInvariant(idx.transcodedOffset == 0)
    _internalInvariant(idx.encodedOffset < self.count)

    let start = idx.encodedOffset
    let cu = _getForeignCodeUnit(at: start)
    if _fastPath(!_isSurrogate(cu)) {
      return cu
    }

    // Validate foreign strings on-read: trailing surrogates are invalid,
    // leading need following trailing
    //
    // TODO(String performance): Consider having a valid performance flag
    // available to check, and assert it's not set in the condition here.
    if _isLeadingSurrogate(cu) {
      let nextOffset = start &+ 1
      guard nextOffset < self.count,
            _isTrailingSurrogate(_getForeignCodeUnit(at: nextOffset))
      else { return UTF16._replacementCodeUnit }
    } else {
      let priorOffset = start &- 1
      guard priorOffset >= 0,
            _isLeadingSurrogate(_getForeignCodeUnit(at: priorOffset))
      else { return UTF16._replacementCodeUnit }
    }

    return cu
  }
}

----Swift.(file)._StringGuts.foreignScalarAlign(_:<<error type>>)
extension _StringGuts  {
  internal func foreignScalarAlign(_ idx: Index) -> Index {
    _internalInvariant(idx.encodedOffset < self.count)

    let ecCU = foreignErrorCorrectedUTF16CodeUnit(at: idx)
    if _fastPath(!_isTrailingSurrogate(ecCU)) {
      return idx
    }
    _internalInvariant(idx.encodedOffset > 0,
      "Error-correction shouldn't give trailing surrogate at position zero")
    return String.Index(encodedOffset: idx.encodedOffset &- 1)
  }
}

----Swift.(file)._StringGuts.foreignErrorCorrectedGrapheme(startingAt:Int,endingAt:Int)
extension _StringGuts  {
  internal func foreignErrorCorrectedGrapheme(
    startingAt start: Int, endingAt end: Int
  ) -> Character {
#if _runtime(_ObjC)
    _internalInvariant(self.isForeign)

    // Both a fast-path for single-code-unit graphemes and validation:
    //   ICU treats isolated surrogates as isolated graphemes
    let count = end &- start
    if start &- end == 1 {
      return Character(String(self.foreignErrorCorrectedScalar(
        startingAt: String.Index(encodedOffset: start)
      ).0))
    }

    // TODO(String performance): Stack buffer if small enough
    var cus = Array<UInt16>(repeating: 0, count: count)
    cus.withUnsafeMutableBufferPointer {
      _cocoaStringCopyCharacters(
        from: self._object.cocoaObject,
        range: start..<end,
        into: $0.baseAddress._unsafelyUnwrappedUnchecked)
    }
    return cus.withUnsafeBufferPointer {
      return Character(String._uncheckedFromUTF16($0))
    }
#else
    fatalError("No foreign strings on Linux in this version of Swift")
#endif
  }
}

----Swift.(file)._StringGuts.errorCorrectedScalar(startingAt:Int)
extension _StringGuts  {
  internal func errorCorrectedScalar(
    startingAt i: Int
  ) -> (Unicode.Scalar, scalarLength: Int) {
    if _fastPath(isFastUTF8) {
      return withFastUTF8 { _decodeScalar($0, startingAt: i) }
    }
    return foreignErrorCorrectedScalar(
      startingAt: String.Index(encodedOffset: i))
  }
}

----Swift.(file)._StringGuts.errorCorrectedCharacter(startingAt:Int,endingAt:Int)
extension _StringGuts  {
  internal func errorCorrectedCharacter(
    startingAt start: Int, endingAt end: Int
  ) -> Character {
    if _fastPath(isFastUTF8) {
      return withFastUTF8(range: start..<end) { utf8 in
        return Character(unchecked: String._uncheckedFromUTF8(utf8))
      }
    }

    return foreignErrorCorrectedGrapheme(startingAt: start, endingAt: end)
  }
}

----Swift.(file).Unicode.ParseResult.valid
extension Unicode.ParseResult {
  case valid(T)
}

----Swift.(file).Unicode.ParseResult.emptyInput
extension Unicode.ParseResult {
  case e
}

----Swift.(file).Unicode.ParseResult.error
extension Unicode.ParseResult {
  case error(length: Int)
}

----Swift.(file).Unicode.Parser
extension Unicode  {
  public typealias Parser = _
}

----Swift.(file).Unicode.Scalar.init(_value:UInt32)
extension Unicode.Scalar {
    internal init(_value: UInt32) {
      self._value = _value
    }
}

----Swift.(file)..(error_type).value
extension Unicode.Scalar :
    _ExpressibleByBuiltinUnicodeScalarLiteral,
    ExpressibleByUnicodeScalarLiteral  {
  public var value: UInt32 { return _value }
}

----Swift.(file)..(error_type).init(_builtinUnicodeScalarLiteral:<<error type>>)
extension Unicode.Scalar :
    _ExpressibleByBuiltinUnicodeScalarLiteral,
    ExpressibleByUnicodeScalarLiteral  {
  public init(_builtinUnicodeScalarLiteral value: Builtin.Int32) {
    self._value = UInt32(value)
  }
}

----Swift.(file)..(error_type).init(unicodeScalarLiteral:<<error type>>)
extension Unicode.Scalar :
    _ExpressibleByBuiltinUnicodeScalarLiteral,
    ExpressibleByUnicodeScalarLiteral  {
  public init(unicodeScalarLiteral value: Unicode.Scalar) {
    self = value
  }
}

----Swift.(file)..(error_type).init(_:UInt32)
extension Unicode.Scalar :
    _ExpressibleByBuiltinUnicodeScalarLiteral,
    ExpressibleByUnicodeScalarLiteral  {
  public init?(_ v: UInt32) {
    // Unicode 6.3.0:
    //
    //     D9.  Unicode codespace: A range of integers from 0 to 10FFFF.
    //
    //     D76. Unicode scalar value: Any Unicode code point except
    //     high-surrogate and low-surrogate code points.
    //
    //     * As a result of this definition, the set of Unicode scalar values
    //     consists of the ranges 0 to D7FF and E000 to 10FFFF, inclusive.
    if (v < 0xD800 || v > 0xDFFF) && v <= 0x10FFFF {
      self._value = v
      return
    }
    // Return nil in case of an invalid unicode scalar value.
    return nil
  }
}

----Swift.(file)..(error_type).init(_:UInt16)
extension Unicode.Scalar :
    _ExpressibleByBuiltinUnicodeScalarLiteral,
    ExpressibleByUnicodeScalarLiteral  {
  public init?(_ v: UInt16) {
    self.init(UInt32(v))
  }
}

----Swift.(file)..(error_type).init(_:UInt8)
extension Unicode.Scalar :
    _ExpressibleByBuiltinUnicodeScalarLiteral,
    ExpressibleByUnicodeScalarLiteral  {
  public init(_ v: UInt8) {
    self._value = UInt32(v)
  }
}

----Swift.(file)..(error_type).init(_:<<error type>>)
extension Unicode.Scalar :
    _ExpressibleByBuiltinUnicodeScalarLiteral,
    ExpressibleByUnicodeScalarLiteral  {
  public init(_ v: Unicode.Scalar) {
    // This constructor allows one to provide necessary type context to
    // disambiguate between function overloads on 'String' and 'Unicode.Scalar'.
    self = v
  }
}

----Swift.(file)..(error_type).escaped(asASCII:Bool)
extension Unicode.Scalar :
    _ExpressibleByBuiltinUnicodeScalarLiteral,
    ExpressibleByUnicodeScalarLiteral  {
  public func escaped(asASCII forceASCII: Bool) -> String {
    func lowNibbleAsHex(_ v: UInt32) -> String {
      let nibble = v & 15
      if nibble < 10 {
        return String(Unicode.Scalar(nibble+48)!)    // 48 = '0'
      } else {
        return String(Unicode.Scalar(nibble-10+65)!) // 65 = 'A'
      }
    }

    if self == "\\" {
      return "\\\\"
    } else if self == "\'" {
      return "\\\'"
    } else if self == "\"" {
      return "\\\""
    } else if _isPrintableASCII {
      return String(self)
    } else if self == "\0" {
      return "\\0"
    } else if self == "\n" {
      return "\\n"
    } else if self == "\r" {
      return "\\r"
    } else if self == "\t" {
      return "\\t"
    } else if UInt32(self) < 128 {
      return "\\u{"
        + lowNibbleAsHex(UInt32(self) >> 4)
        + lowNibbleAsHex(UInt32(self)) + "}"
    } else if !forceASCII {
      return String(self)
    } else if UInt32(self) <= 0xFFFF {
      var result = "\\u{"
      result += lowNibbleAsHex(UInt32(self) >> 12)
      result += lowNibbleAsHex(UInt32(self) >> 8)
      result += lowNibbleAsHex(UInt32(self) >> 4)
      result += lowNibbleAsHex(UInt32(self))
      result += "}"
      return result
    } else {
      // FIXME: Type checker performance prohibits this from being a
      // single chained "+".
      var result = "\\u{"
      result += lowNibbleAsHex(UInt32(self) >> 28)
      result += lowNibbleAsHex(UInt32(self) >> 24)
      result += lowNibbleAsHex(UInt32(self) >> 20)
      result += lowNibbleAsHex(UInt32(self) >> 16)
      result += lowNibbleAsHex(UInt32(self) >> 12)
      result += lowNibbleAsHex(UInt32(self) >> 8)
      result += lowNibbleAsHex(UInt32(self) >> 4)
      result += lowNibbleAsHex(UInt32(self))
      result += "}"
      return result
    }
  }
}

----Swift.(file)..(error_type).isASCII
extension Unicode.Scalar :
    _ExpressibleByBuiltinUnicodeScalarLiteral,
    ExpressibleByUnicodeScalarLiteral  {
  public var isASCII: Bool {
    return value <= 127
  }
}

----Swift.(file)..(error_type).description
extension Unicode.Scalar : CustomStringConvertible, CustomDebugStringConvertible  {
  public var description: String {
    return String(self)
  }
}

----Swift.(file)..(error_type).debugDescription
extension Unicode.Scalar : CustomStringConvertible, CustomDebugStringConvertible  {
  public var debugDescription: String {
    return "\"\(escaped(asASCII: true))\""
  }
}

----Swift.(file)..(error_type).init(_:String)
extension Unicode.Scalar : LosslessStringConvertible  {
  public init?(_ description: String) {
    let scalars = description.unicodeScalars
    guard let v = scalars.first, scalars.count == 1 else {
      return nil
    }
    self = v
  }
}

----Swift.(file)..(error_type).hash(into:Hasher)
extension Unicode.Scalar : Hashable  {
  public func hash(into hasher: inout Hasher) {
    hasher.combine(self.value)
  }
}

----Swift.(file)..(error_type).init(_:Int)
extension Unicode.Scalar  {
  public init?(_ v: Int) {
    if let us = Unicode.Scalar(UInt32(v)) {
      self = us
    } else {
      return nil
    }
  }
}

----Swift.(file).UInt8.init(ascii:<<error type>>)
extension UInt8  {
  public init(ascii v: Unicode.Scalar) {
    _precondition(v.value < 128,
        "Code point value does not fit into ASCII")
    self = UInt8(v.value)
  }
}

----Swift.(file).UInt32.init(_:<<error type>>)
extension UInt32  {
  public init(_ v: Unicode.Scalar) {
    self = v.value
  }
}

----Swift.(file).UInt64.init(_:<<error type>>)
extension UInt64  {
  public init(_ v: Unicode.Scalar) {
    self = UInt64(v.value)
  }
}

----Swift.(file)..(error_type).==infix(_:<<error type>>,_:<<error type>>)
extension Unicode.Scalar : Equatable  {
  public static func == (lhs: Unicode.Scalar, rhs: Unicode.Scalar) -> Bool {
    return lhs.value == rhs.value
  }
}

----Swift.(file)..(error_type).<infix(_:<<error type>>,_:<<error type>>)
extension Unicode.Scalar : Comparable  {
  public static func < (lhs: Unicode.Scalar, rhs: Unicode.Scalar) -> Bool {
    return lhs.value < rhs.value
  }
}

----Swift.(file)..(error_type).UTF16View.init(value:<<error type>>)
extension  {
    internal init(value: Unicode.Scalar) {
      self.value = value
    }
}

----Swift.(file)..(error_type).UTF16View.value
extension  {
    internal var v
}

----Swift.(file)..(error_type).utf16
extension Unicode.Scalar  {
  public var utf16: UTF16View {
    return UTF16View(value: self)
  }
}

----Swift.(file)..(error_type).Indices
extension Unicode.Scalar.UTF16View : RandomAccessCollection  {
  public typealias Indices = Range<Int>
}

----Swift.(file)..(error_type).startIndex
extension Unicode.Scalar.UTF16View : RandomAccessCollection  {
  public var startIndex: Int {
    return 0
  }
}

----Swift.(file)..(error_type).endIndex
extension Unicode.Scalar.UTF16View : RandomAccessCollection  {
  public var endIndex: Int {
    return 0 + UTF16.width(value)
  }
}

----Swift.(file)..(error_type).subscript(_:Int)
extension Unicode.Scalar.UTF16View : RandomAccessCollection  {
  public subscript(position: Int) -> UTF16.CodeUnit {
    return position == 0 ? (
      endIndex == 1 ? UTF16.CodeUnit(value.value) : UTF16.leadSurrogate(value)
    ) : UTF16.trailSurrogate(value)
  }
}

----Swift.(file)..(error_type).init()
extension Unicode.Scalar  {
  public init() {
    Builtin.unreachable()
  }
}

----Swift.(file)..(error_type).withUTF16CodeUnits(_:(UnsafeBufferPointer<UInt16>) throws -> Result)
extension Unicode.Scalar  {
  internal func withUTF16CodeUnits<Result>(
    _ body: (UnsafeBufferPointer<UInt16>) throws -> Result
  ) rethrows -> Result {
    var codeUnits: (UInt16, UInt16) = (self.utf16[0], 0)
    let utf16Count = self.utf16.count
    if utf16Count > 1 {
      _internalInvariant(utf16Count == 2)
      codeUnits.1 = self.utf16[1]
    }
    return try Swift.withUnsafePointer(to: &codeUnits) {
      return try $0.withMemoryRebound(to: UInt16.self, capacity: 2) {
        return try body(UnsafeBufferPointer(start: $0, count: utf16Count))
      }
    }
  }
}

----Swift.(file)..(error_type).withUTF8CodeUnits(_:(UnsafeBufferPointer<UInt8>) throws -> Result)
extension Unicode.Scalar  {
  internal func withUTF8CodeUnits<Result>(
    _ body: (UnsafeBufferPointer<UInt8>) throws -> Result
  ) rethrows -> Result {
    let encodedScalar = UTF8.encode(self)!
    var (codeUnits, utf8Count) = encodedScalar._bytes
    return try Swift.withUnsafePointer(to: &codeUnits) {
      return try $0.withMemoryRebound(to: UInt8.self, capacity: 4) {
        return try body(UnsafeBufferPointer(start: $0, count: utf8Count))
      }
    }
  }
}

----Swift.(file).Unicode.Scalar.Properties.init(_:Unicode.Scalar)
extension Unicode.Scalar.Properties {
    internal init(_ scalar: Unicode.Scalar) {
      self._scalar = scalar
    }
}

----Swift.(file).Unicode.Scalar.Properties.icuValue
extension Unicode.Scalar.Properties {
    internal var icuValue: __swift_stdlib_UChar32 {
      return __swift_stdlib_UChar32(bitPattern: self._scalar._value)
    }
}

----Swift.(file).Unicode.Scalar.properties
extension Unicode.Scalar  {
  public var properties: Properties {
    return Properties(self)
  }
}

----Swift.(file)..(error_type).isAlphabetic
extension Unicode.Scalar.Properties  {
  public var isAlphabetic: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_ALPHABETIC)
  }
}

----Swift.(file)..(error_type).isASCIIHexDigit
extension Unicode.Scalar.Properties  {
  public var isASCIIHexDigit: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_ASCII_HEX_DIGIT)
  }
}

----Swift.(file)..(error_type).isBidiControl
extension Unicode.Scalar.Properties  {
  public var isBidiControl: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_BIDI_CONTROL)
  }
}

----Swift.(file)..(error_type).isBidiMirrored
extension Unicode.Scalar.Properties  {
  public var isBidiMirrored: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_BIDI_MIRRORED)
  }
}

----Swift.(file)..(error_type).isDash
extension Unicode.Scalar.Properties  {
  public var isDash: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_DASH)
  }
}

----Swift.(file)..(error_type).isDefaultIgnorableCodePoint
extension Unicode.Scalar.Properties  {
  public var isDefaultIgnorableCodePoint: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_DEFAULT_IGNORABLE_CODE_POINT)
  }
}

----Swift.(file)..(error_type).isDeprecated
extension Unicode.Scalar.Properties  {
  public var isDeprecated: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_DEPRECATED)
  }
}

----Swift.(file)..(error_type).isDiacritic
extension Unicode.Scalar.Properties  {
  public var isDiacritic: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_DIACRITIC)
  }
}

----Swift.(file)..(error_type).isExtender
extension Unicode.Scalar.Properties  {
  public var isExtender: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_EXTENDER)
  }
}

----Swift.(file)..(error_type).isFullCompositionExclusion
extension Unicode.Scalar.Properties  {
  public var isFullCompositionExclusion: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_FULL_COMPOSITION_EXCLUSION)
  }
}

----Swift.(file)..(error_type).isGraphemeBase
extension Unicode.Scalar.Properties  {
  public var isGraphemeBase: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_GRAPHEME_BASE)
  }
}

----Swift.(file)..(error_type).isGraphemeExtend
extension Unicode.Scalar.Properties  {
  public var isGraphemeExtend: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_GRAPHEME_EXTEND)
  }
}

----Swift.(file)..(error_type).isHexDigit
extension Unicode.Scalar.Properties  {
  public var isHexDigit: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_HEX_DIGIT)
  }
}

----Swift.(file)..(error_type).isIDContinue
extension Unicode.Scalar.Properties  {
  public var isIDContinue: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_ID_CONTINUE)
  }
}

----Swift.(file)..(error_type).isIDStart
extension Unicode.Scalar.Properties  {
  public var isIDStart: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_ID_START)
  }
}

----Swift.(file)..(error_type).isIdeographic
extension Unicode.Scalar.Properties  {
  public var isIdeographic: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_IDEOGRAPHIC)
  }
}

----Swift.(file)..(error_type).isIDSBinaryOperator
extension Unicode.Scalar.Properties  {
  public var isIDSBinaryOperator: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_IDS_BINARY_OPERATOR)
  }
}

----Swift.(file)..(error_type).isIDSTrinaryOperator
extension Unicode.Scalar.Properties  {
  public var isIDSTrinaryOperator: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_IDS_TRINARY_OPERATOR)
  }
}

----Swift.(file)..(error_type).isJoinControl
extension Unicode.Scalar.Properties  {
  public var isJoinControl: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_JOIN_CONTROL)
  }
}

----Swift.(file)..(error_type).isLogicalOrderException
extension Unicode.Scalar.Properties  {
  public var isLogicalOrderException: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_LOGICAL_ORDER_EXCEPTION)
  }
}

----Swift.(file)..(error_type).isLowercase
extension Unicode.Scalar.Properties  {
  public var isLowercase: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_LOWERCASE)
  }
}

----Swift.(file)..(error_type).isMath
extension Unicode.Scalar.Properties  {
  public var isMath: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_MATH)
  }
}

----Swift.(file)..(error_type).isNoncharacterCodePoint
extension Unicode.Scalar.Properties  {
  public var isNoncharacterCodePoint: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_NONCHARACTER_CODE_POINT)
  }
}

----Swift.(file)..(error_type).isQuotationMark
extension Unicode.Scalar.Properties  {
  public var isQuotationMark: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_QUOTATION_MARK)
  }
}

----Swift.(file)..(error_type).isRadical
extension Unicode.Scalar.Properties  {
  public var isRadical: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_RADICAL)
  }
}

----Swift.(file)..(error_type).isSoftDotted
extension Unicode.Scalar.Properties  {
  public var isSoftDotted: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_SOFT_DOTTED)
  }
}

----Swift.(file)..(error_type).isTerminalPunctuation
extension Unicode.Scalar.Properties  {
  public var isTerminalPunctuation: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_TERMINAL_PUNCTUATION)
  }
}

----Swift.(file)..(error_type).isUnifiedIdeograph
extension Unicode.Scalar.Properties  {
  public var isUnifiedIdeograph: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_UNIFIED_IDEOGRAPH)
  }
}

----Swift.(file)..(error_type).isUppercase
extension Unicode.Scalar.Properties  {
  public var isUppercase: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_UPPERCASE)
  }
}

----Swift.(file)..(error_type).isWhitespace
extension Unicode.Scalar.Properties  {
  public var isWhitespace: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_WHITE_SPACE)
  }
}

----Swift.(file)..(error_type).isXIDContinue
extension Unicode.Scalar.Properties  {
  public var isXIDContinue: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_XID_CONTINUE)
  }
}

----Swift.(file)..(error_type).isXIDStart
extension Unicode.Scalar.Properties  {
  public var isXIDStart: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_XID_START)
  }
}

----Swift.(file)..(error_type).isSentenceTerminal
extension Unicode.Scalar.Properties  {
  public var isSentenceTerminal: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_S_TERM)
  }
}

----Swift.(file)..(error_type).isVariationSelector
extension Unicode.Scalar.Properties  {
  public var isVariationSelector: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_VARIATION_SELECTOR)
  }
}

----Swift.(file)..(error_type).isPatternSyntax
extension Unicode.Scalar.Properties  {
  public var isPatternSyntax: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_PATTERN_SYNTAX)
  }
}

----Swift.(file)..(error_type).isPatternWhitespace
extension Unicode.Scalar.Properties  {
  public var isPatternWhitespace: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_PATTERN_WHITE_SPACE)
  }
}

----Swift.(file)..(error_type).isCased
extension Unicode.Scalar.Properties  {
  public var isCased: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_CASED)
  }
}

----Swift.(file)..(error_type).isCaseIgnorable
extension Unicode.Scalar.Properties  {
  public var isCaseIgnorable: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_CASE_IGNORABLE)
  }
}

----Swift.(file)..(error_type).changesWhenLowercased
extension Unicode.Scalar.Properties  {
  public var changesWhenLowercased: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_CHANGES_WHEN_LOWERCASED)
  }
}

----Swift.(file)..(error_type).changesWhenUppercased
extension Unicode.Scalar.Properties  {
  public var changesWhenUppercased: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_CHANGES_WHEN_UPPERCASED)
  }
}

----Swift.(file)..(error_type).changesWhenTitlecased
extension Unicode.Scalar.Properties  {
  public var changesWhenTitlecased: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_CHANGES_WHEN_TITLECASED)
  }
}

----Swift.(file)..(error_type).changesWhenCaseFolded
extension Unicode.Scalar.Properties  {
  public var changesWhenCaseFolded: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_CHANGES_WHEN_CASEFOLDED)
  }
}

----Swift.(file)..(error_type).changesWhenCaseMapped
extension Unicode.Scalar.Properties  {
  public var changesWhenCaseMapped: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_CHANGES_WHEN_CASEMAPPED)
  }
}

----Swift.(file)..(error_type).changesWhenNFKCCaseFolded
extension Unicode.Scalar.Properties  {
  public var changesWhenNFKCCaseFolded: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_CHANGES_WHEN_NFKC_CASEFOLDED)
  }
}

----Swift.(file)..(error_type).isEmoji
extension Unicode.Scalar.Properties  {
  public var isEmoji: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_EMOJI)
  }
}

----Swift.(file)..(error_type).isEmojiPresentation
extension Unicode.Scalar.Properties  {
  public var isEmojiPresentation: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_EMOJI_PRESENTATION)
  }
}

----Swift.(file)..(error_type).isEmojiModifier
extension Unicode.Scalar.Properties  {
  public var isEmojiModifier: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_EMOJI_MODIFIER)
  }
}

----Swift.(file)..(error_type).isEmojiModifierBase
extension Unicode.Scalar.Properties  {
  public var isEmojiModifierBase: Bool {
    return _hasBinaryProperty(__swift_stdlib_UCHAR_EMOJI_MODIFIER_BASE)
  }
}

----Swift.(file)..(error_type).lowercaseMapping
extension Unicode.Scalar.Properties  {
  public var lowercaseMapping: String {
    return _applyMapping(__swift_stdlib_u_strToLower)
  }
}

----Swift.(file)..(error_type).titlecaseMapping
extension Unicode.Scalar.Properties  {
  public var titlecaseMapping: String {
    return _applyMapping { ptr, cap, src, len, locale, err in
      return __swift_stdlib_u_strToTitle(ptr, cap, src, len, nil, locale, err)
    }
  }
}

----Swift.(file)..(error_type).uppercaseMapping
extension Unicode.Scalar.Properties  {
  public var uppercaseMapping: String {
    return _applyMapping(__swift_stdlib_u_strToUpper)
  }
}

----Swift.(file).Unicode.Version
extension Unicode  {
  public typealias Version = (major: Int, minor: Int)
}

----Swift.(file)..(error_type).age
extension Unicode.Scalar.Properties  {
  public var age: Unicode.Version? {
    var versionInfo: __swift_stdlib_UVersionInfo = (0, 0, 0, 0)
    withUnsafeMutablePointer(to: &versionInfo) { tuplePtr in
      tuplePtr.withMemoryRebound(to: UInt8.self, capacity: 4) {
        versionInfoPtr in
        __swift_stdlib_u_charAge(icuValue, versionInfoPtr)
      }
    }
    guard versionInfo.0 != 0 else { return nil }
    return (major: Int(versionInfo.0), minor: Int(versionInfo.1))
  }
}

----Swift.(file).Unicode.GeneralCategory.uppercaseLetter
extension Unicode.GeneralCategory {
    case u
}

----Swift.(file).Unicode.GeneralCategory.lowercaseLetter
extension Unicode.GeneralCategory {
    case l
}

----Swift.(file).Unicode.GeneralCategory.titlecaseLetter
extension Unicode.GeneralCategory {
    case t
}

----Swift.(file).Unicode.GeneralCategory.modifierLetter
extension Unicode.GeneralCategory {
    case m
}

----Swift.(file).Unicode.GeneralCategory.otherLetter
extension Unicode.GeneralCategory {
    case o
}

----Swift.(file).Unicode.GeneralCategory.nonspacingMark
extension Unicode.GeneralCategory {
    case n
}

----Swift.(file).Unicode.GeneralCategory.spacingMark
extension Unicode.GeneralCategory {
    case s
}

----Swift.(file).Unicode.GeneralCategory.enclosingMark
extension Unicode.GeneralCategory {
    case e
}

----Swift.(file).Unicode.GeneralCategory.decimalNumber
extension Unicode.GeneralCategory {
    case d
}

----Swift.(file).Unicode.GeneralCategory.letterNumber
extension Unicode.GeneralCategory {
    case l
}

----Swift.(file).Unicode.GeneralCategory.otherNumber
extension Unicode.GeneralCategory {
    case o
}

----Swift.(file).Unicode.GeneralCategory.connectorPunctuation
extension Unicode.GeneralCategory {
    case c
}

----Swift.(file).Unicode.GeneralCategory.dashPunctuation
extension Unicode.GeneralCategory {
    case d
}

----Swift.(file).Unicode.GeneralCategory.openPunctuation
extension Unicode.GeneralCategory {
    case o
}

----Swift.(file).Unicode.GeneralCategory.closePunctuation
extension Unicode.GeneralCategory {
    case c
}

----Swift.(file).Unicode.GeneralCategory.initialPunctuation
extension Unicode.GeneralCategory {
    case i
}

----Swift.(file).Unicode.GeneralCategory.finalPunctuation
extension Unicode.GeneralCategory {
    case f
}

----Swift.(file).Unicode.GeneralCategory.otherPunctuation
extension Unicode.GeneralCategory {
    case o
}

----Swift.(file).Unicode.GeneralCategory.mathSymbol
extension Unicode.GeneralCategory {
    case m
}

----Swift.(file).Unicode.GeneralCategory.currencySymbol
extension Unicode.GeneralCategory {
    case c
}

----Swift.(file).Unicode.GeneralCategory.modifierSymbol
extension Unicode.GeneralCategory {
    case m
}

----Swift.(file).Unicode.GeneralCategory.otherSymbol
extension Unicode.GeneralCategory {
    case o
}

----Swift.(file).Unicode.GeneralCategory.spaceSeparator
extension Unicode.GeneralCategory {
    case s
}

----Swift.(file).Unicode.GeneralCategory.lineSeparator
extension Unicode.GeneralCategory {
    case l
}

----Swift.(file).Unicode.GeneralCategory.paragraphSeparator
extension Unicode.GeneralCategory {
    case p
}

----Swift.(file).Unicode.GeneralCategory.control
extension Unicode.GeneralCategory {
    case c
}

----Swift.(file).Unicode.GeneralCategory.format
extension Unicode.GeneralCategory {
    case f
}

----Swift.(file).Unicode.GeneralCategory.surrogate
extension Unicode.GeneralCategory {
    case s
}

----Swift.(file).Unicode.GeneralCategory.privateUse
extension Unicode.GeneralCategory {
    case p
}

----Swift.(file).Unicode.GeneralCategory.unassigned
extension Unicode.GeneralCategory {
    case u
}

----Swift.(file).Unicode.GeneralCategory.init(rawValue:__swift_stdlib_UCharCategory)
extension Unicode.GeneralCategory {
    internal init(rawValue: __swift_stdlib_UCharCategory) {
      switch rawValue {
      case __swift_stdlib_U_UNASSIGNED: self = .unassigned
      case __swift_stdlib_U_UPPERCASE_LETTER: self = .uppercaseLetter
      case __swift_stdlib_U_LOWERCASE_LETTER: self = .lowercaseLetter
      case __swift_stdlib_U_TITLECASE_LETTER: self = .titlecaseLetter
      case __swift_stdlib_U_MODIFIER_LETTER: self = .modifierLetter
      case __swift_stdlib_U_OTHER_LETTER: self = .otherLetter
      case __swift_stdlib_U_NON_SPACING_MARK: self = .nonspacingMark
      case __swift_stdlib_U_ENCLOSING_MARK: self = .enclosingMark
      case __swift_stdlib_U_COMBINING_SPACING_MARK: self = .spacingMark
      case __swift_stdlib_U_DECIMAL_DIGIT_NUMBER: self = .decimalNumber
      case __swift_stdlib_U_LETTER_NUMBER: self = .letterNumber
      case __swift_stdlib_U_OTHER_NUMBER: self = .otherNumber
      case __swift_stdlib_U_SPACE_SEPARATOR: self = .spaceSeparator
      case __swift_stdlib_U_LINE_SEPARATOR: self = .lineSeparator
      case __swift_stdlib_U_PARAGRAPH_SEPARATOR: self = .paragraphSeparator
      case __swift_stdlib_U_CONTROL_CHAR: self = .control
      case __swift_stdlib_U_FORMAT_CHAR: self = .format
      case __swift_stdlib_U_PRIVATE_USE_CHAR: self = .privateUse
      case __swift_stdlib_U_SURROGATE: self = .surrogate
      case __swift_stdlib_U_DASH_PUNCTUATION: self = .dashPunctuation
      case __swift_stdlib_U_START_PUNCTUATION: self = .openPunctuation
      case __swift_stdlib_U_END_PUNCTUATION: self = .closePunctuation
      case __swift_stdlib_U_CONNECTOR_PUNCTUATION: self = .connectorPunctuation
      case __swift_stdlib_U_OTHER_PUNCTUATION: self = .otherPunctuation
      case __swift_stdlib_U_MATH_SYMBOL: self = .mathSymbol
      case __swift_stdlib_U_CURRENCY_SYMBOL: self = .currencySymbol
      case __swift_stdlib_U_MODIFIER_SYMBOL: self = .modifierSymbol
      case __swift_stdlib_U_OTHER_SYMBOL: self = .otherSymbol
      case __swift_stdlib_U_INITIAL_PUNCTUATION: self = .initialPunctuation
      case __swift_stdlib_U_FINAL_PUNCTUATION: self = .finalPunctuation
      default: fatalError("Unknown general category \(rawValue)")
      }
    }
}

----Swift.(file)..(error_type).generalCategory
extension Unicode.Scalar.Properties  {
  public var generalCategory: Unicode.GeneralCategory {
    let rawValue = __swift_stdlib_UCharCategory(
      __swift_stdlib_UCharCategory.RawValue(
      __swift_stdlib_u_getIntPropertyValue(
        icuValue, __swift_stdlib_UCHAR_GENERAL_CATEGORY)))
    return Unicode.GeneralCategory(rawValue: rawValue)
  }
}

----Swift.(file)..(error_type).nameAlias
extension Unicode.Scalar.Properties  {
  public var nameAlias: String? {
    return _scalarName(__swift_stdlib_U_CHAR_NAME_ALIAS)
  }
}

----Swift.(file).Unicode.CanonicalCombiningClass.notReordered
extension Unicode.CanonicalCombiningClass {
    public static let n
}

----Swift.(file).Unicode.CanonicalCombiningClass.overlay
extension Unicode.CanonicalCombiningClass {
    public static let o
}

----Swift.(file).Unicode.CanonicalCombiningClass.nukta
extension Unicode.CanonicalCombiningClass {
    public static let n
}

----Swift.(file).Unicode.CanonicalCombiningClass.kanaVoicing
extension Unicode.CanonicalCombiningClass {
    public static let k
}

----Swift.(file).Unicode.CanonicalCombiningClass.virama
extension Unicode.CanonicalCombiningClass {
    public static let v
}

----Swift.(file).Unicode.CanonicalCombiningClass.attachedBelowLeft
extension Unicode.CanonicalCombiningClass {
    public static let a
}

----Swift.(file).Unicode.CanonicalCombiningClass.attachedBelow
extension Unicode.CanonicalCombiningClass {
    public static let a
}

----Swift.(file).Unicode.CanonicalCombiningClass.attachedAbove
extension Unicode.CanonicalCombiningClass {
    public static let a
}

----Swift.(file).Unicode.CanonicalCombiningClass.attachedAboveRight
extension Unicode.CanonicalCombiningClass {
    public static let a
}

----Swift.(file).Unicode.CanonicalCombiningClass.belowLeft
extension Unicode.CanonicalCombiningClass {
    public static let b
}

----Swift.(file).Unicode.CanonicalCombiningClass.below
extension Unicode.CanonicalCombiningClass {
    public static let b
}

----Swift.(file).Unicode.CanonicalCombiningClass.belowRight
extension Unicode.CanonicalCombiningClass {
    public static let b
}

----Swift.(file).Unicode.CanonicalCombiningClass.left
extension Unicode.CanonicalCombiningClass {
    public static let l
}

----Swift.(file).Unicode.CanonicalCombiningClass.right
extension Unicode.CanonicalCombiningClass {
    public static let r
}

----Swift.(file).Unicode.CanonicalCombiningClass.aboveLeft
extension Unicode.CanonicalCombiningClass {
    public static let a
}

----Swift.(file).Unicode.CanonicalCombiningClass.above
extension Unicode.CanonicalCombiningClass {
    public static let a
}

----Swift.(file).Unicode.CanonicalCombiningClass.aboveRight
extension Unicode.CanonicalCombiningClass {
    public static let a
}

----Swift.(file).Unicode.CanonicalCombiningClass.doubleBelow
extension Unicode.CanonicalCombiningClass {
    public static let d
}

----Swift.(file).Unicode.CanonicalCombiningClass.doubleAbove
extension Unicode.CanonicalCombiningClass {
    public static let d
}

----Swift.(file).Unicode.CanonicalCombiningClass.iotaSubscript
extension Unicode.CanonicalCombiningClass {
    public static let i
}

----Swift.(file).Unicode.CanonicalCombiningClass.rawValue
extension Unicode.CanonicalCombiningClass {
    public let r
}

----Swift.(file).Unicode.CanonicalCombiningClass.init(rawValue:UInt8)
extension Unicode.CanonicalCombiningClass {
    public init(rawValue: UInt8) {
      self.rawValue = rawValue
    }
}

----Swift.(file).Unicode.CanonicalCombiningClass.==infix(_:<<error type>>,_:<<error type>>)
extension Unicode.CanonicalCombiningClass {
    public static func == (
      lhs: CanonicalCombiningClass,
      rhs: CanonicalCombiningClass
    ) -> Bool {
      return lhs.rawValue == rhs.rawValue
    }
}

----Swift.(file).Unicode.CanonicalCombiningClass.<infix(_:<<error type>>,_:<<error type>>)
extension Unicode.CanonicalCombiningClass {
    public static func < (
      lhs: CanonicalCombiningClass,
      rhs: CanonicalCombiningClass
    ) -> Bool {
      return lhs.rawValue < rhs.rawValue
    }
}

----Swift.(file).Unicode.CanonicalCombiningClass.hashValue
extension Unicode.CanonicalCombiningClass {
    public var hashValue: Int {
      return rawValue.hashValue
    }
}

----Swift.(file).Unicode.CanonicalCombiningClass.hash(into:Hasher)
extension Unicode.CanonicalCombiningClass {
    public func hash(into hasher: inout Hasher) {
      hasher.combine(rawValue)
    }
}

----Swift.(file)..(error_type).canonicalCombiningClass
extension Unicode.Scalar.Properties  {
  public var canonicalCombiningClass: Unicode.CanonicalCombiningClass {
    let rawValue = UInt8(__swift_stdlib_u_getIntPropertyValue(
      icuValue, __swift_stdlib_UCHAR_CANONICAL_COMBINING_CLASS))
    return Unicode.CanonicalCombiningClass(rawValue: rawValue)
  }
}

----Swift.(file).Unicode.NumericType.decimal
extension Unicode.NumericType {
    case d
}

----Swift.(file).Unicode.NumericType.digit
extension Unicode.NumericType {
    case d
}

----Swift.(file).Unicode.NumericType.numeric
extension Unicode.NumericType {
    case n
}

----Swift.(file).Unicode.NumericType.init(rawValue:__swift_stdlib_UNumericType)
extension Unicode.NumericType {
    internal init?(rawValue: __swift_stdlib_UNumericType) {
      switch rawValue {
      case __swift_stdlib_U_NT_NONE: return nil
      case __swift_stdlib_U_NT_DECIMAL: self = .decimal
      case __swift_stdlib_U_NT_DIGIT: self = .digit
      case __swift_stdlib_U_NT_NUMERIC: self = .numeric
      default: fatalError("Unknown numeric type \(rawValue)")
      }
    }
}

----Swift.(file)..(error_type).numericType
extension Unicode.Scalar.Properties  {
  public var numericType: Unicode.NumericType? {
    let rawValue = __swift_stdlib_UNumericType(
      __swift_stdlib_UNumericType.RawValue(
      __swift_stdlib_u_getIntPropertyValue(
        icuValue, __swift_stdlib_UCHAR_NUMERIC_TYPE)))
    return Unicode.NumericType(rawValue: rawValue)
  }
}

----Swift.(file)..(error_type).numericValue
extension Unicode.Scalar.Properties  {
  public var numericValue: Double? {
    let icuNoNumericValue: Double = -123456789
    let result = __swift_stdlib_u_getNumericValue(icuValue)
    return result != icuNoNumericValue ? result : nil
  }
}

----Swift.(file).Unmanaged.init(_private:Instance)
extension Unmanaged {
  internal init(_private: Instance) { _value = _private }
}

----Swift.(file).Unmanaged.fromOpaque(_:UnsafeRawPointer)
extension Unmanaged {
  public static func fromOpaque(_ value: UnsafeRawPointer) -> Unmanaged {
    return Unmanaged(_private: unsafeBitCast(value, to: Instance.self))
  }
}

----Swift.(file).Unmanaged.toOpaque()
extension Unmanaged {
  public func toOpaque() -> UnsafeMutableRawPointer {
    return unsafeBitCast(_value, to: UnsafeMutableRawPointer.self)
  }
}

----Swift.(file).Unmanaged.passRetained(_:Instance)
extension Unmanaged {
  public static func passRetained(_ value: Instance) -> Unmanaged {
    return Unmanaged(_private: value).retain()
  }
}

----Swift.(file).Unmanaged.passUnretained(_:Instance)
extension Unmanaged {
  public static func passUnretained(_ value: Instance) -> Unmanaged {
    return Unmanaged(_private: value)
  }
}

----Swift.(file).Unmanaged.takeUnretainedValue()
extension Unmanaged {
  public func takeUnretainedValue() -> Instance {
    return _value
  }
}

----Swift.(file).Unmanaged.takeRetainedValue()
extension Unmanaged {
  public func takeRetainedValue() -> Instance {
    let result = _value
    release()
    return result
  }
}

----Swift.(file).Unmanaged.retain()
extension Unmanaged {
  public func retain() -> Unmanaged {
    Builtin.retain(_value)
    return self
  }
}

----Swift.(file).Unmanaged.release()
extension Unmanaged {
  public func release() {
    Builtin.release(_value)
  }
}

----Swift.(file).Unmanaged.autorelease()
extension Unmanaged {
  public func autorelease() -> Unmanaged {
    Builtin.autorelease(_value)
    return self
  }
}

----Swift.(file).UnsafePointer.Distance
extension UnsafePointer {
  public typealias Distance = I
}

----Swift.(file).UnsafePointer.init(_:<<error type>>)
extension UnsafePointer {
  public init(_ _rawValue : Builtin.RawPointer) {
    self._rawValue = _rawValue
  }
}

----Swift.(file).UnsafePointer.deallocate()
extension UnsafePointer {
  public func deallocate() {
    Builtin.deallocRaw(_rawValue, (-1)._builtinWordValue, (-1)._builtinWordValue)
  }
}

----Swift.(file).UnsafePointer.pointee
extension UnsafePointer {
  public var pointee: Pointee {
    @_transparent unsafeAddress {
      return self
    }
  }
}

----Swift.(file).UnsafePointer.withMemoryRebound(to:T.Type,capacity:Int,_:(UnsafePointer<T>) throws -> Result)
extension UnsafePointer {
  public func withMemoryRebound<T, Result>(to type: T.Type, capacity count: Int,
    _ body: (UnsafePointer<T>) throws -> Result
  ) rethrows -> Result {
    Builtin.bindMemory(_rawValue, count._builtinWordValue, T.self)
    defer {
      Builtin.bindMemory(_rawValue, count._builtinWordValue, Pointee.self)
    }
    return try body(UnsafePointer<T>(_rawValue))
  }
}

----Swift.(file).UnsafePointer.subscript(_:Int)
extension UnsafePointer {
  public subscript(i: Int) -> Pointee {
    @_transparent
    unsafeAddress {
      return self + i
    }
  }
}

----Swift.(file).UnsafeMutablePointer.Distance
extension UnsafeMutablePointer {
  public typealias Distance = I
}

----Swift.(file).UnsafeMutablePointer.init(_:<<error type>>)
extension UnsafeMutablePointer {
  public init(_ _rawValue : Builtin.RawPointer) {
    self._rawValue = _rawValue
  }
}

----Swift.(file).UnsafeMutablePointer.init(mutating:UnsafePointer<Pointee>)
extension UnsafeMutablePointer {
  public init(mutating other: UnsafePointer<Pointee>) {
    self._rawValue = other._rawValue
  }
}

----Swift.(file).UnsafeMutablePointer.init(mutating:UnsafePointer<Pointee>?)
extension UnsafeMutablePointer {
  public init?(mutating other: UnsafePointer<Pointee>?) {
    guard let unwrapped = other else { return nil }
    self.init(mutating: unwrapped)
  }
}

----Swift.(file).UnsafeMutablePointer.allocate(capacity:Int)
extension UnsafeMutablePointer {
  public static func allocate(capacity count: Int)
    -> UnsafeMutablePointer<Pointee> {
    let size = MemoryLayout<Pointee>.stride * count
    let rawPtr =
      Builtin.allocRaw(size._builtinWordValue, Builtin.alignof(Pointee.self))
    Builtin.bindMemory(rawPtr, count._builtinWordValue, Pointee.self)
    return UnsafeMutablePointer(rawPtr)
  }
}

----Swift.(file).UnsafeMutablePointer.deallocate()
extension UnsafeMutablePointer {
  public func deallocate() {
    Builtin.deallocRaw(_rawValue, (-1)._builtinWordValue,
                       Builtin.alignof(Pointee.self))
  }
}

----Swift.(file).UnsafeMutablePointer.pointee
extension UnsafeMutablePointer {
  public var pointee: Pointee {
    @_transparent unsafeAddress {
      return UnsafePointer(self)
    }
    @_transparent nonmutating unsafeMutableAddress {
      return self
    }
  }
}

----Swift.(file).UnsafeMutablePointer.initialize(repeating:Pointee,count:Int)
extension UnsafeMutablePointer {
  public func initialize(repeating repeatedValue: Pointee, count: Int) {
    // FIXME: add tests (since the `count` has been added)
    _debugPrecondition(count >= 0,
      "UnsafeMutablePointer.initialize(repeating:count:): negative count")
    // Must not use `initializeFrom` with a `Collection` as that will introduce
    // a cycle.
    for offset in 0..<count {
      Builtin.initialize(repeatedValue, (self + offset)._rawValue)
    }
  }
}

----Swift.(file).UnsafeMutablePointer.initialize(to:Pointee)
extension UnsafeMutablePointer {
  public func initialize(to value: Pointee) {
    Builtin.initialize(value, self._rawValue)
  }
}

----Swift.(file).UnsafeMutablePointer.move()
extension UnsafeMutablePointer {
  public func move() -> Pointee {
    return Builtin.take(_rawValue)
  }
}

----Swift.(file).UnsafeMutablePointer.assign(repeating:Pointee,count:Int)
extension UnsafeMutablePointer {
  public func assign(repeating repeatedValue: Pointee, count: Int) {
    _debugPrecondition(count >= 0, "UnsafeMutablePointer.assign(repeating:count:) with negative count")
    for i in 0..<count {
      self[i] = repeatedValue
    }
  }
}

----Swift.(file).UnsafeMutablePointer.assign(from:UnsafePointer<Pointee>,count:Int)
extension UnsafeMutablePointer {
  public func assign(from source: UnsafePointer<Pointee>, count: Int) {
    _debugPrecondition(
      count >= 0, "UnsafeMutablePointer.assign with negative count")
    if UnsafePointer(self) < source || UnsafePointer(self) >= source + count {
      // assign forward from a disjoint or following overlapping range.
      Builtin.assignCopyArrayFrontToBack(
        Pointee.self, self._rawValue, source._rawValue, count._builtinWordValue)
      // This builtin is equivalent to:
      // for i in 0..<count {
      //   self[i] = source[i]
      // }
    }
    else if UnsafePointer(self) != source {
      // assign backward from a non-following overlapping range.
      Builtin.assignCopyArrayBackToFront(
        Pointee.self, self._rawValue, source._rawValue, count._builtinWordValue)
      // This builtin is equivalent to:
      // var i = count-1
      // while i >= 0 {
      //   self[i] = source[i]
      //   i -= 1
      // }
    }
  }
}

----Swift.(file).UnsafeMutablePointer.moveInitialize(from:UnsafeMutablePointer<Pointee>,count:Int)
extension UnsafeMutablePointer {
  public func moveInitialize(from source: UnsafeMutablePointer, count: Int) {
    _debugPrecondition(
      count >= 0, "UnsafeMutablePointer.moveInitialize with negative count")
    if self < source || self >= source + count {
      // initialize forward from a disjoint or following overlapping range.
      Builtin.takeArrayFrontToBack(
        Pointee.self, self._rawValue, source._rawValue, count._builtinWordValue)
      // This builtin is equivalent to:
      // for i in 0..<count {
      //   (self + i).initialize(to: (source + i).move())
      // }
    }
    else {
      // initialize backward from a non-following overlapping range.
      Builtin.takeArrayBackToFront(
        Pointee.self, self._rawValue, source._rawValue, count._builtinWordValue)
      // This builtin is equivalent to:
      // var src = source + count
      // var dst = self + count
      // while dst != self {
      //   (--dst).initialize(to: (--src).move())
      // }
    }
  }
}

----Swift.(file).UnsafeMutablePointer.initialize(from:UnsafePointer<Pointee>,count:Int)
extension UnsafeMutablePointer {
  public func initialize(from source: UnsafePointer<Pointee>, count: Int) {
    _debugPrecondition(
      count >= 0, "UnsafeMutablePointer.initialize with negative count")
    _debugPrecondition(
      UnsafePointer(self) + count <= source ||
      source + count <= UnsafePointer(self),
      "UnsafeMutablePointer.initialize overlapping range")
    Builtin.copyArray(
      Pointee.self, self._rawValue, source._rawValue, count._builtinWordValue)
    // This builtin is equivalent to:
    // for i in 0..<count {
    //   (self + i).initialize(to: source[i])
    // }
  }
}

----Swift.(file).UnsafeMutablePointer.moveAssign(from:UnsafeMutablePointer<Pointee>,count:Int)
extension UnsafeMutablePointer {
  public func moveAssign(from source: UnsafeMutablePointer, count: Int) {
    _debugPrecondition(
      count >= 0, "UnsafeMutablePointer.moveAssign(from:) with negative count")
    _debugPrecondition(
      self + count <= source || source + count <= self,
      "moveAssign overlapping range")
    Builtin.assignTakeArray(
      Pointee.self, self._rawValue, source._rawValue, count._builtinWordValue)
    // These builtins are equivalent to:
    // for i in 0..<count {
    //   self[i] = (source + i).move()
    // }
  }
}

----Swift.(file).UnsafeMutablePointer.deinitialize(count:Int)
extension UnsafeMutablePointer {
  public func deinitialize(count: Int) -> UnsafeMutableRawPointer {
    _debugPrecondition(count >= 0, "UnsafeMutablePointer.deinitialize with negative count")
    // FIXME: optimization should be implemented, where if the `count` value
    // is 1, the `Builtin.destroy(Pointee.self, _rawValue)` gets called.
    Builtin.destroyArray(Pointee.self, _rawValue, count._builtinWordValue)
    return UnsafeMutableRawPointer(self)
  }
}

----Swift.(file).UnsafeMutablePointer.withMemoryRebound(to:T.Type,capacity:Int,_:(UnsafeMutablePointer<T>) throws -> Result)
extension UnsafeMutablePointer {
  public func withMemoryRebound<T, Result>(to type: T.Type, capacity count: Int,
    _ body: (UnsafeMutablePointer<T>) throws -> Result
  ) rethrows -> Result {
    Builtin.bindMemory(_rawValue, count._builtinWordValue, T.self)
    defer {
      Builtin.bindMemory(_rawValue, count._builtinWordValue, Pointee.self)
    }
    return try body(UnsafeMutablePointer<T>(_rawValue))
  }
}

----Swift.(file).UnsafeMutablePointer.subscript(_:Int)
extension UnsafeMutablePointer {
  public subscript(i: Int) -> Pointee {
    @_transparent
    unsafeAddress {
      return UnsafePointer(self + i)
    }
    @_transparent
    nonmutating unsafeMutableAddress {
      return self + i
    }
  }
}

----Swift.(file).UnsafeRawPointer.Pointee
extension UnsafeRawPointer {
  public typealias Pointee = U
}

----Swift.(file).UnsafeRawPointer.init(_:<<error type>>)
extension UnsafeRawPointer {
  public init(_ _rawValue: Builtin.RawPointer) {
    self._rawValue = _rawValue
  }
}

----Swift.(file).UnsafeRawPointer.init(_:UnsafePointer<T>)
extension UnsafeRawPointer {
  public init<T>(_ other: UnsafePointer<T>) {
    _rawValue = other._rawValue
  }
}

----Swift.(file).UnsafeRawPointer.init(_:UnsafePointer<T>?)
extension UnsafeRawPointer {
  public init?<T>(_ other: UnsafePointer<T>?) {
    guard let unwrapped = other else { return nil }
    _rawValue = unwrapped._rawValue
  }
}

----Swift.(file).UnsafeRawPointer.init(_:UnsafeMutableRawPointer)
extension UnsafeRawPointer {
  public init(_ other: UnsafeMutableRawPointer) {
    _rawValue = other._rawValue
  }
}

----Swift.(file).UnsafeRawPointer.init(_:UnsafeMutableRawPointer?)
extension UnsafeRawPointer {
  public init?(_ other: UnsafeMutableRawPointer?) {
    guard let unwrapped = other else { return nil }
    _rawValue = unwrapped._rawValue
  }
}

----Swift.(file).UnsafeRawPointer.deallocate()
extension UnsafeRawPointer {
  public func deallocate() {
    Builtin.deallocRaw(_rawValue, (-1)._builtinWordValue, (-1)._builtinWordValue)
  }
}

----Swift.(file).UnsafeRawPointer.bindMemory(to:T.Type,capacity:Int)
extension UnsafeRawPointer {
  public func bindMemory<T>(
    to type: T.Type, capacity count: Int
  ) -> UnsafePointer<T> {
    Builtin.bindMemory(_rawValue, count._builtinWordValue, type)
    return UnsafePointer<T>(_rawValue)
  }
}

----Swift.(file).UnsafeRawPointer.assumingMemoryBound(to:T.Type)
extension UnsafeRawPointer {
  public func assumingMemoryBound<T>(to: T.Type) -> UnsafePointer<T> {
    return UnsafePointer<T>(_rawValue)
  }
}

----Swift.(file).UnsafeRawPointer.load(fromByteOffset:Int,as:T.Type)
extension UnsafeRawPointer {
  public func load<T>(fromByteOffset offset: Int = 0, as type: T.Type) -> T {
    _debugPrecondition(0 == (UInt(bitPattern: self + offset)
        & (UInt(MemoryLayout<T>.alignment) - 1)),
      "load from misaligned raw pointer")

    return Builtin.loadRaw((self + offset)._rawValue)
  }
}

----Swift.(file).UnsafeRawPointer.advanced(by:Int)
extension UnsafeRawPointer: Strideable  {
  public func advanced(by n: Int) -> UnsafeRawPointer {
    return UnsafeRawPointer(Builtin.gepRaw_Word(_rawValue, n._builtinWordValue))
  }
}

----Swift.(file).UnsafeMutableRawPointer.Pointee
extension UnsafeMutableRawPointer {
  public typealias Pointee = U
}

----Swift.(file).UnsafeMutableRawPointer.init(_:<<error type>>)
extension UnsafeMutableRawPointer {
  public init(_ _rawValue: Builtin.RawPointer) {
    self._rawValue = _rawValue
  }
}

----Swift.(file).UnsafeMutableRawPointer.init(_:UnsafeMutablePointer<T>)
extension UnsafeMutableRawPointer {
  public init<T>(_ other: UnsafeMutablePointer<T>) {
    _rawValue = other._rawValue
  }
}

----Swift.(file).UnsafeMutableRawPointer.init(_:UnsafeMutablePointer<T>?)
extension UnsafeMutableRawPointer {
  public init?<T>(_ other: UnsafeMutablePointer<T>?) {
    guard let unwrapped = other else { return nil }
    _rawValue = unwrapped._rawValue
  }
}

----Swift.(file).UnsafeMutableRawPointer.init(mutating:UnsafeRawPointer)
extension UnsafeMutableRawPointer {
  public init(mutating other: UnsafeRawPointer) {
    _rawValue = other._rawValue
  }
}

----Swift.(file).UnsafeMutableRawPointer.init(mutating:UnsafeRawPointer?)
extension UnsafeMutableRawPointer {
  public init?(mutating other: UnsafeRawPointer?) {
    guard let unwrapped = other else { return nil }
    _rawValue = unwrapped._rawValue
  }
}

----Swift.(file).UnsafeMutableRawPointer.allocate(byteCount:Int,alignment:Int)
extension UnsafeMutableRawPointer {
  public static func allocate(
    byteCount: Int, alignment: Int
  ) -> UnsafeMutableRawPointer {
    return UnsafeMutableRawPointer(Builtin.allocRaw(
        byteCount._builtinWordValue, alignment._builtinWordValue))
  }
}

----Swift.(file).UnsafeMutableRawPointer.deallocate()
extension UnsafeMutableRawPointer {
  public func deallocate() {
    Builtin.deallocRaw(_rawValue, (-1)._builtinWordValue, (-1)._builtinWordValue)
  }
}

----Swift.(file).UnsafeMutableRawPointer.bindMemory(to:T.Type,capacity:Int)
extension UnsafeMutableRawPointer {
  public func bindMemory<T>(
    to type: T.Type, capacity count: Int
  ) -> UnsafeMutablePointer<T> {
    Builtin.bindMemory(_rawValue, count._builtinWordValue, type)
    return UnsafeMutablePointer<T>(_rawValue)
  }
}

----Swift.(file).UnsafeMutableRawPointer.assumingMemoryBound(to:T.Type)
extension UnsafeMutableRawPointer {
  public func assumingMemoryBound<T>(to: T.Type) -> UnsafeMutablePointer<T> {
    return UnsafeMutablePointer<T>(_rawValue)
  }
}

----Swift.(file).UnsafeMutableRawPointer.initializeMemory(as:T.Type,repeating:T,count:Int)
extension UnsafeMutableRawPointer {
  public func initializeMemory<T>(
    as type: T.Type, repeating repeatedValue: T, count: Int
  ) -> UnsafeMutablePointer<T> {
    _debugPrecondition(count >= 0,
      "UnsafeMutableRawPointer.initializeMemory: negative count")

    Builtin.bindMemory(_rawValue, count._builtinWordValue, type)
    var nextPtr = self
    for _ in 0..<count {
      Builtin.initialize(repeatedValue, nextPtr._rawValue)
      nextPtr += MemoryLayout<T>.stride
    }
    return UnsafeMutablePointer(_rawValue)
  }
}

----Swift.(file).UnsafeMutableRawPointer.initializeMemory(as:T.Type,from:UnsafePointer<T>,count:Int)
extension UnsafeMutableRawPointer {
  public func initializeMemory<T>(
    as type: T.Type, from source: UnsafePointer<T>, count: Int
  ) -> UnsafeMutablePointer<T> {
    _debugPrecondition(
      count >= 0,
      "UnsafeMutableRawPointer.initializeMemory with negative count")
    _debugPrecondition(
      (UnsafeRawPointer(self + count * MemoryLayout<T>.stride)
        <= UnsafeRawPointer(source))
      || UnsafeRawPointer(source + count) <= UnsafeRawPointer(self),
      "UnsafeMutableRawPointer.initializeMemory overlapping range")

    Builtin.bindMemory(_rawValue, count._builtinWordValue, type)
    Builtin.copyArray(
      T.self, self._rawValue, source._rawValue, count._builtinWordValue)
    // This builtin is equivalent to:
    // for i in 0..<count {
    //   (self.assumingMemoryBound(to: T.self) + i).initialize(to: source[i])
    // }
    return UnsafeMutablePointer(_rawValue)
  }
}

----Swift.(file).UnsafeMutableRawPointer.moveInitializeMemory(as:T.Type,from:UnsafeMutablePointer<T>,count:Int)
extension UnsafeMutableRawPointer {
  public func moveInitializeMemory<T>(
    as type: T.Type, from source: UnsafeMutablePointer<T>, count: Int
  ) -> UnsafeMutablePointer<T> {
    _debugPrecondition(
      count >= 0,
      "UnsafeMutableRawPointer.moveInitializeMemory with negative count")

    Builtin.bindMemory(_rawValue, count._builtinWordValue, type)
    if self < UnsafeMutableRawPointer(source)
       || self >= UnsafeMutableRawPointer(source + count) {
      // initialize forward from a disjoint or following overlapping range.
      Builtin.takeArrayFrontToBack(
        T.self, self._rawValue, source._rawValue, count._builtinWordValue)
      // This builtin is equivalent to:
      // for i in 0..<count {
      //   (self.assumingMemoryBound(to: T.self) + i)
      //   .initialize(to: (source + i).move())
      // }
    }
    else {
      // initialize backward from a non-following overlapping range.
      Builtin.takeArrayBackToFront(
        T.self, self._rawValue, source._rawValue, count._builtinWordValue)
      // This builtin is equivalent to:
      // var src = source + count
      // var dst = self.assumingMemoryBound(to: T.self) + count
      // while dst != self {
      //   (--dst).initialize(to: (--src).move())
      // }
    }
    return UnsafeMutablePointer(_rawValue)
  }
}

----Swift.(file).UnsafeMutableRawPointer.load(fromByteOffset:Int,as:T.Type)
extension UnsafeMutableRawPointer {
  public func load<T>(fromByteOffset offset: Int = 0, as type: T.Type) -> T {
    _debugPrecondition(0 == (UInt(bitPattern: self + offset)
        & (UInt(MemoryLayout<T>.alignment) - 1)),
      "load from misaligned raw pointer")

    return Builtin.loadRaw((self + offset)._rawValue)
  }
}

----Swift.(file).UnsafeMutableRawPointer.storeBytes(of:T,toByteOffset:Int,as:T.Type)
extension UnsafeMutableRawPointer {
  public func storeBytes<T>(
    of value: T, toByteOffset offset: Int = 0, as type: T.Type
  ) {
    _debugPrecondition(0 == (UInt(bitPattern: self + offset)
        & (UInt(MemoryLayout<T>.alignment) - 1)),
      "storeBytes to misaligned raw pointer")

    var temp = value
    withUnsafeMutablePointer(to: &temp) { source in
      let rawSrc = UnsafeMutableRawPointer(source)._rawValue
      // FIXME: to be replaced by _memcpy when conversions are implemented.
      Builtin.int_memcpy_RawPointer_RawPointer_Int64(
        (self + offset)._rawValue, rawSrc, UInt64(MemoryLayout<T>.size)._value,
        /*volatile:*/ false._value)
    }
  }
}

----Swift.(file).UnsafeMutableRawPointer.copyMemory(from:UnsafeRawPointer,byteCount:Int)
extension UnsafeMutableRawPointer {
  public func copyMemory(from source: UnsafeRawPointer, byteCount: Int) {
    _debugPrecondition(
      byteCount >= 0, "UnsafeMutableRawPointer.copyMemory with negative count")

    _memmove(dest: self, src: source, size: UInt(byteCount))
  }
}

----Swift.(file).UnsafeMutableRawPointer.advanced(by:Int)
extension UnsafeMutableRawPointer: Strideable  {
  public func advanced(by n: Int) -> UnsafeMutableRawPointer {
    return UnsafeMutableRawPointer(Builtin.gepRaw_Word(_rawValue, n._builtinWordValue))
  }
}

----Swift.(file).OpaquePointer.init(_:UnsafeMutableRawPointer)
extension OpaquePointer  {
  public init(_ from: UnsafeMutableRawPointer) {
    self._rawValue = from._rawValue
  }
}

----Swift.(file).OpaquePointer.init(_:UnsafeMutableRawPointer?)
extension OpaquePointer  {
  public init?(_ from: UnsafeMutableRawPointer?) {
    guard let unwrapped = from else { return nil }
    self._rawValue = unwrapped._rawValue
  }
}

----Swift.(file).OpaquePointer.init(_:UnsafeRawPointer)
extension OpaquePointer  {
  public init(_ from: UnsafeRawPointer) {
    self._rawValue = from._rawValue
  }
}

----Swift.(file).OpaquePointer.init(_:UnsafeRawPointer?)
extension OpaquePointer  {
  public init?(_ from: UnsafeRawPointer?) {
    guard let unwrapped = from else { return nil }
    self._rawValue = unwrapped._rawValue
  }
}

----Swift.(file)._ValidUTF8Buffer.SubSequence
extension _ValidUTF8Buffer : Sequence  {
  public typealias SubSequence = Slice<_ValidUTF8Buffer>
}

----Swift.(file)._ValidUTF8Buffer.Iterator.init(_:_ValidUTF8Buffer)
extension _ValidUTF8Buffer.Iterator {
    public init(_ x: _ValidUTF8Buffer) { _biasedBits = x._biasedBits }
}

----Swift.(file)._ValidUTF8Buffer.Iterator.next()
extension _ValidUTF8Buffer.Iterator {
    public mutating func next() -> Element? {
      if _biasedBits == 0 { return nil }
      defer { _biasedBits >>= 8 }
      return Element(truncatingIfNeeded: _biasedBits) &- 1
    }
}

----Swift.(file)._ValidUTF8Buffer.makeIterator()
extension _ValidUTF8Buffer : Sequence  {
  public func makeIterator() -> Iterator {
    return Iterator(self)
  }
}

----Swift.(file)._ValidUTF8Buffer.Index.init(_biasedBits:UInt32)
extension _ValidUTF8Buffer.Index {
    internal init(_biasedBits: UInt32) { self._biasedBits = _biasedBits }
}

----Swift.(file)._ValidUTF8Buffer.Index.==infix(_:_ValidUTF8Buffer.Index,_:_ValidUTF8Buffer.Index)
extension _ValidUTF8Buffer.Index {
    public static func == (lhs: Index, rhs: Index) -> Bool {
      return lhs._biasedBits == rhs._biasedBits
    }
}

----Swift.(file)._ValidUTF8Buffer.Index.<infix(_:_ValidUTF8Buffer.Index,_:_ValidUTF8Buffer.Index)
extension _ValidUTF8Buffer.Index {
    public static func < (lhs: Index, rhs: Index) -> Bool {
      return lhs._biasedBits > rhs._biasedBits
    }
}

----Swift.(file)._ValidUTF8Buffer.startIndex
extension _ValidUTF8Buffer : Collection  {
  public var startIndex : Index {
    return Index(_biasedBits: _biasedBits)
  }
}

----Swift.(file)._ValidUTF8Buffer.endIndex
extension _ValidUTF8Buffer : Collection  {
  public var endIndex : Index {
    return Index(_biasedBits: 0)
  }
}

----Swift.(file)._ValidUTF8Buffer.count
extension _ValidUTF8Buffer : Collection  {
  public var count : Int {
    return UInt32.bitWidth &>> 3 &- _biasedBits.leadingZeroBitCount &>> 3
  }
}

----Swift.(file)._ValidUTF8Buffer.isEmpty
extension _ValidUTF8Buffer : Collection  {
  public var isEmpty : Bool {
    return _biasedBits == 0
  }
}

----Swift.(file)._ValidUTF8Buffer.index(after:_ValidUTF8Buffer.Index)
extension _ValidUTF8Buffer : Collection  {
  public func index(after i: Index) -> Index {
    _debugPrecondition(i._biasedBits != 0)
    return Index(_biasedBits: i._biasedBits >> 8)
  }
}

----Swift.(file)._ValidUTF8Buffer.subscript(_:_ValidUTF8Buffer.Index)
extension _ValidUTF8Buffer : Collection  {
  public subscript(i: Index) -> Element {
    return Element(truncatingIfNeeded: i._biasedBits) &- 1
  }
}

----Swift.(file)._ValidUTF8Buffer.index(before:_ValidUTF8Buffer.Index)
extension _ValidUTF8Buffer : BidirectionalCollection  {
  public func index(before i: Index) -> Index {
    let offset = _ValidUTF8Buffer(_biasedBits: i._biasedBits).count
    _debugPrecondition(offset != 0)
    return Index(_biasedBits: _biasedBits &>> (offset &<< 3 - 8))
  }
}

----Swift.(file)._ValidUTF8Buffer.Indices
extension _ValidUTF8Buffer : RandomAccessCollection  {
  public typealias Indices = DefaultIndices<_ValidUTF8Buffer>
}

----Swift.(file)._ValidUTF8Buffer.distance(from:_ValidUTF8Buffer.Index,to:_ValidUTF8Buffer.Index)
extension _ValidUTF8Buffer : RandomAccessCollection  {
  public func distance(from i: Index, to j: Index) -> Int {
    _debugPrecondition(_isValid(i))
    _debugPrecondition(_isValid(j))
    return (
      i._biasedBits.leadingZeroBitCount - j._biasedBits.leadingZeroBitCount
    ) &>> 3
  }
}

----Swift.(file)._ValidUTF8Buffer.index(_:_ValidUTF8Buffer.Index,offsetBy:Int)
extension _ValidUTF8Buffer : RandomAccessCollection  {
  public func index(_ i: Index, offsetBy n: Int) -> Index {
    let startOffset = distance(from: startIndex, to: i)
    let newOffset = startOffset + n
    _debugPrecondition(newOffset >= 0)
    _debugPrecondition(newOffset <= count)
    return Index(_biasedBits: _biasedBits._fullShiftRight(newOffset &<< 3))
  }
}

----Swift.(file)._ValidUTF8Buffer.init()
extension _ValidUTF8Buffer : RangeReplaceableCollection  {
  public init() {
    _biasedBits = 0
  }
}

----Swift.(file)._ValidUTF8Buffer.capacity
extension _ValidUTF8Buffer : RangeReplaceableCollection  {
  public var capacity: Int {
    return _ValidUTF8Buffer.capacity
  }
}

----Swift.(file)._ValidUTF8Buffer.capacity
extension _ValidUTF8Buffer : RangeReplaceableCollection  {
  public static var capacity: Int {
    return UInt32.bitWidth / Element.bitWidth
  }
}

----Swift.(file)._ValidUTF8Buffer.append(_:_ValidUTF8Buffer.Element)
extension _ValidUTF8Buffer : RangeReplaceableCollection  {
  public mutating func append(_ e: Element) {
    _debugPrecondition(count + 1 <= capacity)
    _internalInvariant(
      e != 192 && e != 193 && !(245...255).contains(e), "invalid UTF8 byte")
    _biasedBits |= UInt32(e &+ 1) &<< (count &<< 3)
  }
}

----Swift.(file)._ValidUTF8Buffer.removeFirst()
extension _ValidUTF8Buffer : RangeReplaceableCollection  {
  public mutating func removeFirst() -> Element {
    _debugPrecondition(!isEmpty)
    let result = Element(truncatingIfNeeded: _biasedBits) &- 1
    _biasedBits = _biasedBits._fullShiftRight(8)
    return result
  }
}

----Swift.(file)._ValidUTF8Buffer.replaceSubrange(_:Range<_ValidUTF8Buffer.Index>,with:C)
extension _ValidUTF8Buffer : RangeReplaceableCollection  {
  public mutating func replaceSubrange<C: Collection>(
    _ target: Range<Index>, with replacement: C
  ) where C.Element == Element {
    _debugPrecondition(_isValid(target.lowerBound))
    _debugPrecondition(_isValid(target.upperBound))
    var r = _ValidUTF8Buffer()
    for x in self[..<target.lowerBound] { r.append(x) }
    for x in replacement                { r.append(x) }
    for x in self[target.upperBound...] { r.append(x) }
    self = r
  }
}

----Swift.(file)._ValidUTF8Buffer.append(contentsOf:_ValidUTF8Buffer)
extension _ValidUTF8Buffer  {
  public mutating func append(contentsOf other: _ValidUTF8Buffer) {
    _debugPrecondition(count + other.count <= capacity)
    _biasedBits |= UInt32(
      truncatingIfNeeded: other._biasedBits) &<< (count &<< 3)
  }
}

----Swift.(file)._ValidUTF8Buffer.encodedReplacementCharacter
extension _ValidUTF8Buffer  {
  public static var encodedReplacementCharacter : _ValidUTF8Buffer {
    return _ValidUTF8Buffer(_biasedBits: 0xBD_BF_EF &+ 0x01_01_01)
  }
}