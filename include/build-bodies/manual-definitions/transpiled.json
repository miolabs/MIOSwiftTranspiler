[
  ["Swift.(file).min(_:T,_:T)", "return ($info.T.infix_60({Self: $info.T}, y, x) ? y : x)"],
  ["Swift.(file).min(_:T,_:T,_:T,_:[T])", "let minValue = ($info.T.infix_60({Self: $info.T}, y, x) ? y : x);\n{\nif(($info.T.infix_60({Self: $info.T}, z, minValue))) {\nminValue = z;\n}\n};\n{\nif((Optional.infix_33_61({Wrapped: _clarifyGenerics({Self:Array, Element: $info.T})}, rest, null))) {\n{\nlet $value$generator = _cloneStruct(rest.makeIterator({Self: _clarifyGenerics({Self:Array, Element: $info.T})}, ));\nwhile(true) {\nconst value = $value$generator.next({$setThis: $val => $value$generator = $val, Elements: _clarifyGenerics({Self:Array, Element: $info.T})}, );\nif(!((value != null))) break;\nif(!($info.T.infix_60({Self: $info.T}, value, minValue))) break;\nminValue = value;\n}\n};\n}\n};\nreturn minValue"],
  ["Swift.(file).max(_:T,_:T)", "return ($info.T.infix_62_61({Self: $info.T}, y, x) ? y : x)"],
  ["Swift.(file).max(_:T,_:T,_:T,_:[T])", "let maxValue = ($info.T.infix_62_61({Self: $info.T}, y, x) ? y : x);\n{\nif(($info.T.infix_62_61({Self: $info.T}, z, maxValue))) {\nmaxValue = z;\n}\n};\n{\nif((Optional.infix_33_61({Wrapped: _clarifyGenerics({Self:Array, Element: $info.T})}, rest, null))) {\n{\nlet $value$generator = _cloneStruct(rest.makeIterator({Self: _clarifyGenerics({Self:Array, Element: $info.T})}, ));\nwhile(true) {\nconst value = $value$generator.next({$setThis: $val => $value$generator = $val, Elements: _clarifyGenerics({Self:Array, Element: $info.T})}, );\nif(!((value != null))) break;\nif(!($info.T.infix_62_61({Self: $info.T}, value, maxValue))) break;\nmaxValue = value;\n}\n};\n}\n};\nreturn maxValue"],
  ["Swift.(file).AnyHashable.description", "return _create(String, 'initDescribing', {Subject: '?protocol_composition_type'}, this.base)"],
  ["Swift.(file).AnyHashable.debugDescription", "return String.infix_43({}, String.infix_43({}, \"AnyHashable(\", _create(String, 'initReflecting', {Subject: '?protocol_composition_type'}, this.base)), \")\")"],
  ["Swift.(file).AnyHashable.customMirror", "return _create(Mirror, 'initChildrenKeyValuePairsDisplayStyleOptionalAncestorRepresentationMirrorAncestorRepresentation', {Subject: AnyHashable}, this, new Map([[\"value\", this.base]]), null, null)"],
  ["Swift.(file).Array.startIndex", "return 0"],
  ["Swift.(file).Array.index(after:Int)", "return Int.infix_43({}, i, 1)"],
  ["Swift.(file).Array.formIndex(after:Int)", "let i = i$inout.get()\nconst $result = (() => {\nInt.infix_43_61({}, {get: () => i, set: $val => i = $val}, 1);})()\ni$inout.set(i)\nreturn $result"],
  ["Swift.(file).Array.index(before:Int)", "return Int.infix_45({}, i, 1)"],
  ["Swift.(file).Array.formIndex(before:Int)", "let i = i$inout.get()\nconst $result = (() => {\nInt.infix_45_61({}, {get: () => i, set: $val => i = $val}, 1);})()\ni$inout.set(i)\nreturn $result"],
  ["Swift.(file).Array.index(_:Int,offsetBy:Int)", "return Int.infix_43({}, i, distance)"],
  ["Swift.(file).Array.index(_:Int,offsetBy:Int,limitedBy:Int)", "const l = Int.infix_45({}, limit, i);\n{\nif(((Int.infix_62({}, distance, 0) ? Bool.infix_38_38({}, Int.infix_62_61({}, l, 0), () => Int.infix_60({}, l, distance)) : Bool.infix_38_38({}, Int.infix_60_61({}, l, 0), () => Int.infix_60({}, distance, l))))) {\nreturn null;\n}\n};\nreturn Int.infix_43({}, i, distance)"],
  ["Swift.(file).Array.distance(from:Int,to:Int)", "return Int.infix_45({}, end, start)"],
  ["Swift.(file).Array.withContiguousMutableStorageIfAvailable(_:(inout UnsafeMutableBufferPointer<Element>) throws -> R)", "return this.withUnsafeMutableBufferPointer({$setThis: $val => $info0x7fd7b90da940.$setThis(_cloneStruct($val)), Element: $info.Element, R: $info.R}, (($info, bufferPointer$inout) => body({}, {get: () => bufferPointer, set: $val => bufferPointer = $val})))"],
  ["Swift.(file).Array.withContiguousStorageIfAvailable(_:(UnsafeBufferPointer<Element>) throws -> R)", "return this.withUnsafeBufferPointer({Element: $info.Element, R: $info.R}, (($info, bufferPointer) => body({}, bufferPointer)))"],
  ["Swift.(file).Array.+infix(_:Array<Element>,_:Array<Element>)", "let lhs_dupl = _cloneStruct(lhs);\nlhs_dupl.appendContentsOf({$setThis: $val => lhs_dupl = $val, Element: $info.Element, S: _clarifyGenerics({Self:Array, Element: $info.Element})}, rhs);\nreturn lhs_dupl"],
  ["Swift.(file).Array.+=infix(_:Array<Element>,_:Array<Element>)", "let lhs = lhs$inout.get()\nconst $result = (() => {\nlhs.appendContentsOf({$setThis: $val => lhs = $val, Element: $info.Element, S: _clarifyGenerics({Self:Array, Element: $info.Element})}, rhs);})()\nlhs$inout.set(lhs)\nreturn $result"],
  ["Swift.(file).Array.customMirror", "return _create(Mirror, 'initUnlabeledChildrenDisplayStyleOptionalAncestorRepresentationMirrorAncestorRepresentation', {Subject: _clarifyGenerics({Self:Array, Element: this.$info.Element}), C: _clarifyGenerics({Self:Array, Element: this.$info.Element})}, this, this, Mirror.DisplayStyle.collection, null)"],
  ["Swift.(file).Array.withUnsafeMutableBytes(_:(UnsafeMutableRawBufferPointer) throws -> R)", "return this.withUnsafeMutableBufferPointer({$setThis: $val => $info0x7fe0220dfec8.$setThis(_cloneStruct($val)), Element: $info.Element, R: $info.R}, (($info, $0$inout) => body({}, _create(UnsafeMutableRawBufferPointer, 'initUnsafeMutableBufferPointer', {T: $info.Element}, $0))))"],
  ["Swift.(file).Array.withUnsafeBytes(_:(UnsafeRawBufferPointer) throws -> R)", "return this.withUnsafeBufferPointer({Element: $info.Element, R: $info.R}, (($info, $0) => body({}, _create(UnsafeRawBufferPointer, 'initUnsafeBufferPointer', {T: $info.Element}, $0))))"],
  ["Swift.(file).ArraySlice.index(after:Int)", "return Int.infix_43({}, i, 1)"],
  ["Swift.(file).ArraySlice.formIndex(after:Int)", "let i = i$inout.get()\nconst $result = (() => {\nInt.infix_43_61({}, {get: () => i, set: $val => i = $val}, 1);})()\ni$inout.set(i)\nreturn $result"],
  ["Swift.(file).ArraySlice.index(before:Int)", "return Int.infix_45({}, i, 1)"],
  ["Swift.(file).ArraySlice.formIndex(before:Int)", "let i = i$inout.get()\nconst $result = (() => {\nInt.infix_45_61({}, {get: () => i, set: $val => i = $val}, 1);})()\ni$inout.set(i)\nreturn $result"],
  ["Swift.(file).ArraySlice.index(_:Int,offsetBy:Int)", "return Int.infix_43({}, i, distance)"],
  ["Swift.(file).ArraySlice.index(_:Int,offsetBy:Int,limitedBy:Int)", "const l = Int.infix_45({}, limit, i);\n{\nif(((Int.infix_62({}, distance, 0) ? Bool.infix_38_38({}, Int.infix_62_61({}, l, 0), () => Int.infix_60({}, l, distance)) : Bool.infix_38_38({}, Int.infix_60_61({}, l, 0), () => Int.infix_60({}, distance, l))))) {\nreturn null;\n}\n};\nreturn Int.infix_43({}, i, distance)"],
  ["Swift.(file).ArraySlice.distance(from:Int,to:Int)", "return Int.infix_45({}, end, start)"],
  ["Swift.(file).ArraySlice.remove(at:Int)", "const result = this.subscript$get({}, index);\nthis.replaceSubrangeWith({$setThis: $val => $info0x7fbe4e102f38.$setThis(_cloneStruct($val)), Element: this.$info.Element, C: _clarifyGenerics({Self:EmptyCollection, Element: this.$info.Element})}, Int.infix_46_46_60({Self: Int}, index, Int.infix_43({}, index, 1)), _create(EmptyCollection, 'init', {Element: this.$info.Element}, ));\nreturn result"],
  ["Swift.(file).ArraySlice.withContiguousMutableStorageIfAvailable(_:(inout UnsafeMutableBufferPointer<Element>) throws -> R)", "return this.withUnsafeMutableBufferPointer({$setThis: $val => $info0x7fbb900dfb48.$setThis(_cloneStruct($val)), Element: $info.Element, R: $info.R}, (($info, bufferPointer$inout) => body({}, {get: () => bufferPointer, set: $val => bufferPointer = $val})))"],
  ["Swift.(file).ArraySlice.withContiguousStorageIfAvailable(_:(UnsafeBufferPointer<Element>) throws -> R)", "return this.withUnsafeBufferPointer({Element: $info.Element, R: $info.R}, (($info, bufferPointer) => body({}, bufferPointer)))"],
  ["Swift.(file).ArraySlice.customMirror", "return _create(Mirror, 'initUnlabeledChildrenDisplayStyleOptionalAncestorRepresentationMirrorAncestorRepresentation', {Subject: _clarifyGenerics({Self:ArraySlice, Element: this.$info.Element}), C: _clarifyGenerics({Self:ArraySlice, Element: this.$info.Element})}, this, this, Mirror.DisplayStyle.collection, null)"],
  ["Swift.(file).ArraySlice.withUnsafeMutableBytes(_:(UnsafeMutableRawBufferPointer) throws -> R)", "return this.withUnsafeMutableBufferPointer({$setThis: $val => $info0x7f830a8dfed0.$setThis(_cloneStruct($val)), Element: $info.Element, R: $info.R}, (($info, $0$inout) => body({}, _create(UnsafeMutableRawBufferPointer, 'initUnsafeMutableBufferPointer', {T: $info.Element}, $0))))"],
  ["Swift.(file).ArraySlice.withUnsafeBytes(_:(UnsafeRawBufferPointer) throws -> R)", "return this.withUnsafeBufferPointer({Element: $info.Element, R: $info.R}, (($info, $0) => body({}, _create(UnsafeRawBufferPointer, 'initUnsafeBufferPointer', {T: $info.Element}, $0))))"],
  ["Swift.(file).BidirectionalCollection.formIndex(before:Self.Index)", "let i = i$inout.get()\nconst $result = (() => {\ni = this.indexBefore({Self: this.$info.Self}, i);})()\ni$inout.set(i)\nreturn $result"],
  ["Swift.(file).BidirectionalCollection.dropLast(_:Int)", "preconditionFileLine({}, () => Int.infix_62_61({}, k, 0), () => \"Can't drop a negative number of elements from a collection\", '?3', '?3');\nconst end = infix_63_63({T: this.$info.Self.Index}, this.indexOffsetByLimitedBy({Self: this.$info.Self}, this.endIndex, Int.prefix_45({Self: Int}, k), this.startIndex), () => this.startIndex);\nreturn this.subscriptRange$get({}, this.$info.Self.Index.infix_46_46_60({Self: this.$info.Self.Index}, this.startIndex, end))"],
  ["Swift.(file).BidirectionalCollection.suffix(_:Int)", "preconditionFileLine({}, () => Int.infix_62_61({}, maxLength, 0), () => \"Can't take a suffix of negative length from a collection\", '?3', '?3');\nconst start = infix_63_63({T: this.$info.Self.Index}, this.indexOffsetByLimitedBy({Self: this.$info.Self}, this.endIndex, Int.prefix_45({Self: Int}, maxLength), this.startIndex), () => this.startIndex);\nreturn this.subscriptRange$get({}, this.$info.Self.Index.infix_46_46_60({Self: this.$info.Self.Index}, start, this.endIndex))"],
  ["Swift.(file).Bool.random(using:T)", "let generator = generator$inout.get()\nconst $result = (() => {\nreturn UInt64.infix_61_61({}, UInt64.infix_38({}, UInt64.infix_62_62({Self: UInt64, Other: Int}, generator.next({$setThis: $val => generator = $val, Self: $info.T}, ), 17), 1), 0);})()\ngenerator$inout.set(generator)\nreturn $result"],
  ["Swift.(file).Bool.random()", "let g = _create(SystemRandomNumberGenerator, 'init', {}, );\nreturn Bool.randomUsing({T: SystemRandomNumberGenerator}, {get: () => g, set: $val => g = $val})"],
  ["Swift.(file).Bool.description", "return (this ? \"true\" : \"false\")"],
  ["Swift.(file).Bool.hash(into:Hasher)", "let hasher = hasher$inout.get()\nconst $result = (() => {\nhasher.combine({$setThis: $val => hasher = $val, H: UInt8}, (this ? 1 : 0));})()\nhasher$inout.set(hasher)\nreturn $result"],
  ["Swift.(file).Bool.&&infix(_:Bool,_:() throws -> Bool)", "return (lhs ? rhs({}, ) : false)"],
  ["Swift.(file).Bool.||infix(_:Bool,_:() throws -> Bool)", "return (lhs ? true : rhs({}, ))"],
  ["Swift.(file).Bool.toggle()", "$info0x7fdf050e69f0.$setThis(_cloneStruct(Bool.prefix_33({}, this)))"],
  ["Swift.(file).!=infix(_:Any.Type?,_:Any.Type?)", "return Bool.prefix_33({}, infix_61_61({}, t0, t1))"],
  ["Swift.(file).Character.isASCII", "return Optional.infix_33_61({Wrapped: UInt8}, this.asciiValue, null)"],
  ["Swift.(file).Character.isWholeNumber", "return Optional.infix_33_61({Wrapped: Int}, this.wholeNumberValue, null)"],
  ["Swift.(file).Character.isHexDigit", "return Optional.infix_33_61({Wrapped: Int}, this.hexDigitValue, null)"],
  ["Swift.(file).Character.uppercased()", "return _create(String, 'initCharacter', {}, this).uppercased({}, )"],
  ["Swift.(file).Character.lowercased()", "return _create(String, 'initCharacter', {}, this).lowercased({}, )"],
  ["Swift.(file).ClosedRange.isEmpty", "return false"],
  ["Swift.(file).ClosedRange.relative(to:C)", "return _create(Range, 'initUncheckedBoundstuple_type', {Bound: $info.Bound}, {0: this.lowerBound, 1: collection.indexAfter({Self: $info.C}, this.upperBound)})"],
  ["Swift.(file).ClosedRange.contains(_:Bound)", "return Bool.infix_38_38({}, this.$info.Bound.infix_62_61({Self: this.$info.Bound}, _element, this.lowerBound), () => this.$info.Bound.infix_60_61({Self: this.$info.Bound}, _element, this.upperBound))"],
  ["Swift.(file).Comparable....infix(_:Self,_:Self)", "preconditionFileLine({}, () => $info.Self.infix_60_61({Self: $info.Self}, minimum, maximum), () => \"Can't form Range with upperBound < lowerBound\", '?3', '?3');\nreturn _create(ClosedRange, 'initUncheckedBoundstuple_type', {Bound: $info.Self}, {0: minimum, 1: maximum})"],
  ["Swift.(file).ClosedRange.==infix(_:ClosedRange<Bound>,_:ClosedRange<Bound>)", "return Bool.infix_38_38({}, $info.Bound.infix_61_61({Self: $info.Bound}, lhs.lowerBound, rhs.lowerBound), () => $info.Bound.infix_61_61({Self: $info.Bound}, lhs.upperBound, rhs.upperBound))"],
  ["Swift.(file).ClosedRange.description", "return ((\"\") + (this.lowerBound) + (\"...\") + (this.upperBound) + (\"\"))"],
  ["Swift.(file).ClosedRange.debugDescription", "return String.infix_43({}, ((\"ClosedRange(\") + (_create(String, 'initReflecting', {Subject: this.$info.Bound}, this.lowerBound)) + (\"\")), ((\"...\") + (_create(String, 'initReflecting', {Subject: this.$info.Bound}, this.upperBound)) + (\")\")))"],
  ["Swift.(file).ClosedRange.customMirror", "return _create(Mirror, 'initChildrenKeyValuePairsDisplayStyleOptionalAncestorRepresentationMirrorAncestorRepresentation', {Subject: _clarifyGenerics({Self:ClosedRange, Bound: this.$info.Bound})}, this, new Map([[\"lowerBound\", this.lowerBound], [\"upperBound\", this.upperBound]]), null, null)"],
  ["Swift.(file).ClosedRange.clamped(to:ClosedRange<Bound>)", "const lower = (this.$info.Bound.infix_62({Self: this.$info.Bound}, limits.lowerBound, this.lowerBound) ? limits.lowerBound : (this.$info.Bound.infix_60({Self: this.$info.Bound}, limits.upperBound, this.lowerBound) ? limits.upperBound : this.lowerBound));\nconst upper = (this.$info.Bound.infix_60({Self: this.$info.Bound}, limits.upperBound, this.upperBound) ? limits.upperBound : (this.$info.Bound.infix_62({Self: this.$info.Bound}, limits.lowerBound, this.upperBound) ? limits.lowerBound : this.upperBound));\nreturn _create(ClosedRange, 'initUncheckedBoundstuple_type', {Bound: this.$info.Bound}, {0: lower, 1: upper})"],
  ["Swift.(file).ClosedRange.overlaps(_:ClosedRange<Bound>)", "return Bool.infix_124_124({}, this.contains({Bound: this.$info.Bound}, other.lowerBound), () => other.contains({Bound: this.$info.Bound}, this.lowerBound))"],
  ["Swift.(file).ClosedRange.overlaps(_:Range<Bound>)", "return other.overlaps({Bound: this.$info.Bound}, this)"],
  ["Swift.(file).Collection.formIndex(after:Self.Index)", "let i = i$inout.get()\nconst $result = (() => {\ni = this.indexAfter({Self: this.$info.Self}, i);})()\ni$inout.set(i)\nreturn $result"],
  ["Swift.(file).Collection.formIndex(_:Self.Index,offsetBy:Int)", "let i = i$inout.get()\nconst $result = (() => {\ni = this.indexOffsetBy({Self: this.$info.Self}, i, distance);})()\ni$inout.set(i)\nreturn $result"],
  ["Swift.(file).Collection.formIndex(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)", "let i = i$inout.get()\nconst $result = (() => {\n{const advancedIndex = this.indexOffsetByLimitedBy({Self: this.$info.Self}, i, distance, limit)\nif((advancedIndex != null)) {\ni = advancedIndex;\nreturn true;\n}\n};\ni = limit;\nreturn false;})()\ni$inout.set(i)\nreturn $result"],
  ["Swift.(file).Collection.distance(from:Self.Index,to:Self.Index)", "preconditionFileLine({}, () => this.$info.Self.Index.infix_60_61({Self: this.$info.Self.Index}, start, end), () => \"Only BidirectionalCollections can have end come before start\", '?3', '?3');\nlet start_dupl = start;\nlet count = 0;\nwhile(true){\nif(!((this.$info.Self.Index.infix_33_61({Self: this.$info.Self.Index}, start_dupl, end)))) break\ncount = Int.infix_43({}, count, 1);\nthis.formIndexAfter({Self: this.$info.Self}, {get: () => start_dupl, set: $val => start_dupl = $val});\n};\nreturn count"],
  ["Swift.(file).Collection.randomElement(using:T)", "let generator = generator$inout.get()\nconst $result = (() => {\n{\nif(!((Bool.prefix_33({}, this.isEmpty)))) {\nreturn null;\n}\n};\nconst random = Int.randomInUsing({Self: Int, T: $info.T}, Int.infix_46_46_60({Self: Int}, 0, this.count), {get: () => generator, set: $val => generator = $val});\nconst idx = this.indexOffsetBy({Self: $info.Self}, this.startIndex, random);\nreturn this.subscript$get({}, idx);})()\ngenerator$inout.set(generator)\nreturn $result"],
  ["Swift.(file).Collection.randomElement()", "let g = _create(SystemRandomNumberGenerator, 'init', {}, );\nreturn this.randomElementUsing({Self: this.$info.Self, T: SystemRandomNumberGenerator}, {get: () => g, set: $val => g = $val})"],
  ["Swift.(file).Collection.makeIterator()", "return _create(IndexingIterator, 'init_elements', {Elements: this.$info.Self}, this)"],
  ["Swift.(file).Collection.isEmpty", " return this.isEmpty$internal "],
  ["Swift.(file).Collection.first", " return this.first$internal "],
  ["Swift.(file).Collection.underestimatedCount", " return this.underestimatedCount$internal "],
  ["Swift.(file).Collection.count", " return this.count$internal "],
  ["Swift.(file).Collection.dropFirst(_:Int)", "preconditionFileLine({}, () => Int.infix_62_61({}, k, 0), () => \"Can't drop a negative number of elements from a collection\", '?3', '?3');\nconst start = infix_63_63({T: this.$info.Self.Index}, this.indexOffsetByLimitedBy({Self: this.$info.Self}, this.startIndex, k, this.endIndex), () => this.endIndex);\nreturn this.subscriptRange$get({}, this.$info.Self.Index.infix_46_46_60({Self: this.$info.Self.Index}, start, this.endIndex))"],
  ["Swift.(file).Collection.dropLast(_:Int)", "preconditionFileLine({}, () => Int.infix_62_61({}, k, 0), () => \"Can't drop a negative number of elements from a collection\", '?3', '?3');\nconst amount = /*dot_syntax_base_ignored*/max({}, 0, Int.infix_45({}, this.count, k));\nconst end = infix_63_63({T: this.$info.Self.Index}, this.indexOffsetByLimitedBy({Self: this.$info.Self}, this.startIndex, amount, this.endIndex), () => this.endIndex);\nreturn this.subscriptRange$get({}, this.$info.Self.Index.infix_46_46_60({Self: this.$info.Self.Index}, this.startIndex, end))"],
  ["Swift.(file).Collection.drop(while:(Self.Element) throws -> Bool)", "let start = this.startIndex;\nwhile(true){\nif(!((Bool.infix_38_38({}, this.$info.Self.Index.infix_33_61({Self: this.$info.Self.Index}, start, this.endIndex), () => predicate({}, this.subscript$get({}, start)))))) break\nthis.formIndexAfter({Self: this.$info.Self}, {get: () => start, set: $val => start = $val});\n};\nreturn this.subscriptRange$get({}, this.$info.Self.Index.infix_46_46_60({Self: this.$info.Self.Index}, start, this.endIndex))"],
  ["Swift.(file).Collection.prefix(_:Int)", "preconditionFileLine({}, () => Int.infix_62_61({}, maxLength, 0), () => \"Can't take a prefix of negative length from a collection\", '?3', '?3');\nconst end = infix_63_63({T: this.$info.Self.Index}, this.indexOffsetByLimitedBy({Self: this.$info.Self}, this.startIndex, maxLength, this.endIndex), () => this.endIndex);\nreturn this.subscriptRange$get({}, this.$info.Self.Index.infix_46_46_60({Self: this.$info.Self.Index}, this.startIndex, end))"],
  ["Swift.(file).Collection.prefix(while:(Self.Element) throws -> Bool)", "let end = this.startIndex;\nwhile(true){\nif(!((Bool.infix_38_38({}, this.$info.Self.Index.infix_33_61({Self: this.$info.Self.Index}, end, this.endIndex), () => predicate({}, this.subscript$get({}, end)))))) break\nthis.formIndexAfter({Self: this.$info.Self}, {get: () => end, set: $val => end = $val});\n};\nreturn this.subscriptRange$get({}, this.$info.Self.Index.infix_46_46_60({Self: this.$info.Self.Index}, this.startIndex, end))"],
  ["Swift.(file).Collection.suffix(_:Int)", "preconditionFileLine({}, () => Int.infix_62_61({}, maxLength, 0), () => \"Can't take a suffix of negative length from a collection\", '?3', '?3');\nconst amount = /*dot_syntax_base_ignored*/max({}, 0, Int.infix_45({}, this.count, maxLength));\nconst start = infix_63_63({T: this.$info.Self.Index}, this.indexOffsetByLimitedBy({Self: this.$info.Self}, this.startIndex, amount, this.endIndex), () => this.endIndex);\nreturn this.subscriptRange$get({}, this.$info.Self.Index.infix_46_46_60({Self: this.$info.Self.Index}, start, this.endIndex))"],
  ["Swift.(file).Collection.prefix(upTo:Self.Index)", "return this.subscriptRange$get({}, this.$info.Self.Index.infix_46_46_60({Self: this.$info.Self.Index}, this.startIndex, end))"],
  ["Swift.(file).Collection.suffix(from:Self.Index)", "return this.subscriptRange$get({}, this.$info.Self.Index.infix_46_46_60({Self: this.$info.Self.Index}, start, this.endIndex))"],
  ["Swift.(file).Collection.prefix(through:Self.Index)", "return this.prefixUpTo({Self: this.$info.Self}, this.indexAfter({Self: this.$info.Self}, position))"],
  ["Swift.(file).Collection.split(maxSplits:Int,omittingEmptySubsequences:Bool,whereSeparator:(Self.Element) throws -> Bool)", "preconditionFileLine({}, () => Int.infix_62_61({}, maxSplits, 0), () => \"Must take zero or more splits\", '?3', '?3');\nlet result = _create(Array, 'initBuffer', {Element: this.$info.Self.SubSequence}, []);\nlet subSequenceStart = this.startIndex;\nfunction appendSubsequenceEnd($info, end){\n{\nif((Bool.infix_38_38({}, this.$info.Self.Index.infix_61_61({Self: this.$info.Self.Index}, subSequenceStart, end), () => omittingEmptySubsequences))) {\nreturn false;\n}\n};\nresult.append({$setThis: $val => result = $val, Element: this.$info.Self.SubSequence}, this.subscriptRange$get({}, this.$info.Self.Index.infix_46_46_60({Self: this.$info.Self.Index}, subSequenceStart, end)));\nreturn true;\n}\n{\nif((Bool.infix_124_124({}, Int.infix_61_61({}, maxSplits, 0), () => this.isEmpty))) {\n_.discardAssignment = appendSubsequenceEnd({Self: this.$info.Self}, this.endIndex);\nreturn result;\n}\n};\nlet subSequenceEnd = subSequenceStart;\nconst cachedEndIndex = this.endIndex;\nwhile(true){\nif(!((this.$info.Self.Index.infix_33_61({Self: this.$info.Self.Index}, subSequenceEnd, cachedEndIndex)))) break\n{\nif((isSeparator({}, this.subscript$get({}, subSequenceEnd)))) {\nconst didAppend = appendSubsequenceEnd({Self: this.$info.Self}, subSequenceEnd);\nthis.formIndexAfter({Self: this.$info.Self}, {get: () => subSequenceEnd, set: $val => subSequenceEnd = $val});\nsubSequenceStart = subSequenceEnd;\n{\nif((Bool.infix_38_38({}, didAppend, () => Int.infix_61_61({}, result.count, maxSplits)))) {\nbreak;\n}\n};\ncontinue;\n}\n};\nthis.formIndexAfter({Self: this.$info.Self}, {get: () => subSequenceEnd, set: $val => subSequenceEnd = $val});\n};\n{\nif((Bool.infix_124_124({}, this.$info.Self.Index.infix_33_61({Self: this.$info.Self.Index}, subSequenceStart, cachedEndIndex), () => Bool.prefix_33({}, omittingEmptySubsequences)))) {\nresult.append({$setThis: $val => result = $val, Element: this.$info.Self.SubSequence}, this.subscriptRange$get({}, this.$info.Self.Index.infix_46_46_60({Self: this.$info.Self.Index}, subSequenceStart, cachedEndIndex)));\n}\n};\nreturn result"],
  ["Swift.(file).BidirectionalCollection.last", " return this.last$internal "],
  ["Swift.(file).Collection.firstIndex(where:(Self.Element) throws -> Bool)", "let i = this.startIndex;\nwhile(true){\nif(!((this.$info.Self.Index.infix_33_61({Self: this.$info.Self.Index}, i, this.endIndex)))) break\n{\nif((predicate({}, this.subscript$get({}, i)))) {\nreturn i;\n}\n};\nthis.formIndexAfter({Self: this.$info.Self}, {get: () => i, set: $val => i = $val});\n};\nreturn null"],
  ["Swift.(file).BidirectionalCollection.last(where:(Self.Element) throws -> Bool)", "return this.lastIndexWhere({Self: this.$info.Self}, predicate).mapSwift({Wrapped: this.$info.Self.Index, U: this.$info.Self.Element}, (($info, $0) => this.subscript$get({}, $0)))"],
  ["Swift.(file).BidirectionalCollection.lastIndex(where:(Self.Element) throws -> Bool)", "let i = this.endIndex;\nwhile(true){\nif(!((this.$info.Self.Index.infix_33_61({Self: this.$info.Self.Index}, i, this.startIndex)))) break\nthis.formIndexBefore({Self: this.$info.Self}, {get: () => i, set: $val => i = $val});\n{\nif((predicate({}, this.subscript$get({}, i)))) {\nreturn i;\n}\n};\n};\nreturn null"],
  ["Swift.(file).Sequence.shuffled(using:T)", "let generator = generator$inout.get()\nconst $result = (() => {\nlet result = _create(ContiguousArray, 'initBuffer', {Element: $info.Self.Element, S: $info.Self}, this);\nresult.shuffleUsing({$setThis: $val => result = $val, Self: _clarifyGenerics({Self:ContiguousArray, Element: $info.Self.Element}), T: $info.T}, {get: () => generator, set: $val => generator = $val});\nreturn _create(Array, 'initBuffer', {Element: $info.Self.Element, S: _clarifyGenerics({Self:ContiguousArray, Element: $info.Self.Element})}, result);})()\ngenerator$inout.set(generator)\nreturn $result"],
  ["Swift.(file).Sequence.shuffled()", "let g = _create(SystemRandomNumberGenerator, 'init', {}, );\nreturn this.shuffledUsing({Self: this.$info.Self, T: SystemRandomNumberGenerator}, {get: () => g, set: $val => g = $val})"],
  ["Swift.(file).MutableCollection.shuffle(using:T)", "let generator = generator$inout.get()\nconst $result = (() => {\n{\nif(!((Int.infix_62({}, this.count, 1)))) {\nreturn ;\n}\n};\nlet amount = this.count;\nlet currentIndex = this.startIndex;\nwhile(true){\nif(!((Int.infix_62({}, amount, 1)))) break\nconst random = Int.randomInUsing({Self: Int, T: $info.T}, Int.infix_46_46_60({Self: Int}, 0, amount), {get: () => generator, set: $val => generator = $val});\nInt.infix_45_61({}, {get: () => amount, set: $val => amount = $val}, 1);\nthis.swapAt({$setThis: $val => $info0x7f92a30e0e70.$setThis(_cloneStruct($val)), Self: $info.Self}, currentIndex, this.indexOffsetBy({Self: $info.Self}, currentIndex, random));\nthis.formIndexAfter({Self: $info.Self}, {get: () => currentIndex, set: $val => currentIndex = $val});\n};})()\ngenerator$inout.set(generator)\nreturn $result"],
  ["Swift.(file).Comparable.>infix(_:Self,_:Self)", "return $info.Self.infix_60({Self: $info.Self}, rhs, lhs)"],
  ["Swift.(file).Comparable.<=infix(_:Self,_:Self)", "return Bool.prefix_33({}, $info.Self.infix_60({Self: $info.Self}, rhs, lhs))"],
  ["Swift.(file).Comparable.>=infix(_:Self,_:Self)", "return Bool.prefix_33({}, $info.Self.infix_60({Self: $info.Self}, lhs, rhs))"],
  ["Swift.(file).==infix(_:T,_:T)", "return $info.T.RawValue.infix_61_61({Self: $info.T.RawValue}, lhs.rawValue, rhs.rawValue)"],
  ["Swift.(file).!=infix(_:T,_:T)", "return $info.T.RawValue.infix_33_61({Self: $info.T.RawValue}, lhs.rawValue, rhs.rawValue)"],
  ["Swift.(file).!=infix(_:T,_:T)", "return $info.T.RawValue.infix_33_61({Self: $info.T.RawValue}, lhs.rawValue, rhs.rawValue)"],
  ["Swift.(file).ContiguousArray.startIndex", "return 0"],
  ["Swift.(file).ContiguousArray.index(after:Int)", "return Int.infix_43({}, i, 1)"],
  ["Swift.(file).ContiguousArray.formIndex(after:Int)", "let i = i$inout.get()\nconst $result = (() => {\nInt.infix_43_61({}, {get: () => i, set: $val => i = $val}, 1);})()\ni$inout.set(i)\nreturn $result"],
  ["Swift.(file).ContiguousArray.index(before:Int)", "return Int.infix_45({}, i, 1)"],
  ["Swift.(file).ContiguousArray.formIndex(before:Int)", "let i = i$inout.get()\nconst $result = (() => {\nInt.infix_45_61({}, {get: () => i, set: $val => i = $val}, 1);})()\ni$inout.set(i)\nreturn $result"],
  ["Swift.(file).ContiguousArray.index(_:Int,offsetBy:Int)", "return Int.infix_43({}, i, distance)"],
  ["Swift.(file).ContiguousArray.index(_:Int,offsetBy:Int,limitedBy:Int)", "const l = Int.infix_45({}, limit, i);\n{\nif(((Int.infix_62({}, distance, 0) ? Bool.infix_38_38({}, Int.infix_62_61({}, l, 0), () => Int.infix_60({}, l, distance)) : Bool.infix_38_38({}, Int.infix_60_61({}, l, 0), () => Int.infix_60({}, distance, l))))) {\nreturn null;\n}\n};\nreturn Int.infix_43({}, i, distance)"],
  ["Swift.(file).ContiguousArray.distance(from:Int,to:Int)", "return Int.infix_45({}, end, start)"],
  ["Swift.(file).ContiguousArray.withContiguousMutableStorageIfAvailable(_:(inout UnsafeMutableBufferPointer<Element>) throws -> R)", "return this.withUnsafeMutableBufferPointer({$setThis: $val => $info0x7fc031827748.$setThis(_cloneStruct($val)), Element: $info.Element, R: $info.R}, (($info, bufferPointer$inout) => body({}, {get: () => bufferPointer, set: $val => bufferPointer = $val})))"],
  ["Swift.(file).ContiguousArray.withContiguousStorageIfAvailable(_:(UnsafeBufferPointer<Element>) throws -> R)", "return this.withUnsafeBufferPointer({Element: $info.Element, R: $info.R}, (($info, bufferPointer) => body({}, bufferPointer)))"],
  ["Swift.(file).ContiguousArray.customMirror", "return _create(Mirror, 'initUnlabeledChildrenDisplayStyleOptionalAncestorRepresentationMirrorAncestorRepresentation', {Subject: _clarifyGenerics({Self:ContiguousArray, Element: this.$info.Element}), C: _clarifyGenerics({Self:ContiguousArray, Element: this.$info.Element})}, this, this, Mirror.DisplayStyle.collection, null)"],
  ["Swift.(file).ContiguousArray.withUnsafeMutableBytes(_:(UnsafeMutableRawBufferPointer) throws -> R)", "return this.withUnsafeMutableBufferPointer({$setThis: $val => $info0x7fc0920346d0.$setThis(_cloneStruct($val)), Element: $info.Element, R: $info.R}, (($info, $0$inout) => body({}, _create(UnsafeMutableRawBufferPointer, 'initUnsafeMutableBufferPointer', {T: $info.Element}, $0))))"],
  ["Swift.(file).ContiguousArray.withUnsafeBytes(_:(UnsafeRawBufferPointer) throws -> R)", "return this.withUnsafeBufferPointer({Element: $info.Element, R: $info.R}, (($info, $0) => body({}, _create(UnsafeRawBufferPointer, 'initUnsafeBufferPointer', {T: $info.Element}, $0))))"],
  ["Swift.(file).Dictionary.isEmpty", "return Int.infix_61_61({}, this.count, 0)"],
  ["Swift.(file).Dictionary.merging(_:[Key : Value],uniquingKeysWith:(Value, Value) throws -> Value)", "let result = _cloneStruct(this);\nresult.mergeUniquingKeysWith({$setThis: $val => result = $val, Key: this.$info.Key, Value: this.$info.Value}, other, combine);\nreturn result"],
  ["Swift.(file).Dictionary.customMirror", "const style = Mirror.DisplayStyle.dictionary;\nreturn _create(Mirror, 'initUnlabeledChildrenDisplayStyleOptionalAncestorRepresentationMirrorAncestorRepresentation', {Subject: _clarifyGenerics({Self:Dictionary, Key: this.$info.Key, Value: this.$info.Value}), C: _clarifyGenerics({Self:Dictionary, Key: this.$info.Key, Value: this.$info.Value})}, this, this, style, null)"],
  ["Swift.(file).Dictionary.popFirst()", "{\nif(!((Bool.prefix_33({}, this.isEmpty)))) {\nreturn null;\n}\n};\nreturn this.removeAt({$setThis: $val => $info0x7f7f500df038.$setThis(_cloneStruct($val)), Key: this.$info.Key, Value: this.$info.Value}, this.startIndex)"],
  ["Swift.(file).EmptyCollection.makeIterator()", "return _create(EmptyCollection.Iterator, 'init', {Element: this.$info.Element}, )"],
  ["Swift.(file).EmptyCollection.startIndex", "return 0"],
  ["Swift.(file).EmptyCollection.endIndex", "return 0"],
  ["Swift.(file).EmptyCollection.count", "return 0"],
  ["Swift.(file).EmptyCollection.==infix(_:EmptyCollection<Element>,_:EmptyCollection<Element>)", "return true"],
  ["Swift.(file).Equatable.!=infix(_:Self,_:Self)", "return Bool.prefix_33({}, $info.Self.infix_61_61({Self: $info.Self}, lhs, rhs))"],
  ["Swift.(file).===infix(_:AnyObject?,_:AnyObject?)", "const $match = {0: lhs, 1: rhs}\nif(((true))) {\nconst l = $match[0]\nconst r = $match[1]\nreturn ObjectIdentifier.infix_61_61({}, _create(ObjectIdentifier, 'initAnyObject', {}, l), _create(ObjectIdentifier, 'initAnyObject', {}, r));\n}\nelse if((($match.rawValue == Optional.none.rawValue && $match.rawValue == Optional.none.rawValue))) {\nreturn true;\n}\nelse if(((true))) {\nreturn false;\n}"],
  ["Swift.(file).!==infix(_:AnyObject?,_:AnyObject?)", "return Bool.prefix_33({}, infix_61_61_61({}, lhs, rhs))"],
  ["Swift.(file).LazyFilterSequence.underestimatedCount", "return 0"],
  ["Swift.(file).LazySequenceProtocol.filter(_:(Self.Elements.Element) -> Bool)", "return _create(LazyFilterSequence, 'init_basefunction_type', {Base: this.$info.Self.Elements}, this._elements, isIncluded)"],
  ["Swift.(file).LazySequenceProtocol.flatMap(_:(Self.Elements.Element) -> SegmentOfResult)", "return this.mapSwift({Self: $info.Self, U: $info.SegmentOfResult}, transform).joined({Self: _clarifyGenerics({Self:LazyMapSequence, Base: $info.Self.Elements, Element: $info.SegmentOfResult})}, )"],
  ["Swift.(file).LazySequenceProtocol.compactMap(_:(Self.Elements.Element) -> ElementOfResult?)", "return this.mapSwift({Self: $info.Self, U: _clarifyGenerics({Self:Optional, Wrapped: $info.ElementOfResult})}, transform).filterSwift({Self: _clarifyGenerics({Self:LazyMapSequence, Base: $info.Self.Elements, Element: _clarifyGenerics({Self:Optional, Wrapped: $info.ElementOfResult})})}, (($info, $0) => Optional.infix_33_61({Wrapped: $info.ElementOfResult}, $0, null))).mapSwift({Self: _clarifyGenerics({Self:LazyFilterSequence, Base: _clarifyGenerics({Self:LazyMapSequence, Base: $info.Self.Elements, Element: _clarifyGenerics({Self:Optional, Wrapped: $info.ElementOfResult})})}), U: $info.ElementOfResult}, (($info, $0) => $0))"],
  ["Swift.(file).FloatingPointSign.rawValue", "const $match = this\nif((($match.rawValue == FloatingPointSign.plus.rawValue))) {\nreturn 0;\n}\nelse if((($match.rawValue == FloatingPointSign.minus.rawValue))) {\nreturn 1;\n}"],
  ["Swift.(file).FloatingPointSign.==infix(_:FloatingPointSign,_:FloatingPointSign)", "return Int.infix_61_61({}, a.rawValue, b.rawValue)"],
  ["Swift.(file).FloatingPointSign.hashValue", "return this.rawValue.hashValue"],
  ["Swift.(file).FloatingPointSign.hash(into:Hasher)", "let hasher = hasher$inout.get()\nconst $result = (() => {\nhasher.combine({$setThis: $val => hasher = $val, H: Int}, this.rawValue);})()\nhasher$inout.set(hasher)\nreturn $result"],
  ["Swift.(file).FloatingPoint.==infix(_:Self,_:Self)", "return lhs.isEqualTo({Self: $info.Self}, rhs)"],
  ["Swift.(file).FloatingPoint.<infix(_:Self,_:Self)", "return lhs.isLessThan({Self: $info.Self}, rhs)"],
  ["Swift.(file).FloatingPoint.<=infix(_:Self,_:Self)", "return lhs.isLessThanOrEqualTo({Self: $info.Self}, rhs)"],
  ["Swift.(file).FloatingPoint.>infix(_:Self,_:Self)", "return rhs.isLessThan({Self: $info.Self}, lhs)"],
  ["Swift.(file).FloatingPoint.>=infix(_:Self,_:Self)", "return rhs.isLessThanOrEqualTo({Self: $info.Self}, lhs)"],
  ["Swift.(file).FloatingPoint.ulpOfOne", " return this.ulpOfOne$internal }\nstatic get ulpOfOne() { return this.ulpOfOne$get() }\nstatic ulpOfOne$set($newValue) {\nlet $oldValue = this.ulpOfOne$internal\nthis.ulpOfOne$internal = $newValue\n}\nstatic set ulpOfOne($newValue) { this.ulpOfOne$set($newValue) "],
  ["Swift.(file).FloatingPoint.rounded(_:FloatingPointRoundingRule)", "let lhs = this;\nlhs.round({$setThis: $val => lhs = $val, Self: this.$info.Self}, rule);\nreturn lhs"],
  ["Swift.(file).FloatingPoint.rounded()", "return this.rounded({Self: this.$info.Self}, FloatingPointRoundingRule.toNearestOrAwayFromZero)"],
  ["Swift.(file).FloatingPoint.round()", "this.round({$setThis: $val => $info0x7ff368810df8.$setThis(_cloneStruct($val)), Self: this.$info.Self}, FloatingPointRoundingRule.toNearestOrAwayFromZero)"],
  ["Swift.(file).FloatingPoint.nextDown", " return this.nextDown$internal "],
  ["Swift.(file).FloatingPoint.truncatingRemainder(dividingBy:Self)", "let lhs = this;\nlhs.formTruncatingRemainderDividingBy({$setThis: $val => lhs = $val, Self: this.$info.Self}, other);\nreturn lhs"],
  ["Swift.(file).FloatingPoint.remainder(dividingBy:Self)", "let lhs = this;\nlhs.formRemainderDividingBy({$setThis: $val => lhs = $val, Self: this.$info.Self}, other);\nreturn lhs"],
  ["Swift.(file).FloatingPoint.squareRoot()", "let lhs = this;\nlhs.formSquareRoot({$setThis: $val => lhs = $val, Self: this.$info.Self}, );\nreturn lhs"],
  ["Swift.(file).FloatingPoint.addingProduct(_:Self,_:Self)", "let addend = this;\naddend.addProduct({$setThis: $val => addend = $val, Self: this.$info.Self}, lhs, rhs);\nreturn addend"],
  ["Swift.(file).FloatingPoint.minimum(_:Self,_:Self)", "{\nif((Bool.infix_124_124({}, x.isSignalingNaN, () => y.isSignalingNaN))) {\nreturn $info.Self.infix_43({Self: $info.Self}, x, y);\n}\n};\n{\nif((Bool.infix_124_124({}, $info.Self.infix_60_61({Self: $info.Self}, x, y), () => y._isNaN))) {\nreturn x;\n}\n};\nreturn y"],
  ["Swift.(file).FloatingPoint.maximum(_:Self,_:Self)", "{\nif((Bool.infix_124_124({}, x.isSignalingNaN, () => y.isSignalingNaN))) {\nreturn $info.Self.infix_43({Self: $info.Self}, x, y);\n}\n};\n{\nif((Bool.infix_124_124({}, $info.Self.infix_62({Self: $info.Self}, x, y), () => y._isNaN))) {\nreturn x;\n}\n};\nreturn y"],
  ["Swift.(file).FloatingPoint.minimumMagnitude(_:Self,_:Self)", "{\nif((Bool.infix_124_124({}, x.isSignalingNaN, () => y.isSignalingNaN))) {\nreturn $info.Self.infix_43({Self: $info.Self}, x, y);\n}\n};\n{\nif((Bool.infix_124_124({}, $info.Self.infix_60_61({Self: $info.Self}, x.magnitude, y.magnitude), () => y._isNaN))) {\nreturn x;\n}\n};\nreturn y"],
  ["Swift.(file).FloatingPoint.maximumMagnitude(_:Self,_:Self)", "{\nif((Bool.infix_124_124({}, x.isSignalingNaN, () => y.isSignalingNaN))) {\nreturn $info.Self.infix_43({Self: $info.Self}, x, y);\n}\n};\n{\nif((Bool.infix_124_124({}, $info.Self.infix_62({Self: $info.Self}, x.magnitude, y.magnitude), () => y._isNaN))) {\nreturn x;\n}\n};\nreturn y"],
  ["Swift.(file).FloatingPoint.floatingPointClass", " return this.floatingPointClass$internal "],
  ["Swift.(file).BinaryFloatingPoint.radix", " return this.radix$internal }\nstatic get radix() { return this.radix$get() }\nstatic radix$set($newValue) {\nlet $oldValue = this.radix$internal\nthis.radix$internal = $newValue\n}\nstatic set radix($newValue) { this.radix$set($newValue) "],
  ["Swift.(file).BinaryFloatingPoint.isTotallyOrdered(belowOrEqualTo:Self)", "{\nif((this.$info.Self.infix_60({Self: this.$info.Self}, this, other))) {\nreturn true;\n}\n};\n{\nif((this.$info.Self.infix_62({Self: this.$info.Self}, other, this))) {\nreturn false;\n}\n};\n{\nif((FloatingPointSign.infix_33_61({Self: FloatingPointSign}, this.sign, other.sign))) {\nreturn FloatingPointSign.infix_61_61({}, this.sign, FloatingPointSign.minus);\n}\n};\n{\nif((this.$info.Self.RawExponent.infix_62({Self: this.$info.Self.RawExponent}, this.exponentBitPattern, other.exponentBitPattern))) {\nreturn FloatingPointSign.infix_61_61({}, this.sign, FloatingPointSign.minus);\n}\n};\n{\nif((this.$info.Self.RawExponent.infix_60({Self: this.$info.Self.RawExponent}, this.exponentBitPattern, other.exponentBitPattern))) {\nreturn FloatingPointSign.infix_61_61({}, this.sign, FloatingPointSign.plus);\n}\n};\n{\nif((this.$info.Self.RawSignificand.infix_62({Self: this.$info.Self.RawSignificand}, this.significandBitPattern, other.significandBitPattern))) {\nreturn FloatingPointSign.infix_61_61({}, this.sign, FloatingPointSign.minus);\n}\n};\n{\nif((this.$info.Self.RawSignificand.infix_60({Self: this.$info.Self.RawSignificand}, this.significandBitPattern, other.significandBitPattern))) {\nreturn FloatingPointSign.infix_61_61({}, this.sign, FloatingPointSign.plus);\n}\n};\nreturn true"],
  ["Swift.(file).Hasher.combine(_:H)", "value.hashInto({Self: $info.H}, {get: () => this, set: $val => $info0x7fb44d800bd0.$setThis(_cloneStruct($val))})"],
  ["Swift.(file).DefaultIndices.indices", "return this"],
  ["Swift.(file).SignedNumeric.-prefix(_:Self)", "let result = operand;\nresult.negate({$setThis: $val => result = $val, Self: $info.Self}, );\nreturn result"],
  ["Swift.(file).SignedNumeric.negate()", "$info0x7fb5090a53f8.$setThis(_cloneStruct(this.$info.Self.infix_45({Self: this.$info.Self}, _create(this.$info.Self, 'initIntegerLiteral', {Self: this.$info.Self}, 0), this)))"],
  ["Swift.(file).abs(_:T)", "{\nif((infix_61_61({}, $info.T, $info.T.Magnitude))) {\nreturn unsafeBitCastTo({T: $info.T.Magnitude, U: $info.T}, x.magnitude, $info.T);\n}\n};\nreturn ($info.T.infix_60({Self: $info.T}, x, _create($info.T, 'initIntegerLiteral', {Self: $info.T}, 0)) ? $info.T.prefix_45({Self: $info.T}, x) : x)"],
  ["Swift.(file).AdditiveArithmetic.+prefix(_:Self)", "return x"],
  ["Swift.(file).BinaryInteger.signum()", "return this.$info.Self.infix_45({Self: this.$info.Self}, (this.$info.Self.infix_62({Self: this.$info.Self}, this, _create(this.$info.Self, 'initIntegerLiteral', {Self: this.$info.Self}, 0)) ? _create(this.$info.Self, 'initIntegerLiteral', {Self: this.$info.Self}, 1) : _create(this.$info.Self, 'initIntegerLiteral', {Self: this.$info.Self}, 0)), (this.$info.Self.infix_60({Self: this.$info.Self}, this, _create(this.$info.Self, 'initIntegerLiteral', {Self: this.$info.Self}, 0)) ? _create(this.$info.Self, 'initIntegerLiteral', {Self: this.$info.Self}, 1) : _create(this.$info.Self, 'initIntegerLiteral', {Self: this.$info.Self}, 0)))"],
  ["Swift.(file).BinaryInteger.quotientAndRemainder(dividingBy:Self)", "return {0: this.$info.Self.infix_47({Self: this.$info.Self}, this, rhs), 1: this.$info.Self.infix_37({Self: this.$info.Self}, this, rhs)}"],
  ["Swift.(file).BinaryInteger.isMultiple(of:Self)", "{\nif((this.$info.Self.infix_61_61({Self: this.$info.Self, Other: Int}, other, 0))) {\nreturn this.$info.Self.infix_61_61({Self: this.$info.Self, Other: Int}, this, 0);\n}\n};\nreturn this.$info.Self.Magnitude.infix_61_61({Self: this.$info.Self.Magnitude, Other: Int}, this.$info.Self.Magnitude.infix_37({Self: this.$info.Self.Magnitude}, this.magnitude, other.magnitude), 0)"],
  ["Swift.(file).BinaryInteger.&infix(_:Self,_:Self)", "let lhs_dupl = lhs;\n$info.Self.infix_38_61({Self: $info.Self}, {get: () => lhs_dupl, set: $val => lhs_dupl = $val}, rhs);\nreturn lhs_dupl"],
  ["Swift.(file).BinaryInteger.|infix(_:Self,_:Self)", "let lhs_dupl = lhs;\n$info.Self.infix_124_61({Self: $info.Self}, {get: () => lhs_dupl, set: $val => lhs_dupl = $val}, rhs);\nreturn lhs_dupl"],
  ["Swift.(file).BinaryInteger.^infix(_:Self,_:Self)", "let lhs_dupl = lhs;\n$info.Self.infix_94_61({Self: $info.Self}, {get: () => lhs_dupl, set: $val => lhs_dupl = $val}, rhs);\nreturn lhs_dupl"],
  ["Swift.(file).BinaryInteger.>>infix(_:Self,_:RHS)", "let r = lhs;\n$info.Self.infix_62_62_61({Self: $info.Self, RHS: $info.RHS}, {get: () => r, set: $val => r = $val}, rhs);\nreturn r"],
  ["Swift.(file).BinaryInteger.<<infix(_:Self,_:RHS)", "let r = lhs;\n$info.Self.infix_60_60_61({Self: $info.Self, RHS: $info.RHS}, {get: () => r, set: $val => r = $val}, rhs);\nreturn r"],
  ["Swift.(file).BinaryInteger.advanced(by:Int)", "{\nif((Bool.prefix_33({}, this.$info.Self.isSigned))) {\nreturn (Int.infix_60({}, n, 0) ? this.$info.Self.infix_45({Self: this.$info.Self}, this, _create(this.$info.Self, 'init', {Self: this.$info.Self, T: Int}, Int.prefix_45({Self: Int}, n))) : this.$info.Self.infix_43({Self: this.$info.Self}, this, _create(this.$info.Self, 'init', {Self: this.$info.Self, T: Int}, n)));\n}\n};\n{\nif((Bool.infix_61_61({}, this.$info.Self.infix_60({Self: this.$info.Self}, this, _create(this.$info.Self, 'initIntegerLiteral', {Self: this.$info.Self}, 0)), Int.infix_60({Self: Int, Other: this.$info.Self}, n, _create(this.$info.Self, 'initIntegerLiteral', {Self: this.$info.Self}, 0))))) {\nreturn this.$info.Self.infix_43({Self: this.$info.Self}, this, _create(this.$info.Self, 'init', {Self: this.$info.Self, T: Int}, n));\n}\n};\nreturn (this.$info.Self.Magnitude.infix_60({Self: this.$info.Self.Magnitude, Other: UInt}, this.magnitude, n.magnitude) ? _create(this.$info.Self, 'init', {Self: this.$info.Self, T: Int}, Int.infix_43({}, _create(Int, 'init', {Self: Int, T: this.$info.Self}, this), n)) : this.$info.Self.infix_43({Self: this.$info.Self}, this, _create(this.$info.Self, 'init', {Self: this.$info.Self, T: Int}, n)))"],
  ["Swift.(file).BinaryInteger.==infix(_:Self,_:Other)", "const lhsNegative = Bool.infix_38_38({}, $info.Self.isSigned, () => $info.Self.infix_60({Self: $info.Self}, lhs, _create($info.Self, 'initIntegerLiteral', {Self: $info.Self}, 0)));\nconst rhsNegative = Bool.infix_38_38({}, $info.Other.isSigned, () => $info.Other.infix_60({Self: $info.Other}, rhs, _create($info.Other, 'initIntegerLiteral', {Self: $info.Other}, 0)));\n{\nif((Bool.infix_33_61({Self: Bool}, lhsNegative, rhsNegative))) {\nreturn false;\n}\n};\n{\nif((Int.infix_60({}, lhs.bitWidth, rhs.bitWidth))) {\nreturn $info.Other.infix_61_61({Self: $info.Other}, _create($info.Other, 'initTruncatingIfNeeded', {Self: $info.Other, T: $info.Self}, lhs), rhs);\n}\n};\n{\nif((Int.infix_62({}, lhs.bitWidth, rhs.bitWidth))) {\nreturn $info.Self.infix_61_61({Self: $info.Self}, lhs, _create($info.Self, 'initTruncatingIfNeeded', {Self: $info.Self, T: $info.Other}, rhs));\n}\n};\n{\nif(($info.Self.isSigned)) {\nreturn $info.Other.infix_61_61({Self: $info.Other}, _create($info.Other, 'initTruncatingIfNeeded', {Self: $info.Other, T: $info.Self}, lhs), rhs);\n}\n};\nreturn $info.Self.infix_61_61({Self: $info.Self}, lhs, _create($info.Self, 'initTruncatingIfNeeded', {Self: $info.Self, T: $info.Other}, rhs))"],
  ["Swift.(file).BinaryInteger.!=infix(_:Self,_:Other)", "return Bool.prefix_33({}, $info.Self.infix_61_61({Self: $info.Self, Other: $info.Other}, lhs, rhs))"],
  ["Swift.(file).BinaryInteger.<infix(_:Self,_:Other)", "const lhsNegative = Bool.infix_38_38({}, $info.Self.isSigned, () => $info.Self.infix_60({Self: $info.Self}, lhs, _create($info.Self, 'initIntegerLiteral', {Self: $info.Self}, 0)));\nconst rhsNegative = Bool.infix_38_38({}, $info.Other.isSigned, () => $info.Other.infix_60({Self: $info.Other}, rhs, _create($info.Other, 'initIntegerLiteral', {Self: $info.Other}, 0)));\n{\nif((Bool.infix_33_61({Self: Bool}, lhsNegative, rhsNegative))) {\nreturn lhsNegative;\n}\n};\n{\nif((Bool.infix_38_38({}, $info.Self.infix_61_61({Self: $info.Self}, lhs, _create($info.Self, 'initIntegerLiteral', {Self: $info.Self}, 0)), () => $info.Other.infix_61_61({Self: $info.Other}, rhs, _create($info.Other, 'initIntegerLiteral', {Self: $info.Other}, 0))))) {\nreturn false;\n}\n};\nconst rhsAsSelf = _create($info.Self, 'initTruncatingIfNeeded', {Self: $info.Self, T: $info.Other}, rhs);\nconst rhsAsSelfNegative = $info.Self.infix_60({Self: $info.Self}, rhsAsSelf, _create($info.Self, 'initIntegerLiteral', {Self: $info.Self}, 0));\n{\nif((Bool.infix_38_38({}, $info.Other.infix_61_61({Self: $info.Other}, _create($info.Other, 'initTruncatingIfNeeded', {Self: $info.Other, T: $info.Self}, rhsAsSelf), rhs), () => Bool.infix_61_61({}, rhsNegative, rhsAsSelfNegative)))) {\nreturn $info.Self.infix_60({Self: $info.Self}, lhs, rhsAsSelf);\n}\n};\nreturn $info.Other.infix_60({Self: $info.Other}, _create($info.Other, 'initTruncatingIfNeeded', {Self: $info.Other, T: $info.Self}, lhs), rhs)"],
  ["Swift.(file).BinaryInteger.<=infix(_:Self,_:Other)", "return Bool.prefix_33({}, $info.Other.infix_60({Self: $info.Other, Other: $info.Self}, rhs, lhs))"],
  ["Swift.(file).BinaryInteger.>=infix(_:Self,_:Other)", "return Bool.prefix_33({}, $info.Self.infix_60({Self: $info.Self, Other: $info.Other}, lhs, rhs))"],
  ["Swift.(file).BinaryInteger.>infix(_:Self,_:Other)", "return $info.Other.infix_60({Self: $info.Other, Other: $info.Self}, rhs, lhs)"],
  ["Swift.(file).BinaryInteger.!=infix(_:Self,_:Self)", "return Bool.prefix_33({}, $info.Self.infix_61_61({Self: $info.Self}, lhs, rhs))"],
  ["Swift.(file).BinaryInteger.<=infix(_:Self,_:Self)", "return Bool.prefix_33({}, $info.Self.infix_60({Self: $info.Self}, rhs, lhs))"],
  ["Swift.(file).BinaryInteger.>=infix(_:Self,_:Self)", "return Bool.prefix_33({}, $info.Self.infix_60({Self: $info.Self}, lhs, rhs))"],
  ["Swift.(file).BinaryInteger.>infix(_:Self,_:Self)", "return $info.Self.infix_60({Self: $info.Self}, rhs, lhs)"],
  ["Swift.(file).FixedWidthInteger.bitWidth", " return this.bitWidth$internal "],
  ["Swift.(file).FixedWidthInteger.littleEndian", " return this.littleEndian$internal "],
  ["Swift.(file).FixedWidthInteger.bigEndian", " return this.bigEndian$internal "],
  ["Swift.(file).FixedWidthInteger.&>>infix(_:Self,_:Self)", "let lhs_dupl = lhs;\n$info.Self.infix_38_62_62_61({Self: $info.Self}, {get: () => lhs_dupl, set: $val => lhs_dupl = $val}, rhs);\nreturn lhs_dupl"],
  ["Swift.(file).FixedWidthInteger.&>>infix(_:Self,_:Other)", "return $info.Self.infix_38_62_62({Self: $info.Self}, lhs, _create($info.Self, 'initTruncatingIfNeeded', {Self: $info.Self, T: $info.Other}, rhs))"],
  ["Swift.(file).FixedWidthInteger.&>>=infix(_:Self,_:Other)", "let lhs = lhs$inout.get()\nconst $result = (() => {\nlhs = $info.Self.infix_38_62_62({Self: $info.Self, Other: $info.Other}, lhs, rhs);})()\nlhs$inout.set(lhs)\nreturn $result"],
  ["Swift.(file).FixedWidthInteger.&<<infix(_:Self,_:Self)", "let lhs_dupl = lhs;\n$info.Self.infix_38_60_60_61({Self: $info.Self}, {get: () => lhs_dupl, set: $val => lhs_dupl = $val}, rhs);\nreturn lhs_dupl"],
  ["Swift.(file).FixedWidthInteger.&<<infix(_:Self,_:Other)", "return $info.Self.infix_38_60_60({Self: $info.Self}, lhs, _create($info.Self, 'initTruncatingIfNeeded', {Self: $info.Self, T: $info.Other}, rhs))"],
  ["Swift.(file).FixedWidthInteger.&<<=infix(_:Self,_:Other)", "let lhs = lhs$inout.get()\nconst $result = (() => {\nlhs = $info.Self.infix_38_60_60({Self: $info.Self, Other: $info.Other}, lhs, rhs);})()\nlhs$inout.set(lhs)\nreturn $result"],
  ["Swift.(file).FixedWidthInteger.random(in:Range<Self>,using:T)", "let generator = generator$inout.get()\nconst $result = (() => {\npreconditionFileLine({}, () => Bool.prefix_33({}, range.isEmpty), () => \"Can't get random value with an empty range\", '?3', '?3');\nconst delta = _create($info.Self.Magnitude, 'initTruncatingIfNeeded', {Self: $info.Self.Magnitude, T: $info.Self}, $info.Self.infix_38_45({Self: $info.Self}, range.upperBound, range.lowerBound));\nreturn _create($info.Self, 'initTruncatingIfNeeded', {Self: $info.Self, T: $info.Self.Magnitude}, $info.Self.Magnitude.infix_38_43({Self: $info.Self.Magnitude}, _create($info.Self.Magnitude, 'initTruncatingIfNeeded', {Self: $info.Self.Magnitude, T: $info.Self}, range.lowerBound), generator.nextUpperBound({$setThis: $val => generator = $val, Self: $info.T, T: $info.Self.Magnitude}, delta)));})()\ngenerator$inout.set(generator)\nreturn $result"],
  ["Swift.(file).FixedWidthInteger.random(in:Range<Self>)", "let g = _create(SystemRandomNumberGenerator, 'init', {}, );\nreturn $info.Self.randomInUsing({Self: $info.Self, T: SystemRandomNumberGenerator}, range, {get: () => g, set: $val => g = $val})"],
  ["Swift.(file).FixedWidthInteger.random(in:ClosedRange<Self>,using:T)", "let generator = generator$inout.get()\nconst $result = (() => {\npreconditionFileLine({}, () => Bool.prefix_33({}, range.isEmpty), () => \"Can't get random value with an empty range\", '?3', '?3');\nlet delta = _create($info.Self.Magnitude, 'initTruncatingIfNeeded', {Self: $info.Self.Magnitude, T: $info.Self}, $info.Self.infix_38_45({Self: $info.Self}, range.upperBound, range.lowerBound));\n{\nif(($info.Self.Magnitude.infix_61_61({Self: $info.Self.Magnitude}, delta, $info.Self.Magnitude.max))) {\nreturn _create($info.Self, 'initTruncatingIfNeeded', {Self: $info.Self, T: $info.Self.Magnitude}, generator.next({$setThis: $val => generator = $val, Self: $info.T, T: $info.Self.Magnitude}, ));\n}\n};\n$info.Self.Magnitude.infix_43_61({Self: $info.Self.Magnitude}, {get: () => delta, set: $val => delta = $val}, _create($info.Self.Magnitude, 'initIntegerLiteral', {Self: $info.Self.Magnitude}, 1));\nreturn _create($info.Self, 'initTruncatingIfNeeded', {Self: $info.Self, T: $info.Self.Magnitude}, $info.Self.Magnitude.infix_38_43({Self: $info.Self.Magnitude}, _create($info.Self.Magnitude, 'initTruncatingIfNeeded', {Self: $info.Self.Magnitude, T: $info.Self}, range.lowerBound), generator.nextUpperBound({$setThis: $val => generator = $val, Self: $info.T, T: $info.Self.Magnitude}, delta)));})()\ngenerator$inout.set(generator)\nreturn $result"],
  ["Swift.(file).FixedWidthInteger.random(in:ClosedRange<Self>)", "let g = _create(SystemRandomNumberGenerator, 'init', {}, );\nreturn $info.Self.randomInUsing({Self: $info.Self, T: SystemRandomNumberGenerator}, range, {get: () => g, set: $val => g = $val})"],
  ["Swift.(file).FixedWidthInteger.~prefix(_:Self)", "return $info.Self.infix_38_45({Self: $info.Self}, $info.Self.infix_38_45({Self: $info.Self}, _create($info.Self, 'initIntegerLiteral', {Self: $info.Self}, 0), x), _create($info.Self, 'initIntegerLiteral', {Self: $info.Self}, 1))"],
  ["Swift.(file).FixedWidthInteger.>>infix(_:Self,_:Other)", "let lhs_dupl = lhs;\nthis._nonMaskingRightShiftGeneric({Self: $info.Self, Other: $info.Other}, {get: () => lhs_dupl, set: $val => lhs_dupl = $val}, rhs);\nreturn lhs_dupl"],
  ["Swift.(file).FixedWidthInteger.>>=infix(_:Self,_:Other)", "let lhs = lhs$inout.get()\nconst $result = (() => {\nthis._nonMaskingRightShiftGeneric({Self: $info.Self, Other: $info.Other}, {get: () => lhs, set: $val => lhs = $val}, rhs);})()\nlhs$inout.set(lhs)\nreturn $result"],
  ["Swift.(file).FixedWidthInteger.<<infix(_:Self,_:Other)", "let lhs_dupl = lhs;\nthis._nonMaskingLeftShiftGeneric({Self: $info.Self, Other: $info.Other}, {get: () => lhs_dupl, set: $val => lhs_dupl = $val}, rhs);\nreturn lhs_dupl"],
  ["Swift.(file).FixedWidthInteger.<<=infix(_:Self,_:Other)", "let lhs = lhs$inout.get()\nconst $result = (() => {\nthis._nonMaskingLeftShiftGeneric({Self: $info.Self, Other: $info.Other}, {get: () => lhs, set: $val => lhs = $val}, rhs);})()\nlhs$inout.set(lhs)\nreturn $result"],
  ["Swift.(file).FixedWidthInteger.init(truncatingIfNeeded:T)", "{\nif((Int.infix_60_61({}, $info.Self.bitWidth, Int.bitWidth))) {\n$info0x7fe31700da18.$setThis(_cloneStruct(_create($info.Self, 'init_truncatingBitsUInt', {Self: $info.Self}, source._lowWord)));\n}\nelse {\nconst neg = $info.T.infix_60({Self: $info.T}, source, _create($info.T, 'initIntegerLiteral', {Self: $info.T}, 0));\nlet result = (neg ? $info.Self.prefix_126({Self: $info.Self}, _create($info.Self, 'initIntegerLiteral', {Self: $info.Self}, 0)) : _create($info.Self, 'initIntegerLiteral', {Self: $info.Self}, 0));\nlet shift = _create($info.Self, 'initIntegerLiteral', {Self: $info.Self}, 0);\nconst width = _create($info.Self, 'init_truncatingBitsUInt', {Self: $info.Self}, $info.Self.bitWidth._lowWord);\n{\nlet $word$generator = source.words.makeIterator({Self: $info.T.Words}, );\nwhile(true) {\nconst word = $word$generator.next({$setThis: $val => $word$generator = $val, Self: $info.T.Words.Iterator}, );\nif(!((word != null))) break;\n{\nif(!(($info.Self.infix_60({Self: $info.Self}, shift, width)))) {\nbreak;\n}\n};\n$info.Self.infix_94_61({Self: $info.Self}, {get: () => result, set: $val => result = $val}, $info.Self.infix_38_60_60({Self: $info.Self}, _create($info.Self, 'init_truncatingBitsUInt', {Self: $info.Self}, (neg ? UInt.prefix_126({Self: UInt}, word) : word)), shift));\n$info.Self.infix_43_61({Self: $info.Self}, {get: () => shift, set: $val => shift = $val}, _create($info.Self, 'init_truncatingBitsUInt', {Self: $info.Self}, Int.bitWidth._lowWord));\n}\n};\n$info0x7fe31700da18.$setThis(_cloneStruct(result));\n}\n};\nreturn "],
  ["Swift.(file).FixedWidthInteger.&+infix(_:Self,_:Self)", "return lhs.addingReportingOverflow({Self: $info.Self}, rhs)[\"0\"]"],
  ["Swift.(file).FixedWidthInteger.&+=infix(_:Self,_:Self)", "let lhs = lhs$inout.get()\nconst $result = (() => {\nlhs = $info.Self.infix_38_43({Self: $info.Self}, lhs, rhs);})()\nlhs$inout.set(lhs)\nreturn $result"],
  ["Swift.(file).FixedWidthInteger.&-infix(_:Self,_:Self)", "return lhs.subtractingReportingOverflow({Self: $info.Self}, rhs)[\"0\"]"],
  ["Swift.(file).FixedWidthInteger.&-=infix(_:Self,_:Self)", "let lhs = lhs$inout.get()\nconst $result = (() => {\nlhs = $info.Self.infix_38_45({Self: $info.Self}, lhs, rhs);})()\nlhs$inout.set(lhs)\nreturn $result"],
  ["Swift.(file).FixedWidthInteger.&*infix(_:Self,_:Self)", "return lhs.multipliedReportingOverflowBy({Self: $info.Self}, rhs)[\"0\"]"],
  ["Swift.(file).FixedWidthInteger.&*=infix(_:Self,_:Self)", "let lhs = lhs$inout.get()\nconst $result = (() => {\nlhs = $info.Self.infix_38_42({Self: $info.Self}, lhs, rhs);})()\nlhs$inout.set(lhs)\nreturn $result"],
  ["Swift.(file).UnsignedInteger.magnitude", " return this.magnitude$internal "],
  ["Swift.(file).UnsignedInteger.isSigned", " return this.isSigned$internal }\nstatic get isSigned() { return this.isSigned$get() }\nstatic isSigned$set($newValue) {\nlet $oldValue = this.isSigned$internal\nthis.isSigned$internal = $newValue\n}\nstatic set isSigned($newValue) { this.isSigned$set($newValue) "],
  ["Swift.(file).UnsignedInteger.max", " return this.max$internal }\nstatic get max() { return this.max$get() }\nstatic max$set($newValue) {\nlet $oldValue = this.max$internal\nthis.max$internal = $newValue\n}\nstatic set max($newValue) { this.max$set($newValue) "],
  ["Swift.(file).UnsignedInteger.min", " return this.min$internal }\nstatic get min() { return this.min$get() }\nstatic min$set($newValue) {\nlet $oldValue = this.min$internal\nthis.min$internal = $newValue\n}\nstatic set min($newValue) { this.min$set($newValue) "],
  ["Swift.(file).SignedInteger.isSigned", " return this.isSigned$internal }\nstatic get isSigned() { return this.isSigned$get() }\nstatic isSigned$set($newValue) {\nlet $oldValue = this.isSigned$internal\nthis.isSigned$internal = $newValue\n}\nstatic set isSigned($newValue) { this.isSigned$set($newValue) "],
  ["Swift.(file).SignedInteger.isMultiple(of:Self)", "{\nif((this.$info.Self.infix_61_61({Self: this.$info.Self, Other: Int}, other, 0))) {\nreturn this.$info.Self.infix_61_61({Self: this.$info.Self, Other: Int}, this, 0);\n}\n};\n{\nif((this.$info.Self.infix_61_61({Self: this.$info.Self, Other: Int}, other, -1))) {\nreturn true;\n}\n};\nreturn this.$info.Self.infix_61_61({Self: this.$info.Self, Other: Int}, this.$info.Self.infix_37({Self: this.$info.Self}, this, other), 0)"],
  ["Swift.(file).numericCast(_:T)", "return _create($info.U, 'init', {Self: $info.U, T: $info.T}, x)"],
  ["Swift.(file).FixedWidthInteger.>>infix(_:Self,_:Self)", "let lhs_dupl = lhs;\nthis._nonMaskingRightShiftGeneric({Self: $info.Self, Other: $info.Self}, {get: () => lhs_dupl, set: $val => lhs_dupl = $val}, rhs);\nreturn lhs_dupl"],
  ["Swift.(file).FixedWidthInteger.>>=infix(_:Self,_:Self)", "let lhs = lhs$inout.get()\nconst $result = (() => {\nthis._nonMaskingRightShiftGeneric({Self: $info.Self, Other: $info.Self}, {get: () => lhs, set: $val => lhs = $val}, rhs);})()\nlhs$inout.set(lhs)\nreturn $result"],
  ["Swift.(file).FixedWidthInteger.<<infix(_:Self,_:Self)", "let lhs_dupl = lhs;\nthis._nonMaskingLeftShiftGeneric({Self: $info.Self, Other: $info.Self}, {get: () => lhs_dupl, set: $val => lhs_dupl = $val}, rhs);\nreturn lhs_dupl"],
  ["Swift.(file).FixedWidthInteger.<<=infix(_:Self,_:Self)", "let lhs = lhs$inout.get()\nconst $result = (() => {\nthis._nonMaskingLeftShiftGeneric({Self: $info.Self, Other: $info.Self}, {get: () => lhs, set: $val => lhs = $val}, rhs);})()\nlhs$inout.set(lhs)\nreturn $result"],
  ["Swift.(file).FixedWidthInteger.addWithOverflow(_:Self,_:Self)", "const $tuple = lhs.addingReportingOverflow({Self: $info.Self}, rhs), partialValue = $tuple && $tuple[0], overflow = $tuple && $tuple[1];\nreturn {0: partialValue, 1: overflow}"],
  ["Swift.(file).FixedWidthInteger.subtractWithOverflow(_:Self,_:Self)", "const $tuple = lhs.subtractingReportingOverflow({Self: $info.Self}, rhs), partialValue = $tuple && $tuple[0], overflow = $tuple && $tuple[1];\nreturn {0: partialValue, 1: overflow}"],
  ["Swift.(file).FixedWidthInteger.multiplyWithOverflow(_:Self,_:Self)", "const $tuple = lhs.multipliedReportingOverflowBy({Self: $info.Self}, rhs), partialValue = $tuple && $tuple[0], overflow = $tuple && $tuple[1];\nreturn {0: partialValue, 1: overflow}"],
  ["Swift.(file).FixedWidthInteger.divideWithOverflow(_:Self,_:Self)", "const $tuple = lhs.dividedReportingOverflowBy({Self: $info.Self}, rhs), partialValue = $tuple && $tuple[0], overflow = $tuple && $tuple[1];\nreturn {0: partialValue, 1: overflow}"],
  ["Swift.(file).FixedWidthInteger.remainderWithOverflow(_:Self,_:Self)", "const $tuple = lhs.remainderReportingOverflowDividingBy({Self: $info.Self}, rhs), partialValue = $tuple && $tuple[0], overflow = $tuple && $tuple[1];\nreturn {0: partialValue, 1: overflow}"],
  ["Swift.(file).BinaryInteger.addWithOverflow(_:Self,_:Self)", "fatalErrorFileLine({}, () => \"Unavailable\", '?3', '?3')"],
  ["Swift.(file).BinaryInteger.subtractWithOverflow(_:Self,_:Self)", "fatalErrorFileLine({}, () => \"Unavailable\", '?3', '?3')"],
  ["Swift.(file).BinaryInteger.multiplyWithOverflow(_:Self,_:Self)", "fatalErrorFileLine({}, () => \"Unavailable\", '?3', '?3')"],
  ["Swift.(file).BinaryInteger.divideWithOverflow(_:Self,_:Self)", "fatalErrorFileLine({}, () => \"Unavailable\", '?3', '?3')"],
  ["Swift.(file).BinaryInteger.remainderWithOverflow(_:Self,_:Self)", "fatalErrorFileLine({}, () => \"Unavailable\", '?3', '?3')"],
  ["Swift.(file).SignedInteger.&+infix(_:Self,_:Self)", "return this._maskingAdd({Self: $info.Self}, lhs, rhs)"],
  ["Swift.(file).SignedInteger.&-infix(_:Self,_:Self)", "return this._maskingSubtract({Self: $info.Self}, lhs, rhs)"],
  ["Swift.(file).SignedInteger.&+infix(_:Self,_:Self)", "return this._maskingAdd({Self: $info.Self}, lhs, rhs)"],
  ["Swift.(file).SignedInteger.&-infix(_:Self,_:Self)", "return this._maskingSubtract({Self: $info.Self}, lhs, rhs)"],
  ["Swift.(file).Sequence.joined(separator:Separator)", "return _create(JoinedSequence, 'initBaseSeparator', {Base: $info.Self, Separator: $info.Separator}, this, separator)"],
  ["Swift.(file).AnyKeyPath.hashValue", "return _hashValueFor({H: AnyKeyPath}, this)"],
  ["Swift.(file).KeyValuePairs.startIndex", "return 0"],
  ["Swift.(file).LazyCollectionProtocol.lazy", " return this.lazy$internal "],
  ["Swift.(file).LazyCollectionProtocol.lazy", " return this.lazy$internal "],
  ["Swift.(file).LazySequenceProtocol.lazy", " return this.lazy$internal "],
  ["Swift.(file).LazySequenceProtocol.lazy", " return this.lazy$internal "],
  ["Swift.(file).withExtendedLifetime(_:T,_:() throws -> Result)", "let $defer = () => {\n_fixLifetime({T: $info.T}, x);\n}\ntry {;\nreturn body({}, );}catch($error){$defer({T: $info.T, Result: $info.Result}, );throw $error}$defer({T: $info.T, Result: $info.Result}, )"],
  ["Swift.(file).withExtendedLifetime(_:T,_:(T) throws -> Result)", "let $defer = () => {\n_fixLifetime({T: $info.T}, x);\n}\ntry {;\nreturn body({}, x);}catch($error){$defer({T: $info.T, Result: $info.Result}, );throw $error}$defer({T: $info.T, Result: $info.Result}, )"],
  ["Swift.(file).ManagedBuffer.withUnsafeMutablePointerToHeader(_:(UnsafeMutablePointer<Header>) throws -> R)", "return this.withUnsafeMutablePointers({Header: $info.Header, Element: $info.Element, R: $info.R}, (($info, v, _) => body({}, v)))"],
  ["Swift.(file).ManagedBuffer.withUnsafeMutablePointerToElements(_:(UnsafeMutablePointer<Element>) throws -> R)", "return this.withUnsafeMutablePointers({Header: $info.Header, Element: $info.Element, R: $info.R}, (($info, $0, $1) => body({}, $1)))"],
  ["Swift.(file).ManagedBufferPointer.withUnsafeMutablePointerToHeader(_:(UnsafeMutablePointer<Header>) throws -> R)", "return this.withUnsafeMutablePointers({Header: $info.Header, Element: $info.Element, R: $info.R}, (($info, v, _) => body({}, v)))"],
  ["Swift.(file).ManagedBufferPointer.withUnsafeMutablePointerToElements(_:(UnsafeMutablePointer<Element>) throws -> R)", "return this.withUnsafeMutablePointers({Header: $info.Header, Element: $info.Element, R: $info.R}, (($info, $0, $1) => body({}, $1)))"],
  ["Swift.(file).MemoryLayout.size(ofValue:T)", "return MemoryLayout.size"],
  ["Swift.(file).MemoryLayout.stride(ofValue:T)", "return MemoryLayout.stride"],
  ["Swift.(file).MemoryLayout.alignment(ofValue:T)", "return MemoryLayout.alignment"],
  ["Swift.(file).LazySequenceProtocol.flatMap(_:(Self.Elements.Element) -> ElementOfResult?)", "return this.compactMap({Self: $info.Self, ElementOfResult: $info.ElementOfResult}, transform)"],
  ["Swift.(file).String.characters", "return this"],
  ["Swift.(file).String.withMutableCharacters(_:(inout String) -> R)", "return body({}, {get: () => this, set: $val => $info0x7f82160dd4b0.$setThis(_cloneStruct($val))})"],
  ["Swift.(file).Substring.characters", "return this"],
  ["Swift.(file).Substring.withMutableCharacters(_:(inout Substring) -> R)", "return body({}, {get: () => this, set: $val => $info0x7fb6bf1044b8.$setThis(_cloneStruct($val))})"],
  ["Swift.(file).Substring.customPlaygroundQuickLook", "return _create(String, 'initSubstring', {}, this).customPlaygroundQuickLook"],
  ["Swift.(file).Collection.index(_:Self.Index,offsetBy:T)", "return this.indexOffsetBy({Self: $info.Self}, i, _create(Int, 'init', {Self: Int, T: $info.T}, n))"],
  ["Swift.(file).Collection.formIndex(_:Self.Index,offsetBy:T)", "let i = i$inout.get()\nconst $result = (() => {\nreturn this.formIndexOffsetBy({Self: $info.Self}, {get: () => i, set: $val => i = $val}, _create(Int, 'init', {Self: Int, T: $info.T}, n));})()\ni$inout.set(i)\nreturn $result"],
  ["Swift.(file).Collection.index(_:Self.Index,offsetBy:T,limitedBy:Self.Index)", "return this.indexOffsetByLimitedBy({Self: $info.Self}, i, _create(Int, 'init', {Self: Int, T: $info.T}, n), limit)"],
  ["Swift.(file).Collection.formIndex(_:Self.Index,offsetBy:T,limitedBy:Self.Index)", "let i = i$inout.get()\nconst $result = (() => {\nreturn this.formIndexOffsetByLimitedBy({Self: $info.Self}, {get: () => i, set: $val => i = $val}, _create(Int, 'init', {Self: Int, T: $info.T}, n), limit);})()\ni$inout.set(i)\nreturn $result"],
  ["Swift.(file).Collection.distance(from:Self.Index,to:Self.Index)", "return numericCast({T: Int, U: $info.T}, this.distanceFromTo({Self: $info.Self}, start, end))"],
  ["Swift.(file).UnsafeMutablePointer.initialize(to:Pointee,count:Int)", "this.initializeRepeatingCount({Pointee: this.$info.Pointee}, newValue, count)"],
  ["Swift.(file).UnsafeMutablePointer.deinitialize()", "return this.deinitializeCount({Pointee: this.$info.Pointee}, 1)"],
  ["Swift.(file).UnsafeMutablePointer.deallocate(capacity:Int)", "this.deallocate({Pointee: this.$info.Pointee}, )"],
  ["Swift.(file).UnsafeMutablePointer.initialize(from:C)", "const buf = _create(UnsafeMutableBufferPointer, 'initStartOptionalCountInt', {Element: $info.Pointee},   (pointer_to_pointer implicit type='UnsafeMutablePointer<Pointee>' location=/Users/bubulkowanorka/projects/antlr4-visitor/include/build-bodies/body.swift:4:49 range=[/Users/bubulkowanorka/projects/antlr4-visitor/include/build-bodies/body.swift:4:49 - line:4:49]\nthis), numericCast({T: Int, U: Int}, source.count));\nlet $tuple = source._copyContentsInitializing({Self: $info.C}, buf), remainders = $tuple && $tuple[0], writtenUpTo = $tuple && $tuple[1];\npreconditionFileLine({}, () => Optional.infix_61_61({Wrapped: $info.Pointee}, remainders.next({$setThis: $val => remainders = $val, Self: $info.C.Iterator}, ), null), () => \"rhs underreported its count\", '?3', '?3');\npreconditionFileLine({}, () => Int.infix_61_61({}, writtenUpTo, buf.endIndex), () => \"rhs overreported its count\", '?3', '?3')"],
  ["Swift.(file).UnsafeMutableRawPointer.allocate(bytes:Int,alignedTo:Int)", "return UnsafeMutableRawPointer.allocateByteCountAlignment({}, size, alignment)"],
  ["Swift.(file).UnsafeMutableRawPointer.deallocate(bytes:Int,alignedTo:Int)", "this.deallocate({}, )"],
  ["Swift.(file).UnsafeMutableRawPointer.copyBytes(from:UnsafeRawPointer,count:Int)", "this.copyMemoryFromByteCount({}, source, count)"],
  ["Swift.(file).UnsafeMutableRawPointer.initializeMemory(as:T.Type,at:Int,count:Int,to:T)", "return UnsafeMutableRawPointer.infix_43({Self: UnsafeMutableRawPointer}, this, Int.infix_42({}, offset, MemoryLayout.stride)).initializeMemoryAsRepeatingCount({T: $info.T}, type, repeatedValue, count)"],
  ["Swift.(file).UnsafeMutableRawPointer.initializeMemory(as:C.Element.Type,from:C)", "let ptr = _cloneStruct(this);\n{\nlet $element$generator = source.makeIterator({Self: $info.C}, );\nwhile(true) {\nconst _element = $element$generator.next({$setThis: $val => $element$generator = $val, Self: $info.C.Iterator}, );\nif(!((_element != null))) break;\nptr.initializeMemoryAsRepeatingCount({T: $info.C.Element}, $info.C.Element, _element, 1);\nUnsafeMutableRawPointer.infix_43_61({Self: UnsafeMutableRawPointer}, {get: () => ptr, set: $val => ptr = $val}, MemoryLayout.stride);\n}\n};\nreturn _create(UnsafeMutablePointer, 'initRawPointer', {Pointee: $info.C.Element}, this._rawValue)"],
  ["Swift.(file).UnsafeMutableRawBufferPointer.allocate(count:Int)", "return UnsafeMutableRawBufferPointer.allocateByteCountAlignment({}, count, MemoryLayout.alignment)"],
  ["Swift.(file).UnsafeMutableRawBufferPointer.copyBytes(from:UnsafeRawBufferPointer)", "this.copyMemoryFrom({}, source)"],
  ["Swift.(file).Sequence.flatMap(_:(Self.Element) throws -> ElementOfResult?)", "return this._compactMap({Self: $info.Self, ElementOfResult: $info.ElementOfResult}, transform)"],
  ["Swift.(file).Sequence.flatMap(_:(Self.Element) throws -> String)", "return this.mapSwift({Self: this.$info.Self, T: String}, transform)"],
  ["Swift.(file).Collection.flatMap(_:(Self.Element) throws -> String?)", "return this._compactMap({Self: this.$info.Self, ElementOfResult: String}, transform)"],
  ["Swift.(file).Collection.index(where:(Self.Element) throws -> Bool)", "return this.firstIndexWhere({Self: this.$info.Self}, _predicate)"],
  ["Swift.(file).MutableCollection.withContiguousMutableStorageIfAvailable(_:(inout UnsafeMutableBufferPointer<Self.Element>) throws -> R)", "return null"],
  ["Swift.(file).MutableCollection.swapAt(_:Self.Index,_:Self.Index)", "{\nif(!((this.$info.Self.Index.infix_33_61({Self: this.$info.Self.Index}, i, j)))) {\nreturn ;\n}\n};\nconst tmp = this.subscript$get({}, i);\nthis.subscript$set({$setThis: $val => $info0x7f89de05d7c8.$setThis(_cloneStruct($val))}, this.subscript$get({}, j), i);\nthis.subscript$set({$setThis: $val => $info0x7f89de05d7c8.$setThis(_cloneStruct($val))}, tmp, j)"],
  ["Swift.(file).ObjectIdentifier.<infix(_:ObjectIdentifier,_:ObjectIdentifier)", "return UInt.infix_60({}, _create(UInt, 'initBitPatternObjectIdentifier', {}, lhs), _create(UInt, 'initBitPatternObjectIdentifier', {}, rhs))"],
  ["Swift.(file).OptionSet.union(_:Self)", "let r = _create(this.$info.Self, 'initRawValue', {Self: this.$info.Self}, this.rawValue);\nr.formUnion({$setThis: $val => r = $val, Self: this.$info.Self}, other);\nreturn r"],
  ["Swift.(file).OptionSet.intersection(_:Self)", "let r = _create(this.$info.Self, 'initRawValue', {Self: this.$info.Self}, this.rawValue);\nr.formIntersection({$setThis: $val => r = $val, Self: this.$info.Self}, other);\nreturn r"],
  ["Swift.(file).OptionSet.symmetricDifference(_:Self)", "let r = _create(this.$info.Self, 'initRawValue', {Self: this.$info.Self}, this.rawValue);\nr.formSymmetricDifference({$setThis: $val => r = $val, Self: this.$info.Self}, other);\nreturn r"],
  ["Swift.(file).OptionSet.contains(_:Self)", "return this.isSupersetOf({Self: this.$info.Self}, member)"],
  ["Swift.(file).Optional.map(_:(Wrapped) throws -> U)", "const $match = this\nif((($match.rawValue == Optional.some().rawValue))) {\nconst y = $match[0]\nreturn Optional.some({Wrapped: $info.U}, transform({}, y));\n}\nelse if((($match.rawValue == Optional.none.rawValue))) {\nreturn null;\n}"],
  ["Swift.(file).Optional.flatMap(_:(Wrapped) throws -> U?)", "const $match = this\nif((($match.rawValue == Optional.some().rawValue))) {\nconst y = $match[0]\nreturn transform({}, y);\n}\nelse if((($match.rawValue == Optional.none.rawValue))) {\nreturn null;\n}"],
  ["Swift.(file).Optional.debugDescription", "const $match = this\nif((($match.rawValue == Optional.some().rawValue))) {\nconst value = $match[0]\nlet result = \"Optional(\";\ndebugPrintSeparatorTerminatorTo({Target: String}, [value], null, \"\", {get: () => result, set: $val => result = $val});\nString.infix_43_61({}, {get: () => result, set: $val => result = $val}, \")\");\nreturn result;\n}\nelse if((($match.rawValue == Optional.none.rawValue))) {\nreturn \"nil\";\n}"],
  ["Swift.(file).Optional.customMirror", "const $match = this\nif((($match.rawValue == Optional.some().rawValue))) {\nconst value = $match[0]\nreturn _create(Mirror, 'initChildrenKeyValuePairsDisplayStyleOptionalAncestorRepresentationMirrorAncestorRepresentation', {Subject: _clarifyGenerics({Self:Optional, Wrapped: this.$info.Wrapped})}, this, new Map([[\"some\", value]]), Mirror.DisplayStyle.optional, null);\n}\nelse if((($match.rawValue == Optional.none.rawValue))) {\nreturn _create(Mirror, 'initChildrenKeyValuePairsDisplayStyleOptionalAncestorRepresentationMirrorAncestorRepresentation', {Subject: _clarifyGenerics({Self:Optional, Wrapped: this.$info.Wrapped})}, this, new Map([]), Mirror.DisplayStyle.optional, null);\n}"],
  ["Swift.(file).Optional.==infix(_:Wrapped?,_:Wrapped?)", "const $match = {0: lhs, 1: rhs}\nif(((true))) {\nconst l = $match[0]\nconst r = $match[1]\nreturn Optional.infix_61_61({Wrapped: $info.Wrapped}, l, r);\n}\nelse if((($match.rawValue == Optional.none.rawValue && $match.rawValue == Optional.none.rawValue))) {\nreturn true;\n}\nelse if(((true))) {\nreturn false;\n}"],
  ["Swift.(file).Optional.~=infix(_:_OptionalNilComparisonType,_:Wrapped?)", "const $match = rhs\nif((($match.rawValue == Optional.some().rawValue))) {\nreturn false;\n}\nelse if((($match.rawValue == Optional.none.rawValue))) {\nreturn true;\n}"],
  ["Swift.(file).Optional.==infix(_:Wrapped?,_:_OptionalNilComparisonType)", "const $match = lhs\nif((($match.rawValue == Optional.some().rawValue))) {\nreturn false;\n}\nelse if((($match.rawValue == Optional.none.rawValue))) {\nreturn true;\n}"],
  ["Swift.(file).Optional.!=infix(_:Wrapped?,_:_OptionalNilComparisonType)", "const $match = lhs\nif((($match.rawValue == Optional.some().rawValue))) {\nreturn true;\n}\nelse if((($match.rawValue == Optional.none.rawValue))) {\nreturn false;\n}"],
  ["Swift.(file).Optional.==infix(_:_OptionalNilComparisonType,_:Wrapped?)", "const $match = rhs\nif((($match.rawValue == Optional.some().rawValue))) {\nreturn false;\n}\nelse if((($match.rawValue == Optional.none.rawValue))) {\nreturn true;\n}"],
  ["Swift.(file).Optional.!=infix(_:_OptionalNilComparisonType,_:Wrapped?)", "const $match = rhs\nif((($match.rawValue == Optional.some().rawValue))) {\nreturn true;\n}\nelse if((($match.rawValue == Optional.none.rawValue))) {\nreturn false;\n}"],
  ["Swift.(file).??infix(_:T?,_:() throws -> T)", "const $match = optional\nif((($match.rawValue == Optional.some().rawValue))) {\nconst value = $match[0]\nreturn value;\n}\nelse if((($match.rawValue == Optional.none.rawValue))) {\nreturn defaultValue({}, );\n}"],
  ["Swift.(file).??infix(_:T?,_:() throws -> T?)", "const $match = optional\nif((($match.rawValue == Optional.some().rawValue))) {\nconst value = $match[0]\nreturn value;\n}\nelse if((($match.rawValue == Optional.none.rawValue))) {\nreturn defaultValue({}, );\n}"],
  ["Swift.(file).String.write(_:String)", "String.infix_43_61({}, {get: () => this, set: $val => $info0x7f9f990dfce0.$setThis(_cloneStruct($val))}, other)"],
  ["Swift.(file).String.write(to:Target)", "let target = target$inout.get()\nconst $result = (() => {\ntarget.write({$setThis: $val => target = $val, Self: $info.Target}, this);})()\ntarget$inout.set(target)\nreturn $result"],
  ["Swift.(file).Character.write(to:Target)", "let target = target$inout.get()\nconst $result = (() => {\ntarget.write({$setThis: $val => target = $val, Self: $info.Target}, _create(String, 'initCharacter', {}, this));})()\ntarget$inout.set(target)\nreturn $result"],
  ["Swift.(file)._Pointer.successor()", "return this.advancedBy({Self: this.$info.Self}, 1)"],
  ["Swift.(file)._Pointer.predecessor()", "return this.advancedBy({Self: this.$info.Self}, -1)"],
  ["Swift.(file)._Pointer.hash(into:Hasher)", "let hasher = hasher$inout.get()\nconst $result = (() => {\nhasher.combine({$setThis: $val => hasher = $val, H: UInt}, _create(UInt, 'initBitPatternOptional', {P: this.$info.Self}, this));})()\nhasher$inout.set(hasher)\nreturn $result"],
  ["Swift.(file).Strideable.+infix(_:Self,_:Self.Stride)", "return lhs.advancedBy({Self: $info.Self}, rhs)"],
  ["Swift.(file).Strideable.+infix(_:Self.Stride,_:Self)", "return rhs.advancedBy({Self: $info.Self}, lhs)"],
  ["Swift.(file).Strideable.-infix(_:Self,_:Self.Stride)", "return lhs.advancedBy({Self: $info.Self}, $info.Self.Stride.prefix_45({Self: $info.Self.Stride}, rhs))"],
  ["Swift.(file).Strideable.-infix(_:Self,_:Self)", "return rhs.distanceTo({Self: $info.Self}, lhs)"],
  ["Swift.(file).Strideable.+=infix(_:Self,_:Self.Stride)", "let lhs = lhs$inout.get()\nconst $result = (() => {\nlhs = lhs.advancedBy({Self: $info.Self}, rhs);})()\nlhs$inout.set(lhs)\nreturn $result"],
  ["Swift.(file).Strideable.-=infix(_:Self,_:Self.Stride)", "let lhs = lhs$inout.get()\nconst $result = (() => {\nlhs = lhs.advancedBy({Self: $info.Self}, $info.Self.Stride.prefix_45({Self: $info.Self.Stride}, rhs));})()\nlhs$inout.set(lhs)\nreturn $result"],
  ["Swift.(file).Never.<infix(_:Never,_:Never)", ""],
  ["Swift.(file).~=infix(_:T,_:T)", "return $info.T.infix_61_61({Self: $info.T}, a, b)"],
  ["Swift.(file).RandomNumberGenerator.next()", "return $info.T._randomUsing({Self: $info.T, R: $info.Self}, {get: () => this, set: $val => $info0x7fe46280a1c0.$setThis(_cloneStruct($val))})"],
  ["Swift.(file).RandomNumberGenerator.next(upperBound:T)", "preconditionFileLine({}, () => $info.T.infix_33_61({Self: $info.T, Other: Int}, upperBound, 0), () => \"upperBound cannot be zero.\", '?3', '?3');\nconst tmp = $info.T.infix_43({Self: $info.T}, $info.T.infix_37({Self: $info.T}, $info.T.max, upperBound), _create($info.T, 'initIntegerLiteral', {Self: $info.T}, 1));\nconst range = ($info.T.infix_61_61({Self: $info.T}, tmp, upperBound) ? _create($info.T, 'initIntegerLiteral', {Self: $info.T}, 0) : tmp);\nlet random = _create($info.T, 'initIntegerLiteral', {Self: $info.T}, 0);\ndo {\nrandom = this.next({$setThis: $val => $info0x7f9bea0116b8.$setThis(_cloneStruct($val)), Self: $info.Self, T: $info.T}, );\n} while($info.T.infix_60({Self: $info.T}, random, range));\nreturn $info.T.infix_37({Self: $info.T}, random, upperBound)"],
  ["Swift.(file).RandomAccessCollection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)", "const l = this.distanceFromTo({Self: this.$info.Self}, i, limit);\n{\nif(((Int.infix_62({}, distance, 0) ? Bool.infix_38_38({}, Int.infix_62_61({}, l, 0), () => Int.infix_60({}, l, distance)) : Bool.infix_38_38({}, Int.infix_60_61({}, l, 0), () => Int.infix_60({}, distance, l))))) {\nreturn null;\n}\n};\nreturn this.indexOffsetBy({Self: this.$info.Self}, i, distance)"],
  ["Swift.(file).RandomAccessCollection.indices", " return this.indices$internal "],
  ["Swift.(file).RangeExpression.~=infix(_:Self,_:Self.Bound)", "return pattern.contains({Self: $info.Self}, value)"],
  ["Swift.(file).Range.contains(_:Bound)", "return Bool.infix_38_38({}, this.$info.Bound.infix_60_61({Self: this.$info.Bound}, this.lowerBound, _element), () => this.$info.Bound.infix_60({Self: this.$info.Bound}, _element, this.upperBound))"],
  ["Swift.(file).Range.isEmpty", "return this.$info.Bound.infix_61_61({Self: this.$info.Bound}, this.lowerBound, this.upperBound)"],
  ["Swift.(file).Range.startIndex", "return this.lowerBound"],
  ["Swift.(file).Range.endIndex", "return this.upperBound"],
  ["Swift.(file).Range.indices", "return this"],
  ["Swift.(file).Range.relative(to:C)", "return _create(Range, 'initUncheckedBoundstuple_type', {Bound: $info.Bound}, {0: this.lowerBound, 1: this.upperBound})"],
  ["Swift.(file).Range.clamped(to:Range<Bound>)", "const lower = (this.$info.Bound.infix_62({Self: this.$info.Bound}, limits.lowerBound, this.lowerBound) ? limits.lowerBound : (this.$info.Bound.infix_60({Self: this.$info.Bound}, limits.upperBound, this.lowerBound) ? limits.upperBound : this.lowerBound));\nconst upper = (this.$info.Bound.infix_60({Self: this.$info.Bound}, limits.upperBound, this.upperBound) ? limits.upperBound : (this.$info.Bound.infix_62({Self: this.$info.Bound}, limits.lowerBound, this.upperBound) ? limits.lowerBound : this.upperBound));\nreturn _create(Range, 'initUncheckedBoundstuple_type', {Bound: this.$info.Bound}, {0: lower, 1: upper})"],
  ["Swift.(file).Range.description", "return ((\"\") + (this.lowerBound) + (\"..<\") + (this.upperBound) + (\"\"))"],
  ["Swift.(file).Range.debugDescription", "return String.infix_43({}, ((\"Range(\") + (_create(String, 'initReflecting', {Subject: this.$info.Bound}, this.lowerBound)) + (\"\")), ((\"..<\") + (_create(String, 'initReflecting', {Subject: this.$info.Bound}, this.upperBound)) + (\")\")))"],
  ["Swift.(file).Range.customMirror", "return _create(Mirror, 'initChildrenKeyValuePairsDisplayStyleOptionalAncestorRepresentationMirrorAncestorRepresentation', {Subject: _clarifyGenerics({Self:Range, Bound: this.$info.Bound})}, this, new Map([[\"lowerBound\", this.lowerBound], [\"upperBound\", this.upperBound]]), null, null)"],
  ["Swift.(file).Range.==infix(_:Range<Bound>,_:Range<Bound>)", "return Bool.infix_38_38({}, $info.Bound.infix_61_61({Self: $info.Bound}, lhs.lowerBound, rhs.lowerBound), () => $info.Bound.infix_61_61({Self: $info.Bound}, lhs.upperBound, rhs.upperBound))"],
  ["Swift.(file).PartialRangeUpTo.relative(to:C)", "return $info.Bound.infix_46_46_60({Self: $info.Bound}, collection.startIndex, this.upperBound)"],
  ["Swift.(file).PartialRangeUpTo.contains(_:Bound)", "return this.$info.Bound.infix_60({Self: this.$info.Bound}, _element, this.upperBound)"],
  ["Swift.(file).PartialRangeThrough.relative(to:C)", "return $info.Bound.infix_46_46_60({Self: $info.Bound}, collection.startIndex, collection.indexAfter({Self: $info.C}, this.upperBound))"],
  ["Swift.(file).PartialRangeThrough.contains(_:Bound)", "return this.$info.Bound.infix_60_61({Self: this.$info.Bound}, _element, this.upperBound)"],
  ["Swift.(file).PartialRangeFrom.relative(to:C)", "return $info.Bound.infix_46_46_60({Self: $info.Bound}, this.lowerBound, collection.endIndex)"],
  ["Swift.(file).PartialRangeFrom.contains(_:Bound)", "return this.$info.Bound.infix_60_61({Self: this.$info.Bound}, this.lowerBound, _element)"],
  ["Swift.(file).Comparable...<infix(_:Self,_:Self)", "preconditionFileLine({}, () => $info.Self.infix_60_61({Self: $info.Self}, minimum, maximum), () => \"Can't form Range with upperBound < lowerBound\", '?3', '?3');\nreturn _create(Range, 'initUncheckedBoundstuple_type', {Bound: $info.Self}, {0: minimum, 1: maximum})"],
  ["Swift.(file).Comparable...<prefix(_:Self)", "return _create(PartialRangeUpTo, 'init', {Bound: $info.Self}, maximum)"],
  ["Swift.(file).Comparable....prefix(_:Self)", "return _create(PartialRangeThrough, 'init', {Bound: $info.Self}, maximum)"],
  ["Swift.(file).Comparable....postfix(_:Self)", "return _create(PartialRangeFrom, 'init', {Bound: $info.Self}, minimum)"],
  ["Swift.(file).UnboundedRange_....postfix(_:UnboundedRange_)", ""],
  ["Swift.(file).Range.overlaps(_:Range<Bound>)", "return Bool.infix_124_124({}, Bool.infix_38_38({}, Bool.prefix_33({}, other.isEmpty), () => this.contains({Bound: this.$info.Bound}, other.lowerBound)), () => Bool.infix_38_38({}, Bool.prefix_33({}, this.isEmpty), () => other.contains({Bound: this.$info.Bound}, this.lowerBound)))"],
  ["Swift.(file).Range.overlaps(_:ClosedRange<Bound>)", "return Bool.infix_124_124({}, this.contains({Bound: this.$info.Bound}, other.lowerBound), () => Bool.infix_38_38({}, Bool.prefix_33({}, this.isEmpty), () => other.contains({Bound: this.$info.Bound}, this.lowerBound)))"],
  ["Swift.(file).RangeReplaceableCollection.append(_:Self.Element)", "this.insertAt({$setThis: $val => $info0x7fa5f0825f18.$setThis(_cloneStruct($val)), Self: this.$info.Self}, newElement, this.endIndex)"],
  ["Swift.(file).RangeReplaceableCollection.append(contentsOf:S)", "const approximateCapacity = Int.infix_43({}, this.count, numericCast({T: Int, U: Int}, newElements.underestimatedCount));\nthis.reserveCapacity({$setThis: $val => $info0x7fa7988dc258.$setThis(_cloneStruct($val)), Self: $info.Self}, approximateCapacity);\n{\nlet $element$generator = newElements.makeIterator({Self: $info.S}, );\nwhile(true) {\nconst _element = $element$generator.next({$setThis: $val => $element$generator = $val, Self: $info.S.Iterator}, );\nif(!((_element != null))) break;\nthis.append({$setThis: $val => $info0x7fa7988dc258.$setThis(_cloneStruct($val)), Self: $info.Self}, _element);\n}\n}"],
  ["Swift.(file).RangeReplaceableCollection.insert(_:Self.Element,at:Self.Index)", "this.replaceSubrangeWith({$setThis: $val => $info0x7fc6b4818a08.$setThis(_cloneStruct($val)), Self: this.$info.Self, C: _clarifyGenerics({Self:CollectionOfOne, Element: this.$info.Self.Element})}, this.$info.Self.Index.infix_46_46_60({Self: this.$info.Self.Index}, i, i), _create(CollectionOfOne, 'init', {Element: this.$info.Self.Element}, newElement))"],
  ["Swift.(file).RangeReplaceableCollection.insert(contentsOf:C,at:Self.Index)", "this.replaceSubrangeWith({$setThis: $val => $info0x7fec2b87cb48.$setThis(_cloneStruct($val)), Self: $info.Self, C: $info.C}, $info.Self.Index.infix_46_46_60({Self: $info.Self.Index}, i, i), newElements)"],
  ["Swift.(file).RangeReplaceableCollection.remove(at:Self.Index)", "preconditionFileLine({}, () => Bool.prefix_33({}, this.isEmpty), () => \"Can't remove from an empty collection\", '?3', '?3');\nconst result = this.subscript$get({}, position);\nthis.replaceSubrangeWith({$setThis: $val => $info0x7ff4b4006738.$setThis(_cloneStruct($val)), Self: this.$info.Self, C: _clarifyGenerics({Self:EmptyCollection, Element: this.$info.Self.Element})}, this.$info.Self.Index.infix_46_46_60({Self: this.$info.Self.Index}, position, this.indexAfter({Self: this.$info.Self}, position)), _create(EmptyCollection, 'init', {Element: this.$info.Self.Element}, ));\nreturn result"],
  ["Swift.(file).RangeReplaceableCollection.removeSubrange(_:Range<Self.Index>)", "this.replaceSubrangeWith({$setThis: $val => $info0x7fcfca8c5150.$setThis(_cloneStruct($val)), Self: this.$info.Self, C: _clarifyGenerics({Self:EmptyCollection, Element: this.$info.Self.Element})}, bounds, _create(EmptyCollection, 'init', {Element: this.$info.Self.Element}, ))"],
  ["Swift.(file).RangeReplaceableCollection.removeFirst(_:Int)", "{\nif((Int.infix_61_61({}, k, 0))) {\nreturn ;\n}\n};\npreconditionFileLine({}, () => Int.infix_62_61({}, k, 0), () => \"Number of elements to remove should be non-negative\", '?3', '?3');\npreconditionFileLine({}, () => Int.infix_62_61({}, this.count, k), () => \"Can't remove more items from a collection than it has\", '?3', '?3');\nconst end = this.indexOffsetBy({Self: this.$info.Self}, this.startIndex, k);\nthis.removeSubrange({$setThis: $val => $info0x7f9a720b0d18.$setThis(_cloneStruct($val)), Self: this.$info.Self}, this.$info.Self.Index.infix_46_46_60({Self: this.$info.Self.Index}, this.startIndex, end))"],
  ["Swift.(file).RangeReplaceableCollection.removeFirst()", "preconditionFileLine({}, () => Bool.prefix_33({}, this.isEmpty), () => \"Can't remove first element from an empty collection\", '?3', '?3');\nconst firstElement = this.first;\nthis.removeFirstMultiple({$setThis: $val => $info0x7f9ac50d8030.$setThis(_cloneStruct($val)), Self: this.$info.Self}, 1);\nreturn firstElement"],
  ["Swift.(file).RangeReplaceableCollection.removeAll(keepingCapacity:Bool)", "{\nif((Bool.prefix_33({}, keepCapacity))) {\n$info0x7fde50901f90.$setThis(_cloneStruct(_create(this.$info.Self, 'init', {Self: this.$info.Self}, )));\n}\nelse {\nthis.replaceSubrangeWith({$setThis: $val => $info0x7fde50901f90.$setThis(_cloneStruct($val)), Self: this.$info.Self, C: _clarifyGenerics({Self:EmptyCollection, Element: this.$info.Self.Element})}, this.$info.Self.Index.infix_46_46_60({Self: this.$info.Self.Index}, this.startIndex, this.endIndex), _create(EmptyCollection, 'init', {Element: this.$info.Self.Element}, ));\n}\n}"],
  ["Swift.(file).RangeReplaceableCollection.reserveCapacity(_:Int)", ""],
  ["Swift.(file).RangeReplaceableCollection.replaceSubrange(_:R,with:C)", "this.replaceSubrangeWith({$setThis: $val => $info0x7fac2b0ec418.$setThis(_cloneStruct($val)), Self: $info.Self, C: $info.C}, subrange.relativeTo({Self: $info.R, C: $info.Self}, this), newElements)"],
  ["Swift.(file).RangeReplaceableCollection.removeSubrange(_:R)", "this.removeSubrange({$setThis: $val => $info0x7f88a6081840.$setThis(_cloneStruct($val)), Self: $info.Self}, bounds.relativeTo({Self: $info.R, C: $info.Self}, this))"],
  ["Swift.(file).RangeReplaceableCollection.removeLast(_:Int)", "{\nif((Int.infix_61_61({}, k, 0))) {\nreturn ;\n}\n};\npreconditionFileLine({}, () => Int.infix_62_61({}, k, 0), () => \"Number of elements to remove should be non-negative\", '?3', '?3');\npreconditionFileLine({}, () => Int.infix_62_61({}, this.count, k), () => \"Can't remove more items from a collection than it contains\", '?3', '?3');\n{\nif((this._customRemoveLast({$setThis: $val => $info0x7fe1188d3318.$setThis(_cloneStruct($val)), Self: this.$info.Self}, k))) {\nreturn ;\n}\n};\nconst end = this.endIndex;\nthis.removeSubrange({$setThis: $val => $info0x7fe1188d3318.$setThis(_cloneStruct($val)), Self: this.$info.Self}, this.$info.Self.Index.infix_46_46_60({Self: this.$info.Self.Index}, this.indexOffsetBy({Self: this.$info.Self}, end, Int.prefix_45({Self: Int}, k)), end))"],
  ["Swift.(file).RangeReplaceableCollection.removeLast(_:Int)", "{\nif((Int.infix_61_61({}, k, 0))) {\nreturn ;\n}\n};\npreconditionFileLine({}, () => Int.infix_62_61({}, k, 0), () => \"Number of elements to remove should be non-negative\", '?3', '?3');\npreconditionFileLine({}, () => Int.infix_62_61({}, this.count, k), () => \"Can't remove more items from a collection than it contains\", '?3', '?3');\n{\nif((this._customRemoveLast({$setThis: $val => $info0x7feb3e8c5918.$setThis(_cloneStruct($val)), Self: this.$info.Self}, k))) {\nreturn ;\n}\n};\nconst end = this.endIndex;\nthis.removeSubrange({$setThis: $val => $info0x7feb3e8c5918.$setThis(_cloneStruct($val)), Self: this.$info.Self}, this.$info.Self.Index.infix_46_46_60({Self: this.$info.Self.Index}, this.indexOffsetBy({Self: this.$info.Self}, end, Int.prefix_45({Self: Int}, k)), end))"],
  ["Swift.(file).RangeReplaceableCollection.+infix(_:Self,_:Other)", "let lhs_dupl = lhs;\nlhs_dupl.appendContentsOf({$setThis: $val => lhs_dupl = $val, Self: $info.Self, S: $info.Other}, rhs);\nreturn lhs_dupl"],
  ["Swift.(file).RangeReplaceableCollection.+infix(_:Other,_:Self)", "let result = _create($info.Self, 'init', {Self: $info.Self}, );\nresult.reserveCapacity({$setThis: $val => result = $val, Self: $info.Self}, Int.infix_43({}, rhs.count, numericCast({T: Int, U: Int}, lhs.underestimatedCount)));\nresult.appendContentsOf({$setThis: $val => result = $val, Self: $info.Self, S: $info.Other}, lhs);\nresult.appendContentsOf({$setThis: $val => result = $val, Self: $info.Self, S: $info.Self}, rhs);\nreturn result"],
  ["Swift.(file).RangeReplaceableCollection.+=infix(_:Self,_:Other)", "let lhs = lhs$inout.get()\nconst $result = (() => {\nlhs.appendContentsOf({$setThis: $val => lhs = $val, Self: $info.Self, S: $info.Other}, rhs);})()\nlhs$inout.set(lhs)\nreturn $result"],
  ["Swift.(file).RangeReplaceableCollection.+infix(_:Self,_:Other)", "let lhs_dupl = lhs;\nlhs_dupl.appendContentsOf({$setThis: $val => lhs_dupl = $val, Self: $info.Self, S: $info.Other}, rhs);\nreturn lhs_dupl"],
  ["Swift.(file).RangeReplaceableCollection.filter(_:(Self.Element) throws -> Bool)", "return _create(this.$info.Self, 'initBuffer', {Self: this.$info.Self, S: _clarifyGenerics({Self:Array, Element: this.$info.Self.Element})}, this.lazy.filterSwift({Self: _clarifyGenerics({Self:LazySequence, Base: this.$info.Self})}, isIncluded))"],
  ["Swift.(file).RangeReplaceableCollection.removeAll(where:(Self.Element) throws -> Bool)", "$info0x7fa4958df9e8.$setThis(_cloneStruct(_create(this.$info.Self, 'initBuffer', {Self: this.$info.Self, S: _clarifyGenerics({Self:Array, Element: this.$info.Self.Element})}, this.lazy.filterSwift({Self: _clarifyGenerics({Self:LazySequence, Base: this.$info.Self})}, (($info, $0) => Bool.prefix_33({}, shouldBeRemoved({}, $0)))))))"],
  ["Swift.(file).Repeated.startIndex", "return 0"],
  ["Swift.(file).Repeated.endIndex", "return this.count"],
  ["Swift.(file).Result.map(_:(Success) -> NewSuccess)", "const $match = this\nif((($match.rawValue == Result.success().rawValue))) {\nconst success = $match[0]\nreturn Result.success({Success: $info.NewSuccess, Failure: $info.Failure}, transform({}, success));\n}\nelse if((($match.rawValue == Result.failure().rawValue))) {\nconst failure = $match[0]\nreturn Result.failure({Success: $info.NewSuccess, Failure: $info.Failure}, failure);\n}"],
  ["Swift.(file).Result.mapError(_:(Failure) -> NewFailure)", "const $match = this\nif((($match.rawValue == Result.success().rawValue))) {\nconst success = $match[0]\nreturn Result.success({Success: $info.Success, Failure: $info.NewFailure}, success);\n}\nelse if((($match.rawValue == Result.failure().rawValue))) {\nconst failure = $match[0]\nreturn Result.failure({Success: $info.Success, Failure: $info.NewFailure}, transform({}, failure));\n}"],
  ["Swift.(file).Result.flatMap(_:(Success) -> Result<NewSuccess, Failure>)", "const $match = this\nif((($match.rawValue == Result.success().rawValue))) {\nconst success = $match[0]\nreturn transform({}, success);\n}\nelse if((($match.rawValue == Result.failure().rawValue))) {\nconst failure = $match[0]\nreturn Result.failure({Success: $info.NewSuccess, Failure: $info.Failure}, failure);\n}"],
  ["Swift.(file).Result.flatMapError(_:(Failure) -> Result<Success, NewFailure>)", "const $match = this\nif((($match.rawValue == Result.success().rawValue))) {\nconst success = $match[0]\nreturn Result.success({Success: $info.Success, Failure: $info.NewFailure}, success);\n}\nelse if((($match.rawValue == Result.failure().rawValue))) {\nconst failure = $match[0]\nreturn transform({}, failure);\n}"],
  ["Swift.(file).Result.get()", "const $match = this\nif((($match.rawValue == Result.success().rawValue))) {\nconst success = $match[0]\nreturn success;\n}\nelse if((($match.rawValue == Result.failure().rawValue))) {\nconst failure = $match[0]\nthrow failure;\n}"],
  ["Swift.(file).ReversedCollection.makeIterator()", "return _create(ReversedCollection.Iterator, 'init_base', {Base: this.$info.Base}, this._base)"],
  ["Swift.(file).ReversedCollection.startIndex", "return _create(ReversedCollection.Index, 'init', {Base: this.$info.Base}, this._base.endIndex)"],
  ["Swift.(file).ReversedCollection.endIndex", "return _create(ReversedCollection.Index, 'init', {Base: this.$info.Base}, this._base.startIndex)"],
  ["Swift.(file).ReversedCollection.index(after:ReversedCollection<Base>.Index)", "return _create(ReversedCollection.Index, 'init', {Base: this.$info.Base}, this._base.indexBefore({Self: this.$info.Base}, i.base))"],
  ["Swift.(file).ReversedCollection.index(before:ReversedCollection<Base>.Index)", "return _create(ReversedCollection.Index, 'init', {Base: this.$info.Base}, this._base.indexAfter({Self: this.$info.Base}, i.base))"],
  ["Swift.(file).ReversedCollection.index(_:ReversedCollection<Base>.Index,offsetBy:Int)", "return _create(ReversedCollection.Index, 'init', {Base: this.$info.Base}, this._base.indexOffsetBy({Self: this.$info.Base}, i.base, Int.prefix_45({Self: Int}, n)))"],
  ["Swift.(file).ReversedCollection.index(_:ReversedCollection<Base>.Index,offsetBy:Int,limitedBy:ReversedCollection<Base>.Index)", "return this._base.indexOffsetByLimitedBy({Self: this.$info.Base}, i.base, Int.prefix_45({Self: Int}, n), limit.base).mapSwift({Wrapped: this.$info.Base.Index, U: _clarifyGenerics({Self:ReversedCollection, Base: this.$info.Base}).Index}, init({Base: this.$info.Base}, ReversedCollection.Index))"],
  ["Swift.(file).ReversedCollection.distance(from:ReversedCollection<Base>.Index,to:ReversedCollection<Base>.Index)", "return this._base.distanceFromTo({Self: this.$info.Base}, end.base, start.base)"],
  ["Swift.(file).ReversedCollection.reversed()", "return this._base"],
  ["Swift.(file).Sequence.makeIterator()", "return this"],
  ["Swift.(file).Sequence.map(_:(Self.Element) throws -> T)", "const initialCapacity = this.underestimatedCount;\nlet result = _create(ContiguousArray, 'init', {Element: $info.T}, );\nresult.reserveCapacity({$setThis: $val => result = $val, Element: $info.T}, initialCapacity);\nlet iterator = this.makeIterator({Self: $info.Self}, );\n{\nlet $generator = _cloneStruct(Int.infix_46_46_60({Self: Int}, 0, initialCapacity).makeIterator({Self: _clarifyGenerics({Self:Range, Bound: Int})}, ));\nwhile(true) {\nif($generator.next({$setThis: $val => $generator = $val, Elements: _clarifyGenerics({Self:Range, Bound: Int})}, ) == null) break;\nresult.append({$setThis: $val => result = $val, Element: $info.T}, transform({}, iterator.next({$setThis: $val => iterator = $val, Self: $info.Self.Iterator}, )));\n}\n};\nwhile(true){\nconst _element = iterator.next({$setThis: $val => iterator = $val, Self: $info.Self.Iterator}, )\nif(!((_element != null))) break\nresult.append({$setThis: $val => result = $val, Element: $info.T}, transform({}, _element));\n};\nreturn _create(Array, 'initBuffer', {Element: $info.T, S: _clarifyGenerics({Self:ContiguousArray, Element: $info.T})}, result)"],
  ["Swift.(file).Sequence.filter(_:(Self.Element) throws -> Bool)", "return this._filter({Self: this.$info.Self}, isIncluded)"],
  ["Swift.(file).Sequence.underestimatedCount", " return this.underestimatedCount$internal "],
  ["Swift.(file).Sequence.forEach(_:(Self.Element) throws -> Void)", "{\nlet $element$generator = this.makeIterator({Self: this.$info.Self}, );\nwhile(true) {\nconst _element = $element$generator.next({$setThis: $val => $element$generator = $val, Self: this.$info.Self.Iterator}, );\nif(!((_element != null))) break;\nbody({}, _element);\n}\n}"],
  ["Swift.(file).Sequence.first(where:(Self.Element) throws -> Bool)", "{\nlet $element$generator = this.makeIterator({Self: this.$info.Self}, );\nwhile(true) {\nconst _element = $element$generator.next({$setThis: $val => $element$generator = $val, Self: this.$info.Self.Iterator}, );\nif(!((_element != null))) break;\n{\nif((predicate({}, _element))) {\nreturn _element;\n}\n};\n}\n};\nreturn null"],
  ["Swift.(file).Sequence.split(maxSplits:Int,omittingEmptySubsequences:Bool,whereSeparator:(Self.Element) throws -> Bool)", "preconditionFileLine({}, () => Int.infix_62_61({}, maxSplits, 0), () => \"Must take zero or more splits\", '?3', '?3');\nconst whole = _create(Array, 'initBuffer', {Element: this.$info.Self.Element, S: this.$info.Self}, this);\nreturn whole.splitMaxSplitsOmittingEmptySubsequencesWhereSeparator({Self: _clarifyGenerics({Self:Array, Element: this.$info.Self.Element})}, maxSplits, omittingEmptySubsequences, isSeparator)"],
  ["Swift.(file).Sequence.suffix(_:Int)", "preconditionFileLine({}, () => Int.infix_62_61({}, maxLength, 0), () => \"Can't take a suffix of negative length from a sequence\", '?3', '?3');\n{\nif(!((Int.infix_33_61({Self: Int}, maxLength, 0)))) {\nreturn _create(Array, 'initBuffer', {Element: this.$info.Self.Element}, []);\n}\n};\nlet ringBuffer = _create(Array, 'initBuffer', {Element: this.$info.Self.Element}, []);\nringBuffer.reserveCapacity({$setThis: $val => ringBuffer = $val, Element: this.$info.Self.Element}, /*dot_syntax_base_ignored*/min({}, maxLength, this.underestimatedCount));\nlet i = 0;\n{\nlet $element$generator = this.makeIterator({Self: this.$info.Self}, );\nwhile(true) {\nconst _element = $element$generator.next({$setThis: $val => $element$generator = $val, Self: this.$info.Self.Iterator}, );\nif(!((_element != null))) break;\n{\nif((Int.infix_60({}, ringBuffer.count, maxLength))) {\nringBuffer.append({$setThis: $val => ringBuffer = $val, Element: this.$info.Self.Element}, _element);\n}\nelse {\nringBuffer.subscript$set({$setThis: $val => ringBuffer = $val}, _element, i);\nInt.infix_43_61({}, {get: () => i, set: $val => i = $val}, 1);\nInt.infix_37_61({}, {get: () => i, set: $val => i = $val}, maxLength);\n}\n};\n}\n};\n{\nif((Int.infix_33_61({Self: Int}, i, ringBuffer.startIndex))) {\nlet rotated = _create(Array, 'initBuffer', {Element: this.$info.Self.Element}, []);\nrotated.reserveCapacity({$setThis: $val => rotated = $val, Element: this.$info.Self.Element}, ringBuffer.count);\nArray.infix_43_61({Self: _clarifyGenerics({Self:Array, Element: this.$info.Self.Element}), Other: _clarifyGenerics({Self:ArraySlice, Element: this.$info.Self.Element})}, {get: () => rotated, set: $val => rotated = $val}, ringBuffer.subscriptRange$get({}, Int.infix_46_46_60({Self: Int}, i, ringBuffer.endIndex)));\nArray.infix_43_61({Self: _clarifyGenerics({Self:Array, Element: this.$info.Self.Element}), Other: _clarifyGenerics({Self:ArraySlice, Element: this.$info.Self.Element})}, {get: () => rotated, set: $val => rotated = $val}, ringBuffer.subscriptRange$get({}, Int.infix_46_46_60({Self: Int}, 0, i)));\nreturn rotated;\n}\nelse {\nreturn ringBuffer;\n}\n}"],
  ["Swift.(file).Sequence.dropFirst(_:Int)", "return _create(DropFirstSequence, 'initDroppingInt', {Base: this.$info.Self}, this, k)"],
  ["Swift.(file).Sequence.dropLast(_:Int)", "preconditionFileLine({}, () => Int.infix_62_61({}, k, 0), () => \"Can't drop a negative number of elements from a sequence\", '?3', '?3');\n{\nif(!((Int.infix_33_61({Self: Int}, k, 0)))) {\nreturn _create(Array, 'initBuffer', {Element: this.$info.Self.Element, S: this.$info.Self}, this);\n}\n};\nlet result = _create(Array, 'initBuffer', {Element: this.$info.Self.Element}, []);\nlet ringBuffer = _create(Array, 'initBuffer', {Element: this.$info.Self.Element}, []);\nlet i = ringBuffer.startIndex;\n{\nlet $element$generator = this.makeIterator({Self: this.$info.Self}, );\nwhile(true) {\nconst _element = $element$generator.next({$setThis: $val => $element$generator = $val, Self: this.$info.Self.Iterator}, );\nif(!((_element != null))) break;\n{\nif((Int.infix_60({}, ringBuffer.count, k))) {\nringBuffer.append({$setThis: $val => ringBuffer = $val, Element: this.$info.Self.Element}, _element);\n}\nelse {\nresult.append({$setThis: $val => result = $val, Element: this.$info.Self.Element}, ringBuffer.subscript$get({}, i));\nringBuffer.subscript$set({$setThis: $val => ringBuffer = $val}, _element, i);\nInt.infix_43_61({}, {get: () => i, set: $val => i = $val}, 1);\nInt.infix_37_61({}, {get: () => i, set: $val => i = $val}, k);\n}\n};\n}\n};\nreturn result"],
  ["Swift.(file).Sequence.prefix(_:Int)", "return _create(PrefixSequence, 'initMaxLengthInt', {Base: this.$info.Self}, this, maxLength)"],
  ["Swift.(file).Sequence.prefix(while:(Self.Element) throws -> Bool)", "let result = _create(Array, 'initBuffer', {Element: this.$info.Self.Element}, []);\n{\nlet $element$generator = this.makeIterator({Self: this.$info.Self}, );\nwhile(true) {\nconst _element = $element$generator.next({$setThis: $val => $element$generator = $val, Self: this.$info.Self.Iterator}, );\nif(!((_element != null))) break;\n{\nif(!((predicate({}, _element)))) {\nbreak;\n}\n};\nresult.append({$setThis: $val => result = $val, Element: this.$info.Self.Element}, _element);\n}\n};\nreturn result"],
  ["Swift.(file).Sequence.withContiguousStorageIfAvailable(_:(UnsafeBufferPointer<Self.Element>) throws -> R)", "return null"],
  ["Swift.(file).Sequence.min(by:(Self.Element, Self.Element) throws -> Bool)", "let it = this.makeIterator({Self: this.$info.Self}, );\n{let result = it.next({$setThis: $val => it = $val, Self: this.$info.Self.Iterator}, )\nif(!((result != null))) {\nreturn null;\n}\n};\nwhile(true){\nconst e = it.next({$setThis: $val => it = $val, Self: this.$info.Self.Iterator}, )\nif(!((e != null))) break\n{\nif((areInIncreasingOrder({}, e, result))) {\nresult = e;\n}\n};\n};\nreturn result"],
  ["Swift.(file).Sequence.max(by:(Self.Element, Self.Element) throws -> Bool)", "let it = this.makeIterator({Self: this.$info.Self}, );\n{let result = it.next({$setThis: $val => it = $val, Self: this.$info.Self.Iterator}, )\nif(!((result != null))) {\nreturn null;\n}\n};\nwhile(true){\nconst e = it.next({$setThis: $val => it = $val, Self: this.$info.Self.Iterator}, )\nif(!((e != null))) break\n{\nif((areInIncreasingOrder({}, result, e))) {\nresult = e;\n}\n};\n};\nreturn result"],
  ["Swift.(file).Sequence.starts(with:PossiblePrefix,by:(Self.Element, PossiblePrefix.Element) throws -> Bool)", "let possiblePrefixIterator = possiblePrefix.makeIterator({Self: $info.PossiblePrefix}, );\n{\nlet $e0$generator = this.makeIterator({Self: $info.Self}, );\nwhile(true) {\nconst e0 = $e0$generator.next({$setThis: $val => $e0$generator = $val, Self: $info.Self.Iterator}, );\nif(!((e0 != null))) break;\n{const e1 = possiblePrefixIterator.next({$setThis: $val => possiblePrefixIterator = $val, Self: $info.PossiblePrefix.Iterator}, )\nif((e1 != null)) {\n{\nif((Bool.prefix_33({}, areEquivalent({}, e0, e1)))) {\nreturn false;\n}\n};\n}\nelse {\nreturn true;\n}\n};\n}\n};\nreturn Optional.infix_61_61({Wrapped: $info.PossiblePrefix.Element}, possiblePrefixIterator.next({$setThis: $val => possiblePrefixIterator = $val, Self: $info.PossiblePrefix.Iterator}, ), null)"],
  ["Swift.(file).Sequence.elementsEqual(_:OtherSequence,by:(Self.Element, OtherSequence.Element) throws -> Bool)", "let iter1 = this.makeIterator({Self: $info.Self}, );\nlet iter2 = other.makeIterator({Self: $info.OtherSequence}, );\nwhile(true){\nif(!((true))) break\nconst $match = {0: iter1.next({$setThis: $val => iter1 = $val, Self: $info.Self.Iterator}, ), 1: iter2.next({$setThis: $val => iter2 = $val, Self: $info.OtherSequence.Iterator}, )}\nif(((true))) {\nconst e1 = $match[0]\nconst e2 = $match[1]\n{\nif((Bool.prefix_33({}, areEquivalent({}, e1, e2)))) {\nreturn false;\n}\n};\n}\nelse if((($match.rawValue == Optional.none.rawValue) || ($match.rawValue == Optional.none.rawValue))) {\nreturn false;\n}\nelse if((($match.rawValue == Optional.none.rawValue && $match.rawValue == Optional.none.rawValue))) {\nreturn true;\n};\n}"],
  ["Swift.(file).Sequence.lexicographicallyPrecedes(_:OtherSequence,by:(Self.Element, Self.Element) throws -> Bool)", "let iter1 = this.makeIterator({Self: $info.Self}, );\nlet iter2 = other.makeIterator({Self: $info.OtherSequence}, );\nwhile(true){\nif(!((true))) break\n{const e1 = iter1.next({$setThis: $val => iter1 = $val, Self: $info.Self.Iterator}, )\nif((e1 != null)) {\n{const e2 = iter2.next({$setThis: $val => iter2 = $val, Self: $info.OtherSequence.Iterator}, )\nif((e2 != null)) {\n{\nif((areInIncreasingOrder({}, e1, e2))) {\nreturn true;\n}\n};\n{\nif((areInIncreasingOrder({}, e2, e1))) {\nreturn false;\n}\n};\ncontinue;\n}\n};\nreturn false;\n}\n};\nreturn Optional.infix_33_61({Wrapped: $info.Self.Element}, iter2.next({$setThis: $val => iter2 = $val, Self: $info.OtherSequence.Iterator}, ), null);\n}"],
  ["Swift.(file).Sequence.contains(where:(Self.Element) throws -> Bool)", "{\nlet $e$generator = this.makeIterator({Self: this.$info.Self}, );\nwhile(true) {\nconst e = $e$generator.next({$setThis: $val => $e$generator = $val, Self: this.$info.Self.Iterator}, );\nif(!((e != null))) break;\n{\nif((predicate({}, e))) {\nreturn true;\n}\n};\n}\n};\nreturn false"],
  ["Swift.(file).Sequence.allSatisfy(_:(Self.Element) throws -> Bool)", "return Bool.prefix_33({}, this.containsWhere({Self: this.$info.Self}, (($info, $0) => Bool.prefix_33({}, predicate({}, $0)))))"],
  ["Swift.(file).Sequence.count(where:(Self.Element) throws -> Bool)", "let count = 0;\n{\nlet $e$generator = this.makeIterator({Self: this.$info.Self}, );\nwhile(true) {\nconst e = $e$generator.next({$setThis: $val => $e$generator = $val, Self: this.$info.Self.Iterator}, );\nif(!((e != null))) break;\n{\nif((predicate({}, e))) {\nInt.infix_43_61({}, {get: () => count, set: $val => count = $val}, 1);\n}\n};\n}\n};\nreturn count"],
  ["Swift.(file).Sequence.reduce(_:Result,_:(Result, Self.Element) throws -> Result)", "let accumulator = initialResult;\n{\nlet $element$generator = this.makeIterator({Self: $info.Self}, );\nwhile(true) {\nconst _element = $element$generator.next({$setThis: $val => $element$generator = $val, Self: $info.Self.Iterator}, );\nif(!((_element != null))) break;\naccumulator = nextPartialResult({}, accumulator, _element);\n}\n};\nreturn accumulator"],
  ["Swift.(file).Sequence.reduce(into:Result,_:(inout Result, Self.Element) throws -> ())", "let accumulator = initialResult;\n{\nlet $element$generator = this.makeIterator({Self: $info.Self}, );\nwhile(true) {\nconst _element = $element$generator.next({$setThis: $val => $element$generator = $val, Self: $info.Self.Iterator}, );\nif(!((_element != null))) break;\nupdateAccumulatingResult({}, {get: () => accumulator, set: $val => accumulator = $val}, _element);\n}\n};\nreturn accumulator"],
  ["Swift.(file).Sequence.reversed()", "let result = _create(Array, 'initBuffer', {Element: this.$info.Self.Element, S: this.$info.Self}, this);\nconst count = result.count;\n{\nlet $i$generator = _cloneStruct(Int.infix_46_46_60({Self: Int}, 0, Int.infix_47({}, count, 2)).makeIterator({Self: _clarifyGenerics({Self:Range, Bound: Int})}, ));\nwhile(true) {\nconst i = $i$generator.next({$setThis: $val => $i$generator = $val, Elements: _clarifyGenerics({Self:Range, Bound: Int})}, );\nif(!((i != null))) break;\nresult.swapAt({$setThis: $val => result = $val, Self: _clarifyGenerics({Self:Array, Element: this.$info.Self.Element})}, i, Int.infix_45({}, count, Int.infix_43({}, i, 1)));\n}\n};\nreturn result"],
  ["Swift.(file).Sequence.flatMap(_:(Self.Element) throws -> SegmentOfResult)", "let result = _create(Array, 'initBuffer', {Element: $info.SegmentOfResult.Element}, []);\n{\nlet $element$generator = this.makeIterator({Self: $info.Self}, );\nwhile(true) {\nconst _element = $element$generator.next({$setThis: $val => $element$generator = $val, Self: $info.Self.Iterator}, );\nif(!((_element != null))) break;\nresult.appendContentsOf({$setThis: $val => result = $val, Element: $info.SegmentOfResult.Element, S: $info.SegmentOfResult}, transform({}, _element));\n}\n};\nreturn result"],
  ["Swift.(file).Sequence.compactMap(_:(Self.Element) throws -> ElementOfResult?)", "return this._compactMap({Self: $info.Self, ElementOfResult: $info.ElementOfResult}, transform)"],
  ["Swift.(file).Set.filter(_:(Element) throws -> Bool)", "let result = _create(Set, 'init', {Element: this.$info.Element}, );\n{\nlet $element$generator = _cloneStruct(this.makeIterator({Element: this.$info.Element}, ));\nwhile(true) {\nconst _element = $element$generator.next({$setThis: $val => $element$generator = $val, Element: this.$info.Element}, );\nif(!((_element != null))) break;\n{\nif((isIncluded({}, _element))) {\nresult.insert({$setThis: $val => result = $val, Element: this.$info.Element}, _element);\n}\n};\n}\n};\nreturn result"],
  ["Swift.(file).Set.isEmpty", "return Int.infix_61_61({}, this.count, 0)"],
  ["Swift.(file).Set.removeFirst()", "preconditionFileLine({}, () => Bool.prefix_33({}, this.isEmpty), () => \"Can't removeFirst from an empty Set\", '?3', '?3');\nreturn this.removeAt({$setThis: $val => $info0x7fbde6100818.$setThis(_cloneStruct($val)), Element: this.$info.Element}, this.startIndex)"],
  ["Swift.(file).Set.isSubset(of:S)", "{\nif(!((Bool.prefix_33({}, this.isEmpty)))) {\nreturn true;\n}\n};\nconst other = _create(Set, 'initSource', {Element: $info.Element, Source: $info.S}, possibleSuperset);\nreturn this.isSubsetOf({Element: $info.Element}, other)"],
  ["Swift.(file).Set.isStrictSubset(of:S)", "const other = _create(Set, 'initSource', {Element: $info.Element, Source: $info.S}, possibleStrictSuperset);\nreturn this.isStrictSubsetOf({Element: $info.Element}, other)"],
  ["Swift.(file).Set.isSuperset(of:S)", "{\nlet $member$generator = possibleSubset.makeIterator({Self: $info.S}, );\nwhile(true) {\nconst member = $member$generator.next({$setThis: $val => $member$generator = $val, Self: $info.S.Iterator}, );\nif(!((member != null))) break;\n{\nif((Bool.prefix_33({}, this.contains({Element: $info.Element}, member)))) {\nreturn false;\n}\n};\n}\n};\nreturn true"],
  ["Swift.(file).Set.isStrictSuperset(of:S)", "const other = _create(Set, 'initSource', {Element: $info.Element, Source: $info.S}, possibleStrictSubset);\nreturn other.isStrictSubsetOf({Element: $info.Element}, this)"],
  ["Swift.(file).Set.union(_:S)", "let newSet = _cloneStruct(this);\nnewSet.formUnion({$setThis: $val => newSet = $val, Element: $info.Element, S: $info.S}, other);\nreturn newSet"],
  ["Swift.(file).Set.formUnion(_:S)", "{\nlet $item$generator = other.makeIterator({Self: $info.S}, );\nwhile(true) {\nconst item = $item$generator.next({$setThis: $val => $item$generator = $val, Self: $info.S.Iterator}, );\nif(!((item != null))) break;\nthis.insert({$setThis: $val => $info0x7fcbd8020220.$setThis(_cloneStruct($val)), Element: $info.Element}, item);\n}\n}"],
  ["Swift.(file).Set.intersection(_:S)", "const otherSet = _create(Set, 'initSource', {Element: $info.Element, Source: $info.S}, other);\nreturn this.intersection({Element: $info.Element}, otherSet)"],
  ["Swift.(file).Set.formIntersection(_:S)", "const result = _cloneStruct(this.intersection({Element: $info.Element, S: $info.S}, other));\n{\nif((Int.infix_33_61({Self: Int}, result.count, this.count))) {\n$info0x7fa12f80da10.$setThis(_cloneStruct(_cloneStruct(result)));\n}\n}"],
  ["Swift.(file).Set.symmetricDifference(_:S)", "let newSet = _cloneStruct(this);\nnewSet.formSymmetricDifference({$setThis: $val => newSet = $val, Element: $info.Element, S: $info.S}, other);\nreturn newSet"],
  ["Swift.(file).Set.formSymmetricDifference(_:S)", "const otherSet = _create(Set, 'initSource', {Element: $info.Element, Source: $info.S}, other);\nthis.formSymmetricDifference({$setThis: $val => $info0x7ff4ab881a28.$setThis(_cloneStruct($val)), Element: $info.Element}, otherSet)"],
  ["Swift.(file).Set.isSubset(of:Set<Element>)", "{\nif(!((Int.infix_60_61({}, this.count, other.count)))) {\nreturn false;\n}\n};\n{\nlet $member$generator = _cloneStruct(this.makeIterator({Element: this.$info.Element}, ));\nwhile(true) {\nconst member = $member$generator.next({$setThis: $val => $member$generator = $val, Element: this.$info.Element}, );\nif(!((member != null))) break;\n{\nif((Bool.prefix_33({}, other.contains({Element: this.$info.Element}, member)))) {\nreturn false;\n}\n};\n}\n};\nreturn true"],
  ["Swift.(file).Set.isSuperset(of:Set<Element>)", "return other.isSubsetOf({Element: this.$info.Element}, this)"],
  ["Swift.(file).Set.isStrictSuperset(of:Set<Element>)", "return Bool.infix_38_38({}, this.isSupersetOf({Element: this.$info.Element}, other), () => Set.infix_33_61({Self: _clarifyGenerics({Self:Set, Element: this.$info.Element})}, this, other))"],
  ["Swift.(file).Set.isStrictSubset(of:Set<Element>)", "return other.isStrictSupersetOf({Element: this.$info.Element}, this)"],
  ["Swift.(file).Set.intersection(_:Set<Element>)", "let newSet = _create(Set, 'init', {Element: this.$info.Element}, );\n{\nlet $member$generator = _cloneStruct(this.makeIterator({Element: this.$info.Element}, ));\nwhile(true) {\nconst member = $member$generator.next({$setThis: $val => $member$generator = $val, Element: this.$info.Element}, );\nif(!((member != null))) break;\n{\nif((other.contains({Element: this.$info.Element}, member))) {\nnewSet.insert({$setThis: $val => newSet = $val, Element: this.$info.Element}, member);\n}\n};\n}\n};\nreturn newSet"],
  ["Swift.(file).Set.formSymmetricDifference(_:Set<Element>)", "{\nlet $member$generator = _cloneStruct(other.makeIterator({Element: this.$info.Element}, ));\nwhile(true) {\nconst member = $member$generator.next({$setThis: $val => $member$generator = $val, Element: this.$info.Element}, );\nif(!((member != null))) break;\n{\nif((this.contains({Element: this.$info.Element}, member))) {\nthis.remove({$setThis: $val => $info0x7f927e88fb40.$setThis(_cloneStruct($val)), Element: this.$info.Element}, member);\n}\nelse {\nthis.insert({$setThis: $val => $info0x7f927e88fb40.$setThis(_cloneStruct($val)), Element: this.$info.Element}, member);\n}\n};\n}\n}"],
  ["Swift.(file).Set.customMirror", "const style = Mirror.DisplayStyle.set;\nreturn _create(Mirror, 'initUnlabeledChildrenDisplayStyleOptionalAncestorRepresentationMirrorAncestorRepresentation', {Subject: _clarifyGenerics({Self:Set, Element: this.$info.Element}), C: _clarifyGenerics({Self:Set, Element: this.$info.Element})}, this, this, style, null)"],
  ["Swift.(file).Set.popFirst()", "{\nif(!((Bool.prefix_33({}, this.isEmpty)))) {\nreturn null;\n}\n};\nreturn this.removeAt({$setThis: $val => $info0x7f8d930dfc30.$setThis(_cloneStruct($val)), Element: this.$info.Element}, this.startIndex)"],
  ["Swift.(file).SetAlgebra.subtract(_:Self)", "this.formIntersection({$setThis: $val => $info0x7ff6a80274d0.$setThis(_cloneStruct($val)), Self: this.$info.Self}, this.symmetricDifference({Self: this.$info.Self}, other))"],
  ["Swift.(file).SetAlgebra.isSubset(of:Self)", "return this.$info.Self.infix_61_61({Self: this.$info.Self}, this.intersection({Self: this.$info.Self}, other), this)"],
  ["Swift.(file).SetAlgebra.isSuperset(of:Self)", "return other.isSubsetOf({Self: this.$info.Self}, this)"],
  ["Swift.(file).SetAlgebra.isDisjoint(with:Self)", "return this.intersection({Self: this.$info.Self}, other).isEmpty"],
  ["Swift.(file).SetAlgebra.subtracting(_:Self)", "return this.intersection({Self: this.$info.Self}, this.symmetricDifference({Self: this.$info.Self}, other))"],
  ["Swift.(file).SetAlgebra.isEmpty", " return this.isEmpty$internal "],
  ["Swift.(file).SetAlgebra.isStrictSuperset(of:Self)", "return Bool.infix_38_38({}, this.isSupersetOf({Self: this.$info.Self}, other), () => this.$info.Self.infix_33_61({Self: this.$info.Self}, this, other))"],
  ["Swift.(file).SetAlgebra.isStrictSubset(of:Self)", "return other.isStrictSupersetOf({Self: this.$info.Self}, this)"],
  ["Swift.(file).Set.insert(_:ConcreteElement)", "const $tuple = this.insert({$setThis: $val => $info0x7fbec18df560.$setThis(_cloneStruct($val)), Element: $info.Element, ConcreteElement: AnyHashable}, _create(AnyHashable, 'init', {H: $info.ConcreteElement}, newMember)), inserted = $tuple && $tuple[0], memberAfterInsert = $tuple && $tuple[1];\nreturn {0: inserted, 1: memberAfterInsert.base}"],
  ["Swift.(file).Set.update(with:ConcreteElement)", "return this.updateWith({$setThis: $val => $info0x7fdb7f0f2c60.$setThis(_cloneStruct($val)), Element: $info.Element, ConcreteElement: AnyHashable}, _create(AnyHashable, 'init', {H: $info.ConcreteElement}, newMember)).mapSwift({Wrapped: AnyHashable, U: $info.ConcreteElement}, (($info, $0) => $0.base))"],
  ["Swift.(file).Set.remove(_:ConcreteElement)", "return this.remove({$setThis: $val => $info0x7ffd120e0e40.$setThis(_cloneStruct($val)), Element: $info.Element, ConcreteElement: AnyHashable}, _create(AnyHashable, 'init', {H: $info.ConcreteElement}, member)).mapSwift({Wrapped: AnyHashable, U: $info.ConcreteElement}, (($info, $0) => $0.base))"],
  ["Swift.(file).Slice.startIndex", "return this._startIndex"],
  ["Swift.(file).Slice.endIndex", "return this._endIndex"],
  ["Swift.(file).Sequence.sorted(by:(Self.Element, Self.Element) throws -> Bool)", "let result = _create(ContiguousArray, 'initBuffer', {Element: this.$info.Self.Element, S: this.$info.Self}, this);\nresult.sortBy({$setThis: $val => result = $val, Self: _clarifyGenerics({Self:ContiguousArray, Element: this.$info.Self.Element})}, areInIncreasingOrder);\nreturn _create(Array, 'initBuffer', {Element: this.$info.Self.Element, S: _clarifyGenerics({Self:ContiguousArray, Element: this.$info.Self.Element})}, result)"],
  ["Swift.(file).MutableCollection.sort(by:(Self.Element, Self.Element) throws -> Bool)", "const didSortUnsafeBuffer = this._withUnsafeMutableBufferPointerIfSupported({$setThis: $val => $info0x7fc89b8b2640.$setThis(_cloneStruct($val)), Self: this.$info.Self, R: _clarifyGenerics({Self:Optional, Wrapped: Void})}, (($info, buffer$inout) => buffer._stableSortImplBy({$setThis: $val => buffer = $val, Element: this.$info.Self.Element}, areInIncreasingOrder)));\n{\nif((Optional.infix_61_61({Wrapped: _clarifyGenerics({Self:Optional, Wrapped: Void})}, didSortUnsafeBuffer, null))) {\nconst sortedElements = _cloneStruct(this.sortedBy({Self: this.$info.Self}, areInIncreasingOrder));\n{\nlet $generator = _cloneStruct(zip({Sequence1: this.$info.Self.Indices, Sequence2: _clarifyGenerics({Self:Range, Bound: _clarifyGenerics({Self:Array, Element: {$genericType: 'Element'}}).Index})}, this.indices, sortedElements.indices).makeIterator({Sequence1: this.$info.Self.Indices, Sequence2: _clarifyGenerics({Self:Range, Bound: _clarifyGenerics({Self:Array, Element: {$genericType: 'Element'}}).Index})}, ));\nwhile(true) {\nconst $tuple = $generator.next({$setThis: $val => $generator = $val, Sequence1: this.$info.Self.Indices, Sequence2: _clarifyGenerics({Self:Range, Bound: _clarifyGenerics({Self:Array, Element: {$genericType: 'Element'}}).Index})}, ), i = $tuple && $tuple[0], j = $tuple && $tuple[1];\nif(!((i != null) && (j != null))) break;\nthis.subscript$set({$setThis: $val => $info0x7fc89b8b2640.$setThis(_cloneStruct($val))}, sortedElements.subscript$get({}, j), i);\n}\n};\n}\n}"],
  ["Swift.(file).StaticString.debugDescription", "return this.description.debugDescription"],
  ["Swift.(file).StaticString.customMirror", "return _create(Mirror, 'initReflectingprotocol_composition_type', {}, this.description)"],
  ["Swift.(file).Strideable.<infix(_:Self,_:Self)", "return $info.Self.Stride.infix_62({Self: $info.Self.Stride}, x.distanceTo({Self: $info.Self}, y), _create($info.Self.Stride, 'initIntegerLiteral', {Self: $info.Self.Stride}, 0))"],
  ["Swift.(file).Strideable.==infix(_:Self,_:Self)", "return $info.Self.Stride.infix_61_61({Self: $info.Self.Stride}, x.distanceTo({Self: $info.Self}, y), _create($info.Self.Stride, 'initIntegerLiteral', {Self: $info.Self.Stride}, 0))"],
  ["Swift.(file).StrideTo.underestimatedCount", "let it = _cloneStruct(this.makeIterator({Element: this.$info.Element}, ));\nlet count = 0;\nwhile(true){\nif(!((Optional.infix_33_61({Wrapped: this.$info.Element}, it.next({$setThis: $val => it = $val, Element: this.$info.Element}, ), null)))) break\nInt.infix_43_61({}, {get: () => count, set: $val => count = $val}, 1);\n};\nreturn count"],
  ["Swift.(file).StrideThrough.underestimatedCount", "let it = _cloneStruct(this.makeIterator({Element: this.$info.Element}, ));\nlet count = 0;\nwhile(true){\nif(!((Optional.infix_33_61({Wrapped: this.$info.Element}, it.next({$setThis: $val => it = $val, Element: this.$info.Element}, ), null)))) break\nInt.infix_43_61({}, {get: () => count, set: $val => count = $val}, 1);\n};\nreturn count"],
  ["Swift.(file).String.debugDescription", "let result = \"\";\n{\nlet $us$generator = _cloneStruct(this.unicodeScalars.makeIterator({}, ));\nwhile(true) {\nconst us = $us$generator.next({$setThis: $val => $us$generator = $val}, );\nif(!((us != null))) break;\nString.infix_43_61({}, {get: () => result, set: $val => result = $val}, us.escapedAsASCII({}, false));\n}\n};\nString.infix_43_61({}, {get: () => result, set: $val => result = $val}, \"\");\nreturn result"],
  ["Swift.(file).String.+infix(_:String,_:String)", "let result = lhs;\nresult.append({$setThis: $val => result = $val}, rhs);\nreturn result"],
  ["Swift.(file).String.+=infix(_:String,_:String)", "let lhs = lhs$inout.get()\nconst $result = (() => {\nlhs.append({$setThis: $val => lhs = $val}, rhs);})()\nlhs$inout.set(lhs)\nreturn $result"],
  ["Swift.(file).String.description", "return this"],
  ["Swift.(file).String.count", "return this.distanceFromTo({}, this.startIndex, this.endIndex)"],
  ["Swift.(file).StringProtocol.!=infix(_:Self,_:RHS)", "return Bool.prefix_33({}, $info.Self.infix_61_61({Self: $info.Self, RHS: $info.RHS}, lhs, rhs))"],
  ["Swift.(file).StringProtocol.>infix(_:Self,_:RHS)", "return $info.RHS.infix_60({Self: $info.RHS, RHS: $info.Self}, rhs, lhs)"],
  ["Swift.(file).StringProtocol.<=infix(_:Self,_:RHS)", "return Bool.prefix_33({}, $info.RHS.infix_60({Self: $info.RHS, RHS: $info.Self}, rhs, lhs))"],
  ["Swift.(file).StringProtocol.>=infix(_:Self,_:RHS)", "return Bool.prefix_33({}, $info.Self.infix_60({Self: $info.Self, RHS: $info.RHS}, lhs, rhs))"],
  ["Swift.(file)._StringGuts.startUTF16", "fatalErrorFileLine({}, () => \"Not contiguous UTF-16\", '?3', '?3')"],
  ["Swift.(file).DefaultStringInterpolation.appendLiteral(_:String)", "literal.writeTo({Target: DefaultStringInterpolation}, {get: () => this, set: $val => $info0x7fe8f08efaf8.$setThis(_cloneStruct($val))})"],
  ["Swift.(file).DefaultStringInterpolation.appendInterpolation(_:T)", "value.writeTo({Self: $info.T, Target: DefaultStringInterpolation}, {get: () => this, set: $val => $info0x7fb09708e3b8.$setThis(_cloneStruct($val))})"],
  ["Swift.(file).DefaultStringInterpolation.appendInterpolation(_:T)", "value.writeTo({Self: $info.T, Target: DefaultStringInterpolation}, {get: () => this, set: $val => $info0x7f92bf8c5db8.$setThis(_cloneStruct($val))})"],
  ["Swift.(file).DefaultStringInterpolation.appendInterpolation(_:T)", "value.description.writeTo({Target: DefaultStringInterpolation}, {get: () => this, set: $val => $info0x7f92bf03c5b8.$setThis(_cloneStruct($val))})"],
  ["Swift.(file).StringProtocol.hasPrefix(_:Prefix)", "return this.startsWith({Self: $info.Self, PossiblePrefix: $info.Prefix}, prefix)"],
  ["Swift.(file).StringProtocol.hasSuffix(_:Suffix)", "return this.reversed({Self: $info.Self}, ).startsWith({Self: _clarifyGenerics({Self:ReversedCollection, Base: $info.Self}), PossiblePrefix: _clarifyGenerics({Self:ReversedCollection, Base: $info.Suffix})}, suffix.reversed({Self: $info.Suffix}, ))"],
  ["Swift.(file).String.append(contentsOf:String)", "this.append({$setThis: $val => $info0x7ff72b049908.$setThis(_cloneStruct($val))}, newElements)"],
  ["Swift.(file).String.insert(contentsOf:S,at:String.Index)", "this.replaceSubrangeWith({$setThis: $val => $info0x7f93c20e0f18.$setThis(_cloneStruct($val)), C: $info.S}, String.Index.infix_46_46_60({Self: String.Index}, i, i), newElements)"],
  ["Swift.(file).String.max(_:T,_:T)", "return /*dot_syntax_base_ignored*/max({}, x, y)"],
  ["Swift.(file).String.min(_:T,_:T)", "return /*dot_syntax_base_ignored*/min({}, x, y)"],
  ["Swift.(file).Sequence.+infix(_:Self,_:String)", "fatalErrorFileLine({}, null, '?3', '?3')"],
  ["Swift.(file).Sequence.+infix(_:String,_:Self)", "fatalErrorFileLine({}, null, '?3', '?3')"],
  ["Swift.(file).Substring.withCString(_:(UnsafePointer<CChar>) throws -> Result)", "return _create(String, 'initSubstring', {}, this).withCString({Result: $info.Result}, body)"],
  ["Swift.(file).Substring.withCString(encodedAs:TargetEncoding.Type,_:(UnsafePointer<TargetEncoding.CodeUnit>) throws -> Result)", "return _create(String, 'initSubstring', {}, this).withCStringEncodedAs({Result: $info.Result, TargetEncoding: $info.TargetEncoding}, targetEncoding, body)"],
  ["Swift.(file).Substring.customMirror", "return _create(String, 'initSubstring', {}, this).customMirror"],
  ["Swift.(file).Substring.description", "return _create(String, 'initSubstring', {}, this)"],
  ["Swift.(file).Substring.debugDescription", "return _create(String, 'initSubstring', {}, this).debugDescription"],
  ["Swift.(file).Substring.append(contentsOf:S)", "let string = _create(String, 'initSubstring', {}, this);\n$info0x7f7f230da830.$setThis(_cloneStruct(_create(Substring, 'init', {}, )));\nstring.appendContentsOf({$setThis: $val => string = $val, S: $info.S}, _elements);\n$info0x7f7f230da830.$setThis(_cloneStruct(_create(Substring, 'initString', {}, string)))"],
  ["Swift.(file).Substring.lowercased()", "return _create(String, 'initSubstring', {}, this).lowercased({}, )"],
  ["Swift.(file).Substring.uppercased()", "return _create(String, 'initSubstring', {}, this).uppercased({}, )"],
  ["Swift.(file).Substring.filter(_:(Substring.Element) throws -> Bool)", "return _create(String, 'initBuffer', {S: _clarifyGenerics({Self:Array, Element: Character})}, this.lazy.filterSwift({Self: _clarifyGenerics({Self:LazySequence, Base: Substring})}, isIncluded))"],
  ["Swift.(file).Substring.write(_:String)", "this.appendContentsOf({$setThis: $val => $info0x7f8e5e040d00.$setThis(_cloneStruct($val)), S: String}, other)"],
  ["Swift.(file).Substring.write(to:Target)", "let target = target$inout.get()\nconst $result = (() => {\ntarget.write({$setThis: $val => target = $val, Self: $info.Target}, _create(String, 'initSubstring', {}, this));})()\ntarget$inout.set(target)\nreturn $result"],
  ["Swift.(file)._UIntBuffer.makeIterator()", "return _create(_UIntBuffer.Iterator, 'init_UIntBuffer', {Element: this.$info.Element}, this)"],
  ["Swift.(file)._UIntBuffer.capacity", "return Int.infix_47({}, _UIntBuffer.Storage.bitWidth, this.$info.Element.bitWidth)"],
  ["Swift.(file).UTF16.encodedReplacementCharacter", "return _create(Unicode.UTF16.EncodedScalar, 'init_storage_UIntBufferStorage_bitCountUInt8', {Element: UInt16}, 0xFFFD, 16);\n}\nstatic get encodedReplacementCharacter() { return this.encodedReplacementCharacter$get() "],
  ["Swift.(file).UTF16.encode(_:Unicode.Scalar)", "const x = source.value;\n{\nif((_fastPath({}, UInt32.infix_60({}, x, UInt32.infix_60_60({Self: UInt32, Other: Int}, 1, 16))))) {\nreturn _create(Unicode.UTF16.EncodedScalar, 'init_storage_UIntBufferStorage_bitCountUInt8', {Element: UInt16}, x, 16);\n}\n};\nconst x1 = UInt32.infix_45({}, x, UInt32.infix_60_60({Self: UInt32, Other: Int}, 1, 16));\nlet r = UInt32.infix_43({}, 0xdc00, UInt32.infix_38({}, x1, 0x3ff));\nUInt32.infix_38_60_60_61({}, {get: () => r, set: $val => r = $val}, 16);\nUInt32.infix_124_61({}, {get: () => r, set: $val => r = $val}, UInt32.infix_43({}, 0xd800, UInt32.infix_38({}, UInt32.infix_38_62_62({}, x1, 10), 0x3ff)));\nreturn _create(Unicode.UTF16.EncodedScalar, 'init_storage_UIntBufferStorage_bitCountUInt8', {Element: UInt16}, r, 32)"],
  ["Swift.(file).UTF32.encode(_:Unicode.Scalar)", "return _create(Unicode.UTF32.EncodedScalar, 'init', {Element: UInt32}, source.value)"],
  ["Swift.(file).UTF8.encodedReplacementCharacter", "return Unicode.UTF8.EncodedScalar.encodedReplacementCharacter;\n}\nstatic get encodedReplacementCharacter() { return this.encodedReplacementCharacter$get() "],
  ["Swift.(file).UnicodeDecodingResult.==infix(_:UnicodeDecodingResult,_:UnicodeDecodingResult)", "const $match = {0: lhs, 1: rhs}\nif((($match.rawValue == UnicodeDecodingResult.scalarValue().rawValue && $match.rawValue == UnicodeDecodingResult.scalarValue().rawValue))) {\nconst lhsScalar = $match[0][0]\nconst rhsScalar = $match[1][0]\nreturn Unicode.Scalar.infix_61_61({}, lhsScalar, rhsScalar);\n}\nelse if((($match.rawValue == UnicodeDecodingResult.emptyInput.rawValue && $match.rawValue == UnicodeDecodingResult.emptyInput.rawValue))) {\nreturn true;\n}\nelse if((($match.rawValue == UnicodeDecodingResult.error.rawValue && $match.rawValue == UnicodeDecodingResult.error.rawValue))) {\nreturn true;\n}\nelse if(((true))) {\nreturn false;\n}"],
  ["Swift.(file).transcode(_:Input,from:InputEncoding.Type,to:OutputEncoding.Type,stoppingOnError:Bool,into:<<error type>>)", "let input_dupl = input;\nlet p = _create($info.InputEncoding.ForwardParser, 'init', {Self: $info.InputEncoding.ForwardParser}, );\nlet hadError = false;\nwhile(true){\nif(!((true))) break\nconst $match = p.parseScalarFrom({$setThis: $val => p = $val, Self: $info.InputEncoding.ForwardParser, I: $info.Input}, {get: () => input_dupl, set: $val => input_dupl = $val})\nif((($match.rawValue == Unicode.ParseResult.valid().rawValue))) {\nconst s = $match[0]\nconst t = $info.OutputEncoding.transcodeFrom({Self: $info.OutputEncoding, FromEncoding: $info.InputEncoding}, s, inputEncoding);\n{const s = t\nif(!((_fastPath({}, Optional.infix_33_61({Wrapped: $info.OutputEncoding.EncodedScalar}, t, null))) && (s != null))) {\nbreak;\n}\n};\ns.forEachSwift({Self: $info.OutputEncoding.EncodedScalar}, processCodeUnit);\ncontinue;\n}\nelse if((($match.rawValue == Unicode.ParseResult.emptyInput.rawValue))) {\nreturn hadError;\n}\nelse if((($match.rawValue == Unicode.ParseResult.error().rawValue))) {\n{\nif((_slowPath({}, stopOnError))) {\nreturn true;\n}\n};\nhadError = true;\n};\n$info.OutputEncoding.encodedReplacementCharacter.forEachSwift({Self: $info.OutputEncoding.EncodedScalar}, processCodeUnit);\n}"],
  ["Swift.(file).UTF16.width(_:<<error type>>)", "return (UInt32.infix_60_61({}, x.value, 0xFFFF) ? 1 : 2)"],
  ["Swift.(file).UTF16.leadSurrogate(_:<<error type>>)", "preconditionFileLine({}, () => Int.infix_61_61({}, this.width({}, x), 2), null, '?3', '?3');\nreturn UInt16.infix_43({}, 0xD800, _create(UTF16.CodeUnit, 'initTruncatingIfNeeded', {Self: UTF16.CodeUnit, T: UInt32}, UInt32.infix_38_62_62({}, UInt32.infix_45({}, x.value, 0x10000), 10)))"],
  ["Swift.(file).UTF16.trailSurrogate(_:<<error type>>)", "preconditionFileLine({}, () => Int.infix_61_61({}, this.width({}, x), 2), null, '?3', '?3');\nreturn UInt16.infix_43({}, 0xDC00, _create(UTF16.CodeUnit, 'initTruncatingIfNeeded', {Self: UTF16.CodeUnit, T: UInt32}, UInt32.infix_38({}, UInt32.infix_45({}, x.value, 0x10000), UInt32.infix_45({}, UInt32.infix_38_60_60({}, 1, 10), 1))))"],
  ["Swift.(file).UTF16.isLeadSurrogate(_:Unicode.UTF16.CodeUnit)", "return UInt16.infix_61_61({}, UInt16.infix_38({}, x, 0xFC00), 0xD800)"],
  ["Swift.(file).UTF16.isTrailSurrogate(_:Unicode.UTF16.CodeUnit)", "return UInt16.infix_61_61({}, UInt16.infix_38({}, x, 0xFC00), 0xDC00)"],
  ["Swift.(file)._UnicodeEncoding.transcode(_:<<error type>>,from:FromEncoding.Type)", "return this.encode({Self: $info.Self}, $info.FromEncoding.decode({Self: $info.FromEncoding}, content))"],
  ["Swift.(file).UnsafePointer.pointee", " return this.pointee$internal "],
  ["Swift.(file).UnsafeMutablePointer.pointee", " return this.pointee$internal "],
  ["Swift.(file).UnsafeRawPointer.assumingMemoryBound(to:T.Type)", "return _create(UnsafePointer, 'initRawPointer', {Pointee: $info.T}, this._rawValue)"],
  ["Swift.(file).UnsafeMutableRawPointer.assumingMemoryBound(to:T.Type)", "return _create(UnsafeMutablePointer, 'initRawPointer', {Pointee: $info.T}, this._rawValue)"],
  ["Swift.(file)._ValidUTF8Buffer.makeIterator()", "return _create(_ValidUTF8Buffer.Iterator, 'init_ValidUTF8Buffer', {}, this)"],
  ["Swift.(file)._ValidUTF8Buffer.capacity", "return Int.infix_47({}, UInt32.bitWidth, _ValidUTF8Buffer.Element.bitWidth);\n}\nstatic get capacity() { return this.capacity$get() "]
]