[
  ["Swift.(file).min(_:T,_:T)", "\nfunction min<T>($info, x, y){\n\nreturn ($info.T.infix_60({Self: $info.T}, y, x) ? y : x);\n}"],
  ["Swift.(file).min(_:T,_:T,_:T,_:[T])", "\nfunction min<T>($info, x, y, z, rest){\n\n\nlet minValue = min({T: $info.T}, min({T: $info.T}, x, y), z);\n\n;\n\n;\n\n{\nlet $value$generator = _cloneStruct(rest.makeIterator({Self: _clarifyGenerics({Self:Array, Element: $info.T})}, ));\n\n\nwhile(true) {\nconst value$let = $value$generator.next({Elements: _clarifyGenerics({Self:Array, Element: $info.T})}, );\nif(!((value$let != null))) break;\n\nif(!($info.T.infix_60({Self: $info.T}, value$let, minValue))) break;\nminValue = value$let;\n}\n};\nreturn minValue;\n}"],
  ["Swift.(file).max(_:T,_:T)", "\nfunction max<T>($info, x, y){\n\nreturn ($info.T.infix_62_61({Self: $info.T}, y, x) ? y : x);\n}"],
  ["Swift.(file).max(_:T,_:T,_:T,_:[T])", "\nfunction max<T>($info, x, y, z, rest){\n\n\nlet maxValue = max({T: $info.T}, max({T: $info.T}, x, y), z);\n\n;\n\n;\n\n{\nlet $value$generator = _cloneStruct(rest.makeIterator({Self: _clarifyGenerics({Self:Array, Element: $info.T})}, ));\n\n\nwhile(true) {\nconst value$let = $value$generator.next({Elements: _clarifyGenerics({Self:Array, Element: $info.T})}, );\nif(!((value$let != null))) break;\n\nif(!($info.T.infix_62_61({Self: $info.T}, value$let, maxValue))) break;\nmaxValue = value$let;\n}\n};\nreturn maxValue;\n}"],
  ["Swift.(file).EnumeratedSequence.Iterator", "\n\nstatic Iterator = class{\nstatic readonly $struct = true\nstatic readonly $infoAddress = '0x7fe0808eb5a8'\n\n_base$internal\n_base$get() { return this._base$internal }\nget _base() { return this._base$get() }\n_base$set($newValue) {\nlet $oldValue = this._base$internal\nthis._base$internal = $newValue\n}\nset _base($newValue) { this._base$set($newValue) }\n;\n\n\n\n\n\n\n_count$internal\n_count$get() { return this._count$internal }\nget _count() { return this._count$get() }\n_count$set($newValue) {\nlet $oldValue = this._count$internal\nthis._count$internal = $newValue\n}\nset _count($newValue) { this._count$set($newValue) }\n;\n\n\n\n\n\ninit_base($info, _base){\n\nthis._base = _base;\nthis._count = 0;\nreturn ;\n}\ninit$vars() {\n}\n}"],
  ["Swift.(file).Array.index(after:Int)", "\n\nindexAfter($info, i){\n\nreturn Int.infix_43(null, i, 1);\n}"],
  ["Swift.(file).Array.formIndex(after:Int)", "\n\nformIndexAfter($info, i$inout){\n\nlet i = i$inout.get()\nconst $result = (() => {\nInt.infix_43_61(null, {get: () => i, set: $val => i = $val}, 1);})()\ni$inout.set(i)\nreturn $result\n}"],
  ["Swift.(file).Array.index(before:Int)", "\n\nindexBefore($info, i){\n\nreturn Int.infix_45(null, i, 1);\n}"],
  ["Swift.(file).Array.formIndex(before:Int)", "\n\nformIndexBefore($info, i$inout){\n\nlet i = i$inout.get()\nconst $result = (() => {\nInt.infix_45_61(null, {get: () => i, set: $val => i = $val}, 1);})()\ni$inout.set(i)\nreturn $result\n}"],
  ["Swift.(file).Array.index(_:Int,offsetBy:Int)", "\n\nindexOffsetBy($info, i, distance){\n\nreturn Int.infix_43(null, i, distance);\n}"],
  ["Swift.(file).Array.index(_:Int,offsetBy:Int,limitedBy:Int)", "\n\nindexOffsetByLimitedBy($info, i, distance, limit){\n\n\nconst l = Int.infix_45(null, limit, i);\n\n;\n\n;\n\n{\nif(((Int.infix_62(null, distance, 0) ? Bool.infix_38_38(null, Int.infix_62_61(null, l, 0), () => Int.infix_60(null, l, distance)) : Bool.infix_38_38(null, Int.infix_60_61(null, l, 0), () => Int.infix_60(null, distance, l))))) {\n\nreturn null;\n}\n};\nreturn Int.infix_43(null, i, distance);\n}"],
  ["Swift.(file).Array.distance(from:Int,to:Int)", "\n\ndistanceFromTo($info, start, end){\n\nreturn Int.infix_45(null, end, start);\n}"],
  ["Swift.(file).Array.withContiguousMutableStorageIfAvailable(_:(inout UnsafeMutableBufferPointer<Element>) throws -> R)", "\n\nwithContiguousMutableStorageIfAvailable<R>($info, body){\n\nreturn this.withUnsafeMutableBufferPointer({Element: $info.Element, R: $info.R}, (($info, bufferPointer$inout) => body(null, {get: () => bufferPointer, set: $val => bufferPointer = $val})));\n}"],
  ["Swift.(file).Array.withContiguousStorageIfAvailable(_:(UnsafeBufferPointer<Element>) throws -> R)", "\n\nwithContiguousStorageIfAvailable<R>($info, body){\n\nreturn this.withUnsafeBufferPointer({Element: $info.Element, R: $info.R}, (($info, bufferPointer) => body(null, bufferPointer)));\n}"],
  ["Swift.(file).Array.+infix(_:Array<Element>,_:Array<Element>)", "\n\nstatic infix_43($info, lhs, rhs){\n\n\nlet lhs = _cloneStruct(lhs);\n\n;\n\n;\nlhs.appendContentsOf({Element: this.$info.Element, S: _clarifyGenerics({Self:Array, Element: this.$info.Element})}, rhs);\nreturn lhs;\n}"],
  ["Swift.(file).Array.+=infix(_:Array<Element>,_:Array<Element>)", "\n\nstatic infix_43_61($info, lhs$inout, rhs){\n\nlet lhs = lhs$inout.get()\nconst $result = (() => {\nlhs.appendContentsOf({Element: this.$info.Element, S: _clarifyGenerics({Self:Array, Element: this.$info.Element})}, rhs);})()\nlhs$inout.set(lhs)\nreturn $result\n}"],
  ["Swift.(file).Array.withUnsafeMutableBytes(_:(UnsafeMutableRawBufferPointer) throws -> R)", "\n\nwithUnsafeMutableBytes<R>($info, body){\n\nreturn this.withUnsafeMutableBufferPointer({Element: $info.Element, R: $info.R}, (($info, $0$inout) => body(null, _create(UnsafeMutableRawBufferPointer, 'initUnsafeMutableBufferPointer', {T: $info.Element}, $0))));\n}"],
  ["Swift.(file).Array.withUnsafeBytes(_:(UnsafeRawBufferPointer) throws -> R)", "\n\nwithUnsafeBytes<R>($info, body){\n\nreturn this.withUnsafeBufferPointer({Element: $info.Element, R: $info.R}, (($info, $0) => body(null, _create(UnsafeRawBufferPointer, 'initUnsafeBufferPointer', {T: $info.Element}, $0))));\n}"],
  ["Swift.(file).ArraySlice.index(after:Int)", "\n\nindexAfter($info, i){\n\nreturn Int.infix_43(null, i, 1);\n}"],
  ["Swift.(file).ArraySlice.formIndex(after:Int)", "\n\nformIndexAfter($info, i$inout){\n\nlet i = i$inout.get()\nconst $result = (() => {\nInt.infix_43_61(null, {get: () => i, set: $val => i = $val}, 1);})()\ni$inout.set(i)\nreturn $result\n}"],
  ["Swift.(file).ArraySlice.index(before:Int)", "\n\nindexBefore($info, i){\n\nreturn Int.infix_45(null, i, 1);\n}"],
  ["Swift.(file).ArraySlice.formIndex(before:Int)", "\n\nformIndexBefore($info, i$inout){\n\nlet i = i$inout.get()\nconst $result = (() => {\nInt.infix_45_61(null, {get: () => i, set: $val => i = $val}, 1);})()\ni$inout.set(i)\nreturn $result\n}"],
  ["Swift.(file).ArraySlice.index(_:Int,offsetBy:Int)", "\n\nindexOffsetBy($info, i, distance){\n\nreturn Int.infix_43(null, i, distance);\n}"],
  ["Swift.(file).ArraySlice.index(_:Int,offsetBy:Int,limitedBy:Int)", "\n\nindexOffsetByLimitedBy($info, i, distance, limit){\n\n\nconst l = Int.infix_45(null, limit, i);\n\n;\n\n;\n\n{\nif(((Int.infix_62(null, distance, 0) ? Bool.infix_38_38(null, Int.infix_62_61(null, l, 0), () => Int.infix_60(null, l, distance)) : Bool.infix_38_38(null, Int.infix_60_61(null, l, 0), () => Int.infix_60(null, distance, l))))) {\n\nreturn null;\n}\n};\nreturn Int.infix_43(null, i, distance);\n}"],
  ["Swift.(file).ArraySlice.distance(from:Int,to:Int)", "\n\ndistanceFromTo($info, start, end){\n\nreturn Int.infix_45(null, end, start);\n}"],
  ["Swift.(file).ArraySlice.remove(at:Int)", "\n\nremoveAt($info, index){\n\n\nconst result = this.subscript$get(null, index);\n\n;\n\n;\nthis.replaceSubrangeWith({Element: this.$info.Element, C: _clarifyGenerics({Self:EmptyCollection, Element: this.$info.Element})}, Int.infix_46_46_60({Self: Int}, index, Int.infix_43(null, index, 1)), _create(EmptyCollection, 'init', {Element: this.$info.Element}, ));\nreturn result;\n}"],
  ["Swift.(file).ArraySlice.withContiguousMutableStorageIfAvailable(_:(inout UnsafeMutableBufferPointer<Element>) throws -> R)", "\n\nwithContiguousMutableStorageIfAvailable<R>($info, body){\n\nreturn this.withUnsafeMutableBufferPointer({Element: $info.Element, R: $info.R}, (($info, bufferPointer$inout) => body(null, {get: () => bufferPointer, set: $val => bufferPointer = $val})));\n}"],
  ["Swift.(file).ArraySlice.withContiguousStorageIfAvailable(_:(UnsafeBufferPointer<Element>) throws -> R)", "\n\nwithContiguousStorageIfAvailable<R>($info, body){\n\nreturn this.withUnsafeBufferPointer({Element: $info.Element, R: $info.R}, (($info, bufferPointer) => body(null, bufferPointer)));\n}"],
  ["Swift.(file).ArraySlice.withUnsafeMutableBytes(_:(UnsafeMutableRawBufferPointer) throws -> R)", "\n\nwithUnsafeMutableBytes<R>($info, body){\n\nreturn this.withUnsafeMutableBufferPointer({Element: $info.Element, R: $info.R}, (($info, $0$inout) => body(null, _create(UnsafeMutableRawBufferPointer, 'initUnsafeMutableBufferPointer', {T: $info.Element}, $0))));\n}"],
  ["Swift.(file).ArraySlice.withUnsafeBytes(_:(UnsafeRawBufferPointer) throws -> R)", "\n\nwithUnsafeBytes<R>($info, body){\n\nreturn this.withUnsafeBufferPointer({Element: $info.Element, R: $info.R}, (($info, $0) => body(null, _create(UnsafeRawBufferPointer, 'initUnsafeBufferPointer', {T: $info.Element}, $0))));\n}"],
  ["Swift.(file).BidirectionalCollection.formIndex(before:Self.Index)", "\n\nformIndexBefore($info, i$inout){\n\nlet i = i$inout.get()\nconst $result = (() => {\ni = this.indexBefore({Self: this.$info.Self}, i);})()\ni$inout.set(i)\nreturn $result\n}"],
  ["Swift.(file).BidirectionalCollection.dropLast(_:Int)", "\n\ndropLast($info, k){\n\npreconditionFileLine(null, () => Int.infix_62_61(null, k, 0), () => \"Can't drop a negative number of elements from a collection\");\n\nconst end = infix_63_63({T: this.$info.Self.Index}, this.indexOffsetByLimitedBy({Self: this.$info.Self}, this.endIndex, Int.prefix_45({Self: Int}, k), this.startIndex), () => this.startIndex);\n\n;\n\n;\nreturn this.subscriptRange$get(null, this.$info.Self.Index.infix_46_46_60({Self: this.$info.Self.Index}, this.startIndex, end));\n}"],
  ["Swift.(file).BidirectionalCollection.suffix(_:Int)", "\n\nsuffix($info, maxLength){\n\npreconditionFileLine(null, () => Int.infix_62_61(null, maxLength, 0), () => \"Can't take a suffix of negative length from a collection\");\n\nconst start = infix_63_63({T: this.$info.Self.Index}, this.indexOffsetByLimitedBy({Self: this.$info.Self}, this.endIndex, Int.prefix_45({Self: Int}, maxLength), this.startIndex), () => this.startIndex);\n\n;\n\n;\nreturn this.subscriptRange$get(null, this.$info.Self.Index.infix_46_46_60({Self: this.$info.Self.Index}, start, this.endIndex));\n}"],
  ["Swift.(file).Bool.random(using:T)", "\n\nstatic randomUsing<T>($info, generator$inout){\n\nlet generator = generator$inout.get()\nconst $result = (() => {\nreturn UInt64.infix_61_61(null, UInt64.infix_38(null, UInt64.infix_62_62({Self: UInt64, Other: Int}, generator.next({Self: $info.T}, ), 17), 1), 0);})()\ngenerator$inout.set(generator)\nreturn $result\n}"],
  ["Swift.(file).Bool.random()", "\n\nstatic random($info){\n\n\nlet g = _create(SystemRandomNumberGenerator, 'init', null, );\n\n;\n\n;\nreturn Bool.randomUsing({T: SystemRandomNumberGenerator}, {get: () => g, set: $val => g = $val});\n}"],
  ["Swift.(file).Bool.hash(into:Hasher)", "\n\nhashInto($info, hasher$inout){\n\nlet hasher = hasher$inout.get()\nconst $result = (() => {\nhasher.combine({H: UInt8}, (this ? 1 : 0));})()\nhasher$inout.set(hasher)\nreturn $result\n}"],
  ["Swift.(file).Bool.&&infix(_:Bool,_:() throws -> Bool)", "\n\nstatic infix_38_38($info, lhs, rhs){\n\nreturn (lhs ? rhs(null, ) : false);\n}"],
  ["Swift.(file).Bool.||infix(_:Bool,_:() throws -> Bool)", "\n\nstatic infix_124_124($info, lhs, rhs){\n\nreturn (lhs ? true : rhs(null, ));\n}"],
  ["Swift.(file).Bool.toggle()", "\n\ntoggle($info){\n\nObject.assign(this, Bool.prefix_33(null, this));\n}"],
  ["Swift.(file).!=infix(_:Any.Type?,_:Any.Type?)", "\nfunction infix_33_61($info, t0, t1){\n\nreturn Bool.prefix_33(null, infix_61_61(null, t0, t1));\n}"],
  ["Swift.(file).Character.uppercased()", "\n\nuppercased($info){\n\nreturn _create(String, 'initCharacter', null, this).uppercased(null, );\n}"],
  ["Swift.(file).Character.lowercased()", "\n\nlowercased($info){\n\nreturn _create(String, 'initCharacter', null, this).lowercased(null, );\n}"],
  ["Swift.(file).ClosedRange.relative(to:C)", "\n\nrelativeTo<C>($info, collection){\n\nreturn _create(Range, 'initUncheckedBoundstuple_type', {Bound: $info.Bound}, {0: this.lowerBound, 1: collection.indexAfter({Self: $info.C}, this.upperBound)});\n}"],
  ["Swift.(file).ClosedRange.contains(_:Bound)", "\n\ncontains($info, _element){\n\nreturn Bool.infix_38_38(null, this.$info.Bound.infix_62_61({Self: this.$info.Bound}, _element, this.lowerBound), () => this.$info.Bound.infix_60_61({Self: this.$info.Bound}, _element, this.upperBound));\n}"],
  ["Swift.(file).Comparable....infix(_:Self,_:Self)", "\n\nstatic infix_46_46_46($info, minimum, maximum){\n\npreconditionFileLine(null, () => this.$info.Self.infix_60_61({Self: this.$info.Self}, minimum, maximum), () => \"Can't form Range with upperBound < lowerBound\");\nreturn _create(ClosedRange, 'initUncheckedBoundstuple_type', {Bound: this.$info.Self}, {0: minimum, 1: maximum});\n}"],
  ["Swift.(file).ClosedRange.==infix(_:ClosedRange<Bound>,_:ClosedRange<Bound>)", "\n\nstatic infix_61_61($info, lhs, rhs){\n\nreturn Bool.infix_38_38(null, this.$info.Bound.infix_61_61({Self: this.$info.Bound}, lhs.lowerBound, rhs.lowerBound), () => this.$info.Bound.infix_61_61({Self: this.$info.Bound}, lhs.upperBound, rhs.upperBound));\n}"],
  ["Swift.(file).ClosedRange.clamped(to:ClosedRange<Bound>)", "\n\nclampedTo($info, limits){\n\n\nconst lower = (this.$info.Bound.infix_62({Self: this.$info.Bound}, limits.lowerBound, this.lowerBound) ? limits.lowerBound : (this.$info.Bound.infix_60({Self: this.$info.Bound}, limits.upperBound, this.lowerBound) ? limits.upperBound : this.lowerBound));\n\n;\n\n;\n\nconst upper = (this.$info.Bound.infix_60({Self: this.$info.Bound}, limits.upperBound, this.upperBound) ? limits.upperBound : (this.$info.Bound.infix_62({Self: this.$info.Bound}, limits.lowerBound, this.upperBound) ? limits.lowerBound : this.upperBound));\n\n;\n\n;\nreturn _create(ClosedRange, 'initUncheckedBoundstuple_type', {Bound: this.$info.Bound}, {0: lower, 1: upper});\n}"],
  ["Swift.(file).ClosedRange.overlaps(_:ClosedRange<Bound>)", "\n\noverlaps($info, other){\n\nreturn Bool.infix_124_124(null, this.contains({Bound: this.$info.Bound}, other.lowerBound), () => other.contains({Bound: this.$info.Bound}, this.lowerBound));\n}"],
  ["Swift.(file).ClosedRange.overlaps(_:Range<Bound>)", "\n\noverlaps($info, other){\n\nreturn other.overlaps({Bound: this.$info.Bound}, this);\n}"],
  ["Swift.(file).Collection.formIndex(after:Self.Index)", "\n\nformIndexAfter($info, i$inout){\n\nlet i = i$inout.get()\nconst $result = (() => {\ni = this.indexAfter({Self: this.$info.Self}, i);})()\ni$inout.set(i)\nreturn $result\n}"],
  ["Swift.(file).Collection.formIndex(_:Self.Index,offsetBy:Int)", "\n\nformIndexOffsetBy($info, i$inout, distance){\n\nlet i = i$inout.get()\nconst $result = (() => {\ni = this.indexOffsetBy({Self: this.$info.Self}, i, distance);})()\ni$inout.set(i)\nreturn $result\n}"],
  ["Swift.(file).Collection.formIndex(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)", "\n\nformIndexOffsetByLimitedBy($info, i$inout, distance, limit){\n\nlet i = i$inout.get()\nconst $result = (() => {\n\n{const advancedIndex$let = this.indexOffsetByLimitedBy({Self: this.$info.Self}, i, distance, limit)\nif((advancedIndex$let != null)) {\n\ni = advancedIndex$let;\nreturn true;\n}\n};\ni = limit;\nreturn false;})()\ni$inout.set(i)\nreturn $result\n}"],
  ["Swift.(file).Collection.distance(from:Self.Index,to:Self.Index)", "\n\ndistanceFromTo($info, start, end){\n\npreconditionFileLine(null, () => this.$info.Self.Index.infix_60_61({Self: this.$info.Self.Index}, start, end), () => \"Only BidirectionalCollections can have end come before start\");\n\nlet start = start;\n\n;\n\n;\n\nlet count = 0;\n\n;\n\n;\nwhile(true){\n\nif(!((this.$info.Self.Index.infix_33_61({Self: this.$info.Self.Index}, start, end)))) break\ncount = Int.infix_43(null, count, 1);\nthis.formIndexAfter({Self: this.$info.Self}, {get: () => start, set: $val => start = $val});\n};\nreturn count;\n}"],
  ["Swift.(file).Collection.randomElement(using:T)", "\n\nrandomElementUsing<T>($info, generator$inout){\n\nlet generator = generator$inout.get()\nconst $result = (() => {\n\n{\nif(!((Bool.prefix_33(null, this.isEmpty)))) {\n\nreturn null;\n}\n};\n\nconst random = Int.randomInUsing({Self: Int, T: $info.T}, Int.infix_46_46_60({Self: Int}, 0, this.count), {get: () => generator, set: $val => generator = $val});\n\n;\n\n;\n\nconst idx = this.indexOffsetBy({Self: $info.Self}, this.startIndex, random);\n\n;\n\n;\nreturn this.subscript$get(null, idx);})()\ngenerator$inout.set(generator)\nreturn $result\n}"],
  ["Swift.(file).Collection.randomElement()", "\n\nrandomElement($info){\n\n\nlet g = _create(SystemRandomNumberGenerator, 'init', null, );\n\n;\n\n;\nreturn this.randomElementUsing({Self: this.$info.Self, T: SystemRandomNumberGenerator}, {get: () => g, set: $val => g = $val});\n}"],
  ["Swift.(file).Collection.makeIterator()", "\n\nmakeIterator($info){\n\nreturn _create(IndexingIterator, 'init_elements', {Elements: this.$info.Self}, this);\n}"],
  ["Swift.(file).Collection.dropFirst(_:Int)", "\n\ndropFirst($info, k = 1){\n\npreconditionFileLine(null, () => Int.infix_62_61(null, k, 0), () => \"Can't drop a negative number of elements from a collection\");\n\nconst start = infix_63_63({T: this.$info.Self.Index}, this.indexOffsetByLimitedBy({Self: this.$info.Self}, this.startIndex, k, this.endIndex), () => this.endIndex);\n\n;\n\n;\nreturn this.subscriptRange$get(null, this.$info.Self.Index.infix_46_46_60({Self: this.$info.Self.Index}, start, this.endIndex));\n}"],
  ["Swift.(file).Collection.dropLast(_:Int)", "\n\ndropLast($info, k = 1){\n\npreconditionFileLine(null, () => Int.infix_62_61(null, k, 0), () => \"Can't drop a negative number of elements from a collection\");\n\nconst amount = /*dot_syntax_base_ignored*/max(null, 0, Int.infix_45(null, this.count, k));\n\n;\n\n;\n\nconst end = infix_63_63({T: this.$info.Self.Index}, this.indexOffsetByLimitedBy({Self: this.$info.Self}, this.startIndex, amount, this.endIndex), () => this.endIndex);\n\n;\n\n;\nreturn this.subscriptRange$get(null, this.$info.Self.Index.infix_46_46_60({Self: this.$info.Self.Index}, this.startIndex, end));\n}"],
  ["Swift.(file).Collection.drop(while:(Self.Element) throws -> Bool)", "\n\ndropWhile($info, predicate){\n\n\nlet start = this.startIndex;\n\n;\n\n;\nwhile(true){\n\nif(!((Bool.infix_38_38(null, this.$info.Self.Index.infix_33_61({Self: this.$info.Self.Index}, start, this.endIndex), () => predicate(null, this.subscript$get(null, start)))))) break\nthis.formIndexAfter({Self: this.$info.Self}, {get: () => start, set: $val => start = $val});\n};\nreturn this.subscriptRange$get(null, this.$info.Self.Index.infix_46_46_60({Self: this.$info.Self.Index}, start, this.endIndex));\n}"],
  ["Swift.(file).Collection.prefix(_:Int)", "\n\nprefix($info, maxLength){\n\npreconditionFileLine(null, () => Int.infix_62_61(null, maxLength, 0), () => \"Can't take a prefix of negative length from a collection\");\n\nconst end = infix_63_63({T: this.$info.Self.Index}, this.indexOffsetByLimitedBy({Self: this.$info.Self}, this.startIndex, maxLength, this.endIndex), () => this.endIndex);\n\n;\n\n;\nreturn this.subscriptRange$get(null, this.$info.Self.Index.infix_46_46_60({Self: this.$info.Self.Index}, this.startIndex, end));\n}"],
  ["Swift.(file).Collection.prefix(while:(Self.Element) throws -> Bool)", "\n\nprefixWhile($info, predicate){\n\n\nlet end = this.startIndex;\n\n;\n\n;\nwhile(true){\n\nif(!((Bool.infix_38_38(null, this.$info.Self.Index.infix_33_61({Self: this.$info.Self.Index}, end, this.endIndex), () => predicate(null, this.subscript$get(null, end)))))) break\nthis.formIndexAfter({Self: this.$info.Self}, {get: () => end, set: $val => end = $val});\n};\nreturn this.subscriptRange$get(null, this.$info.Self.Index.infix_46_46_60({Self: this.$info.Self.Index}, this.startIndex, end));\n}"],
  ["Swift.(file).Collection.suffix(_:Int)", "\n\nsuffix($info, maxLength){\n\npreconditionFileLine(null, () => Int.infix_62_61(null, maxLength, 0), () => \"Can't take a suffix of negative length from a collection\");\n\nconst amount = /*dot_syntax_base_ignored*/max(null, 0, Int.infix_45(null, this.count, maxLength));\n\n;\n\n;\n\nconst start = infix_63_63({T: this.$info.Self.Index}, this.indexOffsetByLimitedBy({Self: this.$info.Self}, this.startIndex, amount, this.endIndex), () => this.endIndex);\n\n;\n\n;\nreturn this.subscriptRange$get(null, this.$info.Self.Index.infix_46_46_60({Self: this.$info.Self.Index}, start, this.endIndex));\n}"],
  ["Swift.(file).Collection.prefix(upTo:Self.Index)", "\n\nprefixUpTo($info, end){\n\nreturn this.subscriptRange$get(null, this.$info.Self.Index.infix_46_46_60({Self: this.$info.Self.Index}, this.startIndex, end));\n}"],
  ["Swift.(file).Collection.suffix(from:Self.Index)", "\n\nsuffixFrom($info, start){\n\nreturn this.subscriptRange$get(null, this.$info.Self.Index.infix_46_46_60({Self: this.$info.Self.Index}, start, this.endIndex));\n}"],
  ["Swift.(file).Collection.prefix(through:Self.Index)", "\n\nprefixThrough($info, position){\n\nreturn this.prefixUpTo({Self: this.$info.Self}, this.indexAfter({Self: this.$info.Self}, position));\n}"],
  ["Swift.(file).Collection.split(maxSplits:Int,omittingEmptySubsequences:Bool,whereSeparator:(Self.Element) throws -> Bool)", "\n\nsplitMaxSplitsOmittingEmptySubsequencesWhereSeparator($info, maxSplits = Int.max, omittingEmptySubsequences = true, isSeparator){\n\npreconditionFileLine(null, () => Int.infix_62_61(null, maxSplits, 0), () => \"Must take zero or more splits\");\n\nlet result = _create(Array, 'initBuffer', {Element: this.$info.Self.SubSequence}, []);\n\n;\n\n;\n\nlet subSequenceStart = this.startIndex;\n\n;\n\n;\nfunction appendSubsequenceEnd($info, end){\n\n\n{\nif((Bool.infix_38_38(null, this.$info.Self.Index.infix_61_61({Self: this.$info.Self.Index}, subSequenceStart, end), () => omittingEmptySubsequences))) {\n\nreturn false;\n}\n};\nresult.append({Element: this.$info.Self.SubSequence}, this.subscriptRange$get(null, this.$info.Self.Index.infix_46_46_60({Self: this.$info.Self.Index}, subSequenceStart, end)));\nreturn true;\n}\n;\n\n{\nif((Bool.infix_124_124(null, Int.infix_61_61(null, maxSplits, 0), () => this.isEmpty))) {\n\n_.discardAssignment = appendSubsequenceEnd({Self: this.$info.Self}, this.endIndex);\nreturn result;\n}\n};\n\nlet subSequenceEnd = subSequenceStart;\n\n;\n\n;\n\nconst cachedEndIndex = this.endIndex;\n\n;\n\n;\nwhile(true){\n\nif(!((this.$info.Self.Index.infix_33_61({Self: this.$info.Self.Index}, subSequenceEnd, cachedEndIndex)))) break\n\n{\nif((isSeparator(null, this.subscript$get(null, subSequenceEnd)))) {\n\n\nconst didAppend = appendSubsequenceEnd({Self: this.$info.Self}, subSequenceEnd);\n\n;\n\n;\nthis.formIndexAfter({Self: this.$info.Self}, {get: () => subSequenceEnd, set: $val => subSequenceEnd = $val});\nsubSequenceStart = subSequenceEnd;\n\n{\nif((Bool.infix_38_38(null, didAppend, () => Int.infix_61_61(null, result.count, maxSplits)))) {\n\nbreak;\n}\n};\ncontinue;\n}\n};\nthis.formIndexAfter({Self: this.$info.Self}, {get: () => subSequenceEnd, set: $val => subSequenceEnd = $val});\n};\n\n{\nif((Bool.infix_124_124(null, this.$info.Self.Index.infix_33_61({Self: this.$info.Self.Index}, subSequenceStart, cachedEndIndex), () => Bool.prefix_33(null, omittingEmptySubsequences)))) {\n\nresult.append({Element: this.$info.Self.SubSequence}, this.subscriptRange$get(null, this.$info.Self.Index.infix_46_46_60({Self: this.$info.Self.Index}, subSequenceStart, cachedEndIndex)));\n}\n};\nreturn result;\n}"],
  ["Swift.(file).Collection.firstIndex(where:(Self.Element) throws -> Bool)", "\n\nfirstIndexWhere($info, predicate){\n\n\nlet i = this.startIndex;\n\n;\n\n;\nwhile(true){\n\nif(!((this.$info.Self.Index.infix_33_61({Self: this.$info.Self.Index}, i, this.endIndex)))) break\n\n{\nif((predicate(null, this.subscript$get(null, i)))) {\n\nreturn i;\n}\n};\nthis.formIndexAfter({Self: this.$info.Self}, {get: () => i, set: $val => i = $val});\n};\nreturn null;\n}"],
  ["Swift.(file).BidirectionalCollection.last(where:(Self.Element) throws -> Bool)", "\n\nlastWhere($info, predicate){\n\nreturn this.lastIndexWhere({Self: this.$info.Self}, predicate).mapSwift({Wrapped: this.$info.Self.Index, U: this.$info.Self.Element}, (($info, $0) => this.subscript$get(null, $0)));\n}"],
  ["Swift.(file).BidirectionalCollection.lastIndex(where:(Self.Element) throws -> Bool)", "\n\nlastIndexWhere($info, predicate){\n\n\nlet i = this.endIndex;\n\n;\n\n;\nwhile(true){\n\nif(!((this.$info.Self.Index.infix_33_61({Self: this.$info.Self.Index}, i, this.startIndex)))) break\nthis.formIndexBefore({Self: this.$info.Self}, {get: () => i, set: $val => i = $val});\n\n{\nif((predicate(null, this.subscript$get(null, i)))) {\n\nreturn i;\n}\n};\n};\nreturn null;\n}"],
  ["Swift.(file).Sequence.shuffled(using:T)", "\n\nshuffledUsing<T>($info, generator$inout){\n\nlet generator = generator$inout.get()\nconst $result = (() => {\n\nlet result = _create(ContiguousArray, 'initBuffer', {Element: $info.Self.Element, S: $info.Self}, this);\n\n;\n\n;\nresult.shuffleUsing({Self: _clarifyGenerics({Self:ContiguousArray, Element: $info.Self.Element}), T: $info.T}, {get: () => generator, set: $val => generator = $val});\nreturn _create(Array, 'initBuffer', {Element: $info.Self.Element, S: _clarifyGenerics({Self:ContiguousArray, Element: $info.Self.Element})}, result);})()\ngenerator$inout.set(generator)\nreturn $result\n}"],
  ["Swift.(file).Sequence.shuffled()", "\n\nshuffled($info){\n\n\nlet g = _create(SystemRandomNumberGenerator, 'init', null, );\n\n;\n\n;\nreturn this.shuffledUsing({Self: this.$info.Self, T: SystemRandomNumberGenerator}, {get: () => g, set: $val => g = $val});\n}"],
  ["Swift.(file).MutableCollection.shuffle(using:T)", "\n\nshuffleUsing<T>($info, generator$inout){\n\nlet generator = generator$inout.get()\nconst $result = (() => {\n\n{\nif(!((Int.infix_62(null, this.count, 1)))) {\n\nreturn ;\n}\n};\n\nlet amount = this.count;\n\n;\n\n;\n\nlet currentIndex = this.startIndex;\n\n;\n\n;\nwhile(true){\n\nif(!((Int.infix_62(null, amount, 1)))) break\n\nconst random = Int.randomInUsing({Self: Int, T: $info.T}, Int.infix_46_46_60({Self: Int}, 0, amount), {get: () => generator, set: $val => generator = $val});\n\n;\n\n;\nInt.infix_45_61(null, {get: () => amount, set: $val => amount = $val}, 1);\nthis.swapAt({Self: $info.Self}, currentIndex, this.indexOffsetBy({Self: $info.Self}, currentIndex, random));\nthis.formIndexAfter({Self: $info.Self}, {get: () => currentIndex, set: $val => currentIndex = $val});\n};})()\ngenerator$inout.set(generator)\nreturn $result\n}"],
  ["Swift.(file).Comparable.>infix(_:Self,_:Self)", "\n\nstatic infix_62($info, lhs, rhs){\n\nreturn this.$info.Self.infix_60({Self: this.$info.Self}, rhs, lhs);\n}"],
  ["Swift.(file).Comparable.<=infix(_:Self,_:Self)", "\n\nstatic infix_60_61($info, lhs, rhs){\n\nreturn Bool.prefix_33(null, this.$info.Self.infix_60({Self: this.$info.Self}, rhs, lhs));\n}"],
  ["Swift.(file).Comparable.>=infix(_:Self,_:Self)", "\n\nstatic infix_62_61($info, lhs, rhs){\n\nreturn Bool.prefix_33(null, this.$info.Self.infix_60({Self: this.$info.Self}, lhs, rhs));\n}"],
  ["Swift.(file).==infix(_:T,_:T)", "\nfunction infix_61_61<T>($info, lhs, rhs){\n\nreturn $info.T.RawValue.infix_61_61({Self: $info.T.RawValue}, lhs.rawValue, rhs.rawValue);\n}"],
  ["Swift.(file).!=infix(_:T,_:T)", "\nfunction infix_33_61<T>($info, lhs, rhs){\n\nreturn $info.T.RawValue.infix_33_61({Self: $info.T.RawValue}, lhs.rawValue, rhs.rawValue);\n}"],
  ["Swift.(file).!=infix(_:T,_:T)", "\nfunction infix_33_61<T>($info, lhs, rhs){\n\nreturn $info.T.RawValue.infix_33_61({Self: $info.T.RawValue}, lhs.rawValue, rhs.rawValue);\n}"],
  ["Swift.(file).ContiguousArray.index(after:Int)", "\n\nindexAfter($info, i){\n\nreturn Int.infix_43(null, i, 1);\n}"],
  ["Swift.(file).ContiguousArray.formIndex(after:Int)", "\n\nformIndexAfter($info, i$inout){\n\nlet i = i$inout.get()\nconst $result = (() => {\nInt.infix_43_61(null, {get: () => i, set: $val => i = $val}, 1);})()\ni$inout.set(i)\nreturn $result\n}"],
  ["Swift.(file).ContiguousArray.index(before:Int)", "\n\nindexBefore($info, i){\n\nreturn Int.infix_45(null, i, 1);\n}"],
  ["Swift.(file).ContiguousArray.formIndex(before:Int)", "\n\nformIndexBefore($info, i$inout){\n\nlet i = i$inout.get()\nconst $result = (() => {\nInt.infix_45_61(null, {get: () => i, set: $val => i = $val}, 1);})()\ni$inout.set(i)\nreturn $result\n}"],
  ["Swift.(file).ContiguousArray.index(_:Int,offsetBy:Int)", "\n\nindexOffsetBy($info, i, distance){\n\nreturn Int.infix_43(null, i, distance);\n}"],
  ["Swift.(file).ContiguousArray.index(_:Int,offsetBy:Int,limitedBy:Int)", "\n\nindexOffsetByLimitedBy($info, i, distance, limit){\n\n\nconst l = Int.infix_45(null, limit, i);\n\n;\n\n;\n\n{\nif(((Int.infix_62(null, distance, 0) ? Bool.infix_38_38(null, Int.infix_62_61(null, l, 0), () => Int.infix_60(null, l, distance)) : Bool.infix_38_38(null, Int.infix_60_61(null, l, 0), () => Int.infix_60(null, distance, l))))) {\n\nreturn null;\n}\n};\nreturn Int.infix_43(null, i, distance);\n}"],
  ["Swift.(file).ContiguousArray.distance(from:Int,to:Int)", "\n\ndistanceFromTo($info, start, end){\n\nreturn Int.infix_45(null, end, start);\n}"],
  ["Swift.(file).ContiguousArray.withContiguousMutableStorageIfAvailable(_:(inout UnsafeMutableBufferPointer<Element>) throws -> R)", "\n\nwithContiguousMutableStorageIfAvailable<R>($info, body){\n\nreturn this.withUnsafeMutableBufferPointer({Element: $info.Element, R: $info.R}, (($info, bufferPointer$inout) => body(null, {get: () => bufferPointer, set: $val => bufferPointer = $val})));\n}"],
  ["Swift.(file).ContiguousArray.withContiguousStorageIfAvailable(_:(UnsafeBufferPointer<Element>) throws -> R)", "\n\nwithContiguousStorageIfAvailable<R>($info, body){\n\nreturn this.withUnsafeBufferPointer({Element: $info.Element, R: $info.R}, (($info, bufferPointer) => body(null, bufferPointer)));\n}"],
  ["Swift.(file).ContiguousArray.withUnsafeMutableBytes(_:(UnsafeMutableRawBufferPointer) throws -> R)", "\n\nwithUnsafeMutableBytes<R>($info, body){\n\nreturn this.withUnsafeMutableBufferPointer({Element: $info.Element, R: $info.R}, (($info, $0$inout) => body(null, _create(UnsafeMutableRawBufferPointer, 'initUnsafeMutableBufferPointer', {T: $info.Element}, $0))));\n}"],
  ["Swift.(file).ContiguousArray.withUnsafeBytes(_:(UnsafeRawBufferPointer) throws -> R)", "\n\nwithUnsafeBytes<R>($info, body){\n\nreturn this.withUnsafeBufferPointer({Element: $info.Element, R: $info.R}, (($info, $0) => body(null, _create(UnsafeRawBufferPointer, 'initUnsafeBufferPointer', {T: $info.Element}, $0))));\n}"],
  ["Swift.(file).LazyDropWhileSequence.Iterator", "\n\nstatic Iterator = class{\nstatic readonly $struct = true\nstatic readonly $infoAddress = '0x7f98288065a8'\nstatic readonly Element = {$genericType: 'Base', $subchain: 'Element'}\ninit_basePredicatefunction_type($info, _base, predicate){\n\nthis._base = _base;\nthis._predicate = predicate;\nreturn ;\n}\n\n_predicateHasFailed$internal\n_predicateHasFailed$get() { return this._predicateHasFailed$internal }\nget _predicateHasFailed() { return this._predicateHasFailed$get() }\n_predicateHasFailed$set($newValue) {\nlet $oldValue = this._predicateHasFailed$internal\nthis._predicateHasFailed$internal = $newValue\n}\nset _predicateHasFailed($newValue) { this._predicateHasFailed$set($newValue) }\n;\n\n\n\n\n\n\n_base$internal\n_base$get() { return this._base$internal }\nget _base() { return this._base$get() }\n_base$set($newValue) {\nlet $oldValue = this._base$internal\nthis._base$internal = $newValue\n}\nset _base($newValue) { this._base$set($newValue) }\n;\n\n\n\n\n\n\nreadonly _predicate$internal\nreadonly _predicate$get() { return this._predicate$internal }\nreadonly get _predicate() { return this._predicate$get() }\nreadonly _predicate$set($newValue) {\nlet $oldValue = this._predicate$internal\nthis._predicate$internal = $newValue\n}\nreadonly set _predicate($newValue) { this._predicate$set($newValue) }\n;\n\n\n\ninit$vars() {\nthis._predicateHasFailed$internal = false\n}\n}"],
  ["Swift.(file).EmptyCollection.makeIterator()", "\n\nmakeIterator($info){\n\nreturn _create(EmptyCollection.Iterator, 'init', {Element: this.$info.Element}, );\n}"],
  ["Swift.(file).EmptyCollection.==infix(_:EmptyCollection<Element>,_:EmptyCollection<Element>)", "\n\nstatic infix_61_61($info, lhs, rhs){\n\nreturn true;\n}"],
  ["Swift.(file).Equatable.!=infix(_:Self,_:Self)", "\n\nstatic infix_33_61($info, lhs, rhs){\n\nreturn Bool.prefix_33(null, this.$info.Self.infix_61_61({Self: this.$info.Self}, lhs, rhs));\n}"],
  ["Swift.(file).===infix(_:AnyObject?,_:AnyObject?)", "\nfunction infix_61_61_61($info, lhs, rhs){\n\nconst $match = {0: lhs, 1: rhs}\nif(((true))) {\nconst l = $match[0]\nconst r = $match[1]\nreturn ObjectIdentifier.infix_61_61(null, _create(ObjectIdentifier, 'initAnyObject', null, l), _create(ObjectIdentifier, 'initAnyObject', null, r));\n}\nelse if((($match.rawValue == Optional.none.rawValue && $match.rawValue == Optional.none.rawValue))) {\nreturn true;\n}\nelse if(((true))) {\nreturn false;\n};\n}"],
  ["Swift.(file).!==infix(_:AnyObject?,_:AnyObject?)", "\nfunction infix_33_61_61($info, lhs, rhs){\n\nreturn Bool.prefix_33(null, infix_61_61_61(null, lhs, rhs));\n}"],
  ["Swift.(file).LazyFilterSequence.Iterator", "\n\nstatic Iterator = class{\nstatic readonly $struct = true\nstatic readonly $infoAddress = '0x7f872b0dfba8'\n\nbase$internal\nbase$get(){\n\nreturn this._base;\n}\nget base() { return this.base$get() };\n\n\n\n\n_base$internal\n_base$get() { return this._base$internal }\nget _base() { return this._base$get() }\n_base$set($newValue) {\nlet $oldValue = this._base$internal\nthis._base$internal = $newValue\n}\nset _base($newValue) { this._base$set($newValue) }\n;\n\n\n\n\n\n\nreadonly _predicate$internal\nreadonly _predicate$get() { return this._predicate$internal }\nreadonly get _predicate() { return this._predicate$get() }\nreadonly _predicate$set($newValue) {\nlet $oldValue = this._predicate$internal\nthis._predicate$internal = $newValue\n}\nreadonly set _predicate($newValue) { this._predicate$set($newValue) }\n;\n\n\n\ninit_basefunction_type($info, _base, isIncluded){\n\nthis._base = _base;\nthis._predicate = isIncluded;\nreturn ;\n}\ninit$vars() {\n}\n}"],
  ["Swift.(file).LazySequenceProtocol.filter(_:(Self.Elements.Element) -> Bool)", "\n\nfilterSwift($info, isIncluded){\n\nreturn _create(LazyFilterSequence, 'init_basefunction_type', {Base: this.$info.Self.Elements}, this._elements, isIncluded);\n}"],
  ["Swift.(file).LazySequenceProtocol.flatMap(_:(Self.Elements.Element) -> SegmentOfResult)", "\n\nflatMap<SegmentOfResult>($info, transform){\n\nreturn this.mapSwift({Self: $info.Self, U: $info.SegmentOfResult}, transform).joined({Self: _clarifyGenerics({Self:LazyMapSequence, Base: $info.Self.Elements, Element: $info.SegmentOfResult})}, );\n}"],
  ["Swift.(file).LazySequenceProtocol.compactMap(_:(Self.Elements.Element) -> ElementOfResult?)", "\n\ncompactMap<ElementOfResult>($info, transform){\n\nreturn this.mapSwift({Self: $info.Self, U: _clarifyGenerics({Self:Optional, Wrapped: $info.ElementOfResult})}, transform).filterSwift({Self: _clarifyGenerics({Self:LazyMapSequence, Base: $info.Self.Elements, Element: _clarifyGenerics({Self:Optional, Wrapped: $info.ElementOfResult})})}, (($info, $0) => Optional.infix_33_61({Wrapped: $info.ElementOfResult}, $0, null))).mapSwift({Self: _clarifyGenerics({Self:LazyFilterSequence, Base: _clarifyGenerics({Self:LazyMapSequence, Base: $info.Self.Elements, Element: _clarifyGenerics({Self:Optional, Wrapped: $info.ElementOfResult})})}), U: $info.ElementOfResult}, (($info, $0) => $0));\n}"],
  ["Swift.(file).FlattenSequence.Iterator", "\n\nstatic Iterator = class{\nstatic readonly $struct = true\nstatic readonly $infoAddress = '0x7fa54a0075a0'\n\n_base$internal\n_base$get() { return this._base$internal }\nget _base() { return this._base$get() }\n_base$set($newValue) {\nlet $oldValue = this._base$internal\nthis._base$internal = $newValue\n}\nset _base($newValue) { this._base$set($newValue) }\n;\n\n\n\n\n\n\n_inner$internal\n_inner$get() { return this._inner$internal }\nget _inner() { return this._inner$get() }\n_inner$set($newValue) {\nlet $oldValue = this._inner$internal\nthis._inner$internal = $newValue\n}\nset _inner($newValue) { this._inner$set($newValue) }\n;\n\n\n\n\n\ninit_base($info, _base){\n\nthis._base = _base;\nreturn ;\n}\ninit$vars() {\nthis._inner$internal = null\n}\n}"],
  ["Swift.(file).FloatingPointSign.==infix(_:FloatingPointSign,_:FloatingPointSign)", "\n\nstatic infix_61_61($info, a, b){\n\nreturn Int.infix_61_61(null, a.rawValue, b.rawValue);\n}"],
  ["Swift.(file).FloatingPointSign.hash(into:Hasher)", "\n\nhashInto($info, hasher$inout){\n\nlet hasher = hasher$inout.get()\nconst $result = (() => {\nhasher.combine({H: Int}, this.rawValue);})()\nhasher$inout.set(hasher)\nreturn $result\n}"],
  ["Swift.(file).FloatingPoint.==infix(_:Self,_:Self)", "\n\nstatic infix_61_61($info, lhs, rhs){\n\nreturn lhs.isEqualTo({Self: this.$info.Self}, rhs);\n}"],
  ["Swift.(file).FloatingPoint.<infix(_:Self,_:Self)", "\n\nstatic infix_60($info, lhs, rhs){\n\nreturn lhs.isLessThan({Self: this.$info.Self}, rhs);\n}"],
  ["Swift.(file).FloatingPoint.<=infix(_:Self,_:Self)", "\n\nstatic infix_60_61($info, lhs, rhs){\n\nreturn lhs.isLessThanOrEqualTo({Self: this.$info.Self}, rhs);\n}"],
  ["Swift.(file).FloatingPoint.>infix(_:Self,_:Self)", "\n\nstatic infix_62($info, lhs, rhs){\n\nreturn rhs.isLessThan({Self: this.$info.Self}, lhs);\n}"],
  ["Swift.(file).FloatingPoint.>=infix(_:Self,_:Self)", "\n\nstatic infix_62_61($info, lhs, rhs){\n\nreturn rhs.isLessThanOrEqualTo({Self: this.$info.Self}, lhs);\n}"],
  ["Swift.(file).FloatingPoint.rounded(_:FloatingPointRoundingRule)", "\n\nrounded($info, rule){\n\n\nlet lhs = this;\n\n;\n\n;\nlhs.round({Self: this.$info.Self}, rule);\nreturn lhs;\n}"],
  ["Swift.(file).FloatingPoint.rounded()", "\n\nrounded($info){\n\nreturn this.rounded({Self: this.$info.Self}, FloatingPointRoundingRule.toNearestOrAwayFromZero);\n}"],
  ["Swift.(file).FloatingPoint.round()", "\n\nround($info){\n\nthis.round({Self: this.$info.Self}, FloatingPointRoundingRule.toNearestOrAwayFromZero);\n}"],
  ["Swift.(file).FloatingPoint.truncatingRemainder(dividingBy:Self)", "\n\ntruncatingRemainderDividingBy($info, other){\n\n\nlet lhs = this;\n\n;\n\n;\nlhs.formTruncatingRemainderDividingBy({Self: this.$info.Self}, other);\nreturn lhs;\n}"],
  ["Swift.(file).FloatingPoint.remainder(dividingBy:Self)", "\n\nremainderDividingBy($info, other){\n\n\nlet lhs = this;\n\n;\n\n;\nlhs.formRemainderDividingBy({Self: this.$info.Self}, other);\nreturn lhs;\n}"],
  ["Swift.(file).FloatingPoint.squareRoot()", "\n\nsquareRoot($info){\n\n\nlet lhs = this;\n\n;\n\n;\nlhs.formSquareRoot({Self: this.$info.Self}, );\nreturn lhs;\n}"],
  ["Swift.(file).FloatingPoint.addingProduct(_:Self,_:Self)", "\n\naddingProduct($info, lhs, rhs){\n\n\nlet addend = this;\n\n;\n\n;\naddend.addProduct({Self: this.$info.Self}, lhs, rhs);\nreturn addend;\n}"],
  ["Swift.(file).FloatingPoint.minimum(_:Self,_:Self)", "\n\nstatic minimum($info, x, y){\n\n\n{\nif((Bool.infix_124_124(null, x.isSignalingNaN, () => y.isSignalingNaN))) {\n\nreturn this.$info.Self.infix_43({Self: this.$info.Self}, x, y);\n}\n};\n\n{\nif((Bool.infix_124_124(null, this.$info.Self.infix_60_61({Self: this.$info.Self}, x, y), () => y._isNaN))) {\n\nreturn x;\n}\n};\nreturn y;\n}"],
  ["Swift.(file).FloatingPoint.maximum(_:Self,_:Self)", "\n\nstatic maximum($info, x, y){\n\n\n{\nif((Bool.infix_124_124(null, x.isSignalingNaN, () => y.isSignalingNaN))) {\n\nreturn this.$info.Self.infix_43({Self: this.$info.Self}, x, y);\n}\n};\n\n{\nif((Bool.infix_124_124(null, this.$info.Self.infix_62({Self: this.$info.Self}, x, y), () => y._isNaN))) {\n\nreturn x;\n}\n};\nreturn y;\n}"],
  ["Swift.(file).FloatingPoint.minimumMagnitude(_:Self,_:Self)", "\n\nstatic minimumMagnitude($info, x, y){\n\n\n{\nif((Bool.infix_124_124(null, x.isSignalingNaN, () => y.isSignalingNaN))) {\n\nreturn this.$info.Self.infix_43({Self: this.$info.Self}, x, y);\n}\n};\n\n{\nif((Bool.infix_124_124(null, this.$info.Self.infix_60_61({Self: this.$info.Self}, x.magnitude, y.magnitude), () => y._isNaN))) {\n\nreturn x;\n}\n};\nreturn y;\n}"],
  ["Swift.(file).FloatingPoint.maximumMagnitude(_:Self,_:Self)", "\n\nstatic maximumMagnitude($info, x, y){\n\n\n{\nif((Bool.infix_124_124(null, x.isSignalingNaN, () => y.isSignalingNaN))) {\n\nreturn this.$info.Self.infix_43({Self: this.$info.Self}, x, y);\n}\n};\n\n{\nif((Bool.infix_124_124(null, this.$info.Self.infix_62({Self: this.$info.Self}, x.magnitude, y.magnitude), () => y._isNaN))) {\n\nreturn x;\n}\n};\nreturn y;\n}"],
  ["Swift.(file).BinaryFloatingPoint.isTotallyOrdered(belowOrEqualTo:Self)", "\n\nisTotallyOrderedBelowOrEqualTo($info, other){\n\n\n{\nif((this.$info.Self.infix_60({Self: this.$info.Self}, this, other))) {\n\nreturn true;\n}\n};\n\n{\nif((this.$info.Self.infix_62({Self: this.$info.Self}, other, this))) {\n\nreturn false;\n}\n};\n\n{\nif((FloatingPointSign.infix_33_61({Self: FloatingPointSign}, this.sign, other.sign))) {\n\nreturn FloatingPointSign.infix_61_61(null, this.sign, FloatingPointSign.minus);\n}\n};\n\n{\nif((this.$info.Self.RawExponent.infix_62({Self: this.$info.Self.RawExponent}, this.exponentBitPattern, other.exponentBitPattern))) {\n\nreturn FloatingPointSign.infix_61_61(null, this.sign, FloatingPointSign.minus);\n}\n};\n\n{\nif((this.$info.Self.RawExponent.infix_60({Self: this.$info.Self.RawExponent}, this.exponentBitPattern, other.exponentBitPattern))) {\n\nreturn FloatingPointSign.infix_61_61(null, this.sign, FloatingPointSign.plus);\n}\n};\n\n{\nif((this.$info.Self.RawSignificand.infix_62({Self: this.$info.Self.RawSignificand}, this.significandBitPattern, other.significandBitPattern))) {\n\nreturn FloatingPointSign.infix_61_61(null, this.sign, FloatingPointSign.minus);\n}\n};\n\n{\nif((this.$info.Self.RawSignificand.infix_60({Self: this.$info.Self.RawSignificand}, this.significandBitPattern, other.significandBitPattern))) {\n\nreturn FloatingPointSign.infix_61_61(null, this.sign, FloatingPointSign.plus);\n}\n};\nreturn true;\n}"],
  ["Swift.(file).Hasher.combine(_:H)", "\n\ncombine<H>($info, value){\n\nvalue.hashInto({Self: $info.H}, {get: () => this, set: $val => Object.assign(this, $val)});\n}"],
  ["Swift.(file).SignedNumeric.-prefix(_:Self)", "\n\nstatic prefix_45($info, operand){\n\n\nlet result = operand;\n\n;\n\n;\nresult.negate({Self: this.$info.Self}, );\nreturn result;\n}"],
  ["Swift.(file).SignedNumeric.negate()", "\n\nnegate($info){\n\nObject.assign(this, this.$info.Self.infix_45({Self: this.$info.Self}, _create(this.$info.Self, 'initIntegerLiteral', {Self: this.$info.Self}, 0), this));\n}"],
  ["Swift.(file).abs(_:T)", "\nfunction abs<T>($info, x){\n\n\n{\nif((infix_61_61(null, $info.T, $info.T.Magnitude))) {\n\nreturn unsafeBitCastTo({T: $info.T.Magnitude, U: $info.T}, x.magnitude, $info.T);\n}\n};\nreturn ($info.T.infix_60({Self: $info.T}, x, _create($info.T, 'initIntegerLiteral', {Self: $info.T}, 0)) ? $info.T.prefix_45({Self: $info.T}, x) : x);\n}"],
  ["Swift.(file).AdditiveArithmetic.+prefix(_:Self)", "\n\nstatic prefix_43($info, x){\n\nreturn x;\n}"],
  ["Swift.(file).BinaryInteger.signum()", "\n\nsignum($info){\n\nreturn this.$info.Self.infix_45({Self: this.$info.Self}, (this.$info.Self.infix_62({Self: this.$info.Self}, this, _create(this.$info.Self, 'initIntegerLiteral', {Self: this.$info.Self}, 0)) ? _create(this.$info.Self, 'initIntegerLiteral', {Self: this.$info.Self}, 1) : _create(this.$info.Self, 'initIntegerLiteral', {Self: this.$info.Self}, 0)), (this.$info.Self.infix_60({Self: this.$info.Self}, this, _create(this.$info.Self, 'initIntegerLiteral', {Self: this.$info.Self}, 0)) ? _create(this.$info.Self, 'initIntegerLiteral', {Self: this.$info.Self}, 1) : _create(this.$info.Self, 'initIntegerLiteral', {Self: this.$info.Self}, 0)));\n}"],
  ["Swift.(file).BinaryInteger.quotientAndRemainder(dividingBy:Self)", "\n\nquotientAndRemainderDividingBy($info, rhs){\n\nreturn {0: this.$info.Self.infix_47({Self: this.$info.Self}, this, rhs), 1: this.$info.Self.infix_37({Self: this.$info.Self}, this, rhs)};\n}"],
  ["Swift.(file).BinaryInteger.isMultiple(of:Self)", "\n\nisMultipleOf($info, other){\n\n\n{\nif((this.$info.Self.infix_61_61({Self: this.$info.Self, Other: Int}, other, 0))) {\n\nreturn this.$info.Self.infix_61_61({Self: this.$info.Self, Other: Int}, this, 0);\n}\n};\nreturn this.$info.Self.Magnitude.infix_61_61({Self: this.$info.Self.Magnitude, Other: Int}, this.$info.Self.Magnitude.infix_37({Self: this.$info.Self.Magnitude}, this.magnitude, other.magnitude), 0);\n}"],
  ["Swift.(file).BinaryInteger.&infix(_:Self,_:Self)", "\n\nstatic infix_38($info, lhs, rhs){\n\n\nlet lhs = lhs;\n\n;\n\n;\nthis.$info.Self.infix_38_61({Self: this.$info.Self}, {get: () => lhs, set: $val => lhs = $val}, rhs);\nreturn lhs;\n}"],
  ["Swift.(file).BinaryInteger.|infix(_:Self,_:Self)", "\n\nstatic infix_124($info, lhs, rhs){\n\n\nlet lhs = lhs;\n\n;\n\n;\nthis.$info.Self.infix_124_61({Self: this.$info.Self}, {get: () => lhs, set: $val => lhs = $val}, rhs);\nreturn lhs;\n}"],
  ["Swift.(file).BinaryInteger.^infix(_:Self,_:Self)", "\n\nstatic infix_94($info, lhs, rhs){\n\n\nlet lhs = lhs;\n\n;\n\n;\nthis.$info.Self.infix_94_61({Self: this.$info.Self}, {get: () => lhs, set: $val => lhs = $val}, rhs);\nreturn lhs;\n}"],
  ["Swift.(file).BinaryInteger.>>infix(_:Self,_:RHS)", "\n\nstatic infix_62_62<RHS>($info, lhs, rhs){\n\n\nlet r = lhs;\n\n;\n\n;\n$info.Self.infix_62_62_61({Self: $info.Self, RHS: $info.RHS}, {get: () => r, set: $val => r = $val}, rhs);\nreturn r;\n}"],
  ["Swift.(file).BinaryInteger.<<infix(_:Self,_:RHS)", "\n\nstatic infix_60_60<RHS>($info, lhs, rhs){\n\n\nlet r = lhs;\n\n;\n\n;\n$info.Self.infix_60_60_61({Self: $info.Self, RHS: $info.RHS}, {get: () => r, set: $val => r = $val}, rhs);\nreturn r;\n}"],
  ["Swift.(file).BinaryInteger.advanced(by:Int)", "\n\nadvancedBy($info, n){\n\n\n{\nif((Bool.prefix_33(null, this.$info.Self.isSigned))) {\n\nreturn (Int.infix_60(null, n, 0) ? this.$info.Self.infix_45({Self: this.$info.Self}, this, _create(this.$info.Self, 'init', {Self: this.$info.Self, T: Int}, Int.prefix_45({Self: Int}, n))) : this.$info.Self.infix_43({Self: this.$info.Self}, this, _create(this.$info.Self, 'init', {Self: this.$info.Self, T: Int}, n)));\n}\n};\n\n{\nif((Bool.infix_61_61(null, this.$info.Self.infix_60({Self: this.$info.Self}, this, _create(this.$info.Self, 'initIntegerLiteral', {Self: this.$info.Self}, 0)), Int.infix_60({Self: Int, Other: this.$info.Self}, n, _create(this.$info.Self, 'initIntegerLiteral', {Self: this.$info.Self}, 0))))) {\n\nreturn this.$info.Self.infix_43({Self: this.$info.Self}, this, _create(this.$info.Self, 'init', {Self: this.$info.Self, T: Int}, n));\n}\n};\nreturn (this.$info.Self.Magnitude.infix_60({Self: this.$info.Self.Magnitude, Other: UInt}, this.magnitude, n.magnitude) ? _create(this.$info.Self, 'init', {Self: this.$info.Self, T: Int}, Int.infix_43(null, _create(Int, 'init', {Self: Int, T: this.$info.Self}, this), n)) : this.$info.Self.infix_43({Self: this.$info.Self}, this, _create(this.$info.Self, 'init', {Self: this.$info.Self, T: Int}, n)));\n}"],
  ["Swift.(file).BinaryInteger.==infix(_:Self,_:Other)", "\n\nstatic infix_61_61<Other>($info, lhs, rhs){\n\n\nconst lhsNegative = Bool.infix_38_38(null, $info.Self.isSigned, () => $info.Self.infix_60({Self: $info.Self}, lhs, _create($info.Self, 'initIntegerLiteral', {Self: $info.Self}, 0)));\n\n;\n\n;\n\nconst rhsNegative = Bool.infix_38_38(null, $info.Other.isSigned, () => $info.Other.infix_60({Self: $info.Other}, rhs, _create($info.Other, 'initIntegerLiteral', {Self: $info.Other}, 0)));\n\n;\n\n;\n\n{\nif((Bool.infix_33_61({Self: Bool}, lhsNegative, rhsNegative))) {\n\nreturn false;\n}\n};\n\n{\nif((Int.infix_60(null, lhs.bitWidth, rhs.bitWidth))) {\n\nreturn $info.Other.infix_61_61({Self: $info.Other}, _create($info.Other, 'initTruncatingIfNeeded', {Self: $info.Other, T: $info.Self}, lhs), rhs);\n}\n};\n\n{\nif((Int.infix_62(null, lhs.bitWidth, rhs.bitWidth))) {\n\nreturn $info.Self.infix_61_61({Self: $info.Self}, lhs, _create($info.Self, 'initTruncatingIfNeeded', {Self: $info.Self, T: $info.Other}, rhs));\n}\n};\n\n{\nif(($info.Self.isSigned)) {\n\nreturn $info.Other.infix_61_61({Self: $info.Other}, _create($info.Other, 'initTruncatingIfNeeded', {Self: $info.Other, T: $info.Self}, lhs), rhs);\n}\n};\nreturn $info.Self.infix_61_61({Self: $info.Self}, lhs, _create($info.Self, 'initTruncatingIfNeeded', {Self: $info.Self, T: $info.Other}, rhs));\n}"],
  ["Swift.(file).BinaryInteger.!=infix(_:Self,_:Other)", "\n\nstatic infix_33_61<Other>($info, lhs, rhs){\n\nreturn Bool.prefix_33(null, $info.Self.infix_61_61({Self: $info.Self, Other: $info.Other}, lhs, rhs));\n}"],
  ["Swift.(file).BinaryInteger.<infix(_:Self,_:Other)", "\n\nstatic infix_60<Other>($info, lhs, rhs){\n\n\nconst lhsNegative = Bool.infix_38_38(null, $info.Self.isSigned, () => $info.Self.infix_60({Self: $info.Self}, lhs, _create($info.Self, 'initIntegerLiteral', {Self: $info.Self}, 0)));\n\n;\n\n;\n\nconst rhsNegative = Bool.infix_38_38(null, $info.Other.isSigned, () => $info.Other.infix_60({Self: $info.Other}, rhs, _create($info.Other, 'initIntegerLiteral', {Self: $info.Other}, 0)));\n\n;\n\n;\n\n{\nif((Bool.infix_33_61({Self: Bool}, lhsNegative, rhsNegative))) {\n\nreturn lhsNegative;\n}\n};\n\n{\nif((Bool.infix_38_38(null, $info.Self.infix_61_61({Self: $info.Self}, lhs, _create($info.Self, 'initIntegerLiteral', {Self: $info.Self}, 0)), () => $info.Other.infix_61_61({Self: $info.Other}, rhs, _create($info.Other, 'initIntegerLiteral', {Self: $info.Other}, 0))))) {\n\nreturn false;\n}\n};\n\nconst rhsAsSelf = _create($info.Self, 'initTruncatingIfNeeded', {Self: $info.Self, T: $info.Other}, rhs);\n\n;\n\n;\n\nconst rhsAsSelfNegative = $info.Self.infix_60({Self: $info.Self}, rhsAsSelf, _create($info.Self, 'initIntegerLiteral', {Self: $info.Self}, 0));\n\n;\n\n;\n\n{\nif((Bool.infix_38_38(null, $info.Other.infix_61_61({Self: $info.Other}, _create($info.Other, 'initTruncatingIfNeeded', {Self: $info.Other, T: $info.Self}, rhsAsSelf), rhs), () => Bool.infix_61_61(null, rhsNegative, rhsAsSelfNegative)))) {\n\nreturn $info.Self.infix_60({Self: $info.Self}, lhs, rhsAsSelf);\n}\n};\nreturn $info.Other.infix_60({Self: $info.Other}, _create($info.Other, 'initTruncatingIfNeeded', {Self: $info.Other, T: $info.Self}, lhs), rhs);\n}"],
  ["Swift.(file).BinaryInteger.<=infix(_:Self,_:Other)", "\n\nstatic infix_60_61<Other>($info, lhs, rhs){\n\nreturn Bool.prefix_33(null, $info.Other.infix_60({Self: $info.Other, Other: $info.Self}, rhs, lhs));\n}"],
  ["Swift.(file).BinaryInteger.>=infix(_:Self,_:Other)", "\n\nstatic infix_62_61<Other>($info, lhs, rhs){\n\nreturn Bool.prefix_33(null, $info.Self.infix_60({Self: $info.Self, Other: $info.Other}, lhs, rhs));\n}"],
  ["Swift.(file).BinaryInteger.>infix(_:Self,_:Other)", "\n\nstatic infix_62<Other>($info, lhs, rhs){\n\nreturn $info.Other.infix_60({Self: $info.Other, Other: $info.Self}, rhs, lhs);\n}"],
  ["Swift.(file).BinaryInteger.!=infix(_:Self,_:Self)", "\n\nstatic infix_33_61($info, lhs, rhs){\n\nreturn Bool.prefix_33(null, this.$info.Self.infix_61_61({Self: this.$info.Self}, lhs, rhs));\n}"],
  ["Swift.(file).BinaryInteger.<=infix(_:Self,_:Self)", "\n\nstatic infix_60_61($info, lhs, rhs){\n\nreturn Bool.prefix_33(null, this.$info.Self.infix_60({Self: this.$info.Self}, rhs, lhs));\n}"],
  ["Swift.(file).BinaryInteger.>=infix(_:Self,_:Self)", "\n\nstatic infix_62_61($info, lhs, rhs){\n\nreturn Bool.prefix_33(null, this.$info.Self.infix_60({Self: this.$info.Self}, lhs, rhs));\n}"],
  ["Swift.(file).BinaryInteger.>infix(_:Self,_:Self)", "\n\nstatic infix_62($info, lhs, rhs){\n\nreturn this.$info.Self.infix_60({Self: this.$info.Self}, rhs, lhs);\n}"],
  ["Swift.(file).FixedWidthInteger.&>>infix(_:Self,_:Self)", "\n\nstatic infix_38_62_62($info, lhs, rhs){\n\n\nlet lhs = lhs;\n\n;\n\n;\nthis.$info.Self.infix_38_62_62_61({Self: this.$info.Self}, {get: () => lhs, set: $val => lhs = $val}, rhs);\nreturn lhs;\n}"],
  ["Swift.(file).FixedWidthInteger.&>>infix(_:Self,_:Other)", "\n\nstatic infix_38_62_62<Other>($info, lhs, rhs){\n\nreturn $info.Self.infix_38_62_62({Self: $info.Self}, lhs, _create($info.Self, 'initTruncatingIfNeeded', {Self: $info.Self, T: $info.Other}, rhs));\n}"],
  ["Swift.(file).FixedWidthInteger.&>>=infix(_:Self,_:Other)", "\n\nstatic infix_38_62_62_61<Other>($info, lhs$inout, rhs){\n\nlet lhs = lhs$inout.get()\nconst $result = (() => {\nlhs = $info.Self.infix_38_62_62({Self: $info.Self, Other: $info.Other}, lhs, rhs);})()\nlhs$inout.set(lhs)\nreturn $result\n}"],
  ["Swift.(file).FixedWidthInteger.&<<infix(_:Self,_:Self)", "\n\nstatic infix_38_60_60($info, lhs, rhs){\n\n\nlet lhs = lhs;\n\n;\n\n;\nthis.$info.Self.infix_38_60_60_61({Self: this.$info.Self}, {get: () => lhs, set: $val => lhs = $val}, rhs);\nreturn lhs;\n}"],
  ["Swift.(file).FixedWidthInteger.&<<infix(_:Self,_:Other)", "\n\nstatic infix_38_60_60<Other>($info, lhs, rhs){\n\nreturn $info.Self.infix_38_60_60({Self: $info.Self}, lhs, _create($info.Self, 'initTruncatingIfNeeded', {Self: $info.Self, T: $info.Other}, rhs));\n}"],
  ["Swift.(file).FixedWidthInteger.&<<=infix(_:Self,_:Other)", "\n\nstatic infix_38_60_60_61<Other>($info, lhs$inout, rhs){\n\nlet lhs = lhs$inout.get()\nconst $result = (() => {\nlhs = $info.Self.infix_38_60_60({Self: $info.Self, Other: $info.Other}, lhs, rhs);})()\nlhs$inout.set(lhs)\nreturn $result\n}"],
  ["Swift.(file).FixedWidthInteger.random(in:Range<Self>,using:T)", "\n\nstatic randomInUsing<T>($info, range, generator$inout){\n\nlet generator = generator$inout.get()\nconst $result = (() => {\npreconditionFileLine(null, () => Bool.prefix_33(null, range.isEmpty), () => \"Can't get random value with an empty range\");\n\nconst delta = _create($info.Self.Magnitude, 'initTruncatingIfNeeded', {Self: $info.Self.Magnitude, T: $info.Self}, $info.Self.infix_38_45({Self: $info.Self}, range.upperBound, range.lowerBound));\n\n;\n\n;\nreturn _create($info.Self, 'initTruncatingIfNeeded', {Self: $info.Self, T: $info.Self.Magnitude}, $info.Self.Magnitude.infix_38_43({Self: $info.Self.Magnitude}, _create($info.Self.Magnitude, 'initTruncatingIfNeeded', {Self: $info.Self.Magnitude, T: $info.Self}, range.lowerBound), generator.nextUpperBound({Self: $info.T, T: $info.Self.Magnitude}, delta)));})()\ngenerator$inout.set(generator)\nreturn $result\n}"],
  ["Swift.(file).FixedWidthInteger.random(in:Range<Self>)", "\n\nstatic randomIn($info, range){\n\n\nlet g = _create(SystemRandomNumberGenerator, 'init', null, );\n\n;\n\n;\nreturn this.$info.Self.randomInUsing({Self: this.$info.Self, T: SystemRandomNumberGenerator}, range, {get: () => g, set: $val => g = $val});\n}"],
  ["Swift.(file).FixedWidthInteger.random(in:ClosedRange<Self>,using:T)", "\n\nstatic randomInUsing<T>($info, range, generator$inout){\n\nlet generator = generator$inout.get()\nconst $result = (() => {\npreconditionFileLine(null, () => Bool.prefix_33(null, range.isEmpty), () => \"Can't get random value with an empty range\");\n\nlet delta = _create($info.Self.Magnitude, 'initTruncatingIfNeeded', {Self: $info.Self.Magnitude, T: $info.Self}, $info.Self.infix_38_45({Self: $info.Self}, range.upperBound, range.lowerBound));\n\n;\n\n;\n\n{\nif(($info.Self.Magnitude.infix_61_61({Self: $info.Self.Magnitude}, delta, $info.Self.Magnitude.max))) {\n\nreturn _create($info.Self, 'initTruncatingIfNeeded', {Self: $info.Self, T: $info.Self.Magnitude}, generator.next({Self: $info.T, T: $info.Self.Magnitude}, ));\n}\n};\n$info.Self.Magnitude.infix_43_61({Self: $info.Self.Magnitude}, {get: () => delta, set: $val => delta = $val}, _create($info.Self.Magnitude, 'initIntegerLiteral', {Self: $info.Self.Magnitude}, 1));\nreturn _create($info.Self, 'initTruncatingIfNeeded', {Self: $info.Self, T: $info.Self.Magnitude}, $info.Self.Magnitude.infix_38_43({Self: $info.Self.Magnitude}, _create($info.Self.Magnitude, 'initTruncatingIfNeeded', {Self: $info.Self.Magnitude, T: $info.Self}, range.lowerBound), generator.nextUpperBound({Self: $info.T, T: $info.Self.Magnitude}, delta)));})()\ngenerator$inout.set(generator)\nreturn $result\n}"],
  ["Swift.(file).FixedWidthInteger.random(in:ClosedRange<Self>)", "\n\nstatic randomIn($info, range){\n\n\nlet g = _create(SystemRandomNumberGenerator, 'init', null, );\n\n;\n\n;\nreturn this.$info.Self.randomInUsing({Self: this.$info.Self, T: SystemRandomNumberGenerator}, range, {get: () => g, set: $val => g = $val});\n}"],
  ["Swift.(file).FixedWidthInteger.~prefix(_:Self)", "\n\nstatic prefix_126($info, x){\n\nreturn this.$info.Self.infix_38_45({Self: this.$info.Self}, this.$info.Self.infix_38_45({Self: this.$info.Self}, _create(this.$info.Self, 'initIntegerLiteral', {Self: this.$info.Self}, 0), x), _create(this.$info.Self, 'initIntegerLiteral', {Self: this.$info.Self}, 1));\n}"],
  ["Swift.(file).FixedWidthInteger.>>infix(_:Self,_:Other)", "\n\nstatic infix_62_62<Other>($info, lhs, rhs){\n\n\nlet lhs = lhs;\n\n;\n\n;\nthis._nonMaskingRightShiftGeneric({Self: $info.Self, Other: $info.Other}, {get: () => lhs, set: $val => lhs = $val}, rhs);\nreturn lhs;\n}"],
  ["Swift.(file).FixedWidthInteger.>>=infix(_:Self,_:Other)", "\n\nstatic infix_62_62_61<Other>($info, lhs$inout, rhs){\n\nlet lhs = lhs$inout.get()\nconst $result = (() => {\nthis._nonMaskingRightShiftGeneric({Self: $info.Self, Other: $info.Other}, {get: () => lhs, set: $val => lhs = $val}, rhs);})()\nlhs$inout.set(lhs)\nreturn $result\n}"],
  ["Swift.(file).FixedWidthInteger.<<infix(_:Self,_:Other)", "\n\nstatic infix_60_60<Other>($info, lhs, rhs){\n\n\nlet lhs = lhs;\n\n;\n\n;\nthis._nonMaskingLeftShiftGeneric({Self: $info.Self, Other: $info.Other}, {get: () => lhs, set: $val => lhs = $val}, rhs);\nreturn lhs;\n}"],
  ["Swift.(file).FixedWidthInteger.<<=infix(_:Self,_:Other)", "\n\nstatic infix_60_60_61<Other>($info, lhs$inout, rhs){\n\nlet lhs = lhs$inout.get()\nconst $result = (() => {\nthis._nonMaskingLeftShiftGeneric({Self: $info.Self, Other: $info.Other}, {get: () => lhs, set: $val => lhs = $val}, rhs);})()\nlhs$inout.set(lhs)\nreturn $result\n}"],
  ["Swift.(file).FixedWidthInteger.init(truncatingIfNeeded:T)", "\n\ninitTruncatingIfNeeded<T>($info, source){\n\n\n{\nif((Int.infix_60_61(null, $info.Self.bitWidth, Int.bitWidth))) {\n\nObject.assign(this, _create($info.Self, 'init_truncatingBitsUInt', {Self: $info.Self}, source._lowWord));\n}\nelse {\n\nconst neg = $info.T.infix_60({Self: $info.T}, source, _create($info.T, 'initIntegerLiteral', {Self: $info.T}, 0));\n\n;\n\n;\n\nlet result = (neg ? $info.Self.prefix_126({Self: $info.Self}, _create($info.Self, 'initIntegerLiteral', {Self: $info.Self}, 0)) : _create($info.Self, 'initIntegerLiteral', {Self: $info.Self}, 0));\n\n;\n\n;\n\nlet shift = _create($info.Self, 'initIntegerLiteral', {Self: $info.Self}, 0);\n\n;\n\n;\n\nconst width = _create($info.Self, 'init_truncatingBitsUInt', {Self: $info.Self}, $info.Self.bitWidth._lowWord);\n\n;\n\n;\n\n{\nlet $word$generator = source.words.makeIterator({Self: $info.T.Words}, );\n\n\nwhile(true) {\nconst word$let = $word$generator.next({Self: $info.T.Words.Iterator}, );\nif(!((word$let != null))) break;\n\n\n{\nif(!(($info.Self.infix_60({Self: $info.Self}, shift, width)))) {\n\nbreak;\n}\n};\n$info.Self.infix_94_61({Self: $info.Self}, {get: () => result, set: $val => result = $val}, $info.Self.infix_38_60_60({Self: $info.Self}, _create($info.Self, 'init_truncatingBitsUInt', {Self: $info.Self}, (neg ? UInt.prefix_126({Self: UInt}, word$let) : word$let)), shift));\n$info.Self.infix_43_61({Self: $info.Self}, {get: () => shift, set: $val => shift = $val}, _create($info.Self, 'init_truncatingBitsUInt', {Self: $info.Self}, Int.bitWidth._lowWord));\n}\n};\nObject.assign(this, result);\n}\n};\nreturn ;\n}"],
  ["Swift.(file).FixedWidthInteger.&+infix(_:Self,_:Self)", "\n\nstatic infix_38_43($info, lhs, rhs){\n\nreturn lhs.addingReportingOverflow({Self: this.$info.Self}, rhs)[\"0\"];\n}"],
  ["Swift.(file).FixedWidthInteger.&+=infix(_:Self,_:Self)", "\n\nstatic infix_38_43_61($info, lhs$inout, rhs){\n\nlet lhs = lhs$inout.get()\nconst $result = (() => {\nlhs = this.$info.Self.infix_38_43({Self: this.$info.Self}, lhs, rhs);})()\nlhs$inout.set(lhs)\nreturn $result\n}"],
  ["Swift.(file).FixedWidthInteger.&-infix(_:Self,_:Self)", "\n\nstatic infix_38_45($info, lhs, rhs){\n\nreturn lhs.subtractingReportingOverflow({Self: this.$info.Self}, rhs)[\"0\"];\n}"],
  ["Swift.(file).FixedWidthInteger.&-=infix(_:Self,_:Self)", "\n\nstatic infix_38_45_61($info, lhs$inout, rhs){\n\nlet lhs = lhs$inout.get()\nconst $result = (() => {\nlhs = this.$info.Self.infix_38_45({Self: this.$info.Self}, lhs, rhs);})()\nlhs$inout.set(lhs)\nreturn $result\n}"],
  ["Swift.(file).FixedWidthInteger.&*infix(_:Self,_:Self)", "\n\nstatic infix_38_42($info, lhs, rhs){\n\nreturn lhs.multipliedReportingOverflowBy({Self: this.$info.Self}, rhs)[\"0\"];\n}"],
  ["Swift.(file).FixedWidthInteger.&*=infix(_:Self,_:Self)", "\n\nstatic infix_38_42_61($info, lhs$inout, rhs){\n\nlet lhs = lhs$inout.get()\nconst $result = (() => {\nlhs = this.$info.Self.infix_38_42({Self: this.$info.Self}, lhs, rhs);})()\nlhs$inout.set(lhs)\nreturn $result\n}"],
  ["Swift.(file).SignedInteger.isMultiple(of:Self)", "\n\nisMultipleOf($info, other){\n\n\n{\nif((this.$info.Self.infix_61_61({Self: this.$info.Self, Other: Int}, other, 0))) {\n\nreturn this.$info.Self.infix_61_61({Self: this.$info.Self, Other: Int}, this, 0);\n}\n};\n\n{\nif((this.$info.Self.infix_61_61({Self: this.$info.Self, Other: Int}, other, -1))) {\n\nreturn true;\n}\n};\nreturn this.$info.Self.infix_61_61({Self: this.$info.Self, Other: Int}, this.$info.Self.infix_37({Self: this.$info.Self}, this, other), 0);\n}"],
  ["Swift.(file).numericCast(_:T)", "\nfunction numericCast<T, U>($info, x){\n\nreturn _create($info.U, 'init', {Self: $info.U, T: $info.T}, x);\n}"],
  ["Swift.(file).FixedWidthInteger.>>infix(_:Self,_:Self)", "\n\nstatic infix_62_62($info, lhs, rhs){\n\n\nlet lhs = lhs;\n\n;\n\n;\nthis._nonMaskingRightShiftGeneric({Self: this.$info.Self, Other: this.$info.Self}, {get: () => lhs, set: $val => lhs = $val}, rhs);\nreturn lhs;\n}"],
  ["Swift.(file).FixedWidthInteger.>>=infix(_:Self,_:Self)", "\n\nstatic infix_62_62_61($info, lhs$inout, rhs){\n\nlet lhs = lhs$inout.get()\nconst $result = (() => {\nthis._nonMaskingRightShiftGeneric({Self: this.$info.Self, Other: this.$info.Self}, {get: () => lhs, set: $val => lhs = $val}, rhs);})()\nlhs$inout.set(lhs)\nreturn $result\n}"],
  ["Swift.(file).FixedWidthInteger.<<infix(_:Self,_:Self)", "\n\nstatic infix_60_60($info, lhs, rhs){\n\n\nlet lhs = lhs;\n\n;\n\n;\nthis._nonMaskingLeftShiftGeneric({Self: this.$info.Self, Other: this.$info.Self}, {get: () => lhs, set: $val => lhs = $val}, rhs);\nreturn lhs;\n}"],
  ["Swift.(file).FixedWidthInteger.<<=infix(_:Self,_:Self)", "\n\nstatic infix_60_60_61($info, lhs$inout, rhs){\n\nlet lhs = lhs$inout.get()\nconst $result = (() => {\nthis._nonMaskingLeftShiftGeneric({Self: this.$info.Self, Other: this.$info.Self}, {get: () => lhs, set: $val => lhs = $val}, rhs);})()\nlhs$inout.set(lhs)\nreturn $result\n}"],
  ["Swift.(file).FixedWidthInteger.addWithOverflow(_:Self,_:Self)", "\n\nstatic addWithOverflow($info, lhs, rhs){\n\n\nconst $tuple = lhs.addingReportingOverflow({Self: this.$info.Self}, rhs), partialValue = $tuple && $tuple[0], overflow = $tuple && $tuple[1];\n\n;\n\n;\n\n;\nreturn {0: partialValue, 1: overflow};\n}"],
  ["Swift.(file).FixedWidthInteger.subtractWithOverflow(_:Self,_:Self)", "\n\nstatic subtractWithOverflow($info, lhs, rhs){\n\n\nconst $tuple = lhs.subtractingReportingOverflow({Self: this.$info.Self}, rhs), partialValue = $tuple && $tuple[0], overflow = $tuple && $tuple[1];\n\n;\n\n;\n\n;\nreturn {0: partialValue, 1: overflow};\n}"],
  ["Swift.(file).FixedWidthInteger.multiplyWithOverflow(_:Self,_:Self)", "\n\nstatic multiplyWithOverflow($info, lhs, rhs){\n\n\nconst $tuple = lhs.multipliedReportingOverflowBy({Self: this.$info.Self}, rhs), partialValue = $tuple && $tuple[0], overflow = $tuple && $tuple[1];\n\n;\n\n;\n\n;\nreturn {0: partialValue, 1: overflow};\n}"],
  ["Swift.(file).FixedWidthInteger.divideWithOverflow(_:Self,_:Self)", "\n\nstatic divideWithOverflow($info, lhs, rhs){\n\n\nconst $tuple = lhs.dividedReportingOverflowBy({Self: this.$info.Self}, rhs), partialValue = $tuple && $tuple[0], overflow = $tuple && $tuple[1];\n\n;\n\n;\n\n;\nreturn {0: partialValue, 1: overflow};\n}"],
  ["Swift.(file).FixedWidthInteger.remainderWithOverflow(_:Self,_:Self)", "\n\nstatic remainderWithOverflow($info, lhs, rhs){\n\n\nconst $tuple = lhs.remainderReportingOverflowDividingBy({Self: this.$info.Self}, rhs), partialValue = $tuple && $tuple[0], overflow = $tuple && $tuple[1];\n\n;\n\n;\n\n;\nreturn {0: partialValue, 1: overflow};\n}"],
  ["Swift.(file).BinaryInteger.addWithOverflow(_:Self,_:Self)", "\n\nstatic addWithOverflow($info, lhs, rhs){\n\nfatalErrorFileLine(null, () => \"Unavailable\");\n}"],
  ["Swift.(file).BinaryInteger.subtractWithOverflow(_:Self,_:Self)", "\n\nstatic subtractWithOverflow($info, lhs, rhs){\n\nfatalErrorFileLine(null, () => \"Unavailable\");\n}"],
  ["Swift.(file).BinaryInteger.multiplyWithOverflow(_:Self,_:Self)", "\n\nstatic multiplyWithOverflow($info, lhs, rhs){\n\nfatalErrorFileLine(null, () => \"Unavailable\");\n}"],
  ["Swift.(file).BinaryInteger.divideWithOverflow(_:Self,_:Self)", "\n\nstatic divideWithOverflow($info, lhs, rhs){\n\nfatalErrorFileLine(null, () => \"Unavailable\");\n}"],
  ["Swift.(file).BinaryInteger.remainderWithOverflow(_:Self,_:Self)", "\n\nstatic remainderWithOverflow($info, lhs, rhs){\n\nfatalErrorFileLine(null, () => \"Unavailable\");\n}"],
  ["Swift.(file).SignedInteger.&+infix(_:Self,_:Self)", "\n\nstatic infix_38_43($info, lhs, rhs){\n\nreturn this._maskingAdd({Self: this.$info.Self}, lhs, rhs);\n}"],
  ["Swift.(file).SignedInteger.&-infix(_:Self,_:Self)", "\n\nstatic infix_38_45($info, lhs, rhs){\n\nreturn this._maskingSubtract({Self: this.$info.Self}, lhs, rhs);\n}"],
  ["Swift.(file).SignedInteger.&+infix(_:Self,_:Self)", "\n\nstatic infix_38_43($info, lhs, rhs){\n\nreturn this._maskingAdd({Self: this.$info.Self}, lhs, rhs);\n}"],
  ["Swift.(file).SignedInteger.&-infix(_:Self,_:Self)", "\n\nstatic infix_38_45($info, lhs, rhs){\n\nreturn this._maskingSubtract({Self: this.$info.Self}, lhs, rhs);\n}"],
  ["Swift.(file).JoinedSequence.Iterator", "\n\nstatic Iterator = class{\nstatic readonly $struct = true\nstatic readonly $infoAddress = '0x7fd4e38283a0'\n\n_base$internal\n_base$get() { return this._base$internal }\nget _base() { return this._base$get() }\n_base$set($newValue) {\nlet $oldValue = this._base$internal\nthis._base$internal = $newValue\n}\nset _base($newValue) { this._base$set($newValue) }\n;\n\n\n\n\n\n\n_inner$internal\n_inner$get() { return this._inner$internal }\nget _inner() { return this._inner$get() }\n_inner$set($newValue) {\nlet $oldValue = this._inner$internal\nthis._inner$internal = $newValue\n}\nset _inner($newValue) { this._inner$set($newValue) }\n;\n\n\n\n\n\n\n_separatorData$internal\n_separatorData$get() { return this._separatorData$internal }\nget _separatorData() { return this._separatorData$get() }\n_separatorData$set($newValue) {\nlet $oldValue = this._separatorData$internal\nthis._separatorData$internal = $newValue\n}\nset _separatorData($newValue) { this._separatorData$set($newValue) }\n;\n\n\n\n\n\n\n_separator$internal\n_separator$get() { return this._separator$internal }\nget _separator() { return this._separator$get() }\n_separator$set($newValue) {\nlet $oldValue = this._separator$internal\nthis._separator$internal = $newValue\n}\nset _separator($newValue) { this._separator$set($newValue) }\n;\n\n\n\n\n\nstatic _JoinIteratorState = class{\nstatic readonly $infoAddress = '0x7fd4e382bf88'\n\n\nstatic get start() {return Object.assign(new JoinedSequence.Iterator._JoinIteratorState(), {rawValue: \"start\", ...Array.from(arguments).slice(1)})}\n\n\nstatic get generatingElements() {return Object.assign(new JoinedSequence.Iterator._JoinIteratorState(), {rawValue: \"generatingElements\", ...Array.from(arguments).slice(1)})}\n\n\nstatic get generatingSeparator() {return Object.assign(new JoinedSequence.Iterator._JoinIteratorState(), {rawValue: \"generatingSeparator\", ...Array.from(arguments).slice(1)})}\n\n\nstatic get end() {return Object.assign(new JoinedSequence.Iterator._JoinIteratorState(), {rawValue: \"end\", ...Array.from(arguments).slice(1)})}\nstatic infix_61_61($info, a, b){\n\n\nlet index_a;\n\n;\nconst $match = a\nif((($match.rawValue == JoinedSequence.Iterator._JoinIteratorState._.rawValue))) {\nindex_a = 0;\n}\nelse if((($match.rawValue == JoinedSequence.Iterator._JoinIteratorState._.rawValue))) {\nindex_a = 1;\n}\nelse if((($match.rawValue == JoinedSequence.Iterator._JoinIteratorState._.rawValue))) {\nindex_a = 2;\n}\nelse if((($match.rawValue == JoinedSequence.Iterator._JoinIteratorState._.rawValue))) {\nindex_a = 3;\n};\n\nlet index_b;\n\n;\nconst $match = b\nif((($match.rawValue == JoinedSequence.Iterator._JoinIteratorState._.rawValue))) {\nindex_b = 0;\n}\nelse if((($match.rawValue == JoinedSequence.Iterator._JoinIteratorState._.rawValue))) {\nindex_b = 1;\n}\nelse if((($match.rawValue == JoinedSequence.Iterator._JoinIteratorState._.rawValue))) {\nindex_b = 2;\n}\nelse if((($match.rawValue == JoinedSequence.Iterator._JoinIteratorState._.rawValue))) {\nindex_b = 3;\n};\nreturn Int.infix_61_61(null, index_a, index_b);\n}\n\n\n\nhashValue$internal\nhashValue$get() { return this.hashValue$internal }\nget hashValue() { return this.hashValue$get() }\nhashValue$set($newValue) {\nlet $oldValue = this.hashValue$internal\nthis.hashValue$internal = $newValue\n}\nset hashValue($newValue) { this.hashValue$set($newValue) }\n;\n\nhashInto($info, hasher$inout){\n\nlet hasher = hasher$inout.get()\nconst $result = (() => {\n\nlet discriminator;\n\n;\nconst $match = this\nif((($match.rawValue == JoinedSequence.Iterator._JoinIteratorState._.rawValue))) {\ndiscriminator = 0;\n}\nelse if((($match.rawValue == JoinedSequence.Iterator._JoinIteratorState._.rawValue))) {\ndiscriminator = 1;\n}\nelse if((($match.rawValue == JoinedSequence.Iterator._JoinIteratorState._.rawValue))) {\ndiscriminator = 2;\n}\nelse if((($match.rawValue == JoinedSequence.Iterator._JoinIteratorState._.rawValue))) {\ndiscriminator = 3;\n};\nhasher.combine({H: Int}, discriminator);})()\nhasher$inout.set(hasher)\nreturn $result\n}\nstatic infix_61_61($info, a, b){return (a && a.rawValue) == (b && b.rawValue)}\nstatic infix_33_61($info, a, b){return (a && a.rawValue) != (b && b.rawValue)}\ninit$vars() {\n}\n}\n\n_state$internal\n_state$get() { return this._state$internal }\nget _state() { return this._state$get() }\n_state$set($newValue) {\nlet $oldValue = this._state$internal\nthis._state$internal = $newValue\n}\nset _state($newValue) { this._state$set($newValue) }\n;\n\n\n\n\n\ninitBaseSeparator<Separator>($info, base, separator){\n\nthis._base = base;\nthis._separatorData = _create(ContiguousArray, 'initBuffer', {Element: $info.Separator.Element, S: $info.Separator}, separator);\nreturn ;\n}\ninit$vars() {\nthis._inner$internal = null\nthis._separator$internal = null\nthis._state$internal = JoinedSequence.Iterator._JoinIteratorState.start\n}\n}"],
  ["Swift.(file).Sequence.joined(separator:Separator)", "\n\njoinedSeparator<Separator>($info, separator){\n\nreturn _create(JoinedSequence, 'initBaseSeparator', {Base: $info.Self, Separator: $info.Separator}, this, separator);\n}"],
  ["Swift.(file).withExtendedLifetime(_:T,_:() throws -> Result)", "\nfunction withExtendedLifetime<T, Result>($info, x, body){\n\nlet $defer = () => {\n_fixLifetime({T: $info.T}, x);\n}\ntry {;\nreturn body(null, );}catch($error){$defer({T: $info.T, Result: $info.Result}, );throw $error}$defer({T: $info.T, Result: $info.Result}, )\n}"],
  ["Swift.(file).withExtendedLifetime(_:T,_:(T) throws -> Result)", "\nfunction withExtendedLifetime<T, Result>($info, x, body){\n\nlet $defer = () => {\n_fixLifetime({T: $info.T}, x);\n}\ntry {;\nreturn body(null, x);}catch($error){$defer({T: $info.T, Result: $info.Result}, );throw $error}$defer({T: $info.T, Result: $info.Result}, )\n}"],
  ["Swift.(file).ManagedBuffer.withUnsafeMutablePointerToHeader(_:(UnsafeMutablePointer<Header>) throws -> R)", "\n\nwithUnsafeMutablePointerToHeader<R>($info, body){\n\nreturn this.withUnsafeMutablePointers({Header: $info.Header, Element: $info.Element, R: $info.R}, (($info, v, _) => body(null, v)));\n}"],
  ["Swift.(file).ManagedBuffer.withUnsafeMutablePointerToElements(_:(UnsafeMutablePointer<Element>) throws -> R)", "\n\nwithUnsafeMutablePointerToElements<R>($info, body){\n\nreturn this.withUnsafeMutablePointers({Header: $info.Header, Element: $info.Element, R: $info.R}, (($info, $0, $1) => body(null, $1)));\n}"],
  ["Swift.(file).ManagedBufferPointer.withUnsafeMutablePointerToHeader(_:(UnsafeMutablePointer<Header>) throws -> R)", "\n\nwithUnsafeMutablePointerToHeader<R>($info, body){\n\nreturn this.withUnsafeMutablePointers({Header: $info.Header, Element: $info.Element, R: $info.R}, (($info, v, _) => body(null, v)));\n}"],
  ["Swift.(file).ManagedBufferPointer.withUnsafeMutablePointerToElements(_:(UnsafeMutablePointer<Element>) throws -> R)", "\n\nwithUnsafeMutablePointerToElements<R>($info, body){\n\nreturn this.withUnsafeMutablePointers({Header: $info.Header, Element: $info.Element, R: $info.R}, (($info, $0, $1) => body(null, $1)));\n}"],
  ["Swift.(file).LazyMapSequence.Iterator", "\n\nstatic Iterator = class{\nstatic readonly $struct = true\nstatic readonly $infoAddress = '0x7fac460eb7a0'\n\n_base$internal\n_base$get() { return this._base$internal }\nget _base() { return this._base$get() }\n_base$set($newValue) {\nlet $oldValue = this._base$internal\nthis._base$internal = $newValue\n}\nset _base($newValue) { this._base$set($newValue) }\n;\n\n\n\n\n\n\nreadonly _transform$internal\nreadonly _transform$get() { return this._transform$internal }\nreadonly get _transform() { return this._transform$get() }\nreadonly _transform$set($newValue) {\nlet $oldValue = this._transform$internal\nthis._transform$internal = $newValue\n}\nreadonly set _transform($newValue) { this._transform$set($newValue) }\n;\n\n\n\n\nbase$internal\nbase$get(){\n\nreturn this._base;\n}\nget base() { return this.base$get() };\n\n\n\ninit_base_transformfunction_type($info, _base, _transform){\n\nthis._base = _base;\nthis._transform = _transform;\nreturn ;\n}\ninit$vars() {\n}\n}"],
  ["Swift.(file).MemoryLayout.size(ofValue:T)", "\n\nstatic sizeOfValue($info, value){\n\nreturn MemoryLayout.size;\n}"],
  ["Swift.(file).MemoryLayout.stride(ofValue:T)", "\n\nstatic strideOfValue($info, value){\n\nreturn MemoryLayout.stride;\n}"],
  ["Swift.(file).MemoryLayout.alignment(ofValue:T)", "\n\nstatic alignmentOfValue($info, value){\n\nreturn MemoryLayout.alignment;\n}"],
  ["Swift.(file).LazySequenceProtocol.flatMap(_:(Self.Elements.Element) -> ElementOfResult?)", "\n\nflatMap<ElementOfResult>($info, transform){\n\nreturn this.compactMap({Self: $info.Self, ElementOfResult: $info.ElementOfResult}, transform);\n}"],
  ["Swift.(file).String.withMutableCharacters(_:(inout String) -> R)", "\n\nwithMutableCharacters<R>($info, body){\n\nreturn body(null, {get: () => this, set: $val => Object.assign(this, $val)});\n}"],
  ["Swift.(file).Substring.withMutableCharacters(_:(inout Substring) -> R)", "\n\nwithMutableCharacters<R>($info, body){\n\nreturn body(null, {get: () => this, set: $val => Object.assign(this, $val)});\n}"],
  ["Swift.(file).Collection.index(_:Self.Index,offsetBy:T)", "\n\nindexOffsetBy<T>($info, i, n){\n\nreturn this.indexOffsetBy({Self: $info.Self}, i, _create(Int, 'init', {Self: Int, T: $info.T}, n));\n}"],
  ["Swift.(file).Collection.formIndex(_:Self.Index,offsetBy:T)", "\n\nformIndexOffsetBy<T>($info, i$inout, n){\n\nlet i = i$inout.get()\nconst $result = (() => {\nreturn this.formIndexOffsetBy({Self: $info.Self}, {get: () => i, set: $val => i = $val}, _create(Int, 'init', {Self: Int, T: $info.T}, n));})()\ni$inout.set(i)\nreturn $result\n}"],
  ["Swift.(file).Collection.index(_:Self.Index,offsetBy:T,limitedBy:Self.Index)", "\n\nindexOffsetByLimitedBy<T>($info, i, n, limit){\n\nreturn this.indexOffsetByLimitedBy({Self: $info.Self}, i, _create(Int, 'init', {Self: Int, T: $info.T}, n), limit);\n}"],
  ["Swift.(file).Collection.formIndex(_:Self.Index,offsetBy:T,limitedBy:Self.Index)", "\n\nformIndexOffsetByLimitedBy<T>($info, i$inout, n, limit){\n\nlet i = i$inout.get()\nconst $result = (() => {\nreturn this.formIndexOffsetByLimitedBy({Self: $info.Self}, {get: () => i, set: $val => i = $val}, _create(Int, 'init', {Self: Int, T: $info.T}, n), limit);})()\ni$inout.set(i)\nreturn $result\n}"],
  ["Swift.(file).Collection.distance(from:Self.Index,to:Self.Index)", "\n\ndistanceFromTo<T>($info, start, end){\n\nreturn numericCast({T: Int, U: $info.T}, this.distanceFromTo({Self: $info.Self}, start, end));\n}"],
  ["Swift.(file).UnsafeMutablePointer.initialize(to:Pointee,count:Int)", "\n\ninitializeToCount($info, newValue, count = 1){\n\nthis.initializeRepeatingCount({Pointee: this.$info.Pointee}, newValue, count);\n}"],
  ["Swift.(file).UnsafeMutablePointer.deinitialize()", "\n\ndeinitialize($info){\n\nreturn this.deinitializeCount({Pointee: this.$info.Pointee}, 1);\n}"],
  ["Swift.(file).UnsafeMutablePointer.deallocate(capacity:Int)", "\n\ndeallocateCapacity($info, _){\n\nthis.deallocate({Pointee: this.$info.Pointee}, );\n}"],
  ["Swift.(file).UnsafeMutablePointer.initialize(from:C)", "\n\ninitializeFrom<C>($info, source){\n\n\nconst buf = _create(UnsafeMutableBufferPointer, 'initStartOptionalCountInt', {Element: $info.Pointee},   (pointer_to_pointer implicit type='UnsafeMutablePointer<Pointee>' location=/Users/bubulkowanorka/projects/antlr4-visitor/include/build-bodies/body.swift:4:49 range=[/Users/bubulkowanorka/projects/antlr4-visitor/include/build-bodies/body.swift:4:49 - line:4:49]\nthis), numericCast({T: Int, U: Int}, source.count));\n\n;\n\n;\n\nlet $tuple = source._copyContentsInitializing({Self: $info.C}, buf), remainders = $tuple && $tuple[0], writtenUpTo = $tuple && $tuple[1];\n\n;\n\n;\n\n;\npreconditionFileLine(null, () => Optional.infix_61_61({Wrapped: $info.Pointee}, remainders.next({Self: $info.C.Iterator}, ), null), () => \"rhs underreported its count\");\npreconditionFileLine(null, () => Int.infix_61_61(null, writtenUpTo, buf.endIndex), () => \"rhs overreported its count\");\n}"],
  ["Swift.(file).UnsafeMutableRawPointer.allocate(bytes:Int,alignedTo:Int)", "\n\nstatic allocateBytesAlignedTo($info, size, alignment){\n\nreturn UnsafeMutableRawPointer.allocateByteCountAlignment(null, size, alignment);\n}"],
  ["Swift.(file).UnsafeMutableRawPointer.deallocate(bytes:Int,alignedTo:Int)", "\n\ndeallocateBytesAlignedTo($info, _, _){\n\nthis.deallocate(null, );\n}"],
  ["Swift.(file).UnsafeMutableRawPointer.copyBytes(from:UnsafeRawPointer,count:Int)", "\n\ncopyBytesFromCount($info, source, count){\n\nthis.copyMemoryFromByteCount(null, source, count);\n}"],
  ["Swift.(file).UnsafeMutableRawPointer.initializeMemory(as:T.Type,at:Int,count:Int,to:T)", "\n\ninitializeMemoryAsAtCountTo<T>($info, type, offset = 0, count = 1, repeatedValue){\n\nreturn UnsafeMutableRawPointer.infix_43({Self: UnsafeMutableRawPointer}, this, Int.infix_42(null, offset, MemoryLayout.stride)).initializeMemoryAsRepeatingCount({T: $info.T}, type, repeatedValue, count);\n}"],
  ["Swift.(file).UnsafeMutableRawPointer.initializeMemory(as:C.Element.Type,from:C)", "\n\ninitializeMemoryAsFrom<C>($info, type, source){\n\n\nlet ptr = _cloneStruct(this);\n\n;\n\n;\n\n{\nlet $element$generator = source.makeIterator({Self: $info.C}, );\n\n\nwhile(true) {\nconst _element$let = $element$generator.next({Self: $info.C.Iterator}, );\nif(!((_element$let != null))) break;\n\nptr.initializeMemoryAsRepeatingCount({T: $info.C.Element}, $info.C.Element, _element$let, 1);\nUnsafeMutableRawPointer.infix_43_61({Self: UnsafeMutableRawPointer}, {get: () => ptr, set: $val => ptr = $val}, MemoryLayout.stride);\n}\n};\nreturn _create(UnsafeMutablePointer, 'initRawPointer', {Pointee: $info.C.Element}, this._rawValue);\n}"],
  ["Swift.(file).UnsafeMutableRawBufferPointer.allocate(count:Int)", "\n\nstatic allocateCount($info, count){\n\nreturn UnsafeMutableRawBufferPointer.allocateByteCountAlignment(null, count, MemoryLayout.alignment);\n}"],
  ["Swift.(file).UnsafeMutableRawBufferPointer.copyBytes(from:UnsafeRawBufferPointer)", "\n\ncopyBytesFrom($info, source){\n\nthis.copyMemoryFrom(null, source);\n}"],
  ["Swift.(file).Sequence.flatMap(_:(Self.Element) throws -> ElementOfResult?)", "\n\nflatMap<ElementOfResult>($info, transform){\n\nreturn this._compactMap({Self: $info.Self, ElementOfResult: $info.ElementOfResult}, transform);\n}"],
  ["Swift.(file).Sequence.flatMap(_:(Self.Element) throws -> String)", "\n\nflatMap($info, transform){\n\nreturn this.mapSwift({Self: this.$info.Self, T: String}, transform);\n}"],
  ["Swift.(file).Collection.flatMap(_:(Self.Element) throws -> String?)", "\n\nflatMap($info, transform){\n\nreturn this._compactMap({Self: this.$info.Self, ElementOfResult: String}, transform);\n}"],
  ["Swift.(file).Collection.index(where:(Self.Element) throws -> Bool)", "\n\nindexWhere($info, _predicate){\n\nreturn this.firstIndexWhere({Self: this.$info.Self}, _predicate);\n}"],
  ["Swift.(file).MutableCollection.withContiguousMutableStorageIfAvailable(_:(inout UnsafeMutableBufferPointer<Self.Element>) throws -> R)", "\n\nwithContiguousMutableStorageIfAvailable<R>($info, body){\n\nreturn null;\n}"],
  ["Swift.(file).MutableCollection.swapAt(_:Self.Index,_:Self.Index)", "\n\nswapAt($info, i, j){\n\n\n{\nif(!((this.$info.Self.Index.infix_33_61({Self: this.$info.Self.Index}, i, j)))) {\n\nreturn ;\n}\n};\n\nconst tmp = this.subscript$get(null, i);\n\n;\n\n;\nthis.subscript$set(null, this.subscript$get(null, j), i);\nthis.subscript$set(null, tmp, j);\n}"],
  ["Swift.(file).ObjectIdentifier.<infix(_:ObjectIdentifier,_:ObjectIdentifier)", "\n\nstatic infix_60($info, lhs, rhs){\n\nreturn UInt.infix_60(null, _create(UInt, 'initBitPatternObjectIdentifier', null, lhs), _create(UInt, 'initBitPatternObjectIdentifier', null, rhs));\n}"],
  ["Swift.(file).OptionSet.union(_:Self)", "\n\nunion($info, other){\n\n\nlet r = _create(this.$info.Self, 'initRawValue', {Self: this.$info.Self}, this.rawValue);\n\n;\n\n;\nr.formUnion({Self: this.$info.Self}, other);\nreturn r;\n}"],
  ["Swift.(file).OptionSet.intersection(_:Self)", "\n\nintersection($info, other){\n\n\nlet r = _create(this.$info.Self, 'initRawValue', {Self: this.$info.Self}, this.rawValue);\n\n;\n\n;\nr.formIntersection({Self: this.$info.Self}, other);\nreturn r;\n}"],
  ["Swift.(file).OptionSet.symmetricDifference(_:Self)", "\n\nsymmetricDifference($info, other){\n\n\nlet r = _create(this.$info.Self, 'initRawValue', {Self: this.$info.Self}, this.rawValue);\n\n;\n\n;\nr.formSymmetricDifference({Self: this.$info.Self}, other);\nreturn r;\n}"],
  ["Swift.(file).OptionSet.contains(_:Self)", "\n\ncontains($info, member){\n\nreturn this.isSupersetOf({Self: this.$info.Self}, member);\n}"],
  ["Swift.(file).Optional.map(_:(Wrapped) throws -> U)", "\n\nmapSwift<U>($info, transform){\n\nconst $match = this\nif((($match.rawValue == Optional.some().rawValue))) {\nconst y = $match[0]\nreturn Optional.some({Wrapped: $info.U}, transform(null, y));\n}\nelse if((($match.rawValue == Optional.none.rawValue))) {\nreturn null;\n};\n}"],
  ["Swift.(file).Optional.flatMap(_:(Wrapped) throws -> U?)", "\n\nflatMap<U>($info, transform){\n\nconst $match = this\nif((($match.rawValue == Optional.some().rawValue))) {\nconst y = $match[0]\nreturn transform(null, y);\n}\nelse if((($match.rawValue == Optional.none.rawValue))) {\nreturn null;\n};\n}"],
  ["Swift.(file).Optional.==infix(_:Wrapped?,_:Wrapped?)", "\n\nstatic infix_61_61($info, lhs, rhs){\n\nconst $match = {0: lhs, 1: rhs}\nif(((true))) {\nconst l = $match[0]\nconst r = $match[1]\nreturn Optional.infix_61_61({Wrapped: this.$info.Wrapped}, l, r);\n}\nelse if((($match.rawValue == Optional.none.rawValue && $match.rawValue == Optional.none.rawValue))) {\nreturn true;\n}\nelse if(((true))) {\nreturn false;\n};\n}"],
  ["Swift.(file).Optional.~=infix(_:_OptionalNilComparisonType,_:Wrapped?)", "\n\nstatic infix_126_61($info, lhs, rhs){\n\nconst $match = rhs\nif((($match.rawValue == Optional.some().rawValue))) {\nreturn false;\n}\nelse if((($match.rawValue == Optional.none.rawValue))) {\nreturn true;\n};\n}"],
  ["Swift.(file).Optional.==infix(_:Wrapped?,_:_OptionalNilComparisonType)", "\n\nstatic infix_61_61($info, lhs, rhs){\n\nconst $match = lhs\nif((($match.rawValue == Optional.some().rawValue))) {\nreturn false;\n}\nelse if((($match.rawValue == Optional.none.rawValue))) {\nreturn true;\n};\n}"],
  ["Swift.(file).Optional.!=infix(_:Wrapped?,_:_OptionalNilComparisonType)", "\n\nstatic infix_33_61($info, lhs, rhs){\n\nconst $match = lhs\nif((($match.rawValue == Optional.some().rawValue))) {\nreturn true;\n}\nelse if((($match.rawValue == Optional.none.rawValue))) {\nreturn false;\n};\n}"],
  ["Swift.(file).Optional.==infix(_:_OptionalNilComparisonType,_:Wrapped?)", "\n\nstatic infix_61_61($info, lhs, rhs){\n\nconst $match = rhs\nif((($match.rawValue == Optional.some().rawValue))) {\nreturn false;\n}\nelse if((($match.rawValue == Optional.none.rawValue))) {\nreturn true;\n};\n}"],
  ["Swift.(file).Optional.!=infix(_:_OptionalNilComparisonType,_:Wrapped?)", "\n\nstatic infix_33_61($info, lhs, rhs){\n\nconst $match = rhs\nif((($match.rawValue == Optional.some().rawValue))) {\nreturn true;\n}\nelse if((($match.rawValue == Optional.none.rawValue))) {\nreturn false;\n};\n}"],
  ["Swift.(file).??infix(_:T?,_:() throws -> T)", "\nfunction infix_63_63<T>($info, optional, defaultValue){\n\nconst $match = optional\nif((($match.rawValue == Optional.some().rawValue))) {\nconst value = $match[0]\nreturn value;\n}\nelse if((($match.rawValue == Optional.none.rawValue))) {\nreturn defaultValue(null, );\n};\n}"],
  ["Swift.(file).??infix(_:T?,_:() throws -> T?)", "\nfunction infix_63_63<T>($info, optional, defaultValue){\n\nconst $match = optional\nif((($match.rawValue == Optional.some().rawValue))) {\nconst value = $match[0]\nreturn value;\n}\nelse if((($match.rawValue == Optional.none.rawValue))) {\nreturn defaultValue(null, );\n};\n}"],
  ["Swift.(file).String.write(_:String)", "\n\nwrite($info, other){\n\nString.infix_43_61(null, {get: () => this, set: $val => Object.assign(this, $val)}, other);\n}"],
  ["Swift.(file).String.write(to:Target)", "\n\nwriteTo<Target>($info, target$inout){\n\nlet target = target$inout.get()\nconst $result = (() => {\ntarget.write({Self: $info.Target}, this);})()\ntarget$inout.set(target)\nreturn $result\n}"],
  ["Swift.(file).Character.write(to:Target)", "\n\nwriteTo<Target>($info, target$inout){\n\nlet target = target$inout.get()\nconst $result = (() => {\ntarget.write({Self: $info.Target}, _create(String, 'initCharacter', null, this));})()\ntarget$inout.set(target)\nreturn $result\n}"],
  ["Swift.(file)._Pointer.successor()", "\n\nsuccessor($info){\n\nreturn this.advancedBy({Self: this.$info.Self}, 1);\n}"],
  ["Swift.(file)._Pointer.predecessor()", "\n\npredecessor($info){\n\nreturn this.advancedBy({Self: this.$info.Self}, -1);\n}"],
  ["Swift.(file)._Pointer.hash(into:Hasher)", "\n\nhashInto($info, hasher$inout){\n\nlet hasher = hasher$inout.get()\nconst $result = (() => {\nhasher.combine({H: UInt}, _create(UInt, 'initBitPatternOptional', {P: this.$info.Self}, this));})()\nhasher$inout.set(hasher)\nreturn $result\n}"],
  ["Swift.(file).Strideable.+infix(_:Self,_:Self.Stride)", "\n\nstatic infix_43($info, lhs, rhs){\n\nreturn lhs.advancedBy({Self: this.$info.Self}, rhs);\n}"],
  ["Swift.(file).Strideable.+infix(_:Self.Stride,_:Self)", "\n\nstatic infix_43($info, lhs, rhs){\n\nreturn rhs.advancedBy({Self: this.$info.Self}, lhs);\n}"],
  ["Swift.(file).Strideable.-infix(_:Self,_:Self.Stride)", "\n\nstatic infix_45($info, lhs, rhs){\n\nreturn lhs.advancedBy({Self: this.$info.Self}, this.$info.Self.Stride.prefix_45({Self: this.$info.Self.Stride}, rhs));\n}"],
  ["Swift.(file).Strideable.-infix(_:Self,_:Self)", "\n\nstatic infix_45($info, lhs, rhs){\n\nreturn rhs.distanceTo({Self: this.$info.Self}, lhs);\n}"],
  ["Swift.(file).Strideable.+=infix(_:Self,_:Self.Stride)", "\n\nstatic infix_43_61($info, lhs$inout, rhs){\n\nlet lhs = lhs$inout.get()\nconst $result = (() => {\nlhs = lhs.advancedBy({Self: this.$info.Self}, rhs);})()\nlhs$inout.set(lhs)\nreturn $result\n}"],
  ["Swift.(file).Strideable.-=infix(_:Self,_:Self.Stride)", "\n\nstatic infix_45_61($info, lhs$inout, rhs){\n\nlet lhs = lhs$inout.get()\nconst $result = (() => {\nlhs = lhs.advancedBy({Self: this.$info.Self}, this.$info.Self.Stride.prefix_45({Self: this.$info.Self.Stride}, rhs));})()\nlhs$inout.set(lhs)\nreturn $result\n}"],
  ["Swift.(file).Never.<infix(_:Never,_:Never)", "\n\nstatic infix_60($info, lhs, rhs){\n\n}"],
  ["Swift.(file).~=infix(_:T,_:T)", "\nfunction infix_126_61<T>($info, a, b){\n\nreturn $info.T.infix_61_61({Self: $info.T}, a, b);\n}"],
  ["Swift.(file).LazyPrefixWhileSequence.Iterator", "\n\nstatic Iterator = class{\nstatic readonly $struct = true\nstatic readonly $infoAddress = '0x7fac3c0bdba8'\nstatic readonly Element = {$genericType: 'Base', $subchain: 'Element'}\n\n_predicateHasFailed$internal\n_predicateHasFailed$get() { return this._predicateHasFailed$internal }\nget _predicateHasFailed() { return this._predicateHasFailed$get() }\n_predicateHasFailed$set($newValue) {\nlet $oldValue = this._predicateHasFailed$internal\nthis._predicateHasFailed$internal = $newValue\n}\nset _predicateHasFailed($newValue) { this._predicateHasFailed$set($newValue) }\n;\n\n\n\n\n\n\n_base$internal\n_base$get() { return this._base$internal }\nget _base() { return this._base$get() }\n_base$set($newValue) {\nlet $oldValue = this._base$internal\nthis._base$internal = $newValue\n}\nset _base($newValue) { this._base$set($newValue) }\n;\n\n\n\n\n\n\nreadonly _predicate$internal\nreadonly _predicate$get() { return this._predicate$internal }\nreadonly get _predicate() { return this._predicate$get() }\nreadonly _predicate$set($newValue) {\nlet $oldValue = this._predicate$internal\nthis._predicate$internal = $newValue\n}\nreadonly set _predicate($newValue) { this._predicate$set($newValue) }\n;\n\n\n\ninit_basePredicatefunction_type($info, _base, predicate){\n\nthis._base = _base;\nthis._predicate = predicate;\nreturn ;\n}\ninit$vars() {\nthis._predicateHasFailed$internal = false\n}\n}"],
  ["Swift.(file).RandomNumberGenerator.next()", "\n\nnext<T>($info){\n\nreturn $info.T._randomUsing({Self: $info.T, R: $info.Self}, {get: () => this, set: $val => Object.assign(this, $val)});\n}"],
  ["Swift.(file).RandomNumberGenerator.next(upperBound:T)", "\n\nnextUpperBound<T>($info, upperBound){\n\npreconditionFileLine(null, () => $info.T.infix_33_61({Self: $info.T, Other: Int}, upperBound, 0), () => \"upperBound cannot be zero.\");\n\nconst tmp = $info.T.infix_43({Self: $info.T}, $info.T.infix_37({Self: $info.T}, $info.T.max, upperBound), _create($info.T, 'initIntegerLiteral', {Self: $info.T}, 1));\n\n;\n\n;\n\nconst range = ($info.T.infix_61_61({Self: $info.T}, tmp, upperBound) ? _create($info.T, 'initIntegerLiteral', {Self: $info.T}, 0) : tmp);\n\n;\n\n;\n\nlet random = _create($info.T, 'initIntegerLiteral', {Self: $info.T}, 0);\n\n;\n\n;\ndo {\n\nrandom = this.next({Self: $info.Self, T: $info.T}, );\n} while($info.T.infix_60({Self: $info.T}, random, range));\nreturn $info.T.infix_37({Self: $info.T}, random, upperBound);\n}"],
  ["Swift.(file).RandomAccessCollection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)", "\n\nindexOffsetByLimitedBy($info, i, distance, limit){\n\n\nconst l = this.distanceFromTo({Self: this.$info.Self}, i, limit);\n\n;\n\n;\n\n{\nif(((Int.infix_62(null, distance, 0) ? Bool.infix_38_38(null, Int.infix_62_61(null, l, 0), () => Int.infix_60(null, l, distance)) : Bool.infix_38_38(null, Int.infix_60_61(null, l, 0), () => Int.infix_60(null, distance, l))))) {\n\nreturn null;\n}\n};\nreturn this.indexOffsetBy({Self: this.$info.Self}, i, distance);\n}"],
  ["Swift.(file).RangeExpression.~=infix(_:Self,_:Self.Bound)", "\n\nstatic infix_126_61($info, pattern, value){\n\nreturn pattern.contains({Self: this.$info.Self}, value);\n}"],
  ["Swift.(file).Range.contains(_:Bound)", "\n\ncontains($info, _element){\n\nreturn Bool.infix_38_38(null, this.$info.Bound.infix_60_61({Self: this.$info.Bound}, this.lowerBound, _element), () => this.$info.Bound.infix_60({Self: this.$info.Bound}, _element, this.upperBound));\n}"],
  ["Swift.(file).Range.relative(to:C)", "\n\nrelativeTo<C>($info, collection){\n\nreturn _create(Range, 'initUncheckedBoundstuple_type', {Bound: $info.Bound}, {0: this.lowerBound, 1: this.upperBound});\n}"],
  ["Swift.(file).Range.clamped(to:Range<Bound>)", "\n\nclampedTo($info, limits){\n\n\nconst lower = (this.$info.Bound.infix_62({Self: this.$info.Bound}, limits.lowerBound, this.lowerBound) ? limits.lowerBound : (this.$info.Bound.infix_60({Self: this.$info.Bound}, limits.upperBound, this.lowerBound) ? limits.upperBound : this.lowerBound));\n\n;\n\n;\n\nconst upper = (this.$info.Bound.infix_60({Self: this.$info.Bound}, limits.upperBound, this.upperBound) ? limits.upperBound : (this.$info.Bound.infix_62({Self: this.$info.Bound}, limits.lowerBound, this.upperBound) ? limits.lowerBound : this.upperBound));\n\n;\n\n;\nreturn _create(Range, 'initUncheckedBoundstuple_type', {Bound: this.$info.Bound}, {0: lower, 1: upper});\n}"],
  ["Swift.(file).Range.==infix(_:Range<Bound>,_:Range<Bound>)", "\n\nstatic infix_61_61($info, lhs, rhs){\n\nreturn Bool.infix_38_38(null, this.$info.Bound.infix_61_61({Self: this.$info.Bound}, lhs.lowerBound, rhs.lowerBound), () => this.$info.Bound.infix_61_61({Self: this.$info.Bound}, lhs.upperBound, rhs.upperBound));\n}"],
  ["Swift.(file).PartialRangeUpTo.relative(to:C)", "\n\nrelativeTo<C>($info, collection){\n\nreturn $info.Bound.infix_46_46_60({Self: $info.Bound}, collection.startIndex, this.upperBound);\n}"],
  ["Swift.(file).PartialRangeUpTo.contains(_:Bound)", "\n\ncontains($info, _element){\n\nreturn this.$info.Bound.infix_60({Self: this.$info.Bound}, _element, this.upperBound);\n}"],
  ["Swift.(file).PartialRangeThrough.relative(to:C)", "\n\nrelativeTo<C>($info, collection){\n\nreturn $info.Bound.infix_46_46_60({Self: $info.Bound}, collection.startIndex, collection.indexAfter({Self: $info.C}, this.upperBound));\n}"],
  ["Swift.(file).PartialRangeThrough.contains(_:Bound)", "\n\ncontains($info, _element){\n\nreturn this.$info.Bound.infix_60_61({Self: this.$info.Bound}, _element, this.upperBound);\n}"],
  ["Swift.(file).PartialRangeFrom.relative(to:C)", "\n\nrelativeTo<C>($info, collection){\n\nreturn $info.Bound.infix_46_46_60({Self: $info.Bound}, this.lowerBound, collection.endIndex);\n}"],
  ["Swift.(file).PartialRangeFrom.contains(_:Bound)", "\n\ncontains($info, _element){\n\nreturn this.$info.Bound.infix_60_61({Self: this.$info.Bound}, this.lowerBound, _element);\n}"],
  ["Swift.(file).Comparable...<infix(_:Self,_:Self)", "\n\nstatic infix_46_46_60($info, minimum, maximum){\n\npreconditionFileLine(null, () => this.$info.Self.infix_60_61({Self: this.$info.Self}, minimum, maximum), () => \"Can't form Range with upperBound < lowerBound\");\nreturn _create(Range, 'initUncheckedBoundstuple_type', {Bound: this.$info.Self}, {0: minimum, 1: maximum});\n}"],
  ["Swift.(file).Comparable...<prefix(_:Self)", "\n\nstatic prefix_46_46_60($info, maximum){\n\nreturn _create(PartialRangeUpTo, 'init', {Bound: this.$info.Self}, maximum);\n}"],
  ["Swift.(file).Comparable....prefix(_:Self)", "\n\nstatic prefix_46_46_46($info, maximum){\n\nreturn _create(PartialRangeThrough, 'init', {Bound: this.$info.Self}, maximum);\n}"],
  ["Swift.(file).Comparable....postfix(_:Self)", "\n\nstatic postfix_46_46_46($info, minimum){\n\nreturn _create(PartialRangeFrom, 'init', {Bound: this.$info.Self}, minimum);\n}"],
  ["Swift.(file).UnboundedRange_....postfix(_:UnboundedRange_)", "\n\nstatic postfix_46_46_46($info, _){\n\n}"],
  ["Swift.(file).Range.overlaps(_:Range<Bound>)", "\n\noverlaps($info, other){\n\nreturn Bool.infix_124_124(null, Bool.infix_38_38(null, Bool.prefix_33(null, other.isEmpty), () => this.contains({Bound: this.$info.Bound}, other.lowerBound)), () => Bool.infix_38_38(null, Bool.prefix_33(null, this.isEmpty), () => other.contains({Bound: this.$info.Bound}, this.lowerBound)));\n}"],
  ["Swift.(file).Range.overlaps(_:ClosedRange<Bound>)", "\n\noverlaps($info, other){\n\nreturn Bool.infix_124_124(null, this.contains({Bound: this.$info.Bound}, other.lowerBound), () => Bool.infix_38_38(null, Bool.prefix_33(null, this.isEmpty), () => other.contains({Bound: this.$info.Bound}, this.lowerBound)));\n}"],
  ["Swift.(file).RangeReplaceableCollection.append(_:Self.Element)", "\n\nappend($info, newElement){\n\nthis.insertAt({Self: this.$info.Self}, newElement, this.endIndex);\n}"],
  ["Swift.(file).RangeReplaceableCollection.append(contentsOf:S)", "\n\nappendContentsOf<S>($info, newElements){\n\n\nconst approximateCapacity = Int.infix_43(null, this.count, numericCast({T: Int, U: Int}, newElements.underestimatedCount));\n\n;\n\n;\nthis.reserveCapacity({Self: $info.Self}, approximateCapacity);\n\n{\nlet $element$generator = newElements.makeIterator({Self: $info.S}, );\n\n\nwhile(true) {\nconst _element$let = $element$generator.next({Self: $info.S.Iterator}, );\nif(!((_element$let != null))) break;\n\nthis.append({Self: $info.Self}, _element$let);\n}\n};\n}"],
  ["Swift.(file).RangeReplaceableCollection.insert(_:Self.Element,at:Self.Index)", "\n\ninsertAt($info, newElement, i){\n\nthis.replaceSubrangeWith({Self: this.$info.Self, C: _clarifyGenerics({Self:CollectionOfOne, Element: this.$info.Self.Element})}, this.$info.Self.Index.infix_46_46_60({Self: this.$info.Self.Index}, i, i), _create(CollectionOfOne, 'init', {Element: this.$info.Self.Element}, newElement));\n}"],
  ["Swift.(file).RangeReplaceableCollection.insert(contentsOf:C,at:Self.Index)", "\n\ninsertContentsOfAt<C>($info, newElements, i){\n\nthis.replaceSubrangeWith({Self: $info.Self, C: $info.C}, $info.Self.Index.infix_46_46_60({Self: $info.Self.Index}, i, i), newElements);\n}"],
  ["Swift.(file).RangeReplaceableCollection.remove(at:Self.Index)", "\n\nremoveAt($info, position){\n\npreconditionFileLine(null, () => Bool.prefix_33(null, this.isEmpty), () => \"Can't remove from an empty collection\");\n\nconst result = this.subscript$get(null, position);\n\n;\n\n;\nthis.replaceSubrangeWith({Self: this.$info.Self, C: _clarifyGenerics({Self:EmptyCollection, Element: this.$info.Self.Element})}, this.$info.Self.Index.infix_46_46_60({Self: this.$info.Self.Index}, position, this.indexAfter({Self: this.$info.Self}, position)), _create(EmptyCollection, 'init', {Element: this.$info.Self.Element}, ));\nreturn result;\n}"],
  ["Swift.(file).RangeReplaceableCollection.removeSubrange(_:Range<Self.Index>)", "\n\nremoveSubrange($info, bounds){\n\nthis.replaceSubrangeWith({Self: this.$info.Self, C: _clarifyGenerics({Self:EmptyCollection, Element: this.$info.Self.Element})}, bounds, _create(EmptyCollection, 'init', {Element: this.$info.Self.Element}, ));\n}"],
  ["Swift.(file).RangeReplaceableCollection.removeFirst(_:Int)", "\n\nremoveFirst($info, k){\n\n\n{\nif((Int.infix_61_61(null, k, 0))) {\n\nreturn ;\n}\n};\npreconditionFileLine(null, () => Int.infix_62_61(null, k, 0), () => \"Number of elements to remove should be non-negative\");\npreconditionFileLine(null, () => Int.infix_62_61(null, this.count, k), () => \"Can't remove more items from a collection than it has\");\n\nconst end = this.indexOffsetBy({Self: this.$info.Self}, this.startIndex, k);\n\n;\n\n;\nthis.removeSubrange({Self: this.$info.Self}, this.$info.Self.Index.infix_46_46_60({Self: this.$info.Self.Index}, this.startIndex, end));\n}"],
  ["Swift.(file).RangeReplaceableCollection.removeFirst()", "\n\nremoveFirst($info){\n\npreconditionFileLine(null, () => Bool.prefix_33(null, this.isEmpty), () => \"Can't remove first element from an empty collection\");\n\nconst firstElement = this.first;\n\n;\n\n;\nthis.removeFirstMultiple({Self: this.$info.Self}, 1);\nreturn firstElement;\n}"],
  ["Swift.(file).RangeReplaceableCollection.removeAll(keepingCapacity:Bool)", "\n\nremoveAllKeepingCapacity($info, keepCapacity = false){\n\n\n{\nif((Bool.prefix_33(null, keepCapacity))) {\n\nObject.assign(this, _create(this.$info.Self, 'init', {Self: this.$info.Self}, ));\n}\nelse {\nthis.replaceSubrangeWith({Self: this.$info.Self, C: _clarifyGenerics({Self:EmptyCollection, Element: this.$info.Self.Element})}, this.$info.Self.Index.infix_46_46_60({Self: this.$info.Self.Index}, this.startIndex, this.endIndex), _create(EmptyCollection, 'init', {Element: this.$info.Self.Element}, ));\n}\n};\n}"],
  ["Swift.(file).RangeReplaceableCollection.reserveCapacity(_:Int)", "\n\nreserveCapacity($info, n){\n\n}"],
  ["Swift.(file).RangeReplaceableCollection.replaceSubrange(_:R,with:C)", "\n\nreplaceSubrangeWith<C, R>($info, subrange, newElements){\n\nthis.replaceSubrangeWith({Self: $info.Self, C: $info.C}, subrange.relativeTo({Self: $info.R, C: $info.Self}, this), newElements);\n}"],
  ["Swift.(file).RangeReplaceableCollection.removeSubrange(_:R)", "\n\nremoveSubrange<R>($info, bounds){\n\nthis.removeSubrange({Self: $info.Self}, bounds.relativeTo({Self: $info.R, C: $info.Self}, this));\n}"],
  ["Swift.(file).RangeReplaceableCollection.removeLast(_:Int)", "\n\nremoveLast($info, k){\n\n\n{\nif((Int.infix_61_61(null, k, 0))) {\n\nreturn ;\n}\n};\npreconditionFileLine(null, () => Int.infix_62_61(null, k, 0), () => \"Number of elements to remove should be non-negative\");\npreconditionFileLine(null, () => Int.infix_62_61(null, this.count, k), () => \"Can't remove more items from a collection than it contains\");\n\n{\nif((this._customRemoveLast({Self: this.$info.Self}, k))) {\n\nreturn ;\n}\n};\n\nconst end = this.endIndex;\n\n;\n\n;\nthis.removeSubrange({Self: this.$info.Self}, this.$info.Self.Index.infix_46_46_60({Self: this.$info.Self.Index}, this.indexOffsetBy({Self: this.$info.Self}, end, Int.prefix_45({Self: Int}, k)), end));\n}"],
  ["Swift.(file).RangeReplaceableCollection.removeLast(_:Int)", "\n\nremoveLast($info, k){\n\n\n{\nif((Int.infix_61_61(null, k, 0))) {\n\nreturn ;\n}\n};\npreconditionFileLine(null, () => Int.infix_62_61(null, k, 0), () => \"Number of elements to remove should be non-negative\");\npreconditionFileLine(null, () => Int.infix_62_61(null, this.count, k), () => \"Can't remove more items from a collection than it contains\");\n\n{\nif((this._customRemoveLast({Self: this.$info.Self}, k))) {\n\nreturn ;\n}\n};\n\nconst end = this.endIndex;\n\n;\n\n;\nthis.removeSubrange({Self: this.$info.Self}, this.$info.Self.Index.infix_46_46_60({Self: this.$info.Self.Index}, this.indexOffsetBy({Self: this.$info.Self}, end, Int.prefix_45({Self: Int}, k)), end));\n}"],
  ["Swift.(file).RangeReplaceableCollection.+infix(_:Self,_:Other)", "\n\nstatic infix_43<Other>($info, lhs, rhs){\n\n\nlet lhs = lhs;\n\n;\n\n;\nlhs.appendContentsOf({Self: $info.Self, S: $info.Other}, rhs);\nreturn lhs;\n}"],
  ["Swift.(file).RangeReplaceableCollection.+infix(_:Other,_:Self)", "\n\nstatic infix_43<Other>($info, lhs, rhs){\n\n\nlet result = _create($info.Self, 'init', {Self: $info.Self}, );\n\n;\n\n;\nresult.reserveCapacity({Self: $info.Self}, Int.infix_43(null, rhs.count, numericCast({T: Int, U: Int}, lhs.underestimatedCount)));\nresult.appendContentsOf({Self: $info.Self, S: $info.Other}, lhs);\nresult.appendContentsOf({Self: $info.Self, S: $info.Self}, rhs);\nreturn result;\n}"],
  ["Swift.(file).RangeReplaceableCollection.+=infix(_:Self,_:Other)", "\n\nstatic infix_43_61<Other>($info, lhs$inout, rhs){\n\nlet lhs = lhs$inout.get()\nconst $result = (() => {\nlhs.appendContentsOf({Self: $info.Self, S: $info.Other}, rhs);})()\nlhs$inout.set(lhs)\nreturn $result\n}"],
  ["Swift.(file).RangeReplaceableCollection.+infix(_:Self,_:Other)", "\n\nstatic infix_43<Other>($info, lhs, rhs){\n\n\nlet lhs = lhs;\n\n;\n\n;\nlhs.appendContentsOf({Self: $info.Self, S: $info.Other}, rhs);\nreturn lhs;\n}"],
  ["Swift.(file).RangeReplaceableCollection.filter(_:(Self.Element) throws -> Bool)", "\n\nfilterSwift($info, isIncluded){\n\nreturn _create(this.$info.Self, 'initBuffer', {Self: this.$info.Self, S: _clarifyGenerics({Self:Array, Element: this.$info.Self.Element})}, this.lazy.filterSwift({Self: _clarifyGenerics({Self:LazySequence, Base: this.$info.Self})}, isIncluded));\n}"],
  ["Swift.(file).RangeReplaceableCollection.removeAll(where:(Self.Element) throws -> Bool)", "\n\nremoveAllWhere($info, shouldBeRemoved){\n\nObject.assign(this, _create(this.$info.Self, 'initBuffer', {Self: this.$info.Self, S: _clarifyGenerics({Self:Array, Element: this.$info.Self.Element})}, this.lazy.filterSwift({Self: _clarifyGenerics({Self:LazySequence, Base: this.$info.Self})}, (($info, $0) => Bool.prefix_33(null, shouldBeRemoved(null, $0))))));\n}"],
  ["Swift.(file).Result.map(_:(Success) -> NewSuccess)", "\n\nmapSwift<NewSuccess>($info, transform){\n\nconst $match = this\nif((($match.rawValue == Result.success().rawValue))) {\nconst success = $match[0]\nreturn Result.success({Success: $info.NewSuccess, Failure: $info.Failure}, transform(null, success));\n}\nelse if((($match.rawValue == Result.failure().rawValue))) {\nconst failure = $match[0]\nreturn Result.failure({Success: $info.NewSuccess, Failure: $info.Failure}, failure);\n};\n}"],
  ["Swift.(file).Result.mapError(_:(Failure) -> NewFailure)", "\n\nmapError<NewFailure>($info, transform){\n\nconst $match = this\nif((($match.rawValue == Result.success().rawValue))) {\nconst success = $match[0]\nreturn Result.success({Success: $info.Success, Failure: $info.NewFailure}, success);\n}\nelse if((($match.rawValue == Result.failure().rawValue))) {\nconst failure = $match[0]\nreturn Result.failure({Success: $info.Success, Failure: $info.NewFailure}, transform(null, failure));\n};\n}"],
  ["Swift.(file).Result.flatMap(_:(Success) -> Result<NewSuccess, Failure>)", "\n\nflatMap<NewSuccess>($info, transform){\n\nconst $match = this\nif((($match.rawValue == Result.success().rawValue))) {\nconst success = $match[0]\nreturn transform(null, success);\n}\nelse if((($match.rawValue == Result.failure().rawValue))) {\nconst failure = $match[0]\nreturn Result.failure({Success: $info.NewSuccess, Failure: $info.Failure}, failure);\n};\n}"],
  ["Swift.(file).Result.flatMapError(_:(Failure) -> Result<Success, NewFailure>)", "\n\nflatMapError<NewFailure>($info, transform){\n\nconst $match = this\nif((($match.rawValue == Result.success().rawValue))) {\nconst success = $match[0]\nreturn Result.success({Success: $info.Success, Failure: $info.NewFailure}, success);\n}\nelse if((($match.rawValue == Result.failure().rawValue))) {\nconst failure = $match[0]\nreturn transform(null, failure);\n};\n}"],
  ["Swift.(file).Result.get()", "\n\nget($info){\n\nconst $match = this\nif((($match.rawValue == Result.success().rawValue))) {\nconst success = $match[0]\nreturn success;\n}\nelse if((($match.rawValue == Result.failure().rawValue))) {\nconst failure = $match[0]\nthrow failure;\n};\n}"],
  ["Swift.(file).ReversedCollection.Iterator", "\n\nstatic Iterator = class{\nstatic readonly $struct = true\nstatic readonly $infoAddress = '0x7fccfb05c5a8'\n\nreadonly _base$internal\nreadonly _base$get() { return this._base$internal }\nreadonly get _base() { return this._base$get() }\nreadonly _base$set($newValue) {\nlet $oldValue = this._base$internal\nthis._base$internal = $newValue\n}\nreadonly set _base($newValue) { this._base$set($newValue) }\n;\n\n\n\n\n_position$internal\n_position$get() { return this._position$internal }\nget _position() { return this._position$get() }\n_position$set($newValue) {\nlet $oldValue = this._position$internal\nthis._position$internal = $newValue\n}\nset _position($newValue) { this._position$set($newValue) }\n;\n\n\n\n\n\ninit_base($info, _base){\n\nthis._base = _base;\nthis._position = _base.endIndex;\nreturn ;\n}\ninit$vars() {\n}\n}"],
  ["Swift.(file).ReversedCollection.makeIterator()", "\n\nmakeIterator($info){\n\nreturn _create(ReversedCollection.Iterator, 'init_base', {Base: this.$info.Base}, this._base);\n}"],
  ["Swift.(file).ReversedCollection.Index", "\n\nstatic Index = class{\nstatic readonly $struct = true\nstatic readonly $infoAddress = '0x7fae2782a9a8'\n\nreadonly base$internal\nreadonly base$get() { return this.base$internal }\nreadonly get base() { return this.base$get() }\nreadonly base$set($newValue) {\nlet $oldValue = this.base$internal\nthis.base$internal = $newValue\n}\nreadonly set base($newValue) { this.base$set($newValue) }\n;\n\n\n\ninit($info, base){\n\nthis.base = base;\nreturn ;\n}\ninit$vars() {\n}\n}"],
  ["Swift.(file).ReversedCollection.index(after:ReversedCollection<Base>.Index)", "\n\nindexAfter($info, i){\n\nreturn _create(ReversedCollection.Index, 'init', {Base: this.$info.Base}, this._base.indexBefore({Self: this.$info.Base}, i.base));\n}"],
  ["Swift.(file).ReversedCollection.index(before:ReversedCollection<Base>.Index)", "\n\nindexBefore($info, i){\n\nreturn _create(ReversedCollection.Index, 'init', {Base: this.$info.Base}, this._base.indexAfter({Self: this.$info.Base}, i.base));\n}"],
  ["Swift.(file).ReversedCollection.index(_:ReversedCollection<Base>.Index,offsetBy:Int)", "\n\nindexOffsetBy($info, i, n){\n\nreturn _create(ReversedCollection.Index, 'init', {Base: this.$info.Base}, this._base.indexOffsetBy({Self: this.$info.Base}, i.base, Int.prefix_45({Self: Int}, n)));\n}"],
  ["Swift.(file).ReversedCollection.index(_:ReversedCollection<Base>.Index,offsetBy:Int,limitedBy:ReversedCollection<Base>.Index)", "\n\nindexOffsetByLimitedBy($info, i, n, limit){\n\nreturn this._base.indexOffsetByLimitedBy({Self: this.$info.Base}, i.base, Int.prefix_45({Self: Int}, n), limit.base).mapSwift({Wrapped: this.$info.Base.Index, U: _clarifyGenerics({Self:ReversedCollection, Base: this.$info.Base}).Index}, init({Base: this.$info.Base}, ReversedCollection.Index));\n}"],
  ["Swift.(file).ReversedCollection.distance(from:ReversedCollection<Base>.Index,to:ReversedCollection<Base>.Index)", "\n\ndistanceFromTo($info, start, end){\n\nreturn this._base.distanceFromTo({Self: this.$info.Base}, end.base, start.base);\n}"],
  ["Swift.(file).ReversedCollection.reversed()", "\n\nreversed($info){\n\nreturn this._base;\n}"],
  ["Swift.(file).Sequence.makeIterator()", "\n\nmakeIterator($info){\n\nreturn this;\n}"],
  ["Swift.(file).PrefixSequence.Iterator", "\n\nstatic Iterator = class{\nstatic readonly $struct = true\nstatic readonly $infoAddress = '0x7f9d0e0dd1a0'\n\n_base$internal\n_base$get() { return this._base$internal }\nget _base() { return this._base$get() }\n_base$set($newValue) {\nlet $oldValue = this._base$internal\nthis._base$internal = $newValue\n}\nset _base($newValue) { this._base$set($newValue) }\n;\n\n\n\n\n\n\n_remaining$internal\n_remaining$get() { return this._remaining$internal }\nget _remaining() { return this._remaining$get() }\n_remaining$set($newValue) {\nlet $oldValue = this._remaining$internal\nthis._remaining$internal = $newValue\n}\nset _remaining($newValue) { this._remaining$set($newValue) }\n;\n\n\n\n\n\ninitMaxLengthInt($info, base, maxLength){\n\nthis._base = base;\nthis._remaining = maxLength;\nreturn ;\n}\ninit$vars() {\n}\n}"],
  ["Swift.(file).DropWhileSequence.Iterator", "\n\nstatic Iterator = class{\nstatic readonly $struct = true\nstatic readonly $infoAddress = '0x7f963a0b21a8'\n\n_iterator$internal\n_iterator$get() { return this._iterator$internal }\nget _iterator() { return this._iterator$get() }\n_iterator$set($newValue) {\nlet $oldValue = this._iterator$internal\nthis._iterator$internal = $newValue\n}\nset _iterator($newValue) { this._iterator$set($newValue) }\n;\n\n\n\n\n\n\n_nextElement$internal\n_nextElement$get() { return this._nextElement$internal }\nget _nextElement() { return this._nextElement$get() }\n_nextElement$set($newValue) {\nlet $oldValue = this._nextElement$internal\nthis._nextElement$internal = $newValue\n}\nset _nextElement($newValue) { this._nextElement$set($newValue) }\n;\n\n\n\n\n\ninitNextElementOptional($info, iterator, nextElement){\n\nthis._iterator = iterator;\nthis._nextElement = nextElement;\nreturn ;\n}\ninit$vars() {\nthis._nextElement$internal = null\n}\n}"],
  ["Swift.(file).Sequence.map(_:(Self.Element) throws -> T)", "\n\nmapSwift<T>($info, transform){\n\n\nconst initialCapacity = this.underestimatedCount;\n\n;\n\n;\n\nlet result = _create(ContiguousArray, 'init', {Element: $info.T}, );\n\n;\n\n;\nresult.reserveCapacity({Element: $info.T}, initialCapacity);\n\nlet iterator = this.makeIterator({Self: $info.Self}, );\n\n;\n\n;\n\n{\nlet $generator = _cloneStruct(Int.infix_46_46_60({Self: Int}, 0, initialCapacity).makeIterator({Self: _clarifyGenerics({Self:Range, Bound: Int})}, ));\n\n\nwhile(true) {\n;\nif($generator.next({Elements: _clarifyGenerics({Self:Range, Bound: Int})}, ) == null) break;\n\nresult.append({Element: $info.T}, transform(null, iterator.next({Self: $info.Self.Iterator}, )));\n}\n};\nwhile(true){\nconst _element$let = iterator.next({Self: $info.Self.Iterator}, )\nif(!((_element$let != null))) break\nresult.append({Element: $info.T}, transform(null, _element$let));\n};\nreturn _create(Array, 'initBuffer', {Element: $info.T, S: _clarifyGenerics({Self:ContiguousArray, Element: $info.T})}, result);\n}"],
  ["Swift.(file).Sequence.filter(_:(Self.Element) throws -> Bool)", "\n\nfilterSwift($info, isIncluded){\n\nreturn this._filter({Self: this.$info.Self}, isIncluded);\n}"],
  ["Swift.(file).Sequence.forEach(_:(Self.Element) throws -> Void)", "\n\nforEachSwift($info, body){\n\n\n{\nlet $element$generator = this.makeIterator({Self: this.$info.Self}, );\n\n\nwhile(true) {\nconst _element$let = $element$generator.next({Self: this.$info.Self.Iterator}, );\nif(!((_element$let != null))) break;\n\nbody(null, _element$let);\n}\n};\n}"],
  ["Swift.(file).Sequence.first(where:(Self.Element) throws -> Bool)", "\n\nfirstWhere($info, predicate){\n\n\n{\nlet $element$generator = this.makeIterator({Self: this.$info.Self}, );\n\n\nwhile(true) {\nconst _element$let = $element$generator.next({Self: this.$info.Self.Iterator}, );\nif(!((_element$let != null))) break;\n\n\n{\nif((predicate(null, _element$let))) {\n\nreturn _element$let;\n}\n};\n}\n};\nreturn null;\n}"],
  ["Swift.(file).Sequence.split(maxSplits:Int,omittingEmptySubsequences:Bool,whereSeparator:(Self.Element) throws -> Bool)", "\n\nsplitMaxSplitsOmittingEmptySubsequencesWhereSeparator($info, maxSplits = Int.max, omittingEmptySubsequences = true, isSeparator){\n\npreconditionFileLine(null, () => Int.infix_62_61(null, maxSplits, 0), () => \"Must take zero or more splits\");\n\nconst whole = _create(Array, 'initBuffer', {Element: this.$info.Self.Element, S: this.$info.Self}, this);\n\n;\n\n;\nreturn whole.splitMaxSplitsOmittingEmptySubsequencesWhereSeparator({Self: _clarifyGenerics({Self:Array, Element: this.$info.Self.Element})}, maxSplits, omittingEmptySubsequences, isSeparator);\n}"],
  ["Swift.(file).Sequence.suffix(_:Int)", "\n\nsuffix($info, maxLength){\n\npreconditionFileLine(null, () => Int.infix_62_61(null, maxLength, 0), () => \"Can't take a suffix of negative length from a sequence\");\n\n{\nif(!((Int.infix_33_61({Self: Int}, maxLength, 0)))) {\n\nreturn _create(Array, 'initBuffer', {Element: this.$info.Self.Element}, []);\n}\n};\n\nlet ringBuffer = _create(Array, 'initBuffer', {Element: this.$info.Self.Element}, []);\n\n;\n\n;\nringBuffer.reserveCapacity({Element: this.$info.Self.Element}, /*dot_syntax_base_ignored*/min(null, maxLength, this.underestimatedCount));\n\nlet i = 0;\n\n;\n\n;\n\n{\nlet $element$generator = this.makeIterator({Self: this.$info.Self}, );\n\n\nwhile(true) {\nconst _element$let = $element$generator.next({Self: this.$info.Self.Iterator}, );\nif(!((_element$let != null))) break;\n\n\n{\nif((Int.infix_60(null, ringBuffer.count, maxLength))) {\n\nringBuffer.append({Element: this.$info.Self.Element}, _element$let);\n}\nelse {\nringBuffer.subscript$set(null, _element$let, i);\nInt.infix_43_61(null, {get: () => i, set: $val => i = $val}, 1);\nInt.infix_37_61(null, {get: () => i, set: $val => i = $val}, maxLength);\n}\n};\n}\n};\n\n{\nif((Int.infix_33_61({Self: Int}, i, ringBuffer.startIndex))) {\n\n\nlet rotated = _create(Array, 'initBuffer', {Element: this.$info.Self.Element}, []);\n\n;\n\n;\nrotated.reserveCapacity({Element: this.$info.Self.Element}, ringBuffer.count);\nArray.infix_43_61({Self: _clarifyGenerics({Self:Array, Element: this.$info.Self.Element}), Other: _clarifyGenerics({Self:ArraySlice, Element: this.$info.Self.Element})}, {get: () => rotated, set: $val => rotated = $val}, ringBuffer.subscriptRange$get(null, Int.infix_46_46_60({Self: Int}, i, ringBuffer.endIndex)));\nArray.infix_43_61({Self: _clarifyGenerics({Self:Array, Element: this.$info.Self.Element}), Other: _clarifyGenerics({Self:ArraySlice, Element: this.$info.Self.Element})}, {get: () => rotated, set: $val => rotated = $val}, ringBuffer.subscriptRange$get(null, Int.infix_46_46_60({Self: Int}, 0, i)));\nreturn rotated;\n}\nelse {\nreturn ringBuffer;\n}\n};\n}"],
  ["Swift.(file).Sequence.dropFirst(_:Int)", "\n\ndropFirst($info, k = 1){\n\nreturn _create(DropFirstSequence, 'initDroppingInt', {Base: this.$info.Self}, this, k);\n}"],
  ["Swift.(file).Sequence.dropLast(_:Int)", "\n\ndropLast($info, k = 1){\n\npreconditionFileLine(null, () => Int.infix_62_61(null, k, 0), () => \"Can't drop a negative number of elements from a sequence\");\n\n{\nif(!((Int.infix_33_61({Self: Int}, k, 0)))) {\n\nreturn _create(Array, 'initBuffer', {Element: this.$info.Self.Element, S: this.$info.Self}, this);\n}\n};\n\nlet result = _create(Array, 'initBuffer', {Element: this.$info.Self.Element}, []);\n\n;\n\n;\n\nlet ringBuffer = _create(Array, 'initBuffer', {Element: this.$info.Self.Element}, []);\n\n;\n\n;\n\nlet i = ringBuffer.startIndex;\n\n;\n\n;\n\n{\nlet $element$generator = this.makeIterator({Self: this.$info.Self}, );\n\n\nwhile(true) {\nconst _element$let = $element$generator.next({Self: this.$info.Self.Iterator}, );\nif(!((_element$let != null))) break;\n\n\n{\nif((Int.infix_60(null, ringBuffer.count, k))) {\n\nringBuffer.append({Element: this.$info.Self.Element}, _element$let);\n}\nelse {\nresult.append({Element: this.$info.Self.Element}, ringBuffer.subscript$get(null, i));\nringBuffer.subscript$set(null, _element$let, i);\nInt.infix_43_61(null, {get: () => i, set: $val => i = $val}, 1);\nInt.infix_37_61(null, {get: () => i, set: $val => i = $val}, k);\n}\n};\n}\n};\nreturn result;\n}"],
  ["Swift.(file).Sequence.prefix(_:Int)", "\n\nprefix($info, maxLength){\n\nreturn _create(PrefixSequence, 'initMaxLengthInt', {Base: this.$info.Self}, this, maxLength);\n}"],
  ["Swift.(file).Sequence.prefix(while:(Self.Element) throws -> Bool)", "\n\nprefixWhile($info, predicate){\n\n\nlet result = _create(Array, 'initBuffer', {Element: this.$info.Self.Element}, []);\n\n;\n\n;\n\n{\nlet $element$generator = this.makeIterator({Self: this.$info.Self}, );\n\n\nwhile(true) {\nconst _element$let = $element$generator.next({Self: this.$info.Self.Iterator}, );\nif(!((_element$let != null))) break;\n\n\n{\nif(!((predicate(null, _element$let)))) {\n\nbreak;\n}\n};\nresult.append({Element: this.$info.Self.Element}, _element$let);\n}\n};\nreturn result;\n}"],
  ["Swift.(file).Sequence.withContiguousStorageIfAvailable(_:(UnsafeBufferPointer<Self.Element>) throws -> R)", "\n\nwithContiguousStorageIfAvailable<R>($info, body){\n\nreturn null;\n}"],
  ["Swift.(file).Sequence.min(by:(Self.Element, Self.Element) throws -> Bool)", "\n\nminBy($info, areInIncreasingOrder){\n\n\nlet it = this.makeIterator({Self: this.$info.Self}, );\n\n;\n\n;\n\n{let result$let = it.next({Self: this.$info.Self.Iterator}, )\nif(!((result$let != null))) {\n\nreturn null;\n}\n};\nwhile(true){\nconst e$let = it.next({Self: this.$info.Self.Iterator}, )\nif(!((e$let != null))) break\n\n{\nif((areInIncreasingOrder(null, e$let, result$let))) {\n\nresult$let = e$let;\n}\n};\n};\nreturn result$let;\n}"],
  ["Swift.(file).Sequence.max(by:(Self.Element, Self.Element) throws -> Bool)", "\n\nmaxBy($info, areInIncreasingOrder){\n\n\nlet it = this.makeIterator({Self: this.$info.Self}, );\n\n;\n\n;\n\n{let result$let = it.next({Self: this.$info.Self.Iterator}, )\nif(!((result$let != null))) {\n\nreturn null;\n}\n};\nwhile(true){\nconst e$let = it.next({Self: this.$info.Self.Iterator}, )\nif(!((e$let != null))) break\n\n{\nif((areInIncreasingOrder(null, result$let, e$let))) {\n\nresult$let = e$let;\n}\n};\n};\nreturn result$let;\n}"],
  ["Swift.(file).Sequence.starts(with:PossiblePrefix,by:(Self.Element, PossiblePrefix.Element) throws -> Bool)", "\n\nstartsWithBy<PossiblePrefix>($info, possiblePrefix, areEquivalent){\n\n\nlet possiblePrefixIterator = possiblePrefix.makeIterator({Self: $info.PossiblePrefix}, );\n\n;\n\n;\n\n{\nlet $e0$generator = this.makeIterator({Self: $info.Self}, );\n\n\nwhile(true) {\nconst e0$let = $e0$generator.next({Self: $info.Self.Iterator}, );\nif(!((e0$let != null))) break;\n\n\n{const e1$let = possiblePrefixIterator.next({Self: $info.PossiblePrefix.Iterator}, )\nif((e1$let != null)) {\n\n\n{\nif((Bool.prefix_33(null, areEquivalent(null, e0$let, e1$let)))) {\n\nreturn false;\n}\n};\n}\nelse {\nreturn true;\n}\n};\n}\n};\nreturn Optional.infix_61_61({Wrapped: $info.PossiblePrefix.Element}, possiblePrefixIterator.next({Self: $info.PossiblePrefix.Iterator}, ), null);\n}"],
  ["Swift.(file).Sequence.elementsEqual(_:OtherSequence,by:(Self.Element, OtherSequence.Element) throws -> Bool)", "\n\nelementsEqualBy<OtherSequence>($info, other, areEquivalent){\n\n\nlet iter1 = this.makeIterator({Self: $info.Self}, );\n\n;\n\n;\n\nlet iter2 = other.makeIterator({Self: $info.OtherSequence}, );\n\n;\n\n;\nwhile(true){\n\nif(!((true))) break\nconst $match = {0: iter1.next({Self: $info.Self.Iterator}, ), 1: iter2.next({Self: $info.OtherSequence.Iterator}, )}\nif(((true))) {\nconst e1 = $match[0]\nconst e2 = $match[1]\n\n{\nif((Bool.prefix_33(null, areEquivalent(null, e1, e2)))) {\n\nreturn false;\n}\n};\n}\nelse if((($match.rawValue == Optional.none.rawValue) || ($match.rawValue == Optional.none.rawValue))) {\nreturn false;\n}\nelse if((($match.rawValue == Optional.none.rawValue && $match.rawValue == Optional.none.rawValue))) {\nreturn true;\n};\n};\n}"],
  ["Swift.(file).Sequence.lexicographicallyPrecedes(_:OtherSequence,by:(Self.Element, Self.Element) throws -> Bool)", "\n\nlexicographicallyPrecedesBy<OtherSequence>($info, other, areInIncreasingOrder){\n\n\nlet iter1 = this.makeIterator({Self: $info.Self}, );\n\n;\n\n;\n\nlet iter2 = other.makeIterator({Self: $info.OtherSequence}, );\n\n;\n\n;\nwhile(true){\n\nif(!((true))) break\n\n{const e1$let = iter1.next({Self: $info.Self.Iterator}, )\nif((e1$let != null)) {\n\n\n{const e2$let = iter2.next({Self: $info.OtherSequence.Iterator}, )\nif((e2$let != null)) {\n\n\n{\nif((areInIncreasingOrder(null, e1$let, e2$let))) {\n\nreturn true;\n}\n};\n\n{\nif((areInIncreasingOrder(null, e2$let, e1$let))) {\n\nreturn false;\n}\n};\ncontinue;\n}\n};\nreturn false;\n}\n};\nreturn Optional.infix_33_61({Wrapped: $info.Self.Element}, iter2.next({Self: $info.OtherSequence.Iterator}, ), null);\n};\n}"],
  ["Swift.(file).Sequence.contains(where:(Self.Element) throws -> Bool)", "\n\ncontainsWhere($info, predicate){\n\n\n{\nlet $e$generator = this.makeIterator({Self: this.$info.Self}, );\n\n\nwhile(true) {\nconst e$let = $e$generator.next({Self: this.$info.Self.Iterator}, );\nif(!((e$let != null))) break;\n\n\n{\nif((predicate(null, e$let))) {\n\nreturn true;\n}\n};\n}\n};\nreturn false;\n}"],
  ["Swift.(file).Sequence.allSatisfy(_:(Self.Element) throws -> Bool)", "\n\nallSatisfy($info, predicate){\n\nreturn Bool.prefix_33(null, this.containsWhere({Self: this.$info.Self}, (($info, $0) => Bool.prefix_33(null, predicate(null, $0)))));\n}"],
  ["Swift.(file).Sequence.count(where:(Self.Element) throws -> Bool)", "\n\ncountWhere($info, predicate){\n\n\nlet count = 0;\n\n;\n\n;\n\n{\nlet $e$generator = this.makeIterator({Self: this.$info.Self}, );\n\n\nwhile(true) {\nconst e$let = $e$generator.next({Self: this.$info.Self.Iterator}, );\nif(!((e$let != null))) break;\n\n\n{\nif((predicate(null, e$let))) {\n\nInt.infix_43_61(null, {get: () => count, set: $val => count = $val}, 1);\n}\n};\n}\n};\nreturn count;\n}"],
  ["Swift.(file).Sequence.reduce(_:Result,_:(Result, Self.Element) throws -> Result)", "\n\nreduceSwift<Result>($info, initialResult, nextPartialResult){\n\n\nlet accumulator = initialResult;\n\n;\n\n;\n\n{\nlet $element$generator = this.makeIterator({Self: $info.Self}, );\n\n\nwhile(true) {\nconst _element$let = $element$generator.next({Self: $info.Self.Iterator}, );\nif(!((_element$let != null))) break;\n\naccumulator = nextPartialResult(null, accumulator, _element$let);\n}\n};\nreturn accumulator;\n}"],
  ["Swift.(file).Sequence.reduce(into:Result,_:(inout Result, Self.Element) throws -> ())", "\n\nreduceInto<Result>($info, initialResult, updateAccumulatingResult){\n\n\nlet accumulator = initialResult;\n\n;\n\n;\n\n{\nlet $element$generator = this.makeIterator({Self: $info.Self}, );\n\n\nwhile(true) {\nconst _element$let = $element$generator.next({Self: $info.Self.Iterator}, );\nif(!((_element$let != null))) break;\n\nupdateAccumulatingResult(null, {get: () => accumulator, set: $val => accumulator = $val}, _element$let);\n}\n};\nreturn accumulator;\n}"],
  ["Swift.(file).Sequence.reversed()", "\n\nreversed($info){\n\n\nlet result = _create(Array, 'initBuffer', {Element: this.$info.Self.Element, S: this.$info.Self}, this);\n\n;\n\n;\n\nconst count = result.count;\n\n;\n\n;\n\n{\nlet $i$generator = _cloneStruct(Int.infix_46_46_60({Self: Int}, 0, Int.infix_47(null, count, 2)).makeIterator({Self: _clarifyGenerics({Self:Range, Bound: Int})}, ));\n\n\nwhile(true) {\nconst i$let = $i$generator.next({Elements: _clarifyGenerics({Self:Range, Bound: Int})}, );\nif(!((i$let != null))) break;\n\nresult.swapAt({Self: _clarifyGenerics({Self:Array, Element: this.$info.Self.Element})}, i$let, Int.infix_45(null, count, Int.infix_43(null, i$let, 1)));\n}\n};\nreturn result;\n}"],
  ["Swift.(file).Sequence.flatMap(_:(Self.Element) throws -> SegmentOfResult)", "\n\nflatMap<SegmentOfResult>($info, transform){\n\n\nlet result = _create(Array, 'initBuffer', {Element: $info.SegmentOfResult.Element}, []);\n\n;\n\n;\n\n{\nlet $element$generator = this.makeIterator({Self: $info.Self}, );\n\n\nwhile(true) {\nconst _element$let = $element$generator.next({Self: $info.Self.Iterator}, );\nif(!((_element$let != null))) break;\n\nresult.appendContentsOf({Element: $info.SegmentOfResult.Element, S: $info.SegmentOfResult}, transform(null, _element$let));\n}\n};\nreturn result;\n}"],
  ["Swift.(file).Sequence.compactMap(_:(Self.Element) throws -> ElementOfResult?)", "\n\ncompactMap<ElementOfResult>($info, transform){\n\nreturn this._compactMap({Self: $info.Self, ElementOfResult: $info.ElementOfResult}, transform);\n}"],
  ["Swift.(file).SetAlgebra.subtract(_:Self)", "\n\nsubtract($info, other){\n\nthis.formIntersection({Self: this.$info.Self}, this.symmetricDifference({Self: this.$info.Self}, other));\n}"],
  ["Swift.(file).SetAlgebra.isSubset(of:Self)", "\n\nisSubsetOf($info, other){\n\nreturn this.$info.Self.infix_61_61({Self: this.$info.Self}, this.intersection({Self: this.$info.Self}, other), this);\n}"],
  ["Swift.(file).SetAlgebra.isSuperset(of:Self)", "\n\nisSupersetOf($info, other){\n\nreturn other.isSubsetOf({Self: this.$info.Self}, this);\n}"],
  ["Swift.(file).SetAlgebra.isDisjoint(with:Self)", "\n\nisDisjointWith($info, other){\n\nreturn this.intersection({Self: this.$info.Self}, other).isEmpty;\n}"],
  ["Swift.(file).SetAlgebra.subtracting(_:Self)", "\n\nsubtracting($info, other){\n\nreturn this.intersection({Self: this.$info.Self}, this.symmetricDifference({Self: this.$info.Self}, other));\n}"],
  ["Swift.(file).SetAlgebra.isStrictSuperset(of:Self)", "\n\nisStrictSupersetOf($info, other){\n\nreturn Bool.infix_38_38(null, this.isSupersetOf({Self: this.$info.Self}, other), () => this.$info.Self.infix_33_61({Self: this.$info.Self}, this, other));\n}"],
  ["Swift.(file).SetAlgebra.isStrictSubset(of:Self)", "\n\nisStrictSubsetOf($info, other){\n\nreturn other.isStrictSupersetOf({Self: this.$info.Self}, this);\n}"],
  ["Swift.(file).Set.insert(_:ConcreteElement)", "\n\ninsert<ConcreteElement>($info, newMember){\n\n\nconst $tuple = this.insert({Element: $info.Element, ConcreteElement: AnyHashable}, _create(AnyHashable, 'init', {H: $info.ConcreteElement}, newMember)), inserted = $tuple && $tuple[0], memberAfterInsert = $tuple && $tuple[1];\n\n;\n\n;\n\n;\nreturn {0: inserted, 1: memberAfterInsert.base};\n}"],
  ["Swift.(file).Set.update(with:ConcreteElement)", "\n\nupdateWith<ConcreteElement>($info, newMember){\n\nreturn this.updateWith({Element: $info.Element, ConcreteElement: AnyHashable}, _create(AnyHashable, 'init', {H: $info.ConcreteElement}, newMember)).mapSwift({Wrapped: AnyHashable, U: $info.ConcreteElement}, (($info, $0) => $0.base));\n}"],
  ["Swift.(file).Set.remove(_:ConcreteElement)", "\n\nremove<ConcreteElement>($info, member){\n\nreturn this.remove({Element: $info.Element, ConcreteElement: AnyHashable}, _create(AnyHashable, 'init', {H: $info.ConcreteElement}, member)).mapSwift({Wrapped: AnyHashable, U: $info.ConcreteElement}, (($info, $0) => $0.base));\n}"],
  ["Swift.(file).Sequence.sorted(by:(Self.Element, Self.Element) throws -> Bool)", "\n\nsortedBy($info, areInIncreasingOrder){\n\n\nlet result = _create(ContiguousArray, 'initBuffer', {Element: this.$info.Self.Element, S: this.$info.Self}, this);\n\n;\n\n;\nresult.sortBy({Self: _clarifyGenerics({Self:ContiguousArray, Element: this.$info.Self.Element})}, areInIncreasingOrder);\nreturn _create(Array, 'initBuffer', {Element: this.$info.Self.Element, S: _clarifyGenerics({Self:ContiguousArray, Element: this.$info.Self.Element})}, result);\n}"],
  ["Swift.(file).MutableCollection.sort(by:(Self.Element, Self.Element) throws -> Bool)", "\n\nsortBy($info, areInIncreasingOrder){\n\n\nconst didSortUnsafeBuffer = this._withUnsafeMutableBufferPointerIfSupported({Self: this.$info.Self, R: _clarifyGenerics({Self:Optional, Wrapped: Void})}, (($info, buffer$inout) => buffer._stableSortImplBy({Element: this.$info.Self.Element}, areInIncreasingOrder)));\n\n;\n\n;\n\n{\nif((Optional.infix_61_61({Wrapped: _clarifyGenerics({Self:Optional, Wrapped: Void})}, didSortUnsafeBuffer, null))) {\n\n\nconst sortedElements = _cloneStruct(this.sortedBy({Self: this.$info.Self}, areInIncreasingOrder));\n\n;\n\n;\n\n{\nlet $generator = _cloneStruct(zip({Sequence1: this.$info.Self.Indices, Sequence2: _clarifyGenerics({Self:Range, Bound: _clarifyGenerics({Self:Array, Element: {$genericType: 'Element'}}).Index})}, this.indices, sortedElements.indices).makeIterator({Sequence1: this.$info.Self.Indices, Sequence2: _clarifyGenerics({Self:Range, Bound: _clarifyGenerics({Self:Array, Element: {$genericType: 'Element'}}).Index})}, ));\n\n\nwhile(true) {\nconst $tuple = $generator.next({Sequence1: this.$info.Self.Indices, Sequence2: _clarifyGenerics({Self:Range, Bound: _clarifyGenerics({Self:Array, Element: {$genericType: 'Element'}}).Index})}, ), i$let = $tuple && $tuple[0], j$let = $tuple && $tuple[1];\nif(!((i$let != null) && (j$let != null))) break;\n\nthis.subscript$set(null, sortedElements.subscript$get(null, j$let), i$let);\n}\n};\n}\n};\n}"],
  ["Swift.(file).Strideable.<infix(_:Self,_:Self)", "\n\nstatic infix_60($info, x, y){\n\nreturn this.$info.Self.Stride.infix_62({Self: this.$info.Self.Stride}, x.distanceTo({Self: this.$info.Self}, y), _create(this.$info.Self.Stride, 'initIntegerLiteral', {Self: this.$info.Self.Stride}, 0));\n}"],
  ["Swift.(file).Strideable.==infix(_:Self,_:Self)", "\n\nstatic infix_61_61($info, x, y){\n\nreturn this.$info.Self.Stride.infix_61_61({Self: this.$info.Self.Stride}, x.distanceTo({Self: this.$info.Self}, y), _create(this.$info.Self.Stride, 'initIntegerLiteral', {Self: this.$info.Self.Stride}, 0));\n}"],
  ["Swift.(file).String.+infix(_:String,_:String)", "\n\nstatic infix_43($info, lhs, rhs){\n\n\nlet result = lhs;\n\n;\n\n;\nresult.append(null, rhs);\nreturn result;\n}"],
  ["Swift.(file).String.+=infix(_:String,_:String)", "\n\nstatic infix_43_61($info, lhs$inout, rhs){\n\nlet lhs = lhs$inout.get()\nconst $result = (() => {\nlhs.append(null, rhs);})()\nlhs$inout.set(lhs)\nreturn $result\n}"],
  ["Swift.(file).StringProtocol.!=infix(_:Self,_:RHS)", "\n\nstatic infix_33_61<RHS>($info, lhs, rhs){\n\nreturn Bool.prefix_33(null, $info.Self.infix_61_61({Self: $info.Self, RHS: $info.RHS}, lhs, rhs));\n}"],
  ["Swift.(file).StringProtocol.>infix(_:Self,_:RHS)", "\n\nstatic infix_62<RHS>($info, lhs, rhs){\n\nreturn $info.RHS.infix_60({Self: $info.RHS, RHS: $info.Self}, rhs, lhs);\n}"],
  ["Swift.(file).StringProtocol.<=infix(_:Self,_:RHS)", "\n\nstatic infix_60_61<RHS>($info, lhs, rhs){\n\nreturn Bool.prefix_33(null, $info.RHS.infix_60({Self: $info.RHS, RHS: $info.Self}, rhs, lhs));\n}"],
  ["Swift.(file).StringProtocol.>=infix(_:Self,_:RHS)", "\n\nstatic infix_62_61<RHS>($info, lhs, rhs){\n\nreturn Bool.prefix_33(null, $info.Self.infix_60({Self: $info.Self, RHS: $info.RHS}, lhs, rhs));\n}"],
  ["Swift.(file).DefaultStringInterpolation.appendLiteral(_:String)", "\n\nappendLiteral($info, literal){\n\nliteral.writeTo({Target: DefaultStringInterpolation}, {get: () => this, set: $val => Object.assign(this, $val)});\n}"],
  ["Swift.(file).DefaultStringInterpolation.appendInterpolation(_:T)", "\n\nappendInterpolation<T>($info, value){\n\nvalue.writeTo({Self: $info.T, Target: DefaultStringInterpolation}, {get: () => this, set: $val => Object.assign(this, $val)});\n}"],
  ["Swift.(file).DefaultStringInterpolation.appendInterpolation(_:T)", "\n\nappendInterpolation<T>($info, value){\n\nvalue.writeTo({Self: $info.T, Target: DefaultStringInterpolation}, {get: () => this, set: $val => Object.assign(this, $val)});\n}"],
  ["Swift.(file).DefaultStringInterpolation.appendInterpolation(_:T)", "\n\nappendInterpolation<T>($info, value){\n\nvalue.description.writeTo({Target: DefaultStringInterpolation}, {get: () => this, set: $val => Object.assign(this, $val)});\n}"],
  ["Swift.(file).StringProtocol.hasPrefix(_:Prefix)", "\n\nhasPrefix<Prefix>($info, prefix){\n\nreturn this.startsWith({Self: $info.Self, PossiblePrefix: $info.Prefix}, prefix);\n}"],
  ["Swift.(file).StringProtocol.hasSuffix(_:Suffix)", "\n\nhasSuffix<Suffix>($info, suffix){\n\nreturn this.reversed({Self: $info.Self}, ).startsWith({Self: _clarifyGenerics({Self:ReversedCollection, Base: $info.Self}), PossiblePrefix: _clarifyGenerics({Self:ReversedCollection, Base: $info.Suffix})}, suffix.reversed({Self: $info.Suffix}, ));\n}"],
  ["Swift.(file).String.append(contentsOf:String)", "\n\nappendContentsOf($info, newElements){\n\nthis.append(null, newElements);\n}"],
  ["Swift.(file).String.insert(contentsOf:S,at:String.Index)", "\n\ninsertContentsOfAt<S>($info, newElements, i){\n\nthis.replaceSubrangeWith({C: $info.S}, String.Index.infix_46_46_60({Self: String.Index}, i, i), newElements);\n}"],
  ["Swift.(file).String.max(_:T,_:T)", "\n\nmax<T>($info, x, y){\n\nreturn /*dot_syntax_base_ignored*/max(null, x, y);\n}"],
  ["Swift.(file).String.min(_:T,_:T)", "\n\nmin<T>($info, x, y){\n\nreturn /*dot_syntax_base_ignored*/min(null, x, y);\n}"],
  ["Swift.(file).Sequence.+infix(_:Self,_:String)", "\n\nstatic infix_43($info, lhs, rhs){\n\nfatalErrorFileLine(null, );\n}"],
  ["Swift.(file).Sequence.+infix(_:String,_:Self)", "\n\nstatic infix_43($info, lhs, rhs){\n\nfatalErrorFileLine(null, );\n}"],
  ["Swift.(file).Substring.withCString(_:(UnsafePointer<CChar>) throws -> Result)", "\n\nwithCString<Result>($info, body){\n\nreturn _create(String, 'initSubstring', null, this).withCString({Result: $info.Result}, body);\n}"],
  ["Swift.(file).Substring.withCString(encodedAs:TargetEncoding.Type,_:(UnsafePointer<TargetEncoding.CodeUnit>) throws -> Result)", "\n\nwithCStringEncodedAs<Result, TargetEncoding>($info, targetEncoding, body){\n\nreturn _create(String, 'initSubstring', null, this).withCStringEncodedAs({Result: $info.Result, TargetEncoding: $info.TargetEncoding}, targetEncoding, body);\n}"],
  ["Swift.(file).Substring.UTF8View", "\n\nstatic UTF8View = class{\nstatic readonly $struct = true\nstatic readonly $infoAddress = '0x7feb53104bc0'\n\n_slice$internal\n_slice$get() { return this._slice$internal }\nget _slice() { return this._slice$get() }\n_slice$set($newValue) {\nlet $oldValue = this._slice$internal\nthis._slice$internal = $newValue\n}\nset _slice($newValue) { this._slice$set($newValue) }\n;\n\n\n\n\n\ninit_sliceSlice($info, _slice){\nthis._slice = _slice\n}\ninit$vars() {\n}\n}"],
  ["Swift.(file).Substring.UTF16View", "\n\nstatic UTF16View = class{\nstatic readonly $struct = true\nstatic readonly $infoAddress = '0x7fa79b8dfbc0'\n\n_slice$internal\n_slice$get() { return this._slice$internal }\nget _slice() { return this._slice$get() }\n_slice$set($newValue) {\nlet $oldValue = this._slice$internal\nthis._slice$internal = $newValue\n}\nset _slice($newValue) { this._slice$set($newValue) }\n;\n\n\n\n\n\ninit_sliceSlice($info, _slice){\nthis._slice = _slice\n}\ninit$vars() {\n}\n}"],
  ["Swift.(file).Substring.UnicodeScalarView", "\n\nstatic UnicodeScalarView = class{\nstatic readonly $struct = true\nstatic readonly $infoAddress = '0x7ff3e98dfbc8'\n\n_slice$internal\n_slice$get() { return this._slice$internal }\nget _slice() { return this._slice$get() }\n_slice$set($newValue) {\nlet $oldValue = this._slice$internal\nthis._slice$internal = $newValue\n}\nset _slice($newValue) { this._slice$set($newValue) }\n;\n\n\n\n\n\ninit_sliceSlice($info, _slice){\nthis._slice = _slice\n}\ninit$vars() {\n}\n}"],
  ["Swift.(file).Substring.append(contentsOf:S)", "\n\nappendContentsOf<S>($info, _elements){\n\n\nlet string = _create(String, 'initSubstring', null, this);\n\n;\n\n;\nObject.assign(this, _create(Substring, 'init', null, ));\nstring.appendContentsOf({S: $info.S}, _elements);\nObject.assign(this, _create(Substring, 'initString', null, string));\n}"],
  ["Swift.(file).Substring.lowercased()", "\n\nlowercased($info){\n\nreturn _create(String, 'initSubstring', null, this).lowercased(null, );\n}"],
  ["Swift.(file).Substring.uppercased()", "\n\nuppercased($info){\n\nreturn _create(String, 'initSubstring', null, this).uppercased(null, );\n}"],
  ["Swift.(file).Substring.filter(_:(Substring.Element) throws -> Bool)", "\n\nfilterSwift($info, isIncluded){\n\nreturn _create(String, 'initBuffer', {S: _clarifyGenerics({Self:Array, Element: Character})}, this.lazy.filterSwift({Self: _clarifyGenerics({Self:LazySequence, Base: Substring})}, isIncluded));\n}"],
  ["Swift.(file).Substring.write(_:String)", "\n\nwrite($info, other){\n\nthis.appendContentsOf({S: String}, other);\n}"],
  ["Swift.(file).Substring.write(to:Target)", "\n\nwriteTo<Target>($info, target$inout){\n\nlet target = target$inout.get()\nconst $result = (() => {\ntarget.write({Self: $info.Target}, _create(String, 'initSubstring', null, this));})()\ntarget$inout.set(target)\nreturn $result\n}"],
  ["Swift.(file)._UIntBuffer.makeIterator()", "\n\nmakeIterator($info){\n\nreturn _create(_UIntBuffer.Iterator, 'init_UIntBuffer', {Element: this.$info.Element}, this);\n}"],
  ["Swift.(file).UTF16.encode(_:Unicode.Scalar)", "\n\nstatic encode($info, source){\n\n\nconst x = _cloneStruct(source.value);\n\n;\n\n;\n\n{\nif((_fastPath(null, UInt32.infix_60(null, x, UInt32.infix_60_60({Self: UInt32, Other: Int}, 1, 16))))) {\n\nreturn _create(Unicode.UTF16.EncodedScalar, 'init_storage_UIntBufferStorage_bitCountUInt8', {Element: UInt16}, x, 16);\n}\n};\n\nconst x1 = _cloneStruct(UInt32.infix_45(null, x, UInt32.infix_60_60({Self: UInt32, Other: Int}, 1, 16)));\n\n;\n\n;\n\nlet r = _cloneStruct(UInt32.infix_43(null, 0xdc00, UInt32.infix_38(null, x1, 0x3ff)));\n\n;\n\n;\nUInt32.infix_38_60_60_61(null, {get: () => r, set: $val => r = $val}, 16);\nUInt32.infix_124_61(null, {get: () => r, set: $val => r = $val}, UInt32.infix_43(null, 0xd800, UInt32.infix_38(null, UInt32.infix_38_62_62(null, x1, 10), 0x3ff)));\nreturn _create(Unicode.UTF16.EncodedScalar, 'init_storage_UIntBufferStorage_bitCountUInt8', {Element: UInt16}, r, 32);\n}"],
  ["Swift.(file).UTF16.ForwardParser", "\n\nstatic ForwardParser = class{\nstatic readonly $struct = true\nstatic readonly $infoAddress = '0x7fb4208dfbb8'\nstatic readonly _Buffer = _UIntBuffer\ninit($info){\n\nthis._buffer = _create(Unicode.UTF16.ForwardParser._Buffer, 'init', {Element: UInt16}, );\nreturn ;\n}\n\n_buffer$internal\n_buffer$get() { return this._buffer$internal }\nget _buffer() { return this._buffer$get() }\n_buffer$set($newValue) {\nlet $oldValue = this._buffer$internal\nthis._buffer$internal = $newValue\n}\nset _buffer($newValue) { this._buffer$set($newValue) }\n;\n\n\n\n\n\ninit$vars() {\n}\n}"],
  ["Swift.(file).UTF16.ReverseParser", "\n\nstatic ReverseParser = class{\nstatic readonly $struct = true\nstatic readonly $infoAddress = '0x7ffb799041b8'\nstatic readonly _Buffer = _UIntBuffer\ninit($info){\n\nthis._buffer = _create(Unicode.UTF16.ReverseParser._Buffer, 'init', {Element: UInt16}, );\nreturn ;\n}\n\n_buffer$internal\n_buffer$get() { return this._buffer$internal }\nget _buffer() { return this._buffer$get() }\n_buffer$set($newValue) {\nlet $oldValue = this._buffer$internal\nthis._buffer$internal = $newValue\n}\nset _buffer($newValue) { this._buffer$set($newValue) }\n;\n\n\n\n\n\ninit$vars() {\n}\n}"],
  ["Swift.(file).UTF32.encode(_:Unicode.Scalar)", "\n\nstatic encode($info, source){\n\nreturn _create(Unicode.UTF32.EncodedScalar, 'init', {Element: UInt32}, source.value);\n}"],
  ["Swift.(file).UTF8.ForwardParser", "\n\nstatic ForwardParser = class{\nstatic readonly $struct = true\nstatic readonly $infoAddress = '0x7ff4798653b8'\nstatic readonly _Buffer = _UIntBuffer\ninit($info){\n\nthis._buffer = _create(Unicode.UTF8.ForwardParser._Buffer, 'init', {Element: UInt8}, );\nreturn ;\n}\n\n_buffer$internal\n_buffer$get() { return this._buffer$internal }\nget _buffer() { return this._buffer$get() }\n_buffer$set($newValue) {\nlet $oldValue = this._buffer$internal\nthis._buffer$internal = $newValue\n}\nset _buffer($newValue) { this._buffer$set($newValue) }\n;\n\n\n\n\n\ninit$vars() {\n}\n}"],
  ["Swift.(file).UTF8.ReverseParser", "\n\nstatic ReverseParser = class{\nstatic readonly $struct = true\nstatic readonly $infoAddress = '0x7fe35b8dfbb8'\nstatic readonly _Buffer = _UIntBuffer\ninit($info){\n\nthis._buffer = _create(Unicode.UTF8.ReverseParser._Buffer, 'init', {Element: UInt8}, );\nreturn ;\n}\n\n_buffer$internal\n_buffer$get() { return this._buffer$internal }\nget _buffer() { return this._buffer$get() }\n_buffer$set($newValue) {\nlet $oldValue = this._buffer$internal\nthis._buffer$internal = $newValue\n}\nset _buffer($newValue) { this._buffer$set($newValue) }\n;\n\n\n\n\n\ninit$vars() {\n}\n}"],
  ["Swift.(file).UnicodeDecodingResult.==infix(_:UnicodeDecodingResult,_:UnicodeDecodingResult)", "\n\nstatic infix_61_61($info, lhs, rhs){\n\nconst $match = {0: lhs, 1: rhs}\nif((($match.rawValue == UnicodeDecodingResult.scalarValue().rawValue && $match.rawValue == UnicodeDecodingResult.scalarValue().rawValue))) {\nconst lhsScalar = $match[0][0]\nconst rhsScalar = $match[1][0]\nreturn Unicode.Scalar.infix_61_61(null, lhsScalar, rhsScalar);\n}\nelse if((($match.rawValue == UnicodeDecodingResult.emptyInput.rawValue && $match.rawValue == UnicodeDecodingResult.emptyInput.rawValue))) {\nreturn true;\n}\nelse if((($match.rawValue == UnicodeDecodingResult.error.rawValue && $match.rawValue == UnicodeDecodingResult.error.rawValue))) {\nreturn true;\n}\nelse if(((true))) {\nreturn false;\n};\n}"],
  ["Swift.(file).transcode(_:Input,from:InputEncoding.Type,to:OutputEncoding.Type,stoppingOnError:Bool,into:<<error type>>)", "\nfunction transcodeFromToStoppingOnErrorInto<Input, InputEncoding, OutputEncoding>($info, input, inputEncoding, outputEncoding, stopOnError, processCodeUnit){\n\n\nlet input = input;\n\n;\n\n;\n\nlet p = _create($info.InputEncoding.ForwardParser, 'init', {Self: $info.InputEncoding.ForwardParser}, );\n\n;\n\n;\n\nlet hadError = false;\n\n;\n\n;\nwhile(true){\n\nif(!((true))) break\nconst $match = p.parseScalarFrom({Self: $info.InputEncoding.ForwardParser, I: $info.Input}, {get: () => input, set: $val => input = $val})\nif((($match.rawValue == Unicode.ParseResult.valid().rawValue))) {\nconst s = $match[0]\n\nconst t = $info.OutputEncoding.transcodeFrom({Self: $info.OutputEncoding, FromEncoding: $info.InputEncoding}, s, inputEncoding);\n\n;\n\n;\n\n{const s$let = t\nif(!((_fastPath(null, Optional.infix_33_61({Wrapped: $info.OutputEncoding.EncodedScalar}, t, null))) && (s$let != null))) {\n\nbreak;\n}\n};\ns$let.forEachSwift({Self: $info.OutputEncoding.EncodedScalar}, processCodeUnit);\ncontinue;\n}\nelse if((($match.rawValue == Unicode.ParseResult.emptyInput.rawValue))) {\nreturn hadError;\n}\nelse if((($match.rawValue == Unicode.ParseResult.error().rawValue))) {\n\n{\nif((_slowPath(null, stopOnError))) {\n\nreturn true;\n}\n};\nhadError = true;\n};\n$info.OutputEncoding.encodedReplacementCharacter.forEachSwift({Self: $info.OutputEncoding.EncodedScalar}, processCodeUnit);\n};\n}"],
  ["Swift.(file).UTF16.width(_:<<error type>>)", "\n\nstatic width($info, x){\n\nreturn (UInt32.infix_60_61(null, x.value, 0xFFFF) ? 1 : 2);\n}"],
  ["Swift.(file).UTF16.leadSurrogate(_:<<error type>>)", "\n\nstatic leadSurrogate($info, x){\n\npreconditionFileLine(null, () => Int.infix_61_61(null, this.width(null, x), 2));\nreturn UInt16.infix_43(null, 0xD800, _create(UTF16.CodeUnit, 'initTruncatingIfNeeded', {Self: UTF16.CodeUnit, T: UInt32}, UInt32.infix_38_62_62(null, UInt32.infix_45(null, x.value, 0x10000), 10)));\n}"],
  ["Swift.(file).UTF16.trailSurrogate(_:<<error type>>)", "\n\nstatic trailSurrogate($info, x){\n\npreconditionFileLine(null, () => Int.infix_61_61(null, this.width(null, x), 2));\nreturn UInt16.infix_43(null, 0xDC00, _create(UTF16.CodeUnit, 'initTruncatingIfNeeded', {Self: UTF16.CodeUnit, T: UInt32}, UInt32.infix_38(null, UInt32.infix_45(null, x.value, 0x10000), UInt32.infix_45(null, UInt32.infix_38_60_60(null, 1, 10), 1))));\n}"],
  ["Swift.(file).UTF16.isLeadSurrogate(_:Unicode.UTF16.CodeUnit)", "\n\nstatic isLeadSurrogate($info, x){\n\nreturn UInt16.infix_61_61(null, UInt16.infix_38(null, x, 0xFC00), 0xD800);\n}"],
  ["Swift.(file).UTF16.isTrailSurrogate(_:Unicode.UTF16.CodeUnit)", "\n\nstatic isTrailSurrogate($info, x){\n\nreturn UInt16.infix_61_61(null, UInt16.infix_38(null, x, 0xFC00), 0xDC00);\n}"],
  ["Swift.(file)._UnicodeEncoding.transcode(_:<<error type>>,from:FromEncoding.Type)", "\n\nstatic transcodeFrom<FromEncoding>($info, content, _){\n\nreturn this.encode({Self: $info.Self}, $info.FromEncoding.decode({Self: $info.FromEncoding}, content));\n}"],
  ["Swift.(file).Unicode.ParseResult", "\n\nstatic ParseResult = class<T>{\nstatic readonly $infoAddress = '0x7fbb900dfca8'\n\n\nstatic valid() {return Object.assign(new Unicode.ParseResult(), {rawValue: \"valid\", ...Array.from(arguments).slice(1)})}\n\n\nstatic get emptyInput() {return Object.assign(new Unicode.ParseResult(), {rawValue: \"emptyInput\", ...Array.from(arguments).slice(1)})}\n\n\nstatic error() {return Object.assign(new Unicode.ParseResult(), {rawValue: \"error\", ...Array.from(arguments).slice(1)})}\n\n_valid$internal\n_valid$get(){\n\n\n{const $tuple = this, result$let = $tuple && $tuple[0]\nif((result$let != null)) {\n\nreturn result$let;\n}\n};\nreturn null;\n}\nget _valid() { return this._valid$get() };\n\n\n\n\n_error$internal\n_error$get(){\n\n\n{const $tuple = this, result$let = $tuple && $tuple[0]\nif((result$let != null)) {\n\nreturn result$let;\n}\n};\nreturn null;\n}\nget _error() { return this._error$get() };\n\n\n\nstatic infix_61_61($info, a, b){return (a && a.rawValue) == (b && b.rawValue)}\nstatic infix_33_61($info, a, b){return (a && a.rawValue) != (b && b.rawValue)}\ninit$vars() {\n}\n}"],
  ["Swift.(file).Unicode.Scalar", "\n\nstatic Scalar = class{\nstatic readonly $struct = true\nstatic readonly $infoAddress = '0x7f8b0b0dfbb0'\ninit_valueUInt32($info, _value){\n\nthis._value = _cloneStruct(_value);\nreturn ;\n}\n\n_value$internal\n_value$get() { return this._value$internal }\nget _value() { return this._value$get() }\n_value$set($newValue) {\nlet $oldValue = this._value$internal\nthis._value$internal = $newValue\n}\nset _value($newValue) { this._value$set($newValue) }\n;\n\n\n\n\n\ninit$vars() {\n}\n}"],
  ["Swift.(file).UnsafeRawPointer.assumingMemoryBound(to:T.Type)", "\n\nassumingMemoryBoundTo<T>($info, to){\n\nreturn _create(UnsafePointer, 'initRawPointer', {Pointee: $info.T}, this._rawValue);\n}"],
  ["Swift.(file).UnsafeMutableRawPointer.assumingMemoryBound(to:T.Type)", "\n\nassumingMemoryBoundTo<T>($info, to){\n\nreturn _create(UnsafeMutablePointer, 'initRawPointer', {Pointee: $info.T}, this._rawValue);\n}"],
  ["Swift.(file)._ValidUTF8Buffer.makeIterator()", "\n\nmakeIterator($info){\n\nreturn _create(_ValidUTF8Buffer.Iterator, 'init_ValidUTF8Buffer', null, this);\n}"]
]