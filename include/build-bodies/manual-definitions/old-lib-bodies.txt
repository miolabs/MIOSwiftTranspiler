  {"Swift.(file).String.count", "return this.length"},
  {"Swift.(file).print(_:[Any],separator:String,terminator:String)", "console.log.apply(null, #A0)"},
  {"Swift.(file).Dictionary.subscript(_:Dictionary<Key, Value>.Index)", "return this.get(#AA)"},
  {"Swift.(file).Dictionary.subscript(_:Key)", "return this.get(#AA)"},
  {"Swift.(file).Dictionary.subscript(_:Key)#ASS", "if(#A0 == null) this.delete(#A1)\nelse this.set(#A1, #A0)"},
  {"Swift.(file).Dictionary.count", "return this.size"},
  {"Swift.(file).Dictionary.makeIterator()", "return new SwiftIterator((current) => Array.from(this)[current])"},
  {"Swift.(file).Array.count", "return this.length"},
  {"Swift.(file).Array.+infix(_:Array<Element>,_:Array<Element>)", "let r = lhs.concat(rhs)\nr.$info = lhs.$info\nreturn r"},
  {"Swift.(file).Array.+=infix(_:Array<Element>,_:Array<Element>)", "#A0.get().appendContentsOf(null, #A1)"},
  {"Swift.(file).Array.append(_:Element)", "this.push(#AA)"},
  {"Swift.(file).Array.append(contentsOf:S)", "this.push.apply(this, #A0)"},
  {"Swift.(file).Array.insert(_:Element,at:Int)", "this.splice(#A1, 0, #A0)"},
  {"Swift.(file).Array.remove(at:Int)", "this.splice(#AA, 1)"},
  {"Swift.(file).Array.init(repeating:Element,count:Int)", "let result = new Array(count)\nfor(let i = 0; i < count; i++) result[i] = _cloneStruct(repeatedValue)\nreturn result"},
  {"Swift.(file).Set.insert(_:Element)", "this.add(#AA)"},
  {"Swift.(file).Set.count", "return this.size"},
  {"Swift.(file).RangeReplaceableCollection.insert(contentsOf:C,at:Self.Index)", "this.splice.apply(this, [#A1, 0].concat(#A0))"},
  {"Swift.(file).BidirectionalCollection.joined(separator:String)", "return this.join(#AA)"},
  {"Swift.(file).Sequence.joined(separator:String)", "return this.join(#AA)"},
  {"Swift.(file).Collection.makeIterator()", "return new SwiftIterator((current) => this[current])"},
  {"Swift.(file).Sequence.enumerated()", "return this.map((v, i) => [i, v])"},
  {"Swift.(file).Sequence.reduce(_:Result,_:(Result, Self.Element) throws -> Result)", "return this.reduce(#A1.bind(null, null), #A0)"},
  {"Swift.(file)._ArrayProtocol.filter(_:(Self.Element) throws -> Bool)", "return this.filter(#AA.bind(null, null))"},
  {"Swift.(file).Collection.map(_:(Self.Element) throws -> T)", "let result = this.map(transform.bind(null, null))\nresult.$info = {Element: $info.T}\nreturn result"},
  {"Swift.(file).Collection.dropFirst(_:Int)", "let result = []\nif(!k) k = 1\nfor(let i = k; i < this.count; i++) result.push(this[i])\nreturn result"},
  {"Swift.(file).Sequence.sorted(by:(Self.Element, Self.Element) throws -> Bool)", "return _cloneStruct(this).sort((a, b) => areInIncreasingOrder(null, a, b) ? -1 : 1)"},
  {"Swift.(file).MutableCollection.sort(by:(Self.Element, Self.Element) throws -> Bool)", "return this.sort((a, b) => areInIncreasingOrder(null, a, b) ? -1 : 1)"},
  {"Swift.(file).??infix(_:T?,_:() throws -> T)", "return #A0 != null ? #A0 : #A1()"},
  {"Swift.(file).??infix(_:T?,_:() throws -> T?)", "return #A0 != null ? #A0 : #A1()"},
  {"Swift.(file).~=infix(_:T,_:T)", "return $info.T.infix_61_61($info, #A0, #A1)"},
  {"Swift.(file).Comparable...<infix(_:Self,_:Self)", "return _create(Range, 'initUncheckedBoundstuple_type', {Bound: $info.Self}, [minimum, maximum])"},
  {"Swift.(file).Comparable....infix(_:Self,_:Self)", "return _create(ClosedRange, 'initUncheckedBoundstuple_type', {Bound: $info.Self}, [minimum, maximum])"},
  {"Swift.(file).Range.init(uncheckedBounds:(lower: Bound, upper: Bound))", "this.lowerBound$internal = #AA[0]\nthis.upperBound$internal = #AA[1]"},
  {"Swift.(file).ClosedRange.init(uncheckedBounds:(lower: Bound, upper: Bound))", "this.lowerBound$internal = #AA[0]\nthis.upperBound$internal = #AA[1]"},
  {"Swift.(file).Range.lowerBound", "return this.lowerBound$internal"},
  {"Swift.(file).Range.upperBound", "return this.upperBound$internal"},
  {"Swift.(file).ClosedRange.lowerBound", "return this.lowerBound$internal"},
  {"Swift.(file).ClosedRange.upperBound", "return this.upperBound$internal"},
  {"Swift.(file).RangeExpression.~=infix(_:Self,_:Self.Bound)", "return #A0.contains(null, #A1)"},
  {"Swift.(file).Range.contains(_:Bound)", "return #AA >= this.lowerBound && #AA < this.upperBound"},
  {"Swift.(file).ClosedRange.contains(_:Bound)", "return #AA >= this.lowerBound && #AA <= this.upperBound"},
  {"Swift.(file).Array.init()", "return []"},
  {"Swift.(file).Dictionary.init()", "return new Map()"},
  {"Swift.(file).Set.init()", "return new Set()"},
  {"Swift.(file).Set.init(_:Source)", "return new Set(#AA)"},
  {"Swift.(file).Array.init()", "return []"},
  {"Swift.(file).BinaryInteger./infix(_:Self,_:Self)", "return (#A0 / #A1) | 0"},
  {"Swift.(file).BinaryInteger./=infix(_:Self,_:Self)", "lhs$inout.set((lhs$inout.get() / rhs) | 0)"},
  {"Swift.(file).Int8.<<infix(_:Int8,_:Int8)", "let binaryRepr = lhs.toString(2)\nlet result = 0\nfor(let i = 0; i < binaryRepr.length; i++) {\nlet j = i - rhs\nif(binaryRepr[j] !== '1') continue\nresult += j === 0 ? -128 : Math.pow(2, 7 - j)\n}\nreturn result"},
  {"Swift.(file).UInt8.<<infix(_:UInt8,_:UInt8)", "let binaryRepr = lhs.toString(2)\nlet result = 0\nfor(let i = 0; i < binaryRepr.length; i++) {\nlet j = i - rhs\nif(binaryRepr[j] !== '1') continue\nresult += Math.pow(2, 7 - j)\n}\nreturn result"},
  {"Darwin.(file).arc4random_uniform(_:UInt32)", "return (Math.random() * #AA) | 0"},
  {"Darwin.(file).arc4random()", "return arc4random_uniform(null, 4294967296)"},
  {"Swift.(file).abs(_:T)", "return Math.abs(#AA)"},
  {"Swift.(file).min(_:T,_:T,_:T,_:[T])", "let min = x\nif($info.T.infix_60($info, y, min)) min = y\nif(z != null && $info.T.infix_60($info, z, min)) min = z\nif(rest != null)for(let i of rest)if($info.T.infix_60($info, i, min)) min = i\nreturn min"},
  {"Swift.(file).max(_:T,_:T,_:T,_:[T])", "let max = x\nif($info.T.infix_62($info, y, max)) max = y\nif(z != null && $info.T.infix_62($info, z, max)) max = z\nif(rest != null)for(let i of rest)if($info.T.infix_62($info, i, max)) max = i\nreturn max"},
  {"Swift.(file).Array.startIndex", "return 0"},
  {"Swift.(file).Array.endIndex", "return this.length"},
  {"Swift.(file).Array.==infix(_:Array<Element>,_:Array<Element>)", "if(!lhs) return !rhs\nif(lhs.count != rhs.count) return false\nreturn lhs.every((val, i) => lhs.$info.Element.infix_61_61($info, val, rhs instanceof ClosedRange || rhs instanceof Range ? i + rhs.lowerBound : rhs[i]))"},
  {"Swift.(file).Array.subscript(_:Range<Int>)", "return this.slice(bounds.first, bounds.last + 1)"},
  {"Swift.(file).RangeReplaceableCollection.removeSubrange(_:R)", "for(let i = this.count - 1; i >= 0; i--) if(bounds.contains($info, i)) this.splice(i, 1)"},
  {"Swift.(file).RangeReplaceableCollection.removeLast()", "return this.pop()"},
  {"Swift.(file).RangeReplaceableCollection.removeLast(_:Int)", "for(let i = 0; i < k; i++) this.removeLast()"},
  {"Swift.(file).RangeReplaceableCollection.removeFirst()", "return this.shift()"},
  {"Swift.(file).RangeReplaceableCollection.removeFirst(_:Int)", "for(let i = 0; i < k; i++) this.removeFirst()"},
  {"Swift.(file).Collection.dropFirst(_:Int)", "let result = []\nfor(let i = k; i < this.count; i++) result.push(this[i])\nreturn result"},
  {"Swift.(file).Double.infinity", "return Infinity"},
  {"XCTest.(file).XCTAssert(_:() throws -> Bool,_:() -> String,file:StaticString,line:UInt)", "if(!expression()) throw message ? message() : 'assert fail :' + expression"},
  {"XCTest.(file).XCTAssertFalse(_:() throws -> Bool,_:() -> String,file:StaticString,line:UInt)", "if(expression()) throw message ? message() : 'assert fail :' + expression"},
  {"XCTest.(file).XCTAssertGreaterThan(_:() throws -> T,_:() throws -> T,_:() -> String,file:StaticString,line:UInt)", "if(!$info.T.infix_62($info, expression1(), expression2())) throw message ? message() : 'assert fail :' + expression1"},
  {"XCTest.(file).XCTAssertGreaterThanOrEqual(_:() throws -> T,_:() throws -> T,_:() -> String,file:StaticString,line:UInt)", "iif(!$info.T.infix_62_61($info, expression1(), expression2())) throw message ? message() : 'assert fail :' + expression1"},
  {"XCTest.(file).XCTAssertLessThan(_:() throws -> T,_:() throws -> T,_:() -> String,file:StaticString,line:UInt)", "if(!$info.T.infix_60($info, expression1(), expression2())) throw message ? message() : 'assert fail :' + expression1"},
  {"XCTest.(file).XCTAssertLessThanOrEqual(_:() throws -> T,_:() throws -> T,_:() -> String,file:StaticString,line:UInt)", "if(!$info.T.infix_60_61($info, expression1(), expression2())) throw message ? message() : 'assert fail :' + expression1"},
  {"XCTest.(file).XCTAssertNil(_:() throws -> Any?,_:() -> String,file:StaticString,line:UInt)", "if(expression() != undefined) throw message ? message() : 'assert fail :' + expression"},
  {"XCTest.(file).XCTAssertEqual(_:() throws -> T,_:() throws -> T,_:() -> String,file:StaticString,line:UInt)", "if(!$info.T.infix_61_61($info, expression1(), expression2())) throw message ? message() : 'assert fail :' + expression1"},
  {"XCTest.(file).XCTAssertNotEqual(_:() throws -> T,_:() throws -> T,_:() -> String,file:StaticString,line:UInt)", "if(!$info.T.infix_33_61($info, expression1(), expression2())) throw message ? message() : 'assert fail :' + expression1"},
  {"XCTest.(file).XCTAssertNoThrow(_:() throws -> T,_:() -> String,file:StaticString,line:UInt)", "try{expression()}catch(e){throw message ? message() : 'assert fail :' + expression}"},
  {"XCTest.(file).XCTAssertNotNil(_:() throws -> Any?,_:() -> String,file:StaticString,line:UInt)", "if(expression() == undefined) throw message ? message() : 'assert fail :' + expression"},
  {"XCTest.(file).XCTAssertThrowsError(_:() throws -> T,_:() -> String,file:StaticString,line:UInt,_:(Error) -> Void)", "try{expression()}catch(e){return}throw message ? message() : 'assert fail :' + expression"},
  {"XCTest.(file).XCTAssertTrue(_:() throws -> Bool,_:() -> String,file:StaticString,line:UInt)", "if(expression() != true) throw message ? message() : 'assert fail :' + expression"},
  {"XCTest.(file).XCTestCase.init()", "for(const testFunction in this) {\nif(typeof this[testFunction] !== 'function' || XCTestCase.prototype[testFunction]/*is inherited*/ || testFunction.endsWith('$get') || testFunction.endsWith('$set') || testFunction.endsWith('$filePrivate')) continue\nthis.init$vars()\nif(this.setUp) this.setUp()\nif(this.tearDown) this.tearDown()\nthis[testFunction]()\n}"},
  {"Swift.(file).precondition(_:() -> Bool,_:() -> String,file:StaticString,line:UInt)", "if(!condition()) throw message ? message() : 'assert fail :' + condition"}