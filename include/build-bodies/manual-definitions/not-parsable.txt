----- Swift.(file).ASCII.decode(_:Unicode.ASCII.EncodedScalar)
extension ASCII {
  public static func decode(_ source: EncodedScalar) -> Unicode.Scalar {
    return Unicode.Scalar(_unchecked: UInt32(
        source.first._unsafelyUnwrappedUnchecked))
  }
}


----- Swift.(file).ASCII.encode(_:Unicode.Scalar)
extension ASCII {
  public static func encode(
    _ source: Unicode.Scalar
  ) -> EncodedScalar? {
    guard source.value < (1&<<7) else { return nil }
    return EncodedScalar(UInt8(truncatingIfNeeded: source.value))
  }
}


----- Swift.(file).ASCII.transcode(_:FromEncoding.EncodedScalar,from:FromEncoding.Type)
extension ASCII {
  public static func transcode<FromEncoding : Unicode.Encoding>(
    _ content: FromEncoding.EncodedScalar, from _: FromEncoding.Type
  ) -> EncodedScalar? {
    if _fastPath(FromEncoding.self == UTF16.self) {
      let c = _identityCast(content, to: UTF16.EncodedScalar.self)
      guard (c._storage & 0xFF80 == 0) else { return nil }
      return EncodedScalar(CodeUnit(c._storage & 0x7f))
    }
    else if _fastPath(FromEncoding.self == UTF8.self) {
      let c = _identityCast(content, to: UTF8.EncodedScalar.self)
      let first = c.first.unsafelyUnwrapped
      guard (first < 0x80) else { return nil }
      return EncodedScalar(CodeUnit(first))
    }
    return encode(FromEncoding.decode(content))
  }
}


----- Swift.(file).Parser.parseScalar(from:I)
extension Parser {
  public mutating func parseScalar<I : IteratorProtocol>(
    from input: inout I
  ) -> Unicode.ParseResult<Encoding.EncodedScalar>
  where I.Element == Encoding.CodeUnit {
    let n = input.next()
    if _fastPath(n != nil), let x = n {
      guard _fastPath(Int8(truncatingIfNeeded: x) >= 0)
      else { return .error(length: 1) }
      return .valid(Unicode.ASCII.EncodedScalar(x))
    }
    return .emptyInput
  }
}


----- Swift.(file).Iterator.next()
extension Iterator {
  public mutating func next() -> Element? {
    guard let b = _base.next() else { return nil }
    let result = (offset: _count, element: b)
    _count += 1
    return result
  }
}


----- Swift.(file).EnumeratedSequence.makeIterator()
extension EnumeratedSequence {
  public __consuming func makeIterator() -> Iterator {
    return Iterator(_base: _base.makeIterator())
  }
}


----- Swift.(file).AnyHashable.==infix(_:AnyHashable,_:AnyHashable)
extension AnyHashable {
  public static func == (lhs: AnyHashable, rhs: AnyHashable) -> Bool {
    return lhs._box._canonicalBox._isEqual(to: rhs._box._canonicalBox) ?? false
  }
}


----- Swift.(file).AnyHashable.hash(into:Hasher)
extension AnyHashable {
  public func hash(into hasher: inout Hasher) {
    _box._canonicalBox._hash(into: &hasher)
  }
}


----- Swift.(file).Array.init(repeating:Element,count:Int)
extension Array {
  public init(repeating repeatedValue: Element, count: Int) {
    var p: UnsafeMutablePointer<Element>
    (self, p) = Array._allocateUninitialized(count)
    for _ in 0..<count {
      p.initialize(to: repeatedValue)
      p += 1
    }
  }
}


----- Swift.(file).Array.reserveCapacity(_:Int)
extension Array {
  public mutating func reserveCapacity(_ minimumCapacity: Int) {
    if _buffer.requestUniqueMutableBackingBuffer(
      minimumCapacity: minimumCapacity) == nil {

      let newBuffer = _ContiguousArrayBuffer<Element>(
        _uninitializedCount: count, minimumCapacity: minimumCapacity)

      _buffer._copyContents(
        subRange: _buffer.indices,
        initializing: newBuffer.firstElementAddress)
      _buffer = _Buffer(
        _buffer: newBuffer, shiftedToStartIndex: _buffer.startIndex)
    }
    _internalInvariant(capacity >= minimumCapacity)
  }
}


----- Swift.(file).Array.append(_:Element)
extension Array {
  public mutating func append(_ newElement: __owned Element) {
    _makeUniqueAndReserveCapacityIfNotUnique()
    let oldCount = _getCount()
    _reserveCapacityAssumingUniqueBuffer(oldCount: oldCount)
    _appendElementAssumeUniqueAndCapacity(oldCount, newElement: newElement)
  }
}


----- Swift.(file).Array.append(contentsOf:S)
extension Array {
  public mutating func append<S: Sequence>(contentsOf newElements: __owned S)
    where S.Element == Element {

    let newElementsCount = newElements.underestimatedCount
    reserveCapacityForAppend(newElementsCount: newElementsCount)

    let oldCount = self.count
    let startNewElements = _buffer.firstElementAddress + oldCount
    let buf = UnsafeMutableBufferPointer(
                start: startNewElements,
                count: self.capacity - oldCount)

    let (remainder,writtenUpTo) = buf.initialize(from: newElements)

    // trap on underflow from the sequence's underestimate:
    let writtenCount = buf.distance(from: buf.startIndex, to: writtenUpTo)
    precondition(newElementsCount <= writtenCount,
      "newElements.underestimatedCount was an overestimate")
    // can't check for overflow as sequences can underestimate

    _buffer.count += writtenCount

    if writtenUpTo == buf.endIndex {
      // there may be elements that didn't fit in the existing buffer,
      // append them in slow sequence-only mode
      _buffer._arrayAppendSequence(IteratorSequence(remainder))
    }
  }
}


----- Swift.(file).Array.remove(at:Int)
extension Array {
  public mutating func remove(at index: Int) -> Element {
    precondition(index < endIndex, "Index out of range")
    precondition(index >= startIndex, "Index out of range")
    _makeUniqueAndReserveCapacityIfNotUnique()
    let newCount = _getCount() - 1
    let pointer = (_buffer.firstElementAddress + index)
    let result = pointer.move()
    pointer.moveInitialize(from: pointer + 1, count: newCount - index)
    _buffer.count = newCount
    return result
  }
}


----- Swift.(file).Array.insert(_:Element,at:Int)
extension Array {
  public mutating func insert(_ newElement: __owned Element, at i: Int) {
    _checkIndex(i)
    self.replaceSubrange(i..<i, with: CollectionOfOne(newElement))
  }
}


----- Swift.(file).Array.removeAll(keepingCapacity:Bool)
extension Array {
  public mutating func removeAll(keepingCapacity keepCapacity: Bool = false) {
    if !keepCapacity {
      _buffer = _Buffer()
    }
    else {
      self.replaceSubrange(indices, with: EmptyCollection())
    }
  }
}


----- Swift.(file).Array.init(_unsafeUninitializedCapacity:Int,initializingWith:(inout UnsafeMutableBufferPointer<Element>, inout Int) throws -> Void)
extension Array {
  public init(
    _unsafeUninitializedCapacity: Int,
    initializingWith initializer: (
      _ buffer: inout UnsafeMutableBufferPointer<Element>,
      _ initializedCount: inout Int) throws -> Void
  ) rethrows {
    var firstElementAddress: UnsafeMutablePointer<Element>
    (self, firstElementAddress) =
      Array._allocateUninitialized(_unsafeUninitializedCapacity)

    var initializedCount = 0
    defer {
      // Update self.count even if initializer throws an error.
      precondition(
        initializedCount <= _unsafeUninitializedCapacity,
        "Initialized count set to greater than specified capacity."
      )
      self._buffer.count = initializedCount
    }
    var buffer = UnsafeMutableBufferPointer<Element>(
      start: firstElementAddress, count: _unsafeUninitializedCapacity)
    try initializer(&buffer, &initializedCount)
  }
}


----- Swift.(file).Array.withUnsafeBufferPointer(_:(UnsafeBufferPointer<Element>) throws -> R)
extension Array {
  public func withUnsafeBufferPointer<R>(
    _ body: (UnsafeBufferPointer<Element>) throws -> R
  ) rethrows -> R {
    return try _buffer.withUnsafeBufferPointer(body)
  }
}


----- Swift.(file).Array.withUnsafeMutableBufferPointer(_:(inout UnsafeMutableBufferPointer<Element>) throws -> R)
extension Array {
  public mutating func withUnsafeMutableBufferPointer<R>(
    _ body: (inout UnsafeMutableBufferPointer<Element>) throws -> R
  ) rethrows -> R {
    let count = self.count
    // Ensure unique storage
    _buffer._outlinedMakeUniqueBuffer(bufferCount: count)

    // Ensure that body can't invalidate the storage or its bounds by
    // moving self into a temporary working array.
    // NOTE: The stack promotion optimization that keys of the
    // "array.withUnsafeMutableBufferPointer" semantics annotation relies on the
    // array buffer not being able to escape in the closure. It can do this
    // because we swap the array buffer in self with an empty buffer here. Any
    // escape via the address of self in the closure will therefore escape the
    // empty array.

    var work = Array()
    (work, self) = (self, work)

    // Create an UnsafeBufferPointer over work that we can pass to body
    let pointer = work._buffer.firstElementAddress
    var inoutBufferPointer = UnsafeMutableBufferPointer(
      start: pointer, count: count)

    // Put the working array back before returning.
    defer {
      precondition(
        inoutBufferPointer.baseAddress == pointer &&
        inoutBufferPointer.count == count,
        "Array withUnsafeMutableBufferPointer: replacing the buffer is not allowed")

      (work, self) = (self, work)
    }

    // Invoke the body.
    return try body(&inoutBufferPointer)
  }
}


----- Swift.(file).Array.replaceSubrange(_:Range<Int>,with:C)
extension Array {
  public mutating func replaceSubrange<C>(
    _ subrange: Range<Int>,
    with newElements: __owned C
  ) where C: Collection, C.Element == Element {
    precondition(subrange.lowerBound >= self._buffer.startIndex,
      "Array replace: subrange start is negative")

    precondition(subrange.upperBound <= _buffer.endIndex,
      "Array replace: subrange extends past the end")

    let oldCount = _buffer.count
    let eraseCount = subrange.count
    let insertCount = newElements.count
    let growth = insertCount - eraseCount

    if _buffer.requestUniqueMutableBackingBuffer(
      minimumCapacity: oldCount + growth) != nil {

      _buffer.replaceSubrange(
        subrange, with: insertCount, elementsOf: newElements)
    } else {
      _buffer._arrayOutOfPlaceReplace(subrange, with: newElements, count: insertCount)
    }
  }
}


----- Swift.(file).Array.==infix(_:Array<Element>,_:Array<Element>)
extension Array {
  public static func ==(lhs: Array<Element>, rhs: Array<Element>) -> Bool {
    let lhsCount = lhs.count
    if lhsCount != rhs.count {
      return false
    }

    // Test referential equality.
    if lhsCount == 0 || lhs._buffer.identity == rhs._buffer.identity {
      return true
    }


    _internalInvariant(lhs.startIndex == 0 && rhs.startIndex == 0)
    _internalInvariant(lhs.endIndex == lhsCount && rhs.endIndex == lhsCount)

    // We know that lhs.count == rhs.count, compare element wise.
    for idx in 0..<lhsCount {
      if lhs[idx] != rhs[idx] {
        return false
      }
    }

    return true
  }
}


----- Swift.(file).Array.hash(into:Hasher)
extension Array {
  public func hash(into hasher: inout Hasher) {
    hasher.combine(count) // discriminator
    for element in self {
      hasher.combine(element)
    }
  }
}


----- Swift.(file).ArraySlice.init(repeating:Element,count:Int)
extension ArraySlice {
  public init(repeating repeatedValue: Element, count: Int) {
    var p: UnsafeMutablePointer<Element>
    (self, p) = ArraySlice._allocateUninitialized(count)
    for _ in 0..<count {
      p.initialize(to: repeatedValue)
      p += 1
    }
  }
}


----- Swift.(file).ArraySlice.reserveCapacity(_:Int)
extension ArraySlice {
  public mutating func reserveCapacity(_ minimumCapacity: Int) {
    if _buffer.requestUniqueMutableBackingBuffer(
      minimumCapacity: minimumCapacity) == nil {

      let newBuffer = _ContiguousArrayBuffer<Element>(
        _uninitializedCount: count, minimumCapacity: minimumCapacity)

      _buffer._copyContents(
        subRange: _buffer.indices,
        initializing: newBuffer.firstElementAddress)
      _buffer = _Buffer(
        _buffer: newBuffer, shiftedToStartIndex: _buffer.startIndex)
    }
    _internalInvariant(capacity >= minimumCapacity)
  }
}


----- Swift.(file).ArraySlice.append(_:Element)
extension ArraySlice {
  public mutating func append(_ newElement: __owned Element) {
    _makeUniqueAndReserveCapacityIfNotUnique()
    let oldCount = _getCount()
    _reserveCapacityAssumingUniqueBuffer(oldCount: oldCount)
    _appendElementAssumeUniqueAndCapacity(oldCount, newElement: newElement)
  }
}


----- Swift.(file).ArraySlice.append(contentsOf:S)
extension ArraySlice {
  public mutating func append<S: Sequence>(contentsOf newElements: __owned S)
    where S.Element == Element {

    let newElementsCount = newElements.underestimatedCount
    reserveCapacityForAppend(newElementsCount: newElementsCount)

    let oldCount = self.count
    let startNewElements = _buffer.firstElementAddress + oldCount
    let buf = UnsafeMutableBufferPointer(
                start: startNewElements,
                count: self.capacity - oldCount)

    let (remainder,writtenUpTo) = buf.initialize(from: newElements)

    // trap on underflow from the sequence's underestimate:
    let writtenCount = buf.distance(from: buf.startIndex, to: writtenUpTo)
    precondition(newElementsCount <= writtenCount,
      "newElements.underestimatedCount was an overestimate")
    // can't check for overflow as sequences can underestimate

    _buffer.count += writtenCount

    if writtenUpTo == buf.endIndex {
      // there may be elements that didn't fit in the existing buffer,
      // append them in slow sequence-only mode
      _buffer._arrayAppendSequence(IteratorSequence(remainder))
    }
  }
}


----- Swift.(file).ArraySlice.insert(_:Element,at:Int)
extension ArraySlice {
  public mutating func insert(_ newElement: __owned Element, at i: Int) {
    _checkIndex(i)
    self.replaceSubrange(i..<i, with: CollectionOfOne(newElement))
  }
}


----- Swift.(file).ArraySlice.removeAll(keepingCapacity:Bool)
extension ArraySlice {
  public mutating func removeAll(keepingCapacity keepCapacity: Bool = false) {
    if !keepCapacity {
      _buffer = _Buffer()
    }
    else {
      self.replaceSubrange(indices, with: EmptyCollection())
    }
  }
}


----- Swift.(file).ArraySlice.withUnsafeBufferPointer(_:(UnsafeBufferPointer<Element>) throws -> R)
extension ArraySlice {
  public func withUnsafeBufferPointer<R>(
    _ body: (UnsafeBufferPointer<Element>) throws -> R
  ) rethrows -> R {
    return try _buffer.withUnsafeBufferPointer(body)
  }
}


----- Swift.(file).ArraySlice.withUnsafeMutableBufferPointer(_:(inout UnsafeMutableBufferPointer<Element>) throws -> R)
extension ArraySlice {
  public mutating func withUnsafeMutableBufferPointer<R>(
    _ body: (inout UnsafeMutableBufferPointer<Element>) throws -> R
  ) rethrows -> R {
    let count = self.count
    // Ensure unique storage
    _buffer._outlinedMakeUniqueBuffer(bufferCount: count)

    // Ensure that body can't invalidate the storage or its bounds by
    // moving self into a temporary working array.
    // NOTE: The stack promotion optimization that keys of the
    // "array.withUnsafeMutableBufferPointer" semantics annotation relies on the
    // array buffer not being able to escape in the closure. It can do this
    // because we swap the array buffer in self with an empty buffer here. Any
    // escape via the address of self in the closure will therefore escape the
    // empty array.

    var work = ArraySlice()
    (work, self) = (self, work)

    // Create an UnsafeBufferPointer over work that we can pass to body
    let pointer = work._buffer.firstElementAddress
    var inoutBufferPointer = UnsafeMutableBufferPointer(
      start: pointer, count: count)

    // Put the working array back before returning.
    defer {
      precondition(
        inoutBufferPointer.baseAddress == pointer &&
        inoutBufferPointer.count == count,
        "ArraySlice withUnsafeMutableBufferPointer: replacing the buffer is not allowed")

      (work, self) = (self, work)
    }

    // Invoke the body.
    return try body(&inoutBufferPointer)
  }
}


----- Swift.(file).ArraySlice.replaceSubrange(_:Range<Int>,with:C)
extension ArraySlice {
  public mutating func replaceSubrange<C>(
    _ subrange: Range<Int>,
    with newElements: __owned C
  ) where C: Collection, C.Element == Element {
    precondition(subrange.lowerBound >= _buffer.startIndex,
      "ArraySlice replace: subrange start is before the startIndex")

    precondition(subrange.upperBound <= _buffer.endIndex,
      "ArraySlice replace: subrange extends past the end")

    let oldCount = _buffer.count
    let eraseCount = subrange.count
    let insertCount = newElements.count
    let growth = insertCount - eraseCount

    if _buffer.requestUniqueMutableBackingBuffer(
      minimumCapacity: oldCount + growth) != nil {

      _buffer.replaceSubrange(
        subrange, with: insertCount, elementsOf: newElements)
    } else {
      _buffer._arrayOutOfPlaceReplace(subrange, with: newElements, count: insertCount)
    }
  }
}


----- Swift.(file).ArraySlice.==infix(_:ArraySlice<Element>,_:ArraySlice<Element>)
extension ArraySlice {
  public static func ==(lhs: ArraySlice<Element>, rhs: ArraySlice<Element>) -> Bool {
    let lhsCount = lhs.count
    if lhsCount != rhs.count {
      return false
    }

    // Test referential equality.
    if lhsCount == 0 || lhs._buffer.identity == rhs._buffer.identity {
      return true
    }


    var streamLHS = lhs.makeIterator()
    var streamRHS = rhs.makeIterator()

    var nextLHS = streamLHS.next()
    while nextLHS != nil {
      let nextRHS = streamRHS.next()
      if nextLHS != nextRHS {
        return false
      }
      nextLHS = streamLHS.next()
    }


    return true
  }
}


----- Swift.(file).ArraySlice.hash(into:Hasher)
extension ArraySlice {
  public func hash(into hasher: inout Hasher) {
    hasher.combine(count) // discriminator
    for element in self {
      hasher.combine(element)
    }
  }
}


----- Swift.(file)._ArrayProtocol.filter(_:(Self.Element) throws -> Bool)
extension _ArrayProtocol {
  public __consuming func filter(
    _ isIncluded: (Element) throws -> Bool
  ) rethrows -> [Element] {
    return try _filter(isIncluded)
  }
}


----- Swift.(file).assert(_:() -> Bool,_:() -> String,file:StaticString,line:UInt)
public func assert(
  _ condition: @autoclosure () -> Bool,
  _ message: @autoclosure () -> String = String(),
  file: StaticString = #file, line: UInt = #line
) {
  // Only assert in debug mode.
  if _isDebugAssertConfiguration() {
    if !_branchHint(condition(), expected: true) {
      _assertionFailure("Assertion failed", message(), file: file, line: line,
        flags: _fatalErrorFlags())
    }
  }
}


----- Swift.(file).precondition(_:() -> Bool,_:() -> String,file:StaticString,line:UInt)
public func precondition(
  _ condition: @autoclosure () -> Bool,
  _ message: @autoclosure () -> String = String(),
  file: StaticString = #file, line: UInt = #line
) {
  // Only check in debug and release mode. In release mode just trap.
  if _isDebugAssertConfiguration() {
    if !_branchHint(condition(), expected: true) {
      _assertionFailure("Precondition failed", message(), file: file, line: line,
        flags: _fatalErrorFlags())
    }
  } else if _isReleaseAssertConfiguration() {
    let error = !condition()
    Builtin.condfail(error._value)
  }
}


----- Swift.(file).assertionFailure(_:() -> String,file:StaticString,line:UInt)
public func assertionFailure(
  _ message: @autoclosure () -> String = String(),
  file: StaticString = #file, line: UInt = #line
) {
  if _isDebugAssertConfiguration() {
    _assertionFailure("Fatal error", message(), file: file, line: line,
      flags: _fatalErrorFlags())
  }
  else if _isFastAssertConfiguration() {
    _conditionallyUnreachable()
  }
}


----- Swift.(file).preconditionFailure(_:() -> String,file:StaticString,line:UInt)
public func preconditionFailure(
  _ message: @autoclosure () -> String = String(),
  file: StaticString = #file, line: UInt = #line
) -> Never {
  // Only check in debug and release mode.  In release mode just trap.
  if _isDebugAssertConfiguration() {
    _assertionFailure("Fatal error", message(), file: file, line: line,
      flags: _fatalErrorFlags())
  } else if _isReleaseAssertConfiguration() {
    Builtin.int_trap()
  }
  _conditionallyUnreachable()
}


----- Swift.(file).fatalError(_:() -> String,file:StaticString,line:UInt)
public func fatalError(
  _ message: @autoclosure () -> String = String(),
  file: StaticString = #file, line: UInt = #line
) -> Never {
  _assertionFailure("Fatal error", message(), file: file, line: line,
    flags: _fatalErrorFlags())
}


----- Swift.(file).BidirectionalCollection.index(_:Self.Index,offsetBy:Int)
extension BidirectionalCollection {
  public func index(_ i: Index, offsetBy distance: Int) -> Index {
    return _index(i, offsetBy: distance)
  }
}


----- Swift.(file).BidirectionalCollection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)
extension BidirectionalCollection {
  public func index(
    _ i: Index, offsetBy distance: Int, limitedBy limit: Index
  ) -> Index? {
    return _index(i, offsetBy: distance, limitedBy: limit)
  }
}


----- Swift.(file).BidirectionalCollection.distance(from:Self.Index,to:Self.Index)
extension BidirectionalCollection {
  public func distance(from start: Index, to end: Index) -> Int {
    return _distance(from: start, to: end)
  }
}


----- Swift.(file).BidirectionalCollection.popLast()
extension BidirectionalCollection {
  public mutating func popLast() -> Element? {
    guard !isEmpty else { return nil }
    let element = last!
    self = self[startIndex..<index(before: endIndex)]
    return element
  }
}


----- Swift.(file).BidirectionalCollection.removeLast()
extension BidirectionalCollection {
  public mutating func removeLast() -> Element {
    let element = last!
    self = self[startIndex..<index(before: endIndex)]
    return element
  }
}


----- Swift.(file).BidirectionalCollection.removeLast(_:Int)
extension BidirectionalCollection {
  public mutating func removeLast(_ k: Int) {
    if k == 0 { return }
    precondition(k >= 0, "Number of elements to remove should be non-negative")
    precondition(count >= k,
      "Can't remove more items from a collection than it contains")
    self = self[startIndex..<index(endIndex, offsetBy: -k)]
  }
}


----- Swift.(file).Bool.==infix(_:Bool,_:Bool)
extension Bool {
  public static func == (lhs: Bool, rhs: Bool) -> Bool {
    return Bool(Builtin.cmp_eq_Int1(lhs._value, rhs._value))
  }
}


----- Swift.(file).Bool.!prefix(_:Bool)
extension Bool {
  public static prefix func ! (a: Bool) -> Bool {
    return Bool(Builtin.xor_Int1(a._value, true._value))
  }
}


----- Swift.(file).unsafeBitCast(_:T,to:U.Type)
public func unsafeBitCast<T, U>(_ x: T, to type: U.Type) -> U {
  precondition(MemoryLayout<T>.size == MemoryLayout<U>.size,
    "Can't unsafeBitCast between types of different sizes")
  return Builtin.reinterpretCast(x)
}


----- Swift.(file).==infix(_:Any.Type?,_:Any.Type?)
public func == (t0: Any.Type?, t1: Any.Type?) -> Bool {
  switch (t0, t1) {
  case (.none, .none): return true
  case let (.some(ty0), .some(ty1)):
    return Bool(Builtin.is_same_metatype(ty0, ty1))
  default: return false
  }
}


----- Swift.(file).unsafeDowncast(_:AnyObject,to:T.Type)
public func unsafeDowncast<T : AnyObject>(_ x: AnyObject, to type: T.Type) -> T {
  _debugPrecondition(x is T, "invalid unsafeDowncast")
  return Builtin.castReference(x)
}


----- Swift.(file).type(of:T)
public func type<T, Metatype>(of value: T) -> Metatype {
  // This implementation is never used, since calls to `Swift.type(of:)` are
  // resolved as a special case by the type checker.
  Builtin.staticReport(_trueAfterDiagnostics(), true._value,
    ("internal consistency error: 'type(of:)' operation failed to resolve"
     as StaticString).utf8Start._rawValue)
  Builtin.unreachable()
}


----- Swift.(file).withoutActuallyEscaping(_:ClosureType,do:(ClosureType) throws -> ResultType)
public func withoutActuallyEscaping<ClosureType, ResultType>(
  _ closure: ClosureType,
  do body: (_ escapingClosure: ClosureType) throws -> ResultType
) rethrows -> ResultType {
  // This implementation is never used, since calls to
  // `Swift.withoutActuallyEscaping(_:do:)` are resolved as a special case by
  // the type checker.
  Builtin.staticReport(_trueAfterDiagnostics(), true._value,
    ("internal consistency error: 'withoutActuallyEscaping(_:do:)' operation failed to resolve"
     as StaticString).utf8Start._rawValue)
  Builtin.unreachable()
}


----- Swift.(file).String.decodeCString(_:UnsafePointer<Encoding.CodeUnit>?,as:Encoding.Type,repairingInvalidCodeUnits:Bool)
extension String {
  public static func decodeCString<Encoding : _UnicodeEncoding>(
    _ cString: UnsafePointer<Encoding.CodeUnit>?,
    as encoding: Encoding.Type,
    repairingInvalidCodeUnits isRepairing: Bool = true
  ) -> (result: String, repairsMade: Bool)? {
    guard let cPtr = cString else { return nil }

    if _fastPath(encoding == Unicode.UTF8.self) {
      let ptr = UnsafeRawPointer(cPtr).assumingMemoryBound(to: UInt8.self)
      let len = UTF8._nullCodeUnitOffset(in: ptr)
      let codeUnits = UnsafeBufferPointer(start: ptr, count: len)
      if isRepairing {
        return String._fromUTF8Repairing(codeUnits)
      } else {
        guard let str = String._tryFromUTF8(codeUnits) else { return nil }
        return (str, false)
      }
    }

    var end = cPtr
    while end.pointee != 0 { end += 1 }
    let len = end - cPtr
    let codeUnits = UnsafeBufferPointer(start: cPtr, count: len)
    return String._fromCodeUnits(
      codeUnits, encoding: encoding, repair: isRepairing)
  }
}


----- Swift.(file).OpaquePointer.==infix(_:OpaquePointer,_:OpaquePointer)
extension OpaquePointer {
  public static func == (lhs: OpaquePointer, rhs: OpaquePointer) -> Bool {
    return Bool(Builtin.cmp_eq_RawPointer(lhs._rawValue, rhs._rawValue))
  }
}


----- Swift.(file).OpaquePointer.hash(into:Hasher)
extension OpaquePointer {
  public func hash(into hasher: inout Hasher) {
    hasher.combine(Int(Builtin.ptrtoint_Word(_rawValue)))
  }
}


----- Swift.(file).Character.==infix(_:Character,_:Character)
extension Character {
  public static func == (lhs: Character, rhs: Character) -> Bool {
    return lhs._str == rhs._str
  }
}


----- Swift.(file).Character.<infix(_:Character,_:Character)
extension Character {
  public static func < (lhs: Character, rhs: Character) -> Bool {
    return lhs._str < rhs._str
  }
}


----- Swift.(file).Character.hash(into:Hasher)
extension Character {
  public func hash(into hasher: inout Hasher) {
    _str.hash(into: &hasher)
  }
}


----- Swift.(file).Index.==infix(_:ClosedRange<Bound>.Index,_:ClosedRange<Bound>.Index)
extension Index {
  public static func == (
    lhs: ClosedRange<Bound>.Index,
    rhs: ClosedRange<Bound>.Index
  ) -> Bool {
    switch (lhs, rhs) {
    case (.inRange(let l), .inRange(let r)):
      return l == r
    case (.pastEnd, .pastEnd):
      return true
    default:
      return false
    }
  }
}


----- Swift.(file).Index.<infix(_:ClosedRange<Bound>.Index,_:ClosedRange<Bound>.Index)
extension Index {
  public static func < (
    lhs: ClosedRange<Bound>.Index,
    rhs: ClosedRange<Bound>.Index
  ) -> Bool {
    switch (lhs, rhs) {
    case (.inRange(let l), .inRange(let r)):
      return l < r
    case (.inRange, .pastEnd):
      return true
    default:
      return false
    }
  }
}


----- Swift.(file).Index.hash(into:Hasher)
extension Index {
  public func hash(into hasher: inout Hasher) {
    switch self {
    case .inRange(let value):
      hasher.combine(0 as Int8)
      hasher.combine(value)
    case .pastEnd:
      hasher.combine(1 as Int8)
    }
  }
}


----- Swift.(file).ClosedRange.index(after:ClosedRange<Bound>.Index)
extension ClosedRange {
  public func index(after i: Index) -> Index {
    switch i {
    case .inRange(let x):
      return x == upperBound
        ? .pastEnd
        : .inRange(x.advanced(by: 1))
    case .pastEnd:
      _preconditionFailure("Incrementing past end index")
    }
  }
}


----- Swift.(file).ClosedRange.index(before:ClosedRange<Bound>.Index)
extension ClosedRange {
  public func index(before i: Index) -> Index {
    switch i {
    case .inRange(let x):
      precondition(x > lowerBound, "Incrementing past start index")
      return .inRange(x.advanced(by: -1))
    case .pastEnd:
      precondition(upperBound >= lowerBound, "Incrementing past start index")
      return .inRange(upperBound)
    }
  }
}


----- Swift.(file).ClosedRange.index(_:ClosedRange<Bound>.Index,offsetBy:Int)
extension ClosedRange {
  public func index(_ i: Index, offsetBy distance: Int) -> Index {
    switch i {
    case .inRange(let x):
      let d = x.distance(to: upperBound)
      if distance <= d {
        let newPosition = x.advanced(by: numericCast(distance))
        precondition(newPosition >= lowerBound,
          "Advancing past start index")
        return .inRange(newPosition)
      }
      if d - -1 == distance { return .pastEnd }
      _preconditionFailure("Advancing past end index")
    case .pastEnd:
      if distance == 0 {
        return i
      }
      if distance < 0 {
        return index(.inRange(upperBound), offsetBy: numericCast(distance + 1))
      }
      _preconditionFailure("Advancing past end index")
    }
  }
}


----- Swift.(file).ClosedRange.distance(from:ClosedRange<Bound>.Index,to:ClosedRange<Bound>.Index)
extension ClosedRange {
  public func distance(from start: Index, to end: Index) -> Int {
    switch (start, end) {
    case let (.inRange(left), .inRange(right)):
      // in range <--> in range
      return numericCast(left.distance(to: right))
    case let (.inRange(left), .pastEnd):
      // in range --> end
      return numericCast(1 + left.distance(to: upperBound))
    case let (.pastEnd, .inRange(right)):
      // in range <-- end
      return numericCast(upperBound.distance(to: right) - 1)
    case (.pastEnd, .pastEnd):
      // end <--> end
      return 0
    }
  }
}


----- Swift.(file).ClosedRange.hash(into:Hasher)
extension ClosedRange {
  public func hash(into hasher: inout Hasher) {
    hasher.combine(lowerBound)
    hasher.combine(upperBound)
  }
}


----- Swift.(file).IndexingIterator.next()
extension IndexingIterator {
  public mutating func next() -> Elements.Element? {
    if _position == _elements.endIndex { return nil }
    let element = _elements[_position]
    _elements.formIndex(after: &_position)
    return element
  }
}


----- Swift.(file).Collection.index(_:Self.Index,offsetBy:Int)
extension Collection {
  public func index(_ i: Index, offsetBy distance: Int) -> Index {
    return self._advanceForward(i, by: distance)
  }
}


----- Swift.(file).Collection.index(_:Self.Index,offsetBy:Int,limitedBy:Self.Index)
extension Collection {
  public func index(
    _ i: Index, offsetBy distance: Int, limitedBy limit: Index
  ) -> Index? {
    return self._advanceForward(i, by: distance, limitedBy: limit)
  }
}


----- Swift.(file).Collection.popFirst()
extension Collection {
  public mutating func popFirst() -> Element? {
    // TODO: swift-3-indexing-model - review the following
    guard !isEmpty else { return nil }
    let element = first!
    self = self[index(after: startIndex)..<endIndex]
    return element
  }
}


----- Swift.(file).Collection.map(_:(Self.Element) throws -> T)
extension Collection {
  public func map<T>(
    _ transform: (Element) throws -> T
  ) rethrows -> [T] {
    // TODO: swift-3-indexing-model - review the following
    let n = self.count
    if n == 0 {
      return []
    }

    var result = ContiguousArray<T>()
    result.reserveCapacity(n)

    var i = self.startIndex

    for _ in 0..<n {
      result.append(try transform(self[i]))
      formIndex(after: &i)
    }

    _expectEnd(of: self, is: i)
    return Array(result)
  }
}


----- Swift.(file).Collection.split(separator:Self.Element,maxSplits:Int,omittingEmptySubsequences:Bool)
extension Collection {
  public __consuming func split(
    separator: Element,
    maxSplits: Int = Int.max,
    omittingEmptySubsequences: Bool = true
  ) -> [SubSequence] {
    // TODO: swift-3-indexing-model - review the following
    return split(
      maxSplits: maxSplits,
      omittingEmptySubsequences: omittingEmptySubsequences,
      whereSeparator: { $0 == separator })
  }
}


----- Swift.(file).Collection.removeFirst()
extension Collection {
  public mutating func removeFirst() -> Element {
    // TODO: swift-3-indexing-model - review the following
    precondition(!isEmpty, "Can't remove items from an empty collection")
    let element = first!
    self = self[index(after: startIndex)..<endIndex]
    return element
  }
}


----- Swift.(file).Collection.removeFirst(_:Int)
extension Collection {
  public mutating func removeFirst(_ k: Int) {
    if k == 0 { return }
    precondition(k >= 0, "Number of elements to remove should be non-negative")
    precondition(count >= k,
      "Can't remove more items from a collection than it contains")
    self = self[index(startIndex, offsetBy: k)..<endIndex]
  }
}


----- Swift.(file).Collection.firstIndex(of:Self.Element)
extension Collection {
  public func firstIndex(of element: Element) -> Index? {
    if let result = _customIndexOfEquatableElement(element) {
      return result
    }

    var i = self.startIndex
    while i != self.endIndex {
      if self[i] == element {
        return i
      }
      self.formIndex(after: &i)
    }
    return nil
  }
}


----- Swift.(file).BidirectionalCollection.lastIndex(of:Self.Element)
extension BidirectionalCollection {
  public func lastIndex(of element: Element) -> Index? {
    if let result = _customLastIndexOfEquatableElement(element) {
      return result
    }
    return lastIndex(where: { $0 == element })
  }
}


----- Swift.(file).MutableCollection.partition(by:(Self.Element) throws -> Bool)
extension MutableCollection {
  public mutating func partition(
    by belongsInSecondPartition: (Element) throws -> Bool
  ) rethrows -> Index {
    return try _halfStablePartition(isSuffixElement: belongsInSecondPartition)
  }
}


----- Swift.(file).MutableCollection.partition(by:(Self.Element) throws -> Bool)
extension MutableCollection {
  public mutating func partition(
    by belongsInSecondPartition: (Element) throws -> Bool
  ) rethrows -> Index {
    let maybeOffset = try _withUnsafeMutableBufferPointerIfSupported {
      (bufferPointer) -> Int in
      let unsafeBufferPivot = try bufferPointer._partitionImpl(
        by: belongsInSecondPartition)
      return unsafeBufferPivot - bufferPointer.startIndex
    }
    if let offset = maybeOffset {
      return index(startIndex, offsetBy: offset)
    } else {
      return try _partitionImpl(by: belongsInSecondPartition)
    }
  }
}


----- Swift.(file).MutableCollection.shuffle()
extension MutableCollection {
  public mutating func shuffle() {
    var g = SystemRandomNumberGenerator()
    shuffle(using: &g)
  }
}


----- Swift.(file).RawRepresentable.hash(into:Hasher)
extension RawRepresentable {
  public func hash(into hasher: inout Hasher) {
    hasher.combine(rawValue)
  }
}


----- Swift.(file).ContiguousArray.init(repeating:Element,count:Int)
extension ContiguousArray {
  public init(repeating repeatedValue: Element, count: Int) {
    var p: UnsafeMutablePointer<Element>
    (self, p) = ContiguousArray._allocateUninitialized(count)
    for _ in 0..<count {
      p.initialize(to: repeatedValue)
      p += 1
    }
  }
}


----- Swift.(file).ContiguousArray.reserveCapacity(_:Int)
extension ContiguousArray {
  public mutating func reserveCapacity(_ minimumCapacity: Int) {
    if _buffer.requestUniqueMutableBackingBuffer(
      minimumCapacity: minimumCapacity) == nil {

      let newBuffer = _ContiguousArrayBuffer<Element>(
        _uninitializedCount: count, minimumCapacity: minimumCapacity)

      _buffer._copyContents(
        subRange: _buffer.indices,
        initializing: newBuffer.firstElementAddress)
      _buffer = _Buffer(
        _buffer: newBuffer, shiftedToStartIndex: _buffer.startIndex)
    }
    _internalInvariant(capacity >= minimumCapacity)
  }
}


----- Swift.(file).ContiguousArray.append(_:Element)
extension ContiguousArray {
  public mutating func append(_ newElement: __owned Element) {
    _makeUniqueAndReserveCapacityIfNotUnique()
    let oldCount = _getCount()
    _reserveCapacityAssumingUniqueBuffer(oldCount: oldCount)
    _appendElementAssumeUniqueAndCapacity(oldCount, newElement: newElement)
  }
}


----- Swift.(file).ContiguousArray.append(contentsOf:S)
extension ContiguousArray {
  public mutating func append<S: Sequence>(contentsOf newElements: __owned S)
    where S.Element == Element {

    let newElementsCount = newElements.underestimatedCount
    reserveCapacityForAppend(newElementsCount: newElementsCount)

    let oldCount = self.count
    let startNewElements = _buffer.firstElementAddress + oldCount
    let buf = UnsafeMutableBufferPointer(
                start: startNewElements,
                count: self.capacity - oldCount)

    let (remainder,writtenUpTo) = buf.initialize(from: newElements)

    // trap on underflow from the sequence's underestimate:
    let writtenCount = buf.distance(from: buf.startIndex, to: writtenUpTo)
    precondition(newElementsCount <= writtenCount,
      "newElements.underestimatedCount was an overestimate")
    // can't check for overflow as sequences can underestimate

    _buffer.count += writtenCount

    if writtenUpTo == buf.endIndex {
      // there may be elements that didn't fit in the existing buffer,
      // append them in slow sequence-only mode
      _buffer._arrayAppendSequence(IteratorSequence(remainder))
    }
  }
}


----- Swift.(file).ContiguousArray.remove(at:Int)
extension ContiguousArray {
  public mutating func remove(at index: Int) -> Element {
    precondition(index < endIndex, "Index out of range")
    precondition(index >= startIndex, "Index out of range")
    _makeUniqueAndReserveCapacityIfNotUnique()
    let newCount = _getCount() - 1
    let pointer = (_buffer.firstElementAddress + index)
    let result = pointer.move()
    pointer.moveInitialize(from: pointer + 1, count: newCount - index)
    _buffer.count = newCount
    return result
  }
}


----- Swift.(file).ContiguousArray.insert(_:Element,at:Int)
extension ContiguousArray {
  public mutating func insert(_ newElement: __owned Element, at i: Int) {
    _checkIndex(i)
    self.replaceSubrange(i..<i, with: CollectionOfOne(newElement))
  }
}


----- Swift.(file).ContiguousArray.removeAll(keepingCapacity:Bool)
extension ContiguousArray {
  public mutating func removeAll(keepingCapacity keepCapacity: Bool = false) {
    if !keepCapacity {
      _buffer = _Buffer()
    }
    else {
      self.replaceSubrange(indices, with: EmptyCollection())
    }
  }
}


----- Swift.(file).ContiguousArray.withUnsafeBufferPointer(_:(UnsafeBufferPointer<Element>) throws -> R)
extension ContiguousArray {
  public func withUnsafeBufferPointer<R>(
    _ body: (UnsafeBufferPointer<Element>) throws -> R
  ) rethrows -> R {
    return try _buffer.withUnsafeBufferPointer(body)
  }
}


----- Swift.(file).ContiguousArray.withUnsafeMutableBufferPointer(_:(inout UnsafeMutableBufferPointer<Element>) throws -> R)
extension ContiguousArray {
  public mutating func withUnsafeMutableBufferPointer<R>(
    _ body: (inout UnsafeMutableBufferPointer<Element>) throws -> R
  ) rethrows -> R {
    let count = self.count
    // Ensure unique storage
    _buffer._outlinedMakeUniqueBuffer(bufferCount: count)

    // Ensure that body can't invalidate the storage or its bounds by
    // moving self into a temporary working array.
    // NOTE: The stack promotion optimization that keys of the
    // "array.withUnsafeMutableBufferPointer" semantics annotation relies on the
    // array buffer not being able to escape in the closure. It can do this
    // because we swap the array buffer in self with an empty buffer here. Any
    // escape via the address of self in the closure will therefore escape the
    // empty array.

    var work = ContiguousArray()
    (work, self) = (self, work)

    // Create an UnsafeBufferPointer over work that we can pass to body
    let pointer = work._buffer.firstElementAddress
    var inoutBufferPointer = UnsafeMutableBufferPointer(
      start: pointer, count: count)

    // Put the working array back before returning.
    defer {
      precondition(
        inoutBufferPointer.baseAddress == pointer &&
        inoutBufferPointer.count == count,
        "ContiguousArray withUnsafeMutableBufferPointer: replacing the buffer is not allowed")

      (work, self) = (self, work)
    }

    // Invoke the body.
    return try body(&inoutBufferPointer)
  }
}


----- Swift.(file).ContiguousArray.replaceSubrange(_:Range<Int>,with:C)
extension ContiguousArray {
  public mutating func replaceSubrange<C>(
    _ subrange: Range<Int>,
    with newElements: __owned C
  ) where C: Collection, C.Element == Element {
    precondition(subrange.lowerBound >= self._buffer.startIndex,
      "ContiguousArray replace: subrange start is negative")

    precondition(subrange.upperBound <= _buffer.endIndex,
      "ContiguousArray replace: subrange extends past the end")

    let oldCount = _buffer.count
    let eraseCount = subrange.count
    let insertCount = newElements.count
    let growth = insertCount - eraseCount

    if _buffer.requestUniqueMutableBackingBuffer(
      minimumCapacity: oldCount + growth) != nil {

      _buffer.replaceSubrange(
        subrange, with: insertCount, elementsOf: newElements)
    } else {
      _buffer._arrayOutOfPlaceReplace(subrange, with: newElements, count: insertCount)
    }
  }
}


----- Swift.(file).ContiguousArray.==infix(_:ContiguousArray<Element>,_:ContiguousArray<Element>)
extension ContiguousArray {
  public static func ==(lhs: ContiguousArray<Element>, rhs: ContiguousArray<Element>) -> Bool {
    let lhsCount = lhs.count
    if lhsCount != rhs.count {
      return false
    }

    // Test referential equality.
    if lhsCount == 0 || lhs._buffer.identity == rhs._buffer.identity {
      return true
    }


    _internalInvariant(lhs.startIndex == 0 && rhs.startIndex == 0)
    _internalInvariant(lhs.endIndex == lhsCount && rhs.endIndex == lhsCount)

    // We know that lhs.count == rhs.count, compare element wise.
    for idx in 0..<lhsCount {
      if lhs[idx] != rhs[idx] {
        return false
      }
    }

    return true
  }
}


----- Swift.(file).ContiguousArray.hash(into:Hasher)
extension ContiguousArray {
  public func hash(into hasher: inout Hasher) {
    hasher.combine(count) // discriminator
    for element in self {
      hasher.combine(element)
    }
  }
}


----- Swift.(file).Iterator.next()
extension Iterator {
  public mutating func next() -> Element? {
    // Once the predicate has failed for the first time, the base iterator
    // can be used for the rest of the elements.
    if _predicateHasFailed {
      return _base.next()
    }

    // Retrieve and discard elements from the base iterator until one fails
    // the predicate.
    while let nextElement = _base.next() {
      if !_predicate(nextElement) {
        _predicateHasFailed = true
        return nextElement
      }
    }
    return nil
  }
}


----- Swift.(file).LazyDropWhileSequence.makeIterator()
extension LazyDropWhileSequence {
  public __consuming func makeIterator() -> Iterator {
    return Iterator(_base: _base.makeIterator(), predicate: _predicate)
  }
}


----- Swift.(file).LazySequenceProtocol.drop(while:(Self.Elements.Element) -> Bool)
extension LazySequenceProtocol {
  public __consuming func drop(
    while predicate: @escaping (Elements.Element) -> Bool
  ) -> LazyDropWhileSequence<Self.Elements> {
    return LazyDropWhileSequence(_base: self.elements, predicate: predicate)
  }
}


----- Swift.(file).LazyDropWhileSequence.index(after:LazyDropWhileSequence<Base>.Index)
extension LazyDropWhileSequence {
  public func index(after i: Index) -> Index {
    precondition(i < _base.endIndex, "Can't advance past endIndex")
    return _base.index(after: i)
  }
}


----- Swift.(file).LazyDropWhileSequence.index(before:LazyDropWhileSequence<Base>.Index)
extension LazyDropWhileSequence {
  public func index(before i: Index) -> Index {
    precondition(i > startIndex, "Can't move before startIndex")
    return _base.index(before: i)
  }
}


----- Swift.(file).dump(_:T,to:TargetStream,name:String?,indent:Int,maxDepth:Int,maxItems:Int)
public func dump<T, TargetStream : TextOutputStream>(
  _ value: T,
  to target: inout TargetStream,
  name: String? = nil,
  indent: Int = 0,
  maxDepth: Int = .max,
  maxItems: Int = .max
) -> T {
  var maxItemCounter = maxItems
  var visitedItems = [ObjectIdentifier : Int]()
  target._lock()
  defer { target._unlock() }
  _dump_unlocked(
    value,
    to: &target,
    name: name,
    indent: indent,
    maxDepth: maxDepth,
    maxItemCounter: &maxItemCounter,
    visitedItems: &visitedItems)
  return value
}


----- Swift.(file).dump(_:T,name:String?,indent:Int,maxDepth:Int,maxItems:Int)
public func dump<T>(
  _ value: T,
  name: String? = nil,
  indent: Int = 0,
  maxDepth: Int = .max,
  maxItems: Int = .max
) -> T {
  var stdoutStream = _Stdout()
  return dump(
    value,
    to: &stdoutStream,
    name: name,
    indent: indent,
    maxDepth: maxDepth,
    maxItems: maxItems)
}


----- Swift.(file).Iterator.next()
extension Iterator {
  public mutating func next() -> Element? {
    return nil
  }
}


----- Swift.(file).EmptyCollection.index(after:EmptyCollection<Element>.Index)
extension EmptyCollection {
  public func index(after i: Index) -> Index {
    _preconditionFailure("EmptyCollection can't advance indices")
  }
}


----- Swift.(file).EmptyCollection.index(before:EmptyCollection<Element>.Index)
extension EmptyCollection {
  public func index(before i: Index) -> Index {
    _preconditionFailure("EmptyCollection can't advance indices")
  }
}


----- Swift.(file).EmptyCollection.index(_:EmptyCollection<Element>.Index,offsetBy:Int)
extension EmptyCollection {
  public func index(_ i: Index, offsetBy n: Int) -> Index {
    _debugPrecondition(i == startIndex && n == 0, "Index out of range")
    return i
  }
}


----- Swift.(file).EmptyCollection.index(_:EmptyCollection<Element>.Index,offsetBy:Int,limitedBy:EmptyCollection<Element>.Index)
extension EmptyCollection {
  public func index(
    _ i: Index, offsetBy n: Int, limitedBy limit: Index
  ) -> Index? {
    _debugPrecondition(i == startIndex && limit == startIndex,
      "Index out of range")
    return n == 0 ? i : nil
  }
}


----- Swift.(file).EmptyCollection.distance(from:EmptyCollection<Element>.Index,to:EmptyCollection<Element>.Index)
extension EmptyCollection {
  public func distance(from start: Index, to end: Index) -> Int {
    _debugPrecondition(start == 0, "From must be startIndex (or endIndex)")
    _debugPrecondition(end == 0, "To must be endIndex (or startIndex)")
    return 0
  }
}


----- Swift.(file).Iterator.next()
extension Iterator {
  public mutating func next() -> Element? {
    while let n = _base.next() {
      if _predicate(n) {
        return n
      }
    }
    return nil
  }
}


----- Swift.(file).LazyFilterSequence.makeIterator()
extension LazyFilterSequence {
  public __consuming func makeIterator() -> Iterator {
    return Iterator(_base: _base.makeIterator(), _predicate)
  }
}


----- Swift.(file).LazyFilterSequence.index(after:LazyFilterSequence<Base>.Index)
extension LazyFilterSequence {
  public func index(after i: Index) -> Index {
    var i = i
    formIndex(after: &i)
    return i
  }
}


----- Swift.(file).LazyFilterSequence.formIndex(after:LazyFilterSequence<Base>.Index)
extension LazyFilterSequence {
  public func formIndex(after i: inout Index) {
    // TODO: swift-3-indexing-model: _failEarlyRangeCheck i?
    var index = i
    precondition(index != _base.endIndex, "Can't advance past endIndex")
    repeat {
      _base.formIndex(after: &index)
    } while index != _base.endIndex && !_predicate(_base[index])
    i = index
  }
}


----- Swift.(file).LazyFilterSequence.distance(from:LazyFilterSequence<Base>.Index,to:LazyFilterSequence<Base>.Index)
extension LazyFilterSequence {
  public func distance(from start: Index, to end: Index) -> Int {
    // The following line makes sure that distance(from:to:) is invoked on the
    // _base at least once, to trigger a _precondition in forward only
    // collections.
    _ = _base.distance(from: start, to: end)
    var _start: Index
    let _end: Index
    let step: Int
    if start > end {
      _start = end
      _end = start
      step = -1
    }
    else {
      _start = start
      _end = end
      step = 1
    }
    var count = 0
    while _start != _end {
      count += step
      formIndex(after: &_start)
    }
    return count
  }
}


----- Swift.(file).LazyFilterSequence.index(_:LazyFilterSequence<Base>.Index,offsetBy:Int)
extension LazyFilterSequence {
  public func index(_ i: Index, offsetBy n: Int) -> Index {
    var i = i
    let step = n.signum()
    // The following line makes sure that index(_:offsetBy:) is invoked on the
    // _base at least once, to trigger a _precondition in forward only
    // collections.
    _ensureBidirectional(step: step)
    for _ in 0 ..< abs(numericCast(n)) {
      _advanceIndex(&i, step: step)
    }
    return i
  }
}


----- Swift.(file).LazyFilterSequence.formIndex(_:LazyFilterSequence<Base>.Index,offsetBy:Int)
extension LazyFilterSequence {
  public func formIndex(_ i: inout Index, offsetBy n: Int) {
    i = index(i, offsetBy: n)
  }
}


----- Swift.(file).LazyFilterSequence.index(_:LazyFilterSequence<Base>.Index,offsetBy:Int,limitedBy:LazyFilterSequence<Base>.Index)
extension LazyFilterSequence {
  public func index(
    _ i: Index, offsetBy n: Int, limitedBy limit: Index
  ) -> Index? {
    var i = i
    let step = n.signum()
    // The following line makes sure that index(_:offsetBy:limitedBy:) is
    // invoked on the _base at least once, to trigger a _precondition in
    // forward only collections.
    _ensureBidirectional(step: step)
    for _ in 0 ..< abs(numericCast(n)) {
      if i == limit {
        return nil
      }
      _advanceIndex(&i, step: step)
    }
    return i
  }
}


----- Swift.(file).LazyFilterSequence.formIndex(_:LazyFilterSequence<Base>.Index,offsetBy:Int,limitedBy:LazyFilterSequence<Base>.Index)
extension LazyFilterSequence {
  public func formIndex(
    _ i: inout Index, offsetBy n: Int, limitedBy limit: Index
  ) -> Bool {
    if let advancedIndex = index(i, offsetBy: n, limitedBy: limit) {
      i = advancedIndex
      return true
    }
    i = limit
    return false
  }
}


----- Swift.(file).LazyFilterSequence.index(before:LazyFilterSequence<Base>.Index)
extension LazyFilterSequence {
  public func index(before i: Index) -> Index {
    var i = i
    formIndex(before: &i)
    return i
  }
}


----- Swift.(file).LazyFilterSequence.formIndex(before:LazyFilterSequence<Base>.Index)
extension LazyFilterSequence {
  public func formIndex(before i: inout Index) {
    // TODO: swift-3-indexing-model: _failEarlyRangeCheck i?
    var index = i
    precondition(index != _base.startIndex, "Can't retreat before startIndex")
    repeat {
      _base.formIndex(before: &index)
    } while !_predicate(_base[index])
    i = index
  }
}


----- Swift.(file).LazyFilterSequence.filter(_:(LazyFilterSequence<Base>.Element) -> Bool)
extension LazyFilterSequence {
  public __consuming func filter(
    _ isIncluded: @escaping (Element) -> Bool
  ) -> LazyFilterSequence<Base> {
    return LazyFilterSequence(_base: _base) {
      isIncluded($0) && self._predicate($0)
    }
  }
}


----- Swift.(file).Iterator.next()
extension Iterator {
  public mutating func next() -> Element? {
    repeat {
      if _fastPath(_inner != nil) {
        let ret = _inner!.next()
        if _fastPath(ret != nil) {
          return ret
        }
      }
      let s = _base.next()
      if _slowPath(s == nil) {
        return nil
      }
      _inner = s!.makeIterator()
    }
    while true
  }
}


----- Swift.(file).FlattenSequence.makeIterator()
extension FlattenSequence {
  public __consuming func makeIterator() -> Iterator {
    return Iterator(_base: _base.makeIterator())
  }
}


----- Swift.(file).Sequence.joined()
extension Sequence {
  public __consuming func joined() -> FlattenSequence<Self> {
    return FlattenSequence(_base: self)
  }
}


----- Swift.(file).LazySequenceProtocol.joined()
extension LazySequenceProtocol {
  public __consuming func joined() -> LazySequence<FlattenSequence<Elements>> {
    return FlattenSequence(_base: elements).lazy
  }
}


----- Swift.(file).Index.==infix(_:FlattenCollection<Base>.Index,_:FlattenCollection<Base>.Index)
extension Index {
  public static func == (
    lhs: FlattenCollection<Base>.Index,
    rhs: FlattenCollection<Base>.Index
  ) -> Bool {
    return lhs._outer == rhs._outer && lhs._inner == rhs._inner
  }
}


----- Swift.(file).Index.<infix(_:FlattenCollection<Base>.Index,_:FlattenCollection<Base>.Index)
extension Index {
  public static func < (
    lhs: FlattenCollection<Base>.Index,
    rhs: FlattenCollection<Base>.Index
  ) -> Bool {
    // FIXME: swift-3-indexing-model: tests.
    if lhs._outer != rhs._outer {
      return lhs._outer < rhs._outer
    }

    if let lhsInner = lhs._inner, let rhsInner = rhs._inner {
      return lhsInner < rhsInner
    }

    // When combined, the two conditions above guarantee that both
    // `_outer` indices are `_base.endIndex` and both `_inner` indices
    // are `nil`, since `_inner` is `nil` iff `_outer == base.endIndex`.
    precondition(lhs._inner == nil && rhs._inner == nil)

    return false
  }
}


----- Swift.(file).Index.hash(into:Hasher)
extension Index {
  public func hash(into hasher: inout Hasher) {
    hasher.combine(_outer)
    hasher.combine(_inner)
  }
}


----- Swift.(file).FlattenSequence.index(after:FlattenSequence<Base>.Index)
extension FlattenSequence {
  public func index(after i: Index) -> Index {
    return _index(after: i)
  }
}


----- Swift.(file).FlattenSequence.formIndex(after:FlattenSequence<Base>.Index)
extension FlattenSequence {
  public func formIndex(after i: inout Index) {
    i = index(after: i)
  }
}


----- Swift.(file).FlattenSequence.distance(from:FlattenSequence<Base>.Index,to:FlattenSequence<Base>.Index)
extension FlattenSequence {
  public func distance(from start: Index, to end: Index) -> Int {
    // The following check makes sure that distance(from:to:) is invoked on the
    // _base at least once, to trigger a _precondition in forward only
    // collections.
    if end < start {
      _ = _base.distance(from: _base.endIndex, to: _base.startIndex)
    }
    var _start: Index
    let _end: Index
    let step: Int
    if start > end {
      _start = end
      _end = start
      step = -1
    }
    else {
      _start = start
      _end = end
      step = 1
    }
    var count = 0
    while _start != _end {
      count += step
      formIndex(after: &_start)
    }
    return count
  }
}


----- Swift.(file).FlattenSequence.index(_:FlattenSequence<Base>.Index,offsetBy:Int)
extension FlattenSequence {
  public func index(_ i: Index, offsetBy n: Int) -> Index {
    var i = i
    let step = n.signum()
    _ensureBidirectional(step: step)
    for _ in 0 ..< abs(n) {
      _advanceIndex(&i, step: step)
    }
    return i
  }
}


----- Swift.(file).FlattenSequence.formIndex(_:FlattenSequence<Base>.Index,offsetBy:Int)
extension FlattenSequence {
  public func formIndex(_ i: inout Index, offsetBy n: Int) {
    i = index(i, offsetBy: n)
  }
}


----- Swift.(file).FlattenSequence.index(_:FlattenSequence<Base>.Index,offsetBy:Int,limitedBy:FlattenSequence<Base>.Index)
extension FlattenSequence {
  public func index(
    _ i: Index, offsetBy n: Int, limitedBy limit: Index
  ) -> Index? {
    var i = i
    let step = n.signum()
    // The following line makes sure that index(_:offsetBy:limitedBy:) is
    // invoked on the _base at least once, to trigger a _precondition in
    // forward only collections.
    _ensureBidirectional(step: step)
    for _ in 0 ..< abs(n) {
      if i == limit {
        return nil
      }
      _advanceIndex(&i, step: step)
    }
    return i
  }
}


----- Swift.(file).FlattenSequence.formIndex(_:FlattenSequence<Base>.Index,offsetBy:Int,limitedBy:FlattenSequence<Base>.Index)
extension FlattenSequence {
  public func formIndex(
    _ i: inout Index, offsetBy n: Int, limitedBy limit: Index
  ) -> Bool {
    if let advancedIndex = index(i, offsetBy: n, limitedBy: limit) {
      i = advancedIndex
      return true
    }
    i = limit
    return false
  }
}


----- Swift.(file).FlattenSequence.index(before:FlattenSequence<Base>.Index)
extension FlattenSequence {
  public func index(before i: Index) -> Index {
    return _index(before: i)
  }
}


----- Swift.(file).FlattenSequence.formIndex(before:FlattenSequence<Base>.Index)
extension FlattenSequence {
  public func formIndex(before i: inout Index) {
    i = index(before: i)
  }
}


----- Swift.(file).BinaryFloatingPoint.random(in:Range<Self>,using:T)
extension BinaryFloatingPoint {
  public static func random<T: RandomNumberGenerator>(
    in range: Range<Self>,
    using generator: inout T
  ) -> Self {
    precondition(
      !range.isEmpty,
      "Can't get random value with an empty range"
    )
    let delta = range.upperBound - range.lowerBound
    //  TODO: this still isn't quite right, because the computation of delta
    //  can overflow (e.g. if .upperBound = .maximumFiniteMagnitude and
    //  .lowerBound = -.upperBound); this should be re-written with an
    //  algorithm that handles that case correctly, but this precondition
    //  is an acceptable short-term fix.
    precondition(
      delta.isFinite,
      "There is no uniform distribution on an infinite range"
    )
    let rand: Self.RawSignificand
    if Self.RawSignificand.bitWidth == Self.significandBitCount + 1 {
      rand = generator.next()
    } else {
      let significandCount = Self.significandBitCount + 1
      let maxSignificand: Self.RawSignificand = 1 << significandCount
      // Rather than use .next(upperBound:), which has to work with arbitrary
      // upper bounds, and therefore does extra work to avoid bias, we can take
      // a shortcut because we know that maxSignificand is a power of two.
      rand = generator.next() & (maxSignificand - 1)
    }
    let unitRandom = Self.init(rand) * (Self.ulpOfOne / 2)
    let randFloat = delta * unitRandom + range.lowerBound
    if randFloat == range.upperBound {
      return Self.random(in: range, using: &generator)
    }
    return randFloat
  }
}


----- Swift.(file).BinaryFloatingPoint.random(in:Range<Self>)
extension BinaryFloatingPoint {
  public static func random(in range: Range<Self>) -> Self {
    var g = SystemRandomNumberGenerator()
    return Self.random(in: range, using: &g)
  }
}


----- Swift.(file).BinaryFloatingPoint.random(in:ClosedRange<Self>,using:T)
extension BinaryFloatingPoint {
  public static func random<T: RandomNumberGenerator>(
    in range: ClosedRange<Self>,
    using generator: inout T
  ) -> Self {
    precondition(
      !range.isEmpty,
      "Can't get random value with an empty range"
    )
    let delta = range.upperBound - range.lowerBound
    //  TODO: this still isn't quite right, because the computation of delta
    //  can overflow (e.g. if .upperBound = .maximumFiniteMagnitude and
    //  .lowerBound = -.upperBound); this should be re-written with an
    //  algorithm that handles that case correctly, but this precondition
    //  is an acceptable short-term fix.
    precondition(
      delta.isFinite,
      "There is no uniform distribution on an infinite range"
    )
    let rand: Self.RawSignificand
    if Self.RawSignificand.bitWidth == Self.significandBitCount + 1 {
      rand = generator.next()
      let tmp: UInt8 = generator.next() & 1
      if rand == Self.RawSignificand.max && tmp == 1 {
        return range.upperBound
      }
    } else {
      let significandCount = Self.significandBitCount + 1
      let maxSignificand: Self.RawSignificand = 1 << significandCount
      rand = generator.next(upperBound: maxSignificand + 1)
      if rand == maxSignificand {
        return range.upperBound
      }
    }
    let unitRandom = Self.init(rand) * (Self.ulpOfOne / 2)
    let randFloat = delta * unitRandom + range.lowerBound
    return randFloat
  }
}


----- Swift.(file).BinaryFloatingPoint.random(in:ClosedRange<Self>)
extension BinaryFloatingPoint {
  public static func random(in range: ClosedRange<Self>) -> Self {
    var g = SystemRandomNumberGenerator()
    return Self.random(in: range, using: &g)
  }
}


----- Swift.(file).Hasher.combine(bytes:UnsafeRawBufferPointer)
extension Hasher {
  public mutating func combine(bytes: UnsafeRawBufferPointer) {
    _core.combine(bytes: bytes)
  }
}


----- Swift.(file).Hasher.finalize()
extension Hasher {
  public __consuming func finalize() -> Int {
    var core = _core
    return Int(truncatingIfNeeded: core.finalize())
  }
}


----- Swift.(file).DefaultIndices.index(after:DefaultIndices<Elements>.Index)
extension DefaultIndices {
  public func index(after i: Index) -> Index {
    // FIXME: swift-3-indexing-model: range check.
    return _elements.index(after: i)
  }
}


----- Swift.(file).DefaultIndices.formIndex(after:DefaultIndices<Elements>.Index)
extension DefaultIndices {
  public func formIndex(after i: inout Index) {
    // FIXME: swift-3-indexing-model: range check.
    _elements.formIndex(after: &i)
  }
}


----- Swift.(file).DefaultIndices.index(before:DefaultIndices<Elements>.Index)
extension DefaultIndices {
  public func index(before i: Index) -> Index {
    // FIXME: swift-3-indexing-model: range check.
    return _elements.index(before: i)
  }
}


----- Swift.(file).DefaultIndices.formIndex(before:DefaultIndices<Elements>.Index)
extension DefaultIndices {
  public func formIndex(before i: inout Index) {
    // FIXME: swift-3-indexing-model: range check.
    _elements.formIndex(before: &i)
  }
}


----- Swift.(file).readLine(strippingNewline:Bool)
public func readLine(strippingNewline: Bool = true) -> String? {
  var linePtrVar: UnsafeMutablePointer<UInt8>?
  var readBytes = swift_stdlib_readLine_stdin(&linePtrVar)
  if readBytes == -1 {
    return nil
  }
  _internalInvariant(readBytes >= 0,
    "unexpected return value from swift_stdlib_readLine_stdin")
  if readBytes == 0 {
    return ""
  }

  let linePtr = linePtrVar!
  if strippingNewline {
    // FIXME: Unicode conformance.  To fix this, we need to reimplement the
    // code we call above to get a line, since it will only stop on LF.
    //
    // <rdar://problem/20013999> Recognize Unicode newlines in readLine()
    //
    // Recognize only LF and CR+LF combinations for now.
    let cr = UInt8(ascii: "\r")
    let lf = UInt8(ascii: "\n")
    if readBytes == 1 && linePtr[0] == lf {
      return ""
    }
    if readBytes >= 2 {
      switch (linePtr[readBytes - 2], linePtr[readBytes - 1]) {
      case (cr, lf):
        readBytes -= 2
        break
      case (_, lf):
        readBytes -= 1
        break
      default:
        ()
      }
    }
  }
  let result = String._fromUTF8Repairing(
    UnsafeBufferPointer(start: linePtr, count: readBytes)).0
  _swift_stdlib_free(linePtr)
  return result
}


----- Swift.(file).FixedWidthInteger.init(_:S,radix:Int)
extension FixedWidthInteger {
  public init?<S : StringProtocol>(_ text: S, radix: Int = 10) {
    precondition(2...36 ~= radix, "Radix not in range 2...36")

    if let str = text as? String, str._guts.isFastUTF8 {
      guard let ret = str._guts.withFastUTF8 ({ utf8 -> Self? in
        var iter = utf8.makeIterator()
        return _parseASCII(codeUnits: &iter, radix: Self(radix))
      }) else {
        return nil
      }
      self = ret
      return
    }

    // TODO(String performance): We can provide fast paths for common radices,
    // native UTF-8 storage, etc.

    var iter = text.utf8.makeIterator()
    guard let ret = Self._parseASCIISlowPath(
      codeUnits: &iter, radix: Self(radix)
    ) else { return nil }

    self = ret
  }
}


----- Swift.(file).BinaryInteger.distance(to:Self)
extension BinaryInteger {
  public func distance(to other: Self) -> Int {
    if !Self.isSigned {
      if self > other {
        if let result = Int(exactly: self - other) {
          return -result
        }
      } else {
        if let result = Int(exactly: other - self) {
          return result
        }
      }
    } else {
      let isNegative = self < (0 as Self)
      if isNegative == (other < (0 as Self)) {
        if let result = Int(exactly: other - self) {
          return result
        }
      } else {
        if let result = Int(exactly: self.magnitude + other.magnitude) {
          return isNegative ? result : -result
        }
      }
    }
    _preconditionFailure("Distance is not representable in Int")
  }
}


----- Swift.(file).Iterator.next()
extension Iterator {
  public mutating func next() -> Element? {
    while true {
      switch _state {
      case .start:
        if let nextSubSequence = _base.next() {
          _inner = nextSubSequence.makeIterator()
          _state = .generatingElements
        } else {
          _state = .end
          return nil
        }

      case .generatingElements:
        let result = _inner!.next()
        if _fastPath(result != nil) {
          return result
        }
        _inner = _base.next()?.makeIterator()
        if _inner == nil {
          _state = .end
          return nil
        }
        if !_separatorData.isEmpty {
          _separator = _separatorData.makeIterator()
          _state = .generatingSeparator
        }

      case .generatingSeparator:
        let result = _separator!.next()
        if _fastPath(result != nil) {
          return result
        }
        _state = .generatingElements

      case .end:
        return nil
      }
    }
  }
}


----- Swift.(file).JoinedSequence.makeIterator()
extension JoinedSequence {
  public __consuming func makeIterator() -> Iterator {
    return Iterator(base: _base.makeIterator(), separator: _separator)
  }
}


----- Swift.(file).AnyKeyPath.hash(into:Hasher)
extension AnyKeyPath {
  final public func hash(into hasher: inout Hasher) {
    ObjectIdentifier(type(of: self)).hash(into: &hasher)
    return withBuffer {
      var buffer = $0
      if buffer.data.isEmpty { return }
      while true {
        let (component, type) = buffer.next()
        hasher.combine(component.value)
        if let type = type {
          hasher.combine(unsafeBitCast(type, to: Int.self))
        } else {
          break
        }
      }
    }
  }
}


----- Swift.(file).AnyKeyPath.==infix(_:AnyKeyPath,_:AnyKeyPath)
extension AnyKeyPath {
  public static func ==(a: AnyKeyPath, b: AnyKeyPath) -> Bool {
    // Fast-path identical objects
    if a === b {
      return true
    }
    // Short-circuit differently-typed key paths
    if type(of: a) != type(of: b) {
      return false
    }
    return a.withBuffer {
      var aBuffer = $0
      return b.withBuffer {
        var bBuffer = $0

        // Two equivalent key paths should have the same reference prefix
        if aBuffer.hasReferencePrefix != bBuffer.hasReferencePrefix {
          return false
        }

        // Identity is equal to identity
        if aBuffer.data.isEmpty {
          return bBuffer.data.isEmpty
        }

        while true {
          let (aComponent, aType) = aBuffer.next()
          let (bComponent, bType) = bBuffer.next()

          if aComponent.header.endOfReferencePrefix
              != bComponent.header.endOfReferencePrefix
            || aComponent.value != bComponent.value
            || aType != bType {
            return false
          }
          if aType == nil {
            return true
          }
        }
      }
    }
  }
}


----- Swift.(file)._AppendKeyPath.appending(path:AnyKeyPath)
extension _AppendKeyPath {
  public func appending(path: AnyKeyPath) -> AnyKeyPath? {
    return _tryToAppendKeyPaths(root: self, leaf: path)
  }
}


----- Swift.(file)._AppendKeyPath.appending(path:AnyKeyPath)
extension _AppendKeyPath {
  public func appending<Root>(path: AnyKeyPath) -> PartialKeyPath<Root>?
  where Self == PartialKeyPath<Root> {
    return _tryToAppendKeyPaths(root: self, leaf: path)
  }
}


----- Swift.(file)._AppendKeyPath.appending(path:KeyPath<AppendedRoot, AppendedValue>)
extension _AppendKeyPath {
  public func appending<Root, AppendedRoot, AppendedValue>(
    path: KeyPath<AppendedRoot, AppendedValue>
  ) -> KeyPath<Root, AppendedValue>?
  where Self == PartialKeyPath<Root> {
    return _tryToAppendKeyPaths(root: self, leaf: path)
  }
}


----- Swift.(file)._AppendKeyPath.appending(path:ReferenceWritableKeyPath<AppendedRoot, AppendedValue>)
extension _AppendKeyPath {
  public func appending<Root, AppendedRoot, AppendedValue>(
    path: ReferenceWritableKeyPath<AppendedRoot, AppendedValue>
  ) -> ReferenceWritableKeyPath<Root, AppendedValue>?
  where Self == PartialKeyPath<Root> {
    return _tryToAppendKeyPaths(root: self, leaf: path)
  }
}


----- Swift.(file)._AppendKeyPath.appending(path:KeyPath<Value, AppendedValue>)
extension _AppendKeyPath {
  public func appending<Root, Value, AppendedValue>(
    path: KeyPath<Value, AppendedValue>
  ) -> KeyPath<Root, AppendedValue>
  where Self: KeyPath<Root, Value> {
    return _appendingKeyPaths(root: self, leaf: path)
  }
}


----- Swift.(file)._AppendKeyPath.appending(path:ReferenceWritableKeyPath<Value, AppendedValue>)
extension _AppendKeyPath {
  public func appending<Root, Value, AppendedValue>(
    path: ReferenceWritableKeyPath<Value, AppendedValue>
  ) -> ReferenceWritableKeyPath<Root, AppendedValue>
  where Self == KeyPath<Root, Value> {
    return _appendingKeyPaths(root: self, leaf: path)
  }
}


----- Swift.(file)._AppendKeyPath.appending(path:WritableKeyPath<Value, AppendedValue>)
extension _AppendKeyPath {
  public func appending<Root, Value, AppendedValue>(
    path: WritableKeyPath<Value, AppendedValue>
  ) -> WritableKeyPath<Root, AppendedValue>
  where Self == WritableKeyPath<Root, Value> {
    return _appendingKeyPaths(root: self, leaf: path)
  }
}


----- Swift.(file)._AppendKeyPath.appending(path:ReferenceWritableKeyPath<Value, AppendedValue>)
extension _AppendKeyPath {
  public func appending<Root, Value, AppendedValue>(
    path: ReferenceWritableKeyPath<Value, AppendedValue>
  ) -> ReferenceWritableKeyPath<Root, AppendedValue>
  where Self == WritableKeyPath<Root, Value> {
    return _appendingKeyPaths(root: self, leaf: path)
  }
}


----- Swift.(file)._AppendKeyPath.appending(path:WritableKeyPath<Value, AppendedValue>)
extension _AppendKeyPath {
  public func appending<Root, Value, AppendedValue>(
    path: WritableKeyPath<Value, AppendedValue>
  ) -> ReferenceWritableKeyPath<Root, AppendedValue>
  where Self == ReferenceWritableKeyPath<Root, Value> {
    return _appendingKeyPaths(root: self, leaf: path)
  }
}


----- Swift.(file).LazySequence.index(after:LazySequence<Base>.Index)
extension LazySequence {
  public func index(after i: Index) -> Index {
    return _base.index(after: i)
  }
}


----- Swift.(file).LazySequence.index(_:LazySequence<Base>.Index,offsetBy:Int)
extension LazySequence {
  public func index(_ i: Index, offsetBy n: Int) -> Index {
    return _base.index(i, offsetBy: n)
  }
}


----- Swift.(file).LazySequence.index(_:LazySequence<Base>.Index,offsetBy:Int,limitedBy:LazySequence<Base>.Index)
extension LazySequence {
  public func index(
    _ i: Index, offsetBy n: Int, limitedBy limit: Index
  ) -> Index? {
    return _base.index(i, offsetBy: n, limitedBy: limit)
  }
}


----- Swift.(file).LazySequence.distance(from:LazySequence<Base>.Index,to:LazySequence<Base>.Index)
extension LazySequence {
  public func distance(from start: Index, to end: Index) -> Int {
    return _base.distance(from:start, to: end)
  }
}


----- Swift.(file).LazySequence.index(before:LazySequence<Base>.Index)
extension LazySequence {
  public func index(before i: Index) -> Index {
    return _base.index(before: i)
  }
}


----- Swift.(file).LazySequence.makeIterator()
extension LazySequence {
  public __consuming func makeIterator() -> Iterator {
    return _base.makeIterator()
  }
}


----- Swift.(file).withUnsafeMutablePointer(to:T,_:(UnsafeMutablePointer<T>) throws -> Result)
public func withUnsafeMutablePointer<T, Result>(
  to value: inout T,
  _ body: (UnsafeMutablePointer<T>) throws -> Result
) rethrows -> Result
{
  return try body(UnsafeMutablePointer<T>(Builtin.addressof(&value)))
}


----- Swift.(file).withUnsafePointer(to:T,_:(UnsafePointer<T>) throws -> Result)
public func withUnsafePointer<T, Result>(
  to value: T,
  _ body: (UnsafePointer<T>) throws -> Result
) rethrows -> Result
{
  return try body(UnsafePointer<T>(Builtin.addressOfBorrow(value)))
}


----- Swift.(file).withUnsafePointer(to:T,_:(UnsafePointer<T>) throws -> Result)
public func withUnsafePointer<T, Result>(
  to value: inout T,
  _ body: (UnsafePointer<T>) throws -> Result
) rethrows -> Result
{
  return try body(UnsafePointer<T>(Builtin.addressof(&value)))
}


----- Swift.(file).String.withCString(_:(UnsafePointer<Int8>) throws -> Result)
extension String {
  public func withCString<Result>(
    _ body: (UnsafePointer<Int8>) throws -> Result
  ) rethrows -> Result {
    return try _guts.withCString(body)
  }
}


----- Swift.(file).ManagedBuffer.create(minimumCapacity:Int,makingHeaderWith:(ManagedBuffer<Header, Element>) throws -> Header)
extension ManagedBuffer {
  public final class func create(
    minimumCapacity: Int,
    makingHeaderWith factory: (
      ManagedBuffer<Header, Element>) throws -> Header
  ) rethrows -> ManagedBuffer<Header, Element> {

    let p = Builtin.allocWithTailElems_1(
         self,
         minimumCapacity._builtinWordValue, Element.self)

    let initHeaderVal = try factory(p)
    p.headerAddress.initialize(to: initHeaderVal)
    // The _fixLifetime is not really needed, because p is used afterwards.
    // But let's be conservative and fix the lifetime after we use the
    // headerAddress.
    _fixLifetime(p)
    return p
  }
}


----- Swift.(file).ManagedBuffer.withUnsafeMutablePointers(_:(UnsafeMutablePointer<Header>, UnsafeMutablePointer<Element>) throws -> R)
extension ManagedBuffer {
  public final func withUnsafeMutablePointers<R>(
    _ body: (UnsafeMutablePointer<Header>, UnsafeMutablePointer<Element>) throws -> R
  ) rethrows -> R {
    defer { _fixLifetime(self) }
    return try body(headerAddress, firstElementAddress)
  }
}


----- Swift.(file).tryReallocateUniquelyReferenced(buffer:Buffer,newMinimumCapacity:Int)
public func tryReallocateUniquelyReferenced<Header, Element, Buffer: ManagedBuffer<Header, Element>>(
  buffer: inout Buffer,
  newMinimumCapacity: Int
) -> Bool {
  precondition(_isBitwiseTakable(Header.self))
  precondition(_isBitwiseTakable(Element.self))
  precondition(isKnownUniquelyReferenced(&buffer))

  let newSizeInBytes = MemoryLayout<Header>.stride
    + newMinimumCapacity * MemoryLayout<Element>.stride

  return withUnsafeMutablePointer(to: &buffer) {
    $0.withMemoryRebound(to: UnsafeMutableRawPointer.self, capacity: 1) {
      if let reallocdObject = _reallocObject($0.pointee, newSizeInBytes) {
        $0.pointee = reallocdObject
        return true
      } else {
        return false
      }
    }
  }
}


----- Swift.(file).ManagedBufferPointer.withUnsafeMutablePointers(_:(UnsafeMutablePointer<Header>, UnsafeMutablePointer<Element>) throws -> R)
extension ManagedBufferPointer {
  public func withUnsafeMutablePointers<R>(
    _ body: (UnsafeMutablePointer<Header>, UnsafeMutablePointer<Element>) throws -> R
  ) rethrows -> R {
    defer { _fixLifetime(_nativeBuffer) }
    return try body(_headerPointer, _elementPointer)
  }
}


----- Swift.(file).ManagedBufferPointer.isUniqueReference()
extension ManagedBufferPointer {
  public mutating func isUniqueReference() -> Bool {
    return _isUnique(&_nativeBuffer)
  }
}


----- Swift.(file).ManagedBufferPointer.==infix(_:ManagedBufferPointer<Header, Element>,_:ManagedBufferPointer<Header, Element>)
extension ManagedBufferPointer {
  public static func == (
    lhs: ManagedBufferPointer,
    rhs: ManagedBufferPointer
  ) -> Bool {
    return lhs._address == rhs._address
  }
}


----- Swift.(file).isKnownUniquelyReferenced(_:T)
public func isKnownUniquelyReferenced<T : AnyObject>(_ object: inout T) -> Bool
{
  return _isUnique(&object)
}


----- Swift.(file).isKnownUniquelyReferenced(_:T?)
public func isKnownUniquelyReferenced<T : AnyObject>(
  _ object: inout T?
) -> Bool {
  return _isUnique(&object)
}


----- Swift.(file).Iterator.next()
extension Iterator {
  public mutating func next() -> Element? {
    return _base.next().map(_transform)
  }
}


----- Swift.(file).LazyMapSequence.makeIterator()
extension LazyMapSequence {
  public __consuming func makeIterator() -> Iterator {
    return Iterator(_base: _base.makeIterator(), _transform: _transform)
  }
}


----- Swift.(file).LazyMapSequence.index(after:LazyMapSequence<Base, Element>.Index)
extension LazyMapSequence {
  public func index(after i: Index) -> Index { return _base.index(after: i) }
}


----- Swift.(file).LazyMapSequence.formIndex(after:LazyMapSequence<Base, Element>.Index)
extension LazyMapSequence {
  public func formIndex(after i: inout Index) { _base.formIndex(after: &i) }
}


----- Swift.(file).LazyMapSequence.index(_:LazyMapSequence<Base, Element>.Index,offsetBy:Int)
extension LazyMapSequence {
  public func index(_ i: Index, offsetBy n: Int) -> Index {
    return _base.index(i, offsetBy: n)
  }
}


----- Swift.(file).LazyMapSequence.index(_:LazyMapSequence<Base, Element>.Index,offsetBy:Int,limitedBy:LazyMapSequence<Base, Element>.Index)
extension LazyMapSequence {
  public func index(
    _ i: Index, offsetBy n: Int, limitedBy limit: Index
  ) -> Index? {
    return _base.index(i, offsetBy: n, limitedBy: limit)
  }
}


----- Swift.(file).LazyMapSequence.distance(from:LazyMapSequence<Base, Element>.Index,to:LazyMapSequence<Base, Element>.Index)
extension LazyMapSequence {
  public func distance(from start: Index, to end: Index) -> Int {
    return _base.distance(from: start, to: end)
  }
}


----- Swift.(file).LazyMapSequence.index(before:LazyMapSequence<Base, Element>.Index)
extension LazyMapSequence {
  public func index(before i: Index) -> Index { return _base.index(before: i) }
}


----- Swift.(file).LazyMapSequence.formIndex(before:LazyMapSequence<Base, Element>.Index)
extension LazyMapSequence {
  public func formIndex(before i: inout Index) {
    _base.formIndex(before: &i)
  }
}


----- Swift.(file).LazySequenceProtocol.map(_:(Self.Element) -> U)
extension LazySequenceProtocol {
  public func map<U>(
    _ transform: @escaping (Element) -> U
  ) -> LazyMapSequence<Elements, U> {
    return LazyMapSequence(_base: elements, transform: transform)
  }
}


----- Swift.(file).LazyMapSequence.map(_:(Element) -> ElementOfResult)
extension LazyMapSequence {
  public func map<ElementOfResult>(
    _ transform: @escaping (Element) -> ElementOfResult
  ) -> LazyMapSequence<Base, ElementOfResult> {
    return LazyMapSequence<Base, ElementOfResult>(
      _base: _base,
      transform: { transform(self._transform($0)) })
  }
}


----- Swift.(file).LazyMapSequence.map(_:(Element) -> ElementOfResult)
extension LazyMapSequence {
  public func map<ElementOfResult>(
    _ transform: @escaping (Element) -> ElementOfResult
  ) -> LazyMapCollection<Base, ElementOfResult> {
    return LazyMapCollection<Base, ElementOfResult>(
      _base: _base,
      transform: {transform(self._transform($0))})
  }
}


----- Swift.(file).MemoryLayout.offset(of:PartialKeyPath<T>)
extension MemoryLayout {
  public static func offset(of key: PartialKeyPath<T>) -> Int? {
    return key._storedInlineOffset
  }
}


----- Swift.(file).Collection.index(of:Self.Element)
extension Collection {
  public func index(of element: Element) -> Index? {
    return firstIndex(of: element)
  }
}


----- Swift.(file).swap(_:T,_:T)
public func swap<T>(_ a: inout T, _ b: inout T) {
  // Semantically equivalent to (a, b) = (b, a).
  // Microoptimized to avoid retain/release traffic.
  let p1 = Builtin.addressof(&a)
  let p2 = Builtin.addressof(&b)
  _debugPrecondition(
    p1 != p2,
    "swapping a location with itself is not supported")

  // Take from P1.
  let tmp: T = Builtin.take(p1)
  // Transfer P2 into P1.
  Builtin.initialize(Builtin.take(p2) as T, p1)
  // Initialize P2.
  Builtin.initialize(tmp, p2)
}


----- Swift.(file)._SwiftNewtypeWrapper.hash(into:Hasher)
extension _SwiftNewtypeWrapper {
  public func hash(into hasher: inout Hasher) {
    hasher.combine(rawValue)
  }
}


----- Swift.(file).ObjectIdentifier.==infix(_:ObjectIdentifier,_:ObjectIdentifier)
extension ObjectIdentifier {
  public static func == (x: ObjectIdentifier, y: ObjectIdentifier) -> Bool {
    return Bool(Builtin.cmp_eq_RawPointer(x._value, y._value))
  }
}


----- Swift.(file).ObjectIdentifier.hash(into:Hasher)
extension ObjectIdentifier {
  public func hash(into hasher: inout Hasher) {
    hasher.combine(Int(Builtin.ptrtoint_Word(_value)))
  }
}


----- Swift.(file).OptionSet.insert(_:Self.Element)
extension OptionSet {
  public mutating func insert(
    _ newMember: Element
  ) -> (inserted: Bool, memberAfterInsert: Element) {
    let oldMember = self.intersection(newMember)
    let shouldInsert = oldMember != newMember
    let result = (
      inserted: shouldInsert,
      memberAfterInsert: shouldInsert ? newMember : oldMember)
    if shouldInsert {
      self.formUnion(newMember)
    }
    return result
  }
}


----- Swift.(file).OptionSet.remove(_:Self.Element)
extension OptionSet {
  public mutating func remove(_ member: Element) -> Element? {
    let r = isSuperset(of: member) ? Optional(member) : nil
    self.subtract(member)
    return r
  }
}


----- Swift.(file).OptionSet.update(with:Self.Element)
extension OptionSet {
  public mutating func update(with newMember: Element) -> Element? {
    let r = self.intersection(newMember)
    self.formUnion(newMember)
    return r.isEmpty ? nil : r
  }
}


----- Swift.(file).OptionSet.formUnion(_:Self)
extension OptionSet {
  public mutating func formUnion(_ other: Self) {
    self = Self(rawValue: self.rawValue | other.rawValue)
  }
}


----- Swift.(file).OptionSet.formIntersection(_:Self)
extension OptionSet {
  public mutating func formIntersection(_ other: Self) {
    self = Self(rawValue: self.rawValue & other.rawValue)
  }
}


----- Swift.(file).OptionSet.formSymmetricDifference(_:Self)
extension OptionSet {
  public mutating func formSymmetricDifference(_ other: Self) {
    self = Self(rawValue: self.rawValue ^ other.rawValue)
  }
}


----- Swift.(file).Optional.hash(into:Hasher)
extension Optional {
  public func hash(into hasher: inout Hasher) {
    switch self {
    case .none:
      hasher.combine(0 as UInt8)
    case .some(let wrapped):
      hasher.combine(1 as UInt8)
      hasher.combine(wrapped)
    }
  }
}


----- Swift.(file).Scalar.write(to:Target)
extension Scalar {
  public func write<Target : TextOutputStream>(to target: inout Target) {
    target.write(String(Character(self)))
  }
}


----- Swift.(file)._Pointer.==infix(_:Self,_:Self)
extension _Pointer {
  public static func == (lhs: Self, rhs: Self) -> Bool {
    return Bool(Builtin.cmp_eq_RawPointer(lhs._rawValue, rhs._rawValue))
  }
}


----- Swift.(file)._Pointer.<infix(_:Self,_:Self)
extension _Pointer {
  public static func < (lhs: Self, rhs: Self) -> Bool {
    return Bool(Builtin.cmp_ult_RawPointer(lhs._rawValue, rhs._rawValue))
  }
}


----- Swift.(file)._Pointer.distance(to:Self)
extension _Pointer {
  public func distance(to end: Self) -> Int {
    return
      Int(Builtin.sub_Word(Builtin.ptrtoint_Word(end._rawValue),
                           Builtin.ptrtoint_Word(_rawValue)))
      / MemoryLayout<Pointee>.stride
  }
}


----- Swift.(file)._Pointer.advanced(by:Int)
extension _Pointer {
  public func advanced(by n: Int) -> Self {
    return Self(Builtin.gep_Word(
      self._rawValue, n._builtinWordValue, Pointee.self))
  }
}


----- Swift.(file).Iterator.next()
extension Iterator {
  public mutating func next() -> Element? {
    // Return elements from the base iterator until one fails the predicate.
    if !_predicateHasFailed, let nextElement = _base.next() {
      if _predicate(nextElement) {
        return nextElement
      } else {
        _predicateHasFailed = true
      }
    }
    return nil
  }
}


----- Swift.(file).LazyPrefixWhileSequence.makeIterator()
extension LazyPrefixWhileSequence {
  public __consuming func makeIterator() -> Iterator {
    return Iterator(_base: _base.makeIterator(), predicate: _predicate)
  }
}


----- Swift.(file).LazySequenceProtocol.prefix(while:(Self.Elements.Element) -> Bool)
extension LazySequenceProtocol {
  public __consuming func prefix(
    while predicate: @escaping (Elements.Element) -> Bool
  ) -> LazyPrefixWhileSequence<Self.Elements> {
    return LazyPrefixWhileSequence(_base: self.elements, predicate: predicate)
  }
}


----- Swift.(file).Index.==infix(_:LazyPrefixWhileCollection<Base>.Index,_:LazyPrefixWhileCollection<Base>.Index)
extension Index {
  public static func == (
    lhs: LazyPrefixWhileCollection<Base>.Index,
    rhs: LazyPrefixWhileCollection<Base>.Index
  ) -> Bool {
    switch (lhs._value, rhs._value) {
    case let (.index(l), .index(r)):
      return l == r
    case (.pastEnd, .pastEnd):
      return true
    case (.pastEnd, .index), (.index, .pastEnd):
      return false
    }
  }
}


----- Swift.(file).Index.<infix(_:LazyPrefixWhileCollection<Base>.Index,_:LazyPrefixWhileCollection<Base>.Index)
extension Index {
  public static func < (
    lhs: LazyPrefixWhileCollection<Base>.Index,
    rhs: LazyPrefixWhileCollection<Base>.Index
  ) -> Bool {
    switch (lhs._value, rhs._value) {
    case let (.index(l), .index(r)):
      return l < r
    case (.index, .pastEnd):
      return true
    case (.pastEnd, _):
      return false
    }
  }
}


----- Swift.(file).Index.hash(into:Hasher)
extension Index {
  public func hash(into hasher: inout Hasher) {
    switch _value {
    case .index(let value):
      hasher.combine(value)
    case .pastEnd:
      hasher.combine(Int.max)
    }
  }
}


----- Swift.(file).LazyPrefixWhileSequence.index(after:LazyPrefixWhileSequence<Base>.Index)
extension LazyPrefixWhileSequence {
  public func index(after i: Index) -> Index {
    precondition(i != endIndex, "Can't advance past endIndex")
    guard case .index(let i) = i._value else {
      _preconditionFailure("Invalid index passed to index(after:)")
    }
    let nextIndex = _base.index(after: i)
    guard nextIndex != _base.endIndex && _predicate(_base[nextIndex]) else {
      return Index(endOf: _base)
    }
    return Index(nextIndex)
  }
}


----- Swift.(file).LazyPrefixWhileSequence.index(before:LazyPrefixWhileSequence<Base>.Index)
extension LazyPrefixWhileSequence {
  public func index(before i: Index) -> Index {
    switch i._value {
    case .index(let i):
      precondition(i != _base.startIndex, "Can't move before startIndex")
      return Index(_base.index(before: i))
    case .pastEnd:
      // Look for the position of the last element in a non-empty
      // prefix(while:) collection by searching forward for a predicate
      // failure.

      // Safe to assume that `_base.startIndex != _base.endIndex`; if they
      // were equal, `_base.startIndex` would be used as the `endIndex` of
      // this collection.
      _internalInvariant(!_base.isEmpty)
      var result = _base.startIndex
      while true {
        let next = _base.index(after: result)
        if next == _base.endIndex || !_predicate(_base[next]) {
          break
        }
        result = next
      }
      return Index(result)
    }
  }
}


----- Swift.(file).print(_:[Any],separator:String,terminator:String)
public func print(
  _ items: Any...,
  separator: String = " ",
  terminator: String = "\n"
) {
  if let hook = _playgroundPrintHook {
    var output = _TeeStream(left: "", right: _Stdout())
    _print(items, separator: separator, terminator: terminator, to: &output)
    hook(output.left)
  }
  else {
    var output = _Stdout()
    _print(items, separator: separator, terminator: terminator, to: &output)
  }
}


----- Swift.(file).debugPrint(_:[Any],separator:String,terminator:String)
public func debugPrint(
  _ items: Any...,
  separator: String = " ",
  terminator: String = "\n"
) {
  if let hook = _playgroundPrintHook {
    var output = _TeeStream(left: "", right: _Stdout())
    _debugPrint(items, separator: separator, terminator: terminator, to: &output)
    hook(output.left)
  }
  else {
    var output = _Stdout()
    _debugPrint(items, separator: separator, terminator: terminator, to: &output)
  }
}


----- Swift.(file).print(_:[Any],separator:String,terminator:String,to:Target)
public func print<Target : TextOutputStream>(
  _ items: Any...,
  separator: String = " ",
  terminator: String = "\n",
  to output: inout Target
) {
  _print(items, separator: separator, terminator: terminator, to: &output)
}


----- Swift.(file).debugPrint(_:[Any],separator:String,terminator:String,to:Target)
public func debugPrint<Target : TextOutputStream>(
  _ items: Any...,
  separator: String = " ",
  terminator: String = "\n",
  to output: inout Target
) {
  _debugPrint(items, separator: separator, terminator: terminator, to: &output)
}


----- Swift.(file).SystemRandomNumberGenerator.next()
extension SystemRandomNumberGenerator {
  public mutating func next() -> UInt64 {
    var random: UInt64 = 0
    swift_stdlib_random(&random, MemoryLayout<UInt64>.size)
    return random
  }
}


----- Swift.(file).RandomAccessCollection.index(after:Self.Index)
extension RandomAccessCollection {
  public func index(after i: Index) -> Index {
    // FIXME: swift-3-indexing-model: tests for the trap.
    _failEarlyRangeCheck(
      i, bounds: Range(uncheckedBounds: (startIndex, endIndex)))
    return i.advanced(by: 1)
  }
}


----- Swift.(file).RandomAccessCollection.index(before:Self.Index)
extension RandomAccessCollection {
  public func index(before i: Index) -> Index {
    let result = i.advanced(by: -1)
    // FIXME: swift-3-indexing-model: tests for the trap.
    _failEarlyRangeCheck(
      result, bounds: Range(uncheckedBounds: (startIndex, endIndex)))
    return result
  }
}


----- Swift.(file).RandomAccessCollection.index(_:Self.Index,offsetBy:Self.Index.Stride)
extension RandomAccessCollection {
  public func index(_ i: Index, offsetBy distance: Index.Stride) -> Index {
    let result = i.advanced(by: distance)
    // This range check is not precise, tighter bounds exist based on `n`.
    // Unfortunately, we would need to perform index manipulation to
    // compute those bounds, which is probably too slow in the general
    // case.
    // FIXME: swift-3-indexing-model: tests for the trap.
    _failEarlyRangeCheck(
      result, bounds: ClosedRange(uncheckedBounds: (startIndex, endIndex)))
    return result
  }
}


----- Swift.(file).RandomAccessCollection.distance(from:Self.Index,to:Self.Index)
extension RandomAccessCollection {
  public func distance(from start: Index, to end: Index) -> Index.Stride {
    // FIXME: swift-3-indexing-model: tests for traps.
    _failEarlyRangeCheck(
      start, bounds: ClosedRange(uncheckedBounds: (startIndex, endIndex)))
    _failEarlyRangeCheck(
      end, bounds: ClosedRange(uncheckedBounds: (startIndex, endIndex)))
    return start.distance(to: end)
  }
}


----- Swift.(file).Range.index(after:Range<Bound>.Index)
extension Range {
  public func index(after i: Index) -> Index {
    _failEarlyRangeCheck(i, bounds: startIndex..<endIndex)

    return i.advanced(by: 1)
  }
}


----- Swift.(file).Range.index(before:Range<Bound>.Index)
extension Range {
  public func index(before i: Index) -> Index {
    precondition(i > lowerBound)
    precondition(i <= upperBound)

    return i.advanced(by: -1)
  }
}


----- Swift.(file).Range.index(_:Range<Bound>.Index,offsetBy:Int)
extension Range {
  public func index(_ i: Index, offsetBy n: Int) -> Index {
    let r = i.advanced(by: numericCast(n))
    precondition(r >= lowerBound)
    precondition(r <= upperBound)
    return r
  }
}


----- Swift.(file).Range.distance(from:Range<Bound>.Index,to:Range<Bound>.Index)
extension Range {
  public func distance(from start: Index, to end: Index) -> Int {
    return numericCast(start.distance(to: end))
  }
}


----- Swift.(file).Range.hash(into:Hasher)
extension Range {
  public func hash(into hasher: inout Hasher) {
    hasher.combine(lowerBound)
    hasher.combine(upperBound)
  }
}


----- Swift.(file).PartialRangeFrom.Iterator
extension PartialRangeFrom {
  public struct Iterator: IteratorProtocol {
    @usableFromInline
    internal var _current: Bound
    @inlinable
    public init(_current: Bound) { self._current = _current }

    /// Advances to the next element and returns it, or `nil` if no next
    /// element exists.
    ///
    /// Once `nil` has been returned, all subsequent calls return `nil`.
    ///
    /// - Returns: The next element in the underlying sequence, if a next
    ///   element exists; otherwise, `nil`.
    @inlinable
    public mutating func next() -> Bound? {
      defer { _current = _current.advanced(by: 1) }
      return _current
    }
  }
}


----- Swift.(file).PartialRangeFrom.makeIterator()
extension PartialRangeFrom {
  public __consuming func makeIterator() -> Iterator {
    return Iterator(_current: lowerBound)
  }
}


----- Swift.(file).RangeReplaceableCollection.removeFirst()
extension RangeReplaceableCollection {
  public mutating func removeFirst() -> Element {
    precondition(!isEmpty, "Can't remove items from an empty collection")
    let element = first!
    self = self[index(after: startIndex)..<endIndex]
    return element
  }
}


----- Swift.(file).RangeReplaceableCollection.removeFirst(_:Int)
extension RangeReplaceableCollection {
  public mutating func removeFirst(_ k: Int) {
    if k == 0 { return }
    precondition(k >= 0, "Number of elements to remove should be non-negative")
    precondition(count >= k,
      "Can't remove more items from a collection than it contains")
    self = self[index(startIndex, offsetBy: k)..<endIndex]
  }
}


----- Swift.(file).RangeReplaceableCollection.popLast()
extension RangeReplaceableCollection {
  public mutating func popLast() -> Element? {
    if isEmpty { return nil }
    // duplicate of removeLast logic below, to avoid redundant precondition
    if let result = _customRemoveLast() { return result }
    return remove(at: index(before: endIndex))
  }
}


----- Swift.(file).RangeReplaceableCollection.removeLast()
extension RangeReplaceableCollection {
  public mutating func removeLast() -> Element {
    precondition(!isEmpty, "Can't remove last element from an empty collection")
    // NOTE if you change this implementation, change popLast above as well
    // AND change the tie-breaker implementations in the next extension
    if let result = _customRemoveLast() { return result }
    return remove(at: index(before: endIndex))
  }
}


----- Swift.(file).RangeReplaceableCollection.popLast()
extension RangeReplaceableCollection {
  public mutating func popLast() -> Element? {
    if isEmpty { return nil }
    // duplicate of removeLast logic below, to avoid redundant precondition
    if let result = _customRemoveLast() { return result }
    return remove(at: index(before: endIndex))
  }
}


----- Swift.(file).RangeReplaceableCollection.removeLast()
extension RangeReplaceableCollection {
  public mutating func removeLast() -> Element {
    precondition(!isEmpty, "Can't remove last element from an empty collection")
    // NOTE if you change this implementation, change popLast above as well
    if let result = _customRemoveLast() { return result }
    return remove(at: index(before: endIndex))
  }
}


----- Swift.(file).RangeReplaceableCollection.removeAll(where:(Self.Element) throws -> Bool)
extension RangeReplaceableCollection {
  public mutating func removeAll(
    where shouldBeRemoved: (Element) throws -> Bool
  ) rethrows {
    let suffixStart = try _halfStablePartition(isSuffixElement: shouldBeRemoved)
    removeSubrange(suffixStart...)
  }
}


----- Swift.(file).repeatElement(_:T,count:Int)
public func repeatElement<T>(_ element: T, count n: Int) -> Repeated<T> {
  return Repeated(_repeating: element, count: n)
}


----- Swift.(file).MutableCollection.reverse()
extension MutableCollection {
  public mutating func reverse() {
    if isEmpty { return }
    var f = startIndex
    var l = index(before: endIndex)
    while f < l {
      swapAt(f, l)
      formIndex(after: &f)
      formIndex(before: &l)
    }
  }
}


----- Swift.(file).Iterator.next()
extension Iterator {
  public mutating func next() -> Element? {
    guard _fastPath(_position != _base.startIndex) else { return nil }
    _base.formIndex(before: &_position)
    return _base[_position]
  }
}


----- Swift.(file).Index.==infix(_:ReversedCollection<Base>.Index,_:ReversedCollection<Base>.Index)
extension Index {
  public static func == (
    lhs: ReversedCollection<Base>.Index,
    rhs: ReversedCollection<Base>.Index
  ) -> Bool {
    // Note ReversedIndex has inverted logic compared to base Base.Index
    return lhs.base == rhs.base
  }
}


----- Swift.(file).Index.<infix(_:ReversedCollection<Base>.Index,_:ReversedCollection<Base>.Index)
extension Index {
  public static func < (
    lhs: ReversedCollection<Base>.Index,
    rhs: ReversedCollection<Base>.Index
  ) -> Bool {
    // Note ReversedIndex has inverted logic compared to base Base.Index
    return lhs.base > rhs.base
  }
}


----- Swift.(file).Index.hash(into:Hasher)
extension Index {
  public func hash(into hasher: inout Hasher) {
    hasher.combine(base)
  }
}


----- Swift.(file).BidirectionalCollection.reversed()
extension BidirectionalCollection {
  public __consuming func reversed() -> ReversedCollection<Self> {
    return ReversedCollection(_base: self)
  }
}


----- Swift.(file).DropFirstSequence.makeIterator()
extension DropFirstSequence {
  public __consuming func makeIterator() -> Iterator {
    var it = _base.makeIterator()
    var dropped = 0
    while dropped < _limit, it.next() != nil { dropped &+= 1 }
    return it
  }
}


----- Swift.(file).DropFirstSequence.dropFirst(_:Int)
extension DropFirstSequence {
  public __consuming func dropFirst(_ k: Int) -> DropFirstSequence<Base> {
    // If this is already a _DropFirstSequence, we need to fold in
    // the current drop count and drop limit so no data is lost.
    //
    // i.e. [1,2,3,4].dropFirst(1).dropFirst(1) should be equivalent to
    // [1,2,3,4].dropFirst(2).
    return DropFirstSequence(_base, dropping: _limit + k)
  }
}


----- Swift.(file).Iterator.next()
extension Iterator {
  public mutating func next() -> Element? {
    if _remaining != 0 {
      _remaining &-= 1
      return _base.next()
    } else {
      return nil
    }
  }
}


----- Swift.(file).PrefixSequence.makeIterator()
extension PrefixSequence {
  public __consuming func makeIterator() -> Iterator {
    return Iterator(_base.makeIterator(), maxLength: _maxLength)
  }
}


----- Swift.(file).PrefixSequence.prefix(_:Int)
extension PrefixSequence {
  public __consuming func prefix(_ maxLength: Int) -> PrefixSequence<Base> {
    let length = Swift.min(maxLength, self._maxLength)
    return PrefixSequence(_base, maxLength: length)
  }
}


----- Swift.(file).Iterator.next()
extension Iterator {
  public mutating func next() -> Element? {
    guard let next = _nextElement else { return nil }
    _nextElement = _iterator.next()
    return next
  }
}


----- Swift.(file).DropWhileSequence.makeIterator()
extension DropWhileSequence {
  public func makeIterator() -> Iterator {
    return Iterator(_iterator, nextElement: _nextElement)
  }
}


----- Swift.(file).DropWhileSequence.drop(while:(Base.Element) throws -> Bool)
extension DropWhileSequence {
  public __consuming func drop(
    while predicate: (Element) throws -> Bool
  ) rethrows -> DropWhileSequence<Base> {
    guard let x = _nextElement, try predicate(x) else { return self }
    return try DropWhileSequence(iterator: _iterator, predicate: predicate)
  }
}


----- Swift.(file).Sequence.split(separator:Self.Element,maxSplits:Int,omittingEmptySubsequences:Bool)
extension Sequence {
  public __consuming func split(
    separator: Element,
    maxSplits: Int = Int.max,
    omittingEmptySubsequences: Bool = true
  ) -> [ArraySlice<Element>] {
    return split(
      maxSplits: maxSplits,
      omittingEmptySubsequences: omittingEmptySubsequences,
      whereSeparator: { $0 == separator })
  }
}


----- Swift.(file).Sequence.drop(while:(Self.Element) throws -> Bool)
extension Sequence {
  public __consuming func drop(
    while predicate: (Element) throws -> Bool
  ) rethrows -> DropWhileSequence<Self> {
    return try DropWhileSequence(self, predicate: predicate)
  }
}


----- Swift.(file).IteratorSequence.next()
extension IteratorSequence {
  public mutating func next() -> Base.Element? {
    return _base.next()
  }
}


----- Swift.(file).Sequence.enumerated()
extension Sequence {
  public func enumerated() -> EnumeratedSequence<Self> {
    return EnumeratedSequence(_base: self)
  }
}


----- Swift.(file).Sequence.min()
extension Sequence {
  public func min() -> Element? {
    return self.min(by: <)
  }
}


----- Swift.(file).Sequence.max()
extension Sequence {
  public func max() -> Element? {
    return self.max(by: <)
  }
}


----- Swift.(file).Sequence.starts(with:PossiblePrefix)
extension Sequence {
  public func starts<PossiblePrefix: Sequence>(
    with possiblePrefix: PossiblePrefix
  ) -> Bool where PossiblePrefix.Element == Element {
    return self.starts(with: possiblePrefix, by: ==)
  }
}


----- Swift.(file).Sequence.elementsEqual(_:OtherSequence)
extension Sequence {
  public func elementsEqual<OtherSequence: Sequence>(
    _ other: OtherSequence
  ) -> Bool where OtherSequence.Element == Element {
    return self.elementsEqual(other, by: ==)
  }
}


----- Swift.(file).Sequence.lexicographicallyPrecedes(_:OtherSequence)
extension Sequence {
  public func lexicographicallyPrecedes<OtherSequence: Sequence>(
    _ other: OtherSequence
  ) -> Bool where OtherSequence.Element == Element {
    return self.lexicographicallyPrecedes(other, by: <)
  }
}


----- Swift.(file).Sequence.contains(_:Self.Element)
extension Sequence {
  public func contains(_ element: Element) -> Bool {
    if let result = _customContainsEquatableElement(element) {
      return result
    } else {
      return self.contains { $0 == element }
    }
  }
}


----- Swift.(file).Slice.index(after:Slice<Base>.Index)
extension Slice {
  public func index(after i: Index) -> Index {
    // FIXME: swift-3-indexing-model: range check.
    return _base.index(after: i)
  }
}


----- Swift.(file).Slice.formIndex(after:Slice<Base>.Index)
extension Slice {
  public func formIndex(after i: inout Index) {
    // FIXME: swift-3-indexing-model: range check.
    _base.formIndex(after: &i)
  }
}


----- Swift.(file).Slice.index(_:Slice<Base>.Index,offsetBy:Int)
extension Slice {
  public func index(_ i: Index, offsetBy n: Int) -> Index {
    // FIXME: swift-3-indexing-model: range check.
    return _base.index(i, offsetBy: n)
  }
}


----- Swift.(file).Slice.index(_:Slice<Base>.Index,offsetBy:Int,limitedBy:Slice<Base>.Index)
extension Slice {
  public func index(
    _ i: Index, offsetBy n: Int, limitedBy limit: Index
  ) -> Index? {
    // FIXME: swift-3-indexing-model: range check.
    return _base.index(i, offsetBy: n, limitedBy: limit)
  }
}


----- Swift.(file).Slice.distance(from:Slice<Base>.Index,to:Slice<Base>.Index)
extension Slice {
  public func distance(from start: Index, to end: Index) -> Int {
    // FIXME: swift-3-indexing-model: range check.
    return _base.distance(from: start, to: end)
  }
}


----- Swift.(file).Slice.index(before:Slice<Base>.Index)
extension Slice {
  public func index(before i: Index) -> Index {
    // FIXME: swift-3-indexing-model: range check.
    return _base.index(before: i)
  }
}


----- Swift.(file).Slice.formIndex(before:Slice<Base>.Index)
extension Slice {
  public func formIndex(before i: inout Index) {
    // FIXME: swift-3-indexing-model: range check.
    _base.formIndex(before: &i)
  }
}


----- Swift.(file).Slice.replaceSubrange(_:Range<Slice<Base>.Index>,with:C)
extension Slice {
  public mutating func replaceSubrange<C>(
    _ subRange: Range<Index>, with newElements: C
  ) where C : Collection, C.Element == Base.Element {

    // FIXME: swift-3-indexing-model: range check.
    let sliceOffset =
      _base.distance(from: _base.startIndex, to: _startIndex)
    let newSliceCount =
      _base.distance(from: _startIndex, to: subRange.lowerBound)
      + _base.distance(from: subRange.upperBound, to: _endIndex)
      + (numericCast(newElements.count) as Int)
    _base.replaceSubrange(subRange, with: newElements)
    _startIndex = _base.index(_base.startIndex, offsetBy: sliceOffset)
    _endIndex = _base.index(_startIndex, offsetBy: newSliceCount)
  }
}


----- Swift.(file).Slice.insert(_:Base.Element,at:Slice<Base>.Index)
extension Slice {
  public mutating func insert(_ newElement: Base.Element, at i: Index) {
    // FIXME: swift-3-indexing-model: range check.
    let sliceOffset = _base.distance(from: _base.startIndex, to: _startIndex)
    let newSliceCount = count + 1
    _base.insert(newElement, at: i)
    _startIndex = _base.index(_base.startIndex, offsetBy: sliceOffset)
    _endIndex = _base.index(_startIndex, offsetBy: newSliceCount)
  }
}


----- Swift.(file).Slice.insert(contentsOf:S,at:Slice<Base>.Index)
extension Slice {
  public mutating func insert<S>(contentsOf newElements: S, at i: Index)
  where S: Collection, S.Element == Base.Element {

    // FIXME: swift-3-indexing-model: range check.
    let sliceOffset = _base.distance(from: _base.startIndex, to: _startIndex)
    let newSliceCount = count + newElements.count
    _base.insert(contentsOf: newElements, at: i)
    _startIndex = _base.index(_base.startIndex, offsetBy: sliceOffset)
    _endIndex = _base.index(_startIndex, offsetBy: newSliceCount)
  }
}


----- Swift.(file).Slice.remove(at:Slice<Base>.Index)
extension Slice {
  public mutating func remove(at i: Index) -> Base.Element {
    // FIXME: swift-3-indexing-model: range check.
    let sliceOffset = _base.distance(from: _base.startIndex, to: _startIndex)
    let newSliceCount = count - 1
    let result = _base.remove(at: i)
    _startIndex = _base.index(_base.startIndex, offsetBy: sliceOffset)
    _endIndex = _base.index(_startIndex, offsetBy: newSliceCount)
    return result
  }
}


----- Swift.(file).Slice.removeSubrange(_:Range<Slice<Base>.Index>)
extension Slice {
  public mutating func removeSubrange(_ bounds: Range<Index>) {
    // FIXME: swift-3-indexing-model: range check.
    let sliceOffset = _base.distance(from: _base.startIndex, to: _startIndex)
    let newSliceCount =
      count - distance(from: bounds.lowerBound, to: bounds.upperBound)
    _base.removeSubrange(bounds)
    _startIndex = _base.index(_base.startIndex, offsetBy: sliceOffset)
    _endIndex = _base.index(_startIndex, offsetBy: newSliceCount)
  }
}


----- Swift.(file).Slice.replaceSubrange(_:Range<Slice<Base>.Index>,with:C)
extension Slice {
  public mutating func replaceSubrange<C>(
    _ subRange: Range<Index>, with newElements: C
  ) where C : Collection, C.Element == Base.Element {
    // FIXME: swift-3-indexing-model: range check.
    if subRange.lowerBound == _base.startIndex {
      let newSliceCount =
        _base.distance(from: _startIndex, to: subRange.lowerBound)
        + _base.distance(from: subRange.upperBound, to: _endIndex)
        + (numericCast(newElements.count) as Int)
      _base.replaceSubrange(subRange, with: newElements)
      _startIndex = _base.startIndex
      _endIndex = _base.index(_startIndex, offsetBy: newSliceCount)
    } else {
      let shouldUpdateStartIndex = subRange.lowerBound == _startIndex
      let lastValidIndex = _base.index(before: subRange.lowerBound)
      let newEndIndexOffset =
        _base.distance(from: subRange.upperBound, to: _endIndex)
        + (numericCast(newElements.count) as Int) + 1
      _base.replaceSubrange(subRange, with: newElements)
      if shouldUpdateStartIndex {
        _startIndex = _base.index(after: lastValidIndex)
      }
      _endIndex = _base.index(lastValidIndex, offsetBy: newEndIndexOffset)
    }
  }
}


----- Swift.(file).Slice.insert(_:Base.Element,at:Slice<Base>.Index)
extension Slice {
  public mutating func insert(_ newElement: Base.Element, at i: Index) {
    // FIXME: swift-3-indexing-model: range check.
    if i == _base.startIndex {
      let newSliceCount = count + 1
      _base.insert(newElement, at: i)
      _startIndex = _base.startIndex
      _endIndex = _base.index(_startIndex, offsetBy: newSliceCount)
    } else {
      let shouldUpdateStartIndex = i == _startIndex
      let lastValidIndex = _base.index(before: i)
      let newEndIndexOffset = _base.distance(from: i, to: _endIndex) + 2
      _base.insert(newElement, at: i)
      if shouldUpdateStartIndex {
        _startIndex = _base.index(after: lastValidIndex)
      }
      _endIndex = _base.index(lastValidIndex, offsetBy: newEndIndexOffset)
    }
  }
}


----- Swift.(file).Slice.insert(contentsOf:S,at:Slice<Base>.Index)
extension Slice {
  public mutating func insert<S>(contentsOf newElements: S, at i: Index)
  where S : Collection, S.Element == Base.Element {
    // FIXME: swift-3-indexing-model: range check.
    if i == _base.startIndex {
      let newSliceCount = count + numericCast(newElements.count)
      _base.insert(contentsOf: newElements, at: i)
      _startIndex = _base.startIndex
      _endIndex = _base.index(_startIndex, offsetBy: newSliceCount)
    } else {
      let shouldUpdateStartIndex = i == _startIndex
      let lastValidIndex = _base.index(before: i)
      let newEndIndexOffset =
        _base.distance(from: i, to: _endIndex)
        + numericCast(newElements.count) + 1
      _base.insert(contentsOf: newElements, at: i)
      if shouldUpdateStartIndex {
        _startIndex = _base.index(after: lastValidIndex)
      }
      _endIndex = _base.index(lastValidIndex, offsetBy: newEndIndexOffset)
    }
  }
}


----- Swift.(file).Slice.remove(at:Slice<Base>.Index)
extension Slice {
  public mutating func remove(at i: Index) -> Base.Element {
    // FIXME: swift-3-indexing-model: range check.
    if i == _base.startIndex {
      let newSliceCount = count - 1
      let result = _base.remove(at: i)
      _startIndex = _base.startIndex
      _endIndex = _base.index(_startIndex, offsetBy: newSliceCount)
      return result
    } else {
      let shouldUpdateStartIndex = i == _startIndex
      let lastValidIndex = _base.index(before: i)
      let newEndIndexOffset = _base.distance(from: i, to: _endIndex)
      let result = _base.remove(at: i)
      if shouldUpdateStartIndex {
        _startIndex = _base.index(after: lastValidIndex)
      }
      _endIndex = _base.index(lastValidIndex, offsetBy: newEndIndexOffset)
      return result
    }
  }
}


----- Swift.(file).Slice.removeSubrange(_:Range<Slice<Base>.Index>)
extension Slice {
  public mutating func removeSubrange(_ bounds: Range<Index>) {
    // FIXME: swift-3-indexing-model: range check.
    if bounds.lowerBound == _base.startIndex {
      let newSliceCount =
        count - _base.distance(from: bounds.lowerBound, to: bounds.upperBound)
      _base.removeSubrange(bounds)
      _startIndex = _base.startIndex
      _endIndex = _base.index(_startIndex, offsetBy: newSliceCount)
    } else {
      let shouldUpdateStartIndex = bounds.lowerBound == _startIndex
      let lastValidIndex = _base.index(before: bounds.lowerBound)
      let newEndIndexOffset =
          _base.distance(from: bounds.lowerBound, to: _endIndex)
        - _base.distance(from: bounds.lowerBound, to: bounds.upperBound)
        + 1
      _base.removeSubrange(bounds)
      if shouldUpdateStartIndex {
        _startIndex = _base.index(after: lastValidIndex)
      }
      _endIndex = _base.index(lastValidIndex, offsetBy: newEndIndexOffset)
    }
  }
}


----- Swift.(file).Sequence.sorted()
extension Sequence {
  public func sorted() -> [Element] {
    return sorted(by: <)
  }
}


----- Swift.(file).MutableCollection.sort()
extension MutableCollection {
  public mutating func sort() {
    sort(by: <)
  }
}


----- Swift.(file).StaticString.withUTF8Buffer(_:(UnsafeBufferPointer<UInt8>) -> R)
extension StaticString {
  public func withUTF8Buffer<R>(
    _ body: (UnsafeBufferPointer<UInt8>) -> R) -> R {
    if hasPointerRepresentation {
      return body(UnsafeBufferPointer(
        start: utf8Start, count: utf8CodeUnitCount))
    } else {
      var buffer: UInt64 = 0
      var i = 0
      let sink: (UInt8) -> Void = {
#if _endian(little)
        buffer = buffer | (UInt64($0) << (UInt64(i) * 8))
#else
        buffer = buffer | (UInt64($0) << (UInt64(7-i) * 8))
#endif
        i += 1
      }
      UTF8.encode(unicodeScalar, into: sink)
      return body(UnsafeBufferPointer(
        start: UnsafePointer(Builtin.addressof(&buffer)),
        count: i))
    }
  }
}


----- Swift.(file).StrideToIterator.next()
extension StrideToIterator {
  public mutating func next() -> Element? {
    let result = _current.value
    if _stride > 0 ? result >= _end : result <= _end {
      return nil
    }
    _current = Element._step(after: _current, from: _start, by: _stride)
    return result
  }
}


----- Swift.(file).StrideTo.makeIterator()
extension StrideTo {
  public __consuming func makeIterator() -> StrideToIterator<Element> {
    return StrideToIterator(_start: _start, end: _end, stride: _stride)
  }
}


----- Swift.(file).stride(from:T,to:T,by:T.Stride)
public func stride<T>(
  from start: T, to end: T, by stride: T.Stride
) -> StrideTo<T> {
  return StrideTo(_start: start, end: end, stride: stride)
}


----- Swift.(file).StrideThroughIterator.next()
extension StrideThroughIterator {
  public mutating func next() -> Element? {
    let result = _current.value
    if _stride > 0 ? result >= _end : result <= _end {
      // This check is needed because if we just changed the above operators
      // to > and <, respectively, we might advance current past the end
      // and throw it out of bounds (e.g. above Int.max) unnecessarily.
      if result == _end && !_didReturnEnd {
        _didReturnEnd = true
        return result
      }
      return nil
    }
    _current = Element._step(after: _current, from: _start, by: _stride)
    return result
  }
}


----- Swift.(file).StrideThrough.makeIterator()
extension StrideThrough {
  public __consuming func makeIterator() -> StrideThroughIterator<Element> {
    return StrideThroughIterator(_start: _start, end: _end, stride: _stride)
  }
}


----- Swift.(file).stride(from:T,through:T,by:T.Stride)
public func stride<T>(
  from start: T, through end: T, by stride: T.Stride
) -> StrideThrough<T> {
  return StrideThrough(_start: start, end: end, stride: stride)
}


----- Swift.(file).String.withCString(encodedAs:TargetEncoding.Type,_:(UnsafePointer<TargetEncoding.CodeUnit>) throws -> Result)
extension String {
  public func withCString<Result, TargetEncoding: Unicode.Encoding>(
    encodedAs targetEncoding: TargetEncoding.Type,
    _ body: (UnsafePointer<TargetEncoding.CodeUnit>) throws -> Result
  ) rethrows -> Result {
    if targetEncoding == UTF8.self {
      return try self.withCString {
        (cPtr: UnsafePointer<CChar>) -> Result  in
        _internalInvariant(UInt8.self == TargetEncoding.CodeUnit.self)
        let ptr = UnsafeRawPointer(cPtr).assumingMemoryBound(
          to: TargetEncoding.CodeUnit.self)
        return try body(ptr)
      }
    }
    return try _slowWithCString(encodedAs: targetEncoding, body)
  }
}


----- Swift.(file).Sequence.joined(separator:String)
extension Sequence {
  public func joined(separator: String = "") -> String {
    return _joined(separator: separator)
  }
}


----- Swift.(file).BidirectionalCollection.joined(separator:String)
extension BidirectionalCollection {
  public func joined(separator: String = "") -> String {
    return _joined(separator: separator)
  }
}


----- Swift.(file).String.lowercased()
extension String {
  public func lowercased() -> String {
    if _fastPath(_guts.isFastASCII) {
      return _guts.withFastUTF8 { utf8 in
        // TODO(String performance): We can directly call appendInPlace
        var result = String()
        result.reserveCapacity(utf8.count)
        for u8 in utf8 {
          result._guts.append(String(Unicode.Scalar(_lowercaseASCII(u8)))._guts)
        }
        return result
      }
    }

    // TODO(String performance): Try out incremental case-conversion rather than
    // make UTF-16 array beforehand
    let codeUnits = Array(self.utf16).withUnsafeBufferPointer {
      (uChars: UnsafeBufferPointer<UInt16>) -> Array<UInt16> in
      var result = Array<UInt16>(repeating: 0, count: uChars.count)
      let len = result.withUnsafeMutableBufferPointer {
        (output) -> Int in
        var err = __swift_stdlib_U_ZERO_ERROR
        return Int(truncatingIfNeeded:
          __swift_stdlib_u_strToLower(
            output.baseAddress._unsafelyUnwrappedUnchecked,
            Int32(output.count),
            uChars.baseAddress._unsafelyUnwrappedUnchecked,
            Int32(uChars.count),
            "",
            &err))
      }
      if len > uChars.count {
        var err = __swift_stdlib_U_ZERO_ERROR
        result = Array<UInt16>(repeating: 0, count: len)
        result.withUnsafeMutableBufferPointer {
          output -> Void in
          __swift_stdlib_u_strToLower(
            output.baseAddress._unsafelyUnwrappedUnchecked,
            Int32(output.count),
            uChars.baseAddress._unsafelyUnwrappedUnchecked,
            Int32(uChars.count),
            "",
            &err)
        }
      }
      return result
    }
    return codeUnits.withUnsafeBufferPointer { String._uncheckedFromUTF16($0) }
  }
}


----- Swift.(file).String.uppercased()
extension String {
  public func uppercased() -> String {
    if _fastPath(_guts.isFastASCII) {
      return _guts.withFastUTF8 { utf8 in
        // TODO(String performance): code-unit appendInPlace on guts
        var result = String()
        result.reserveCapacity(utf8.count)
        for u8 in utf8 {
          result._guts.append(String(Unicode.Scalar(_uppercaseASCII(u8)))._guts)
        }
        return result
      }
    }

    // TODO(String performance): Try out incremental case-conversion rather than
    // make UTF-16 array beforehand
    let codeUnits = Array(self.utf16).withUnsafeBufferPointer {
      (uChars: UnsafeBufferPointer<UInt16>) -> Array<UInt16> in
      var result = Array<UInt16>(repeating: 0, count: uChars.count)
      let len = result.withUnsafeMutableBufferPointer {
        (output) -> Int in
        var err = __swift_stdlib_U_ZERO_ERROR
        return Int(truncatingIfNeeded:
          __swift_stdlib_u_strToUpper(
            output.baseAddress._unsafelyUnwrappedUnchecked,
            Int32(output.count),
            uChars.baseAddress._unsafelyUnwrappedUnchecked,
            Int32(uChars.count),
            "",
            &err))
      }
      if len > uChars.count {
        var err = __swift_stdlib_U_ZERO_ERROR
        result = Array<UInt16>(repeating: 0, count: len)
        result.withUnsafeMutableBufferPointer {
          output -> Void in
          __swift_stdlib_u_strToUpper(
            output.baseAddress._unsafelyUnwrappedUnchecked,
            Int32(output.count),
            uChars.baseAddress._unsafelyUnwrappedUnchecked,
            Int32(uChars.count),
            "",
            &err)
        }
      }
      return result
    }
    return codeUnits.withUnsafeBufferPointer { String._uncheckedFromUTF16($0) }
  }
}


----- Swift.(file).String.index(after:String.Index)
extension String {
  public func index(after i: Index) -> Index {
    precondition(i < endIndex, "String index is out of bounds")

    // TODO: known-ASCII fast path, single-scalar-grapheme fast path, etc.
    let stride = _characterStride(startingAt: i)
    let nextOffset = i.encodedOffset &+ stride
    let nextStride = _characterStride(
      startingAt: Index(encodedOffset: nextOffset))

    return Index(
      encodedOffset: nextOffset, characterStride: nextStride)
  }
}


----- Swift.(file).String.index(before:String.Index)
extension String {
  public func index(before i: Index) -> Index {
    precondition(i > startIndex, "String index is out of bounds")

    // TODO: known-ASCII fast path, single-scalar-grapheme fast path, etc.
    let stride = _characterStride(endingAt: i)
    let priorOffset = i.encodedOffset &- stride
    return Index(encodedOffset: priorOffset, characterStride: stride)
  }
}


----- Swift.(file).String.index(_:String.Index,offsetBy:String.IndexDistance)
extension String {
  public func index(_ i: Index, offsetBy n: IndexDistance) -> Index {
    // TODO: known-ASCII and single-scalar-grapheme fast path, etc.
    return _index(i, offsetBy: n)
  }
}


----- Swift.(file).String.index(_:String.Index,offsetBy:String.IndexDistance,limitedBy:String.Index)
extension String {
  public func index(
    _ i: Index, offsetBy n: IndexDistance, limitedBy limit: Index
  ) -> Index? {
    // TODO: known-ASCII and single-scalar-grapheme fast path, etc.
    return _index(i, offsetBy: n, limitedBy: limit)
  }
}


----- Swift.(file).String.distance(from:String.Index,to:String.Index)
extension String {
  public func distance(from start: Index, to end: Index) -> IndexDistance {
    // TODO: known-ASCII and single-scalar-grapheme fast path, etc.
    return _distance(from: start, to: end)
  }
}


----- Swift.(file).String.Iterator
extension String {
  public struct Iterator: IteratorProtocol {
    @usableFromInline
    internal var _guts: _StringGuts

    @usableFromInline
    internal var _position: Int = 0

    @usableFromInline
    internal var _end: Int

    @inlinable
    internal init(_ guts: _StringGuts) {
      self._end = guts.count
      self._guts = guts
    }

    @inlinable
    public mutating func next() -> Character? {
      guard _fastPath(_position < _end) else { return nil }

      let len = _guts._opaqueCharacterStride(startingAt: _position)
      let nextPosition = _position &+ len
      let result = _guts.errorCorrectedCharacter(
        startingAt: _position, endingAt: nextPosition)
      _position = nextPosition
      return result
    }
  }
}


----- Swift.(file).String.makeIterator()
extension String {
  public __consuming func makeIterator() -> Iterator {
    return Iterator(_guts)
  }
}


----- Swift.(file).StringProtocol.==infix(_:Self,_:RHS)
extension StringProtocol {
  public static func == <RHS: StringProtocol>(lhs: Self, rhs: RHS) -> Bool {
    return _stringCompare(
      lhs._wholeGuts, lhs._offsetRange,
      rhs._wholeGuts, rhs._offsetRange,
      expecting: .equal)
  }
}


----- Swift.(file).StringProtocol.<infix(_:Self,_:RHS)
extension StringProtocol {
  public static func < <RHS: StringProtocol>(lhs: Self, rhs: RHS) -> Bool {
    return _stringCompare(
      lhs._wholeGuts, lhs._offsetRange,
      rhs._wholeGuts, rhs._offsetRange,
      expecting: .less)
  }
}


----- Swift.(file).String.==infix(_:String,_:String)
extension String {
  public static func == (lhs: String, rhs: String) -> Bool {
    return _stringCompare(lhs._guts, rhs._guts, expecting: .equal)
  }
}


----- Swift.(file).String.<infix(_:String,_:String)
extension String {
  public static func < (lhs: String, rhs: String) -> Bool {
    return _stringCompare(lhs._guts, rhs._guts, expecting: .less)
  }
}


----- Swift.(file).String.hash(into:Hasher)
extension String {
  public func hash(into hasher: inout Hasher) {
    if _fastPath(self._guts.isNFCFastUTF8) {
      self._guts.withFastUTF8 {
        hasher.combine(bytes: UnsafeRawBufferPointer($0))
      }
      hasher.combine(0xFF as UInt8) // terminator
      return
    }

    _gutsSlice._normalizedHash(into: &hasher)
  }
}


----- Swift.(file).StringProtocol.hash(into:Hasher)
extension StringProtocol {
  public func hash(into hasher: inout Hasher) {
    _gutsSlice._normalizedHash(into: &hasher)
  }
}


----- Swift.(file).String.Index
extension String {
  public struct Index {
    @usableFromInline
    internal var _rawBits: UInt64

    @inlinable @inline(__always)
    init(_ raw: UInt64) {
      self._rawBits = raw
      self._invariantCheck()
    }
  }
}


----- Swift.(file).Index.==infix(_:<<error type>>,_:<<error type>>)
extension Index {
  public static func == (lhs: String.Index, rhs: String.Index) -> Bool {
    return lhs.orderingValue == rhs.orderingValue
  }
}


----- Swift.(file).Index.<infix(_:<<error type>>,_:<<error type>>)
extension Index {
  public static func < (lhs: String.Index, rhs: String.Index) -> Bool {
    return lhs.orderingValue < rhs.orderingValue
  }
}


----- Swift.(file).Index.hash(into:Hasher)
extension Index {
  public func hash(into hasher: inout Hasher) {
    hasher.combine(orderingValue)
  }
}


----- Swift.(file).Index.samePosition(in:String.UTF8View)
extension Index {
  public func samePosition(
    in utf8: String.UTF8View
    ) -> String.UTF8View.Index? {
    return String.UTF8View.Index(self, within: utf8)
  }
}


----- Swift.(file).Index.samePosition(in:String.UTF16View)
extension Index {
  public func samePosition(
    in utf16: String.UTF16View
  ) -> String.UTF16View.Index? {
    return String.UTF16View.Index(self, within: utf16)
  }
}


----- Swift.(file).DefaultStringInterpolation.appendInterpolation(_:T)
extension DefaultStringInterpolation {
  public mutating func appendInterpolation<T>(_ value: T) {
    _print_unlocked(value, &self)
  }
}


----- Swift.(file).DefaultStringInterpolation.write(_:String)
extension DefaultStringInterpolation {
  public mutating func write(_ string: String) {
    _storage.append(string)
  }
}


----- Swift.(file).String.init(repeating:String,count:Int)
extension String {
  public init(repeating repeatedValue: String, count: Int) {
    precondition(count >= 0, "Negative count not allowed")
    guard count > 1 else {
      self = count == 0 ? "" : repeatedValue
      return
    }

    // TODO(String performance): We can directly call appendInPlace
    var result = String()
    result.reserveCapacity(repeatedValue._guts.count &* count)
    for _ in 0..<count {
      result += repeatedValue
    }
    self = result
  }
}


----- Swift.(file).String.hasPrefix(_:String)
extension String {
  public func hasPrefix(_ prefix: String) -> Bool {
    if _fastPath(self._guts.isNFCFastUTF8 && prefix._guts.isNFCFastUTF8) {
      guard prefix._guts.count <= self._guts.count else { return false }
      return prefix._guts.withFastUTF8 { nfcPrefix in
        let prefixEnd = nfcPrefix.count
        return self._guts.withFastUTF8(range: 0..<prefixEnd) { nfcSlicedSelf in
          return _binaryCompare(nfcSlicedSelf, nfcPrefix) == 0
        }
      }
    }

    return starts(with: prefix)
  }
}


----- Swift.(file).String.hasSuffix(_:String)
extension String {
  public func hasSuffix(_ suffix: String) -> Bool {
    if _fastPath(self._guts.isNFCFastUTF8 && suffix._guts.isNFCFastUTF8) {
      guard suffix._guts.count <= self._guts.count else { return false }
      return suffix._guts.withFastUTF8 { nfcSuffix in
        let suffixStart = self._guts.count - nfcSuffix.count
        return self._guts.withFastUTF8(range: suffixStart..<self._guts.count) {
          nfcSlicedSelf in return _binaryCompare(nfcSlicedSelf, nfcSuffix) == 0
        }
      }
    }

    return self.reversed().starts(with: suffix.reversed())
  }
}


----- Swift.(file).String.reserveCapacity(_:Int)
extension String {
  public mutating func reserveCapacity(_ n: Int) {
    self._guts.reserveCapacity(n)
  }
}


----- Swift.(file).String.append(_:String)
extension String {
  public mutating func append(_ other: String) {
    if self.isEmpty && !_guts.hasNativeStorage {
      self = other
      return
    }
    self._guts.append(other._guts)
  }
}


----- Swift.(file).String.append(_:Character)
extension String {
  public mutating func append(_ c: Character) {
    self.append(c._str)
  }
}


----- Swift.(file).String.append(contentsOf:Substring)
extension String {
  public mutating func append(contentsOf newElements: Substring) {
    self._guts.append(newElements._gutsSlice)
  }
}


----- Swift.(file).String.append(contentsOf:S)
extension String {
  public mutating func append<S : Sequence>(contentsOf newElements: S)
  where S.Iterator.Element == Character {
    if let str = newElements as? String {
      self.append(str)
      return
    }
    if let substr = newElements as? Substring {
      self.append(contentsOf: substr)
      return
    }
    for c in newElements {
      self.append(c._str)
    }
  }
}


----- Swift.(file).String.replaceSubrange(_:Range<String.Index>,with:C)
extension String {
  public mutating func replaceSubrange<C>(
    _ bounds: Range<Index>,
    with newElements: C
  ) where C : Collection, C.Iterator.Element == Character {
    _guts.replaceSubrange(bounds, with: newElements)
  }
}


----- Swift.(file).String.insert(_:Character,at:String.Index)
extension String {
  public mutating func insert(_ newElement: Character, at i: Index) {
    self.replaceSubrange(i..<i, with: newElement._str)
  }
}


----- Swift.(file).String.remove(at:String.Index)
extension String {
  public mutating func remove(at i: Index) -> Character {
    let result = self[i]
    _guts.remove(from: i, to: self.index(after: i))
    return result
  }
}


----- Swift.(file).String.removeSubrange(_:Range<String.Index>)
extension String {
  public mutating func removeSubrange(_ bounds: Range<Index>) {
    _guts.remove(from: bounds.lowerBound, to: bounds.upperBound)
  }
}


----- Swift.(file).String.removeAll(keepingCapacity:Bool)
extension String {
  public mutating func removeAll(keepingCapacity keepCapacity: Bool = false) {
    guard keepCapacity else {
      self = ""
      return
    }
    _guts.clear()
  }
}


----- Swift.(file).String.UTF16View
extension String {
  public struct UTF16View {
    @usableFromInline
    internal var _guts: _StringGuts

    @inlinable
    internal init(_ guts: _StringGuts) {
      self._guts = guts
      _invariantCheck()
    }
  }
}


----- Swift.(file).UTF16View.index(after:String.UTF16View.Index)
extension UTF16View {
  public func index(after i: Index) -> Index {
    if _slowPath(_guts.isForeign) { return _foreignIndex(after: i) }
    if _guts.isASCII { return i.nextEncoded }

    // For a BMP scalar (1-3 UTF-8 code units), advance past it. For a non-BMP
    // scalar, use a transcoded offset first.
    let len = _guts.fastUTF8ScalarLength(startingAt: i.encodedOffset)
    if len == 4 && i.transcodedOffset == 0 {
      return i.nextTranscoded
    }
    return i.strippingTranscoding.encoded(offsetBy: len)
  }
}


----- Swift.(file).UTF16View.index(before:String.UTF16View.Index)
extension UTF16View {
  public func index(before i: Index) -> Index {
    precondition(!i.isZeroPosition)
    if _slowPath(_guts.isForeign) { return _foreignIndex(before: i) }
    if _guts.isASCII { return i.priorEncoded }

    if i.transcodedOffset != 0 {
      _internalInvariant(i.transcodedOffset == 1)
      return i.strippingTranscoding
    }

    let len = _guts.fastUTF8ScalarLength(endingAt: i.encodedOffset)
    if len == 4 {
      // 2 UTF-16 code units comprise this scalar; advance to the beginning and
      // start mid-scalar transcoding
      return i.encoded(offsetBy: -len).nextTranscoded
    }

    // Single UTF-16 code unit
    _internalInvariant((1...3) ~= len)
    return i.encoded(offsetBy: -len)
  }
}


----- Swift.(file).UTF16View.index(_:String.UTF16View.Index,offsetBy:Int)
extension UTF16View {
  public func index(_ i: Index, offsetBy n: Int) -> Index {
    if _slowPath(_guts.isForeign) {
      return _foreignIndex(i, offsetBy: n)
    }

    let lowerOffset = _nativeGetOffset(for: i)
    let result = _nativeGetIndex(for: lowerOffset + n)
    return result
  }
}


----- Swift.(file).UTF16View.index(_:String.UTF16View.Index,offsetBy:Int,limitedBy:String.UTF16View.Index)
extension UTF16View {
  public func index(
    _ i: Index, offsetBy n: Int, limitedBy limit: Index
  ) -> Index? {
    if _slowPath(_guts.isForeign) {
      return _foreignIndex(i, offsetBy: n, limitedBy: limit)
    }

    let iOffset = _nativeGetOffset(for: i)
    let limitOffset = _nativeGetOffset(for: limit)

    // If distance < 0, limit has no effect if it is greater than i.
    if _slowPath(n < 0 && limit <= i && limitOffset > iOffset + n) {
      return nil
    }
    // If distance > 0, limit has no effect if it is less than i.
    if _slowPath(n >= 0 && limit >= i && limitOffset < iOffset + n) {
      return nil
    }

    let result = _nativeGetIndex(for: iOffset + n)
    return result
  }
}


----- Swift.(file).UTF16View.distance(from:String.UTF16View.Index,to:String.UTF16View.Index)
extension UTF16View {
  public func distance(from start: Index, to end: Index) -> Int {
    if _slowPath(_guts.isForeign) {
      return _foreignDistance(from: start, to: end)
    }

    let lower = _nativeGetOffset(for: start)
    let upper = _nativeGetOffset(for: end)
    return upper &- lower
  }
}


----- Swift.(file).UTF16View.Iterator
extension UTF16View {
  public struct Iterator: IteratorProtocol {
    @usableFromInline
    internal var _guts: _StringGuts

    @usableFromInline
    internal var _position: Int = 0

    @usableFromInline
    internal var _end: Int

    // If non-nil, return this value for `next()` (and set it to nil).
    //
    // This is set when visiting a non-BMP scalar: the leading surrogate is
    // returned, this field is set with the value of the trailing surrogate, and
    // `_position` is advanced to the start of the next scalar.
    @usableFromInline
    internal var _nextIsTrailingSurrogate: UInt16? = nil

    @inlinable
    internal init(_ guts: _StringGuts) {
      self._end = guts.count
      self._guts = guts
    }

    @inlinable
    public mutating func next() -> UInt16? {
      if _slowPath(_nextIsTrailingSurrogate != nil) {
        let trailing = self._nextIsTrailingSurrogate._unsafelyUnwrappedUnchecked
        self._nextIsTrailingSurrogate = nil
        return trailing
      }
      guard _fastPath(_position < _end) else { return nil }

      let (scalar, len) = _guts.errorCorrectedScalar(startingAt: _position)
      _position &+= len

      if _slowPath(scalar.value > UInt16.max) {
        self._nextIsTrailingSurrogate = scalar.utf16[1]
        return scalar.utf16[0]
      }
      return UInt16(truncatingIfNeeded: scalar.value)
    }
  }
}


----- Swift.(file).UTF16View.makeIterator()
extension UTF16View {
  public __consuming func makeIterator() -> Iterator {
    return Iterator(_guts)
  }
}


----- Swift.(file).Index.samePosition(in:String.UnicodeScalarView)
extension Index {
  public func samePosition(
    in unicodeScalars: String.UnicodeScalarView
  ) -> String.UnicodeScalarIndex? {
    return String.UnicodeScalarIndex(self, within: unicodeScalars)
  }
}


----- Swift.(file).String.UTF8View
extension String {
  public struct UTF8View {
    @usableFromInline
    internal var _guts: _StringGuts

    @inlinable @inline(__always)
    internal init(_ guts: _StringGuts) {
      self._guts = guts
      _invariantCheck()
    }
  }
}


----- Swift.(file).UTF8View.index(after:String.UTF8View.Index)
extension UTF8View {
  public func index(after i: Index) -> Index {
    if _fastPath(_guts.isFastUTF8) {
      return i.nextEncoded
    }

    return _foreignIndex(after: i)
  }
}


----- Swift.(file).UTF8View.index(before:String.UTF8View.Index)
extension UTF8View {
  public func index(before i: Index) -> Index {
    precondition(!i.isZeroPosition)
    if _fastPath(_guts.isFastUTF8) {
      return i.priorEncoded
    }

    return _foreignIndex(before: i)
  }
}


----- Swift.(file).UTF8View.index(_:String.UTF8View.Index,offsetBy:Int)
extension UTF8View {
  public func index(_ i: Index, offsetBy n: Int) -> Index {
    if _fastPath(_guts.isFastUTF8) {
      precondition(n + i.encodedOffset <= _guts.count)
      return i.encoded(offsetBy: n)
    }

    return _foreignIndex(i, offsetBy: n)
  }
}


----- Swift.(file).UTF8View.index(_:String.UTF8View.Index,offsetBy:Int,limitedBy:String.UTF8View.Index)
extension UTF8View {
  public func index(
    _ i: Index, offsetBy n: Int, limitedBy limit: Index
  ) -> Index? {
    if _fastPath(_guts.isFastUTF8) {
      // Check the limit: ignore limit if it precedes `i` (in the correct
      // direction), otherwise must not be beyond limit (in the correct
      // direction).
      let iOffset = i.encodedOffset
      let result = iOffset + n
      let limitOffset = limit.encodedOffset
      if n >= 0 {
        guard limitOffset < iOffset || result <= limitOffset else { return nil }
      } else {
        guard limitOffset > iOffset || result >= limitOffset else { return nil }
      }
      return Index(encodedOffset: result)
    }

    return _foreignIndex(i, offsetBy: n, limitedBy: limit)
  }
}


----- Swift.(file).UTF8View.distance(from:String.UTF8View.Index,to:String.UTF8View.Index)
extension UTF8View {
  public func distance(from i: Index, to j: Index) -> Int {
    if _fastPath(_guts.isFastUTF8) {
      return j.encodedOffset &- i.encodedOffset
    }
    return _foreignDistance(from: i, to: j)
  }
}


----- Swift.(file).UTF8View.withContiguousStorageIfAvailable(_:(UnsafeBufferPointer<String.UTF8View.Element>) throws -> R)
extension UTF8View {
  public func withContiguousStorageIfAvailable<R>(
    _ body: (UnsafeBufferPointer<Element>) throws -> R
  ) rethrows -> R? {
    guard _guts.isFastUTF8 else { return nil }
    return try _guts.withFastUTF8(body)
  }
}


----- Swift.(file).String.UnicodeScalarView
extension String {
  public struct UnicodeScalarView {
    @usableFromInline
    internal var _guts: _StringGuts

    @inlinable @inline(__always)
    internal init(_ _guts: _StringGuts) {
      self._guts = _guts
      _invariantCheck()
    }
  }
}


----- Swift.(file).UnicodeScalarView.index(after:String.UnicodeScalarView.Index)
extension UnicodeScalarView {
  public func index(after i: Index) -> Index {
    _internalInvariant(i < endIndex)
    // TODO(String performance): isASCII fast-path

    if _fastPath(_guts.isFastUTF8) {
      let len = _guts.fastUTF8ScalarLength(startingAt: i.encodedOffset)
      return i.encoded(offsetBy: len)
    }

    return _foreignIndex(after: i)
  }
}


----- Swift.(file).UnicodeScalarView.index(before:String.UnicodeScalarView.Index)
extension UnicodeScalarView {
  public func index(before i: Index) -> Index {
    precondition(i.encodedOffset > 0)
    // TODO(String performance): isASCII fast-path

    if _fastPath(_guts.isFastUTF8) {
      let len = _guts.withFastUTF8 { utf8 -> Int in
        return _utf8ScalarLength(utf8, endingAt: i.encodedOffset)
      }
      _internalInvariant(len <= 4, "invalid UTF8")
      return i.encoded(offsetBy: -len)
    }

    return _foreignIndex(before: i)
  }
}


----- Swift.(file).UnicodeScalarView.Iterator
extension UnicodeScalarView {
  public struct Iterator: IteratorProtocol {
    @usableFromInline
    internal var _guts: _StringGuts

    @usableFromInline
    internal var _position: Int = 0

    @usableFromInline
    internal var _end: Int

    @inlinable
    internal init(_ guts: _StringGuts) {
      self._end = guts.count
      self._guts = guts
    }

    @inlinable
    public mutating func next() -> Unicode.Scalar? {
      guard _fastPath(_position < _end) else { return nil }

      let (result, len) = _guts.errorCorrectedScalar(startingAt: _position)
      _position &+= len
      return result
    }
  }
}


----- Swift.(file).UnicodeScalarView.makeIterator()
extension UnicodeScalarView {
  public __consuming func makeIterator() -> Iterator {
    return Iterator(_guts)
  }
}


----- Swift.(file).UnicodeScalarView.reserveCapacity(_:Int)
extension UnicodeScalarView {
  public mutating func reserveCapacity(_ n: Int) {
    self._guts.reserveCapacity(n)
  }
}


----- Swift.(file).UnicodeScalarView.append(_:Unicode.Scalar)
extension UnicodeScalarView {
  public mutating func append(_ c: Unicode.Scalar) {
    self._guts.append(String(c)._guts)
  }
}


----- Swift.(file).UnicodeScalarView.append(contentsOf:S)
extension UnicodeScalarView {
  public mutating func append<S : Sequence>(contentsOf newElements: S)
  where S.Element == Unicode.Scalar {
    // TODO(String performance): Skip extra String allocation
    let scalars = String(decoding: newElements.map { $0.value }, as: UTF32.self)
    self = (String(self._guts) + scalars).unicodeScalars
  }
}


----- Swift.(file).UnicodeScalarView.replaceSubrange(_:Range<String.UnicodeScalarView.Index>,with:C)
extension UnicodeScalarView {
  public mutating func replaceSubrange<C>(
    _ bounds: Range<Index>,
    with newElements: C
  ) where C : Collection, C.Element == Unicode.Scalar {
    // TODO(String performance): Skip extra String and Array allocation

    let utf8Replacement = newElements.flatMap { String($0).utf8 }
    let replacement = utf8Replacement.withUnsafeBufferPointer {
      return String._uncheckedFromUTF8($0)
    }
    var copy = String(_guts)
    copy.replaceSubrange(bounds, with: replacement)
    self = copy.unicodeScalars
  }
}


----- Swift.(file).Index.samePosition(in:String)
extension Index {
  public func samePosition(in characters: String) -> String.Index? {
    return String.Index(self, within: characters)
  }
}


----- Swift.(file).Substring.index(after:Substring.Index)
extension Substring {
  public func index(after i: Index) -> Index {
    precondition(i < endIndex, "Cannot increment beyond endIndex")
    precondition(i >= startIndex, "Cannot increment an invalid index")
    return _slice.index(after: i)
  }
}


----- Swift.(file).Substring.index(before:Substring.Index)
extension Substring {
  public func index(before i: Index) -> Index {
    precondition(i <= endIndex, "Cannot decrement an invalid index")
    precondition(i > startIndex, "Cannot decrement beyond startIndex")
    return _slice.index(before: i)
  }
}


----- Swift.(file).Substring.index(_:Substring.Index,offsetBy:Int)
extension Substring {
  public func index(_ i: Index, offsetBy n: Int) -> Index {
    let result = _slice.index(i, offsetBy: n)
    precondition(
      (_slice._startIndex ... _slice.endIndex).contains(result),
      "Operation results in an invalid index")
    return result
  }
}


----- Swift.(file).Substring.index(_:Substring.Index,offsetBy:Int,limitedBy:Substring.Index)
extension Substring {
  public func index(
    _ i: Index, offsetBy n: Int, limitedBy limit: Index
  ) -> Index? {
    let result = _slice.index(i, offsetBy: n, limitedBy: limit)
    precondition(result.map {
        (_slice._startIndex ... _slice.endIndex).contains($0)
      } ?? true,
      "Operation results in an invalid index")
    return result
  }
}


----- Swift.(file).Substring.distance(from:Substring.Index,to:Substring.Index)
extension Substring {
  public func distance(from start: Index, to end: Index) -> Int {
    return _slice.distance(from: start, to: end)
  }
}


----- Swift.(file).Substring.replaceSubrange(_:Range<Substring.Index>,with:C)
extension Substring {
  public mutating func replaceSubrange<C>(
    _ bounds: Range<Index>,
    with newElements: C
  ) where C : Collection, C.Iterator.Element == Iterator.Element {
    _slice.replaceSubrange(bounds, with: newElements)
  }
}


----- Swift.(file).Substring.replaceSubrange(_:Range<Substring.Index>,with:Substring)
extension Substring {
  public mutating func replaceSubrange(
    _ bounds: Range<Index>, with newElements: Substring
  ) {
    replaceSubrange(bounds, with: newElements._slice)
  }
}


----- Swift.(file).UTF8View.index(after:Substring.UTF8View.Index)
extension UTF8View {
  public func index(after i: Index) -> Index { return _slice.index(after: i) }
}


----- Swift.(file).UTF8View.formIndex(after:Substring.UTF8View.Index)
extension UTF8View {
  public func formIndex(after i: inout Index) {
    _slice.formIndex(after: &i)
  }
}


----- Swift.(file).UTF8View.index(_:Substring.UTF8View.Index,offsetBy:Int)
extension UTF8View {
  public func index(_ i: Index, offsetBy n: Int) -> Index {
    return _slice.index(i, offsetBy: n)
  }
}


----- Swift.(file).UTF8View.index(_:Substring.UTF8View.Index,offsetBy:Int,limitedBy:Substring.UTF8View.Index)
extension UTF8View {
  public func index(
    _ i: Index, offsetBy n: Int, limitedBy limit: Index
  ) -> Index? {
    return _slice.index(i, offsetBy: n, limitedBy: limit)
  }
}


----- Swift.(file).UTF8View.distance(from:Substring.UTF8View.Index,to:Substring.UTF8View.Index)
extension UTF8View {
  public func distance(from start: Index, to end: Index) -> Int {
    return _slice.distance(from: start, to: end)
  }
}


----- Swift.(file).UTF8View.index(before:Substring.UTF8View.Index)
extension UTF8View {
  public func index(before i: Index) -> Index { return _slice.index(before: i) }
}


----- Swift.(file).UTF8View.formIndex(before:Substring.UTF8View.Index)
extension UTF8View {
  public func formIndex(before i: inout Index) {
    _slice.formIndex(before: &i)
  }
}


----- Swift.(file).UTF16View.index(after:Substring.UTF16View.Index)
extension UTF16View {
  public func index(after i: Index) -> Index { return _slice.index(after: i) }
}


----- Swift.(file).UTF16View.formIndex(after:Substring.UTF16View.Index)
extension UTF16View {
  public func formIndex(after i: inout Index) {
    _slice.formIndex(after: &i)
  }
}


----- Swift.(file).UTF16View.index(_:Substring.UTF16View.Index,offsetBy:Int)
extension UTF16View {
  public func index(_ i: Index, offsetBy n: Int) -> Index {
    return _slice.index(i, offsetBy: n)
  }
}


----- Swift.(file).UTF16View.index(_:Substring.UTF16View.Index,offsetBy:Int,limitedBy:Substring.UTF16View.Index)
extension UTF16View {
  public func index(
    _ i: Index, offsetBy n: Int, limitedBy limit: Index
  ) -> Index? {
    return _slice.index(i, offsetBy: n, limitedBy: limit)
  }
}


----- Swift.(file).UTF16View.distance(from:Substring.UTF16View.Index,to:Substring.UTF16View.Index)
extension UTF16View {
  public func distance(from start: Index, to end: Index) -> Int {
    return _slice.distance(from: start, to: end)
  }
}


----- Swift.(file).UTF16View.index(before:Substring.UTF16View.Index)
extension UTF16View {
  public func index(before i: Index) -> Index { return _slice.index(before: i) }
}


----- Swift.(file).UTF16View.formIndex(before:Substring.UTF16View.Index)
extension UTF16View {
  public func formIndex(before i: inout Index) {
    _slice.formIndex(before: &i)
  }
}


----- Swift.(file).UnicodeScalarView.index(after:Substring.UnicodeScalarView.Index)
extension UnicodeScalarView {
  public func index(after i: Index) -> Index { return _slice.index(after: i) }
}


----- Swift.(file).UnicodeScalarView.formIndex(after:Substring.UnicodeScalarView.Index)
extension UnicodeScalarView {
  public func formIndex(after i: inout Index) {
    _slice.formIndex(after: &i)
  }
}


----- Swift.(file).UnicodeScalarView.index(_:Substring.UnicodeScalarView.Index,offsetBy:Int)
extension UnicodeScalarView {
  public func index(_ i: Index, offsetBy n: Int) -> Index {
    return _slice.index(i, offsetBy: n)
  }
}


----- Swift.(file).UnicodeScalarView.index(_:Substring.UnicodeScalarView.Index,offsetBy:Int,limitedBy:Substring.UnicodeScalarView.Index)
extension UnicodeScalarView {
  public func index(
    _ i: Index, offsetBy n: Int, limitedBy limit: Index
  ) -> Index? {
    return _slice.index(i, offsetBy: n, limitedBy: limit)
  }
}


----- Swift.(file).UnicodeScalarView.distance(from:Substring.UnicodeScalarView.Index,to:Substring.UnicodeScalarView.Index)
extension UnicodeScalarView {
  public func distance(from start: Index, to end: Index) -> Int {
    return _slice.distance(from: start, to: end)
  }
}


----- Swift.(file).UnicodeScalarView.index(before:Substring.UnicodeScalarView.Index)
extension UnicodeScalarView {
  public func index(before i: Index) -> Index { return _slice.index(before: i) }
}


----- Swift.(file).UnicodeScalarView.formIndex(before:Substring.UnicodeScalarView.Index)
extension UnicodeScalarView {
  public func formIndex(before i: inout Index) {
    _slice.formIndex(before: &i)
  }
}


----- Swift.(file).UnicodeScalarView.replaceSubrange(_:Range<Substring.UnicodeScalarView.Index>,with:C)
extension UnicodeScalarView {
  public mutating func replaceSubrange<C : Collection>(
    _ target: Range<Index>, with replacement: C
  ) where C.Element == Element {
    _slice.replaceSubrange(target, with: replacement)
  }
}


----- Swift.(file)._UIntBuffer.Iterator
extension _UIntBuffer {
  public struct Iterator : IteratorProtocol, Sequence {
    @inlinable
    @inline(__always)
    public init(_ x: _UIntBuffer) { _impl = x }

    @inlinable
    @inline(__always)
    public mutating func next() -> Element? {
      if _impl._bitCount == 0 { return nil }
      defer {
        _impl._storage = _impl._storage &>> Element.bitWidth
        _impl._bitCount = _impl._bitCount &- _impl._elementWidth
      }
      return Element(truncatingIfNeeded: _impl._storage)
    }
    public
    var _impl: _UIntBuffer
  }
}


----- Swift.(file)._UIntBuffer.Index
extension _UIntBuffer {
  public struct Index : Comparable {
    @usableFromInline
    internal var bitOffset: UInt8

    @inlinable
    internal init(bitOffset: UInt8) { self.bitOffset = bitOffset }

    @inlinable
    public static func == (lhs: Index, rhs: Index) -> Bool {
      return lhs.bitOffset == rhs.bitOffset
    }
    @inlinable
    public static func < (lhs: Index, rhs: Index) -> Bool {
      return lhs.bitOffset < rhs.bitOffset
    }
  }
}


----- Swift.(file)._UIntBuffer.index(after:_UIntBuffer<Element>.Index)
extension _UIntBuffer {
  public func index(after i: Index) -> Index {
    return Index(bitOffset: i.bitOffset &+ _elementWidth)
  }
}


----- Swift.(file)._UIntBuffer.index(before:_UIntBuffer<Element>.Index)
extension _UIntBuffer {
  public func index(before i: Index) -> Index {
    return Index(bitOffset: i.bitOffset &- _elementWidth)
  }
}


----- Swift.(file)._UIntBuffer.index(_:_UIntBuffer<Element>.Index,offsetBy:Int)
extension _UIntBuffer {
  public func index(_ i: Index, offsetBy n: Int) -> Index {
    let x = Int(i.bitOffset) &+ n &* Element.bitWidth
    return Index(bitOffset: UInt8(truncatingIfNeeded: x))
  }
}


----- Swift.(file)._UIntBuffer.distance(from:_UIntBuffer<Element>.Index,to:_UIntBuffer<Element>.Index)
extension _UIntBuffer {
  public func distance(from i: Index, to j: Index) -> Int {
    return (Int(j.bitOffset) &- Int(i.bitOffset)) / Element.bitWidth
  }
}


----- Swift.(file)._UIntBuffer.append(_:Element)
extension _UIntBuffer {
  public mutating func append(_ newElement: Element) {
    _debugPrecondition(count + 1 <= capacity)
    _storage &= ~(Storage(Element.max) &<< _bitCount)
    _storage |= Storage(newElement) &<< _bitCount
    _bitCount = _bitCount &+ _elementWidth
  }
}


----- Swift.(file)._UIntBuffer.removeFirst()
extension _UIntBuffer {
  public mutating func removeFirst() -> Element {
    _debugPrecondition(!isEmpty)
    let result = Element(truncatingIfNeeded: _storage)
    _bitCount = _bitCount &- _elementWidth
    _storage = _storage._fullShiftRight(_elementWidth)
    return result
  }
}


----- Swift.(file)._UIntBuffer.replaceSubrange(_:Range<_UIntBuffer<Element>.Index>,with:C)
extension _UIntBuffer {
  public mutating func replaceSubrange<C: Collection>(
    _ target: Range<Index>, with replacement: C
  ) where C.Element == Element {
    _debugPrecondition(
      (0..<_bitCount)._contains_(
        target.lowerBound.bitOffset..<target.upperBound.bitOffset))

    let replacement1 = _UIntBuffer(replacement)

    let targetCount = distance(
      from: target.lowerBound, to: target.upperBound)
    let growth = replacement1.count &- targetCount
    _debugPrecondition(count + growth <= capacity)

    let headCount = distance(from: startIndex, to: target.lowerBound)
    let tailOffset = distance(from: startIndex, to: target.upperBound)

    let w = Element.bitWidth
    let headBits = _storage & ._lowBits(headCount &* w)
    let tailBits = _storage._fullShiftRight(tailOffset &* w)

    _storage = headBits
    _storage |= replacement1._storage &<< (headCount &* w)
    _storage |= tailBits &<< ((tailOffset &+ growth) &* w)
    _bitCount = UInt8(
      truncatingIfNeeded: Int(_bitCount) &+ growth &* w)
  }
}


----- Swift.(file).UTF16.decode(_:Unicode.UTF16.EncodedScalar)
extension UTF16 {
  public static func decode(_ source: EncodedScalar) -> Unicode.Scalar {
    let bits = source._storage
    if _fastPath(source._bitCount == 16) {
      return Unicode.Scalar(_unchecked: bits & 0xffff)
    }
    _internalInvariant(source._bitCount == 32)
    let lower: UInt32 = bits >> 16 & 0x03ff
    let upper: UInt32 = (bits & 0x03ff) << 10
    let value = 0x10000 + (lower | upper)
    return Unicode.Scalar(_unchecked: value)
  }
}


----- Swift.(file).UTF16.transcode(_:FromEncoding.EncodedScalar,from:FromEncoding.Type)
extension UTF16 {
  public static func transcode<FromEncoding : Unicode.Encoding>(
    _ content: FromEncoding.EncodedScalar, from _: FromEncoding.Type
  ) -> EncodedScalar? {
    if _fastPath(FromEncoding.self == UTF8.self) {
      let c = _identityCast(content, to: UTF8.EncodedScalar.self)
      var b = c.count
      b = b &- 1
      if _fastPath(b == 0) {
        return EncodedScalar(
          _storage: (c._biasedBits &- 0x1) & 0b0__111_1111, _bitCount: 16)
      }
      var s = c._biasedBits &- 0x01010101
      var r = s
      r &<<= 6
      s &>>= 8
      r |= s & 0b0__11_1111
      b = b &- 1

      if _fastPath(b == 0) {
        return EncodedScalar(_storage: r & 0b0__111_1111_1111, _bitCount: 16)
      }
      r &<<= 6
      s &>>= 8
      r |= s & 0b0__11_1111
      b = b &- 1

      if _fastPath(b == 0) {
        return EncodedScalar(_storage: r & 0xFFFF, _bitCount: 16)
      }

      r &<<= 6
      s &>>= 8
      r |= s & 0b0__11_1111
      r &= (1 &<< 21) - 1
      return encode(Unicode.Scalar(_unchecked: r))
    }
    else if _fastPath(FromEncoding.self == UTF16.self) {
      return unsafeBitCast(content, to: UTF16.EncodedScalar.self)
    }
    return encode(FromEncoding.decode(content))
  }
}


----- Swift.(file).UTF32.decode(_:Unicode.UTF32.EncodedScalar)
extension UTF32 {
  public static func decode(_ source: EncodedScalar) -> Unicode.Scalar {
    return Unicode.Scalar(_unchecked: source.first!)
  }
}


----- Swift.(file).Parser.parseScalar(from:I)
extension Parser {
  public mutating func parseScalar<I : IteratorProtocol>(
    from input: inout I
  ) -> Unicode.ParseResult<Encoding.EncodedScalar>
  where I.Element == Encoding.CodeUnit {
    let n = input.next()
    if _fastPath(n != nil), let x = n {
      // Check code unit is valid: not surrogate-reserved and within range.
      guard _fastPath((x &>> 11) != 0b1101_1 && x <= 0x10ffff)
      else { return .error(length: 1) }

      // x is a valid scalar.
      return .valid(UTF32.EncodedScalar(x))
    }
    return .emptyInput
  }
}


----- Swift.(file).UTF8.decode(_:Unicode.UTF8.EncodedScalar)
extension UTF8 {
  public static func decode(_ source: EncodedScalar) -> Unicode.Scalar {
    switch source.count {
    case 1:
      return Unicode.Scalar(_unchecked: source._biasedBits &- 0x01)
    case 2:
      let bits = source._biasedBits &- 0x0101
      var value = (bits & 0b0_______________________11_1111__0000_0000) &>> 8
      value    |= (bits & 0b0________________________________0001_1111) &<< 6
      return Unicode.Scalar(_unchecked: value)
    case 3:
      let bits = source._biasedBits &- 0x010101
      var value = (bits & 0b0____________11_1111__0000_0000__0000_0000) &>> 16
      value    |= (bits & 0b0_______________________11_1111__0000_0000) &>> 2
      value    |= (bits & 0b0________________________________0000_1111) &<< 12
      return Unicode.Scalar(_unchecked: value)
    default:
      _internalInvariant(source.count == 4)
      let bits = source._biasedBits &- 0x01010101
      var value = (bits & 0b0_11_1111__0000_0000__0000_0000__0000_0000) &>> 24
      value    |= (bits & 0b0____________11_1111__0000_0000__0000_0000) &>> 10
      value    |= (bits & 0b0_______________________11_1111__0000_0000) &<< 4
      value    |= (bits & 0b0________________________________0000_0111) &<< 18
      return Unicode.Scalar(_unchecked: value)
    }
  }
}


----- Swift.(file).UTF8.encode(_:Unicode.Scalar)
extension UTF8 {
  public static func encode(
    _ source: Unicode.Scalar
  ) -> EncodedScalar? {
    var c = source.value
    if _fastPath(c < (1&<<7)) {
      return EncodedScalar(_containing: UInt8(c))
    }
    var o = c & 0b0__0011_1111
    c &>>= 6
    o &<<= 8
    if _fastPath(c < (1&<<5)) {
      return EncodedScalar(_biasedBits: (o | c) &+ 0b0__1000_0001__1100_0001)
    }
    o |= c & 0b0__0011_1111
    c &>>= 6
    o &<<= 8
    if _fastPath(c < (1&<<4)) {
      return EncodedScalar(
        _biasedBits: (o | c) &+ 0b0__1000_0001__1000_0001__1110_0001)
    }
    o |= c & 0b0__0011_1111
    c &>>= 6
    o &<<= 8
    return EncodedScalar(
      _biasedBits: (o | c ) &+ 0b0__1000_0001__1000_0001__1000_0001__1111_0001)
  }
}


----- Swift.(file).UTF8.transcode(_:FromEncoding.EncodedScalar,from:FromEncoding.Type)
extension UTF8 {
  public static func transcode<FromEncoding : _UnicodeEncoding>(
    _ content: FromEncoding.EncodedScalar, from _: FromEncoding.Type
  ) -> EncodedScalar? {
    if _fastPath(FromEncoding.self == UTF16.self) {
      let c = _identityCast(content, to: UTF16.EncodedScalar.self)
      var u0 = UInt16(truncatingIfNeeded: c._storage)
      if _fastPath(u0 < 0x80) {
        return EncodedScalar(_containing: UInt8(truncatingIfNeeded: u0))
      }
      var r = UInt32(u0 & 0b0__11_1111)
      r &<<= 8
      u0 &>>= 6
      if _fastPath(u0 < (1&<<5)) {
        return EncodedScalar(
          _biasedBits: (UInt32(u0) | r) &+ 0b0__1000_0001__1100_0001)
      }
      r |= UInt32(u0 & 0b0__11_1111)
      r &<<= 8
      if _fastPath(u0 & (0xF800 &>> 6) != (0xD800 &>> 6)) {
        u0 &>>= 6
        return EncodedScalar(
          _biasedBits: (UInt32(u0) | r) &+ 0b0__1000_0001__1000_0001__1110_0001)
      }
    }
    else if _fastPath(FromEncoding.self == UTF8.self) {
      return _identityCast(content, to: UTF8.EncodedScalar.self)
    }
    return encode(FromEncoding.decode(content))
  }
}


----- Swift.(file)._UTFParser.parseScalar(from:I)
extension _UTFParser {
  public mutating func parseScalar<I : IteratorProtocol>(
    from input: inout I
  ) -> Unicode.ParseResult<Encoding.EncodedScalar>
    where I.Element == Encoding.CodeUnit {

    // Bufferless single-scalar fastpath.
    if _fastPath(_buffer.isEmpty) {
      guard let codeUnit = input.next() else { return .emptyInput }
      // ASCII, return immediately.
      if Encoding._isScalar(codeUnit) {
        return .valid(Encoding.EncodedScalar(CollectionOfOne(codeUnit)))
      }
      // Non-ASCII, proceed to buffering mode.
      _buffer.append(codeUnit)
    } else if Encoding._isScalar(
      Encoding.CodeUnit(truncatingIfNeeded: _buffer._storage)
    ) {
      // ASCII in _buffer.  We don't refill the buffer so we can return
      // to bufferless mode once we've exhausted it.
      let codeUnit = Encoding.CodeUnit(truncatingIfNeeded: _buffer._storage)
      _buffer.remove(at: _buffer.startIndex)
      return .valid(Encoding.EncodedScalar(CollectionOfOne(codeUnit)))
    }
    // Buffering mode.
    // Fill buffer back to 4 bytes (or as many as are left in the iterator).
    repeat {
      if let codeUnit = input.next() {
        _buffer.append(codeUnit)
      } else {
        if _buffer.isEmpty { return .emptyInput }
        break // We still have some bytes left in our buffer.
      }
    } while _buffer.count < _buffer.capacity

    // Find one unicode scalar.
    let (isValid, scalarBitCount) = _parseMultipleCodeUnits()
    _internalInvariant(scalarBitCount % numericCast(Encoding.CodeUnit.bitWidth) == 0)
    _internalInvariant(1...4 ~= scalarBitCount / 8)
    _internalInvariant(scalarBitCount <= _buffer._bitCount)

    // Consume the decoded bytes (or maximal subpart of ill-formed sequence).
    let encodedScalar = _bufferedScalar(bitCount: scalarBitCount)

    _buffer._storage = UInt32(
      // widen to 64 bits so that we can empty the buffer in the 4-byte case
      truncatingIfNeeded: UInt64(_buffer._storage) &>> scalarBitCount)

    _buffer._bitCount = _buffer._bitCount &- scalarBitCount

    if _fastPath(isValid) {
      return .valid(encodedScalar)
    }
    return .error(
      length: Int(scalarBitCount / numericCast(Encoding.CodeUnit.bitWidth)))
  }
}


----- Swift.(file)..decode(_:I)
extension  {
  public mutating func decode<I : IteratorProtocol>(
    _ input: inout I
  ) -> UnicodeDecodingResult where I.Element == CodeUnit {
    guard case ._swift3Buffer(var parser) = self else {
      Builtin.unreachable()
    }
    defer { self = ._swift3Buffer(parser) }

    switch parser.parseScalar(from: &input) {
    case .valid(let s): return .scalarValue(UTF8.decode(s))
    case .error: return .error
    case .emptyInput: return .emptyInput
    }
  }
}


----- Swift.(file)..encode(_:<<error type>>,into:<<error type>>)
extension  {
  public static func encode(
    _ input: Unicode.Scalar,
    into processCodeUnit: (CodeUnit) -> Void
  ) {
    var s = encode(input)!._biasedBits
    processCodeUnit(UInt8(truncatingIfNeeded: s) &- 0x01)
    s &>>= 8
    if _fastPath(s == 0) { return }
    processCodeUnit(UInt8(truncatingIfNeeded: s) &- 0x01)
    s &>>= 8
    if _fastPath(s == 0) { return }
    processCodeUnit(UInt8(truncatingIfNeeded: s) &- 0x01)
    s &>>= 8
    if _fastPath(s == 0) { return }
    processCodeUnit(UInt8(truncatingIfNeeded: s) &- 0x01)
  }
}


----- Swift.(file)..isContinuation(_:<<error type>>)
extension  {
  public static func isContinuation(_ byte: CodeUnit) -> Bool {
    return byte & 0b11_00__0000 == 0b10_00__0000
  }
}


----- Swift.(file)..decode(_:I)
extension  {
  public mutating func decode<I : IteratorProtocol>(
    _ input: inout I
  ) -> UnicodeDecodingResult where I.Element == CodeUnit {
    guard case ._swift3Buffer(var parser) = self else {
      Builtin.unreachable()
    }
    defer { self = ._swift3Buffer(parser) }
    switch parser.parseScalar(from: &input) {
    case .valid(let s): return .scalarValue(UTF16.decode(s))
    case .error: return .error
    case .emptyInput: return .emptyInput
    }
  }
}


----- Swift.(file)..encode(_:<<error type>>,into:<<error type>>)
extension  {
  public static func encode(
    _ input: Unicode.Scalar,
    into processCodeUnit: (CodeUnit) -> Void
  ) {
    var s = encode(input)!._storage
    processCodeUnit(UInt16(truncatingIfNeeded: s))
    s &>>= 16
    if _fastPath(s == 0) { return }
    processCodeUnit(UInt16(truncatingIfNeeded: s))
  }
}


----- Swift.(file)..decode(_:I)
extension  {
  public mutating func decode<I : IteratorProtocol>(
    _ input: inout I
  ) -> UnicodeDecodingResult where I.Element == CodeUnit {
    var parser = ForwardParser()

    switch parser.parseScalar(from: &input) {
    case .valid(let s): return .scalarValue(UTF32.decode(s))
    case .error:      return .error
    case .emptyInput:   return .emptyInput
    }
  }
}


----- Swift.(file)..encode(_:<<error type>>,into:<<error type>>)
extension  {
  public static func encode(
    _ input: Unicode.Scalar,
    into processCodeUnit: (CodeUnit) -> Void
  ) {
    processCodeUnit(UInt32(input))
  }
}


----- Swift.(file).UTF16.transcodedLength(of:Input,decodedAs:Encoding.Type,repairingIllFormedSequences:Bool)
extension UTF16 {
  public static func transcodedLength<
    Input : IteratorProtocol,
    Encoding : Unicode.Encoding
  >(
    of input: Input,
    decodedAs sourceEncoding: Encoding.Type,
    repairingIllFormedSequences: Bool
  ) -> (count: Int, isASCII: Bool)?
    where Encoding.CodeUnit == Input.Element {

    var utf16Count = 0
    var i = input
    var d = Encoding.ForwardParser()

    // Fast path for ASCII in a UTF8 buffer
    if sourceEncoding == Unicode.UTF8.self {
      var peek: Encoding.CodeUnit = 0
      while let u = i.next() {
        peek = u
        guard _fastPath(peek < 0x80) else { break }
        utf16Count = utf16Count + 1
      }
      if _fastPath(peek < 0x80) { return (utf16Count, true) }

      var d1 = UTF8.ForwardParser()
      d1._buffer.append(numericCast(peek))
      d = _identityCast(d1, to: Encoding.ForwardParser.self)
    }

    var utf16BitUnion: CodeUnit = 0
    while true {
      let s = d.parseScalar(from: &i)
      if _fastPath(s._valid != nil), let scalarContent = s._valid {
        let utf16 = transcode(scalarContent, from: sourceEncoding)
          ._unsafelyUnwrappedUnchecked
        utf16Count += utf16.count
        for x in utf16 { utf16BitUnion |= x }
      }
      else if let _ = s._error {
        guard _fastPath(repairingIllFormedSequences) else { return nil }
        utf16Count += 1
        utf16BitUnion |= UTF16._replacementCodeUnit
      }
      else {
        return (utf16Count, utf16BitUnion < 0x80)
      }
    }
  }
}


----- Swift.(file).transcode(_:InputEncoding.Type,_:OutputEncoding.Type,_:Input,_:<<error type>>,stopOnError:Bool)
public func transcode<Input, InputEncoding, OutputEncoding>(
  _ inputEncoding: InputEncoding.Type, _ outputEncoding: OutputEncoding.Type,
  _ input: Input, _ output: (OutputEncoding.CodeUnit) -> Void,
  stopOnError: Bool
) -> Bool
  where
  Input : IteratorProtocol,
  InputEncoding : UnicodeCodec,
  OutputEncoding : UnicodeCodec,
  InputEncoding.CodeUnit == Input.Element {
  Builtin.unreachable()
}


----- Swift.(file).Scalar.init(_:<<error type>>)
extension Scalar {
  public init(_ v: Unicode.Scalar) {
    // This constructor allows one to provide necessary type context to
    // disambiguate between function overloads on 'String' and 'Unicode.Scalar'.
    self = v
  }
}


----- Swift.(file).Scalar.escaped(asASCII:Bool)
extension Scalar {
  public func escaped(asASCII forceASCII: Bool) -> String {
    func lowNibbleAsHex(_ v: UInt32) -> String {
      let nibble = v & 15
      if nibble < 10 {
        return String(Unicode.Scalar(nibble+48)!)    // 48 = '0'
      } else {
        return String(Unicode.Scalar(nibble-10+65)!) // 65 = 'A'
      }
    }

    if self == "\\" {
      return "\\\\"
    } else if self == "\'" {
      return "\\\'"
    } else if self == "\"" {
      return "\\\""
    } else if _isPrintableASCII {
      return String(self)
    } else if self == "\0" {
      return "\\0"
    } else if self == "\n" {
      return "\\n"
    } else if self == "\r" {
      return "\\r"
    } else if self == "\t" {
      return "\\t"
    } else if UInt32(self) < 128 {
      return "\\u{"
        + lowNibbleAsHex(UInt32(self) >> 4)
        + lowNibbleAsHex(UInt32(self)) + "}"
    } else if !forceASCII {
      return String(self)
    } else if UInt32(self) <= 0xFFFF {
      var result = "\\u{"
      result += lowNibbleAsHex(UInt32(self) >> 12)
      result += lowNibbleAsHex(UInt32(self) >> 8)
      result += lowNibbleAsHex(UInt32(self) >> 4)
      result += lowNibbleAsHex(UInt32(self))
      result += "}"
      return result
    } else {
      // FIXME: Type checker performance prohibits this from being a
      // single chained "+".
      var result = "\\u{"
      result += lowNibbleAsHex(UInt32(self) >> 28)
      result += lowNibbleAsHex(UInt32(self) >> 24)
      result += lowNibbleAsHex(UInt32(self) >> 20)
      result += lowNibbleAsHex(UInt32(self) >> 16)
      result += lowNibbleAsHex(UInt32(self) >> 12)
      result += lowNibbleAsHex(UInt32(self) >> 8)
      result += lowNibbleAsHex(UInt32(self) >> 4)
      result += lowNibbleAsHex(UInt32(self))
      result += "}"
      return result
    }
  }
}


----- Swift.(file).Scalar.hash(into:Hasher)
extension Scalar {
  public func hash(into hasher: inout Hasher) {
    hasher.combine(self.value)
  }
}


----- Swift.(file).Scalar.==infix(_:<<error type>>,_:<<error type>>)
extension Scalar {
  public static func == (lhs: Unicode.Scalar, rhs: Unicode.Scalar) -> Bool {
    return lhs.value == rhs.value
  }
}


----- Swift.(file).Scalar.<infix(_:<<error type>>,_:<<error type>>)
extension Scalar {
  public static func < (lhs: Unicode.Scalar, rhs: Unicode.Scalar) -> Bool {
    return lhs.value < rhs.value
  }
}


----- Swift.(file).Scalar.UTF16View
extension Scalar {
  public struct UTF16View {
    @inlinable
    internal init(value: Unicode.Scalar) {
      self.value = value
    }
    @usableFromInline
    internal var value: Unicode.Scalar
  }
}


----- Swift.(file).Scalar.Properties
extension Scalar {
  public struct Properties {
    @usableFromInline
    internal var _scalar: Unicode.Scalar

    internal init(_ scalar: Unicode.Scalar) {
      self._scalar = scalar
    }

    // Provide the value as UChar32 to make calling the ICU APIs cleaner
    internal var icuValue: __swift_stdlib_UChar32 {
      return __swift_stdlib_UChar32(bitPattern: self._scalar._value)
    }
  }
}


----- Swift.(file).Unicode.CanonicalCombiningClass
extension Unicode {
  public struct CanonicalCombiningClass:
    Comparable, Hashable, RawRepresentable
  {
    /// Base glyphs that occupy their own space and do not combine with others.
    public static let notReordered = CanonicalCombiningClass(rawValue: 0)

    /// Marks that overlay a base letter or symbol.
    public static let overlay = CanonicalCombiningClass(rawValue: 1)

    /// Diacritic nukta marks in Brahmi-derived scripts.
    public static let nukta = CanonicalCombiningClass(rawValue: 7)

    /// Combining marks that are attached to hiragana and katakana to indicate
    /// voicing changes.
    public static let kanaVoicing = CanonicalCombiningClass(rawValue: 8)

    /// Diacritic virama marks in Brahmi-derived scripts.
    public static let virama = CanonicalCombiningClass(rawValue: 9)

    /// Marks attached at the bottom left.
    public static let attachedBelowLeft = CanonicalCombiningClass(rawValue: 200)

    /// Marks attached directly below.
    public static let attachedBelow = CanonicalCombiningClass(rawValue: 202)

    /// Marks attached directly above.
    public static let attachedAbove = CanonicalCombiningClass(rawValue: 214)

    /// Marks attached at the top right.
    public static let attachedAboveRight =
      CanonicalCombiningClass(rawValue: 216)

    /// Distinct marks at the bottom left.
    public static let belowLeft = CanonicalCombiningClass(rawValue: 218)

    /// Distinct marks directly below.
    public static let below = CanonicalCombiningClass(rawValue: 220)

    /// Distinct marks at the bottom right.
    public static let belowRight = CanonicalCombiningClass(rawValue: 222)

    /// Distinct marks to the left.
    public static let left = CanonicalCombiningClass(rawValue: 224)

    /// Distinct marks to the right.
    public static let right = CanonicalCombiningClass(rawValue: 226)

    /// Distinct marks at the top left.
    public static let aboveLeft = CanonicalCombiningClass(rawValue: 228)

    /// Distinct marks directly above.
    public static let above = CanonicalCombiningClass(rawValue: 230)

    /// Distinct marks at the top right.
    public static let aboveRight = CanonicalCombiningClass(rawValue: 232)

    /// Distinct marks subtending two bases.
    public static let doubleBelow = CanonicalCombiningClass(rawValue: 233)

    /// Distinct marks extending above two bases.
    public static let doubleAbove = CanonicalCombiningClass(rawValue: 234)

    /// Greek iota subscript only (U+0345 COMBINING GREEK YPOGEGRAMMENI).
    public static let iotaSubscript = CanonicalCombiningClass(rawValue: 240)

    /// The raw integer value of the canonical combining class.
    public let rawValue: UInt8

    /// Creates a new canonical combining class with the given raw integer
    /// value.
    ///
    /// - Parameter rawValue: The raw integer value of the canonical combining
    ///   class.
    public init(rawValue: UInt8) {
      self.rawValue = rawValue
    }

    public static func == (
      lhs: CanonicalCombiningClass,
      rhs: CanonicalCombiningClass
    ) -> Bool {
      return lhs.rawValue == rhs.rawValue
    }

    public static func < (
      lhs: CanonicalCombiningClass,
      rhs: CanonicalCombiningClass
    ) -> Bool {
      return lhs.rawValue < rhs.rawValue
    }

    public var hashValue: Int {
      return rawValue.hashValue
    }

    public func hash(into hasher: inout Hasher) {
      hasher.combine(rawValue)
    }
  }
}


----- Swift.(file).Unmanaged.fromOpaque(_:UnsafeRawPointer)
extension Unmanaged {
  public static func fromOpaque(_ value: UnsafeRawPointer) -> Unmanaged {
    return Unmanaged(_private: unsafeBitCast(value, to: Instance.self))
  }
}


----- Swift.(file).Unmanaged.toOpaque()
extension Unmanaged {
  public func toOpaque() -> UnsafeMutableRawPointer {
    return unsafeBitCast(_value, to: UnsafeMutableRawPointer.self)
  }
}


----- Swift.(file).Unmanaged.passRetained(_:Instance)
extension Unmanaged {
  public static func passRetained(_ value: Instance) -> Unmanaged {
    return Unmanaged(_private: value).retain()
  }
}


----- Swift.(file).Unmanaged.passUnretained(_:Instance)
extension Unmanaged {
  public static func passUnretained(_ value: Instance) -> Unmanaged {
    return Unmanaged(_private: value)
  }
}


----- Swift.(file).Unmanaged.takeUnretainedValue()
extension Unmanaged {
  public func takeUnretainedValue() -> Instance {
    return _value
  }
}


----- Swift.(file).Unmanaged.takeRetainedValue()
extension Unmanaged {
  public func takeRetainedValue() -> Instance {
    let result = _value
    release()
    return result
  }
}


----- Swift.(file).Unmanaged.retain()
extension Unmanaged {
  public func retain() -> Unmanaged {
    Builtin.retain(_value)
    return self
  }
}


----- Swift.(file).Unmanaged.release()
extension Unmanaged {
  public func release() {
    Builtin.release(_value)
  }
}


----- Swift.(file).Unmanaged.autorelease()
extension Unmanaged {
  public func autorelease() -> Unmanaged {
    Builtin.autorelease(_value)
    return self
  }
}


----- Swift.(file).UnsafePointer.deallocate()
extension UnsafePointer {
  public func deallocate() {
    Builtin.deallocRaw(_rawValue, (-1)._builtinWordValue, (-1)._builtinWordValue)
  }
}


----- Swift.(file).UnsafePointer.withMemoryRebound(to:T.Type,capacity:Int,_:(UnsafePointer<T>) throws -> Result)
extension UnsafePointer {
  public func withMemoryRebound<T, Result>(to type: T.Type, capacity count: Int,
    _ body: (UnsafePointer<T>) throws -> Result
  ) rethrows -> Result {
    Builtin.bindMemory(_rawValue, count._builtinWordValue, T.self)
    defer {
      Builtin.bindMemory(_rawValue, count._builtinWordValue, Pointee.self)
    }
    return try body(UnsafePointer<T>(_rawValue))
  }
}


----- Swift.(file).UnsafeMutablePointer.allocate(capacity:Int)
extension UnsafeMutablePointer {
  public static func allocate(capacity count: Int)
    -> UnsafeMutablePointer<Pointee> {
    let size = MemoryLayout<Pointee>.stride * count
    let rawPtr =
      Builtin.allocRaw(size._builtinWordValue, Builtin.alignof(Pointee.self))
    Builtin.bindMemory(rawPtr, count._builtinWordValue, Pointee.self)
    return UnsafeMutablePointer(rawPtr)
  }
}


----- Swift.(file).UnsafeMutablePointer.deallocate()
extension UnsafeMutablePointer {
  public func deallocate() {
    Builtin.deallocRaw(_rawValue, (-1)._builtinWordValue,
                       Builtin.alignof(Pointee.self))
  }
}


----- Swift.(file).UnsafeMutablePointer.initialize(repeating:Pointee,count:Int)
extension UnsafeMutablePointer {
  public func initialize(repeating repeatedValue: Pointee, count: Int) {
    // FIXME: add tests (since the `count` has been added)
    _debugPrecondition(count >= 0,
      "UnsafeMutablePointer.initialize(repeating:count:): negative count")
    // Must not use `initializeFrom` with a `Collection` as that will introduce
    // a cycle.
    for offset in 0..<count {
      Builtin.initialize(repeatedValue, (self + offset)._rawValue)
    }
  }
}


----- Swift.(file).UnsafeMutablePointer.initialize(to:Pointee)
extension UnsafeMutablePointer {
  public func initialize(to value: Pointee) {
    Builtin.initialize(value, self._rawValue)
  }
}


----- Swift.(file).UnsafeMutablePointer.move()
extension UnsafeMutablePointer {
  public func move() -> Pointee {
    return Builtin.take(_rawValue)
  }
}


----- Swift.(file).UnsafeMutablePointer.assign(repeating:Pointee,count:Int)
extension UnsafeMutablePointer {
  public func assign(repeating repeatedValue: Pointee, count: Int) {
    _debugPrecondition(count >= 0, "UnsafeMutablePointer.assign(repeating:count:) with negative count")
    for i in 0..<count {
      self[i] = repeatedValue
    }
  }
}


----- Swift.(file).UnsafeMutablePointer.assign(from:UnsafePointer<Pointee>,count:Int)
extension UnsafeMutablePointer {
  public func assign(from source: UnsafePointer<Pointee>, count: Int) {
    _debugPrecondition(
      count >= 0, "UnsafeMutablePointer.assign with negative count")
    if UnsafePointer(self) < source || UnsafePointer(self) >= source + count {
      // assign forward from a disjoint or following overlapping range.
      Builtin.assignCopyArrayFrontToBack(
        Pointee.self, self._rawValue, source._rawValue, count._builtinWordValue)
      // This builtin is equivalent to:
      // for i in 0..<count {
      //   self[i] = source[i]
      // }
    }
    else if UnsafePointer(self) != source {
      // assign backward from a non-following overlapping range.
      Builtin.assignCopyArrayBackToFront(
        Pointee.self, self._rawValue, source._rawValue, count._builtinWordValue)
      // This builtin is equivalent to:
      // var i = count-1
      // while i >= 0 {
      //   self[i] = source[i]
      //   i -= 1
      // }
    }
  }
}


----- Swift.(file).UnsafeMutablePointer.moveInitialize(from:UnsafeMutablePointer<Pointee>,count:Int)
extension UnsafeMutablePointer {
  public func moveInitialize(from source: UnsafeMutablePointer, count: Int) {
    _debugPrecondition(
      count >= 0, "UnsafeMutablePointer.moveInitialize with negative count")
    if self < source || self >= source + count {
      // initialize forward from a disjoint or following overlapping range.
      Builtin.takeArrayFrontToBack(
        Pointee.self, self._rawValue, source._rawValue, count._builtinWordValue)
      // This builtin is equivalent to:
      // for i in 0..<count {
      //   (self + i).initialize(to: (source + i).move())
      // }
    }
    else {
      // initialize backward from a non-following overlapping range.
      Builtin.takeArrayBackToFront(
        Pointee.self, self._rawValue, source._rawValue, count._builtinWordValue)
      // This builtin is equivalent to:
      // var src = source + count
      // var dst = self + count
      // while dst != self {
      //   (--dst).initialize(to: (--src).move())
      // }
    }
  }
}


----- Swift.(file).UnsafeMutablePointer.initialize(from:UnsafePointer<Pointee>,count:Int)
extension UnsafeMutablePointer {
  public func initialize(from source: UnsafePointer<Pointee>, count: Int) {
    _debugPrecondition(
      count >= 0, "UnsafeMutablePointer.initialize with negative count")
    _debugPrecondition(
      UnsafePointer(self) + count <= source ||
      source + count <= UnsafePointer(self),
      "UnsafeMutablePointer.initialize overlapping range")
    Builtin.copyArray(
      Pointee.self, self._rawValue, source._rawValue, count._builtinWordValue)
    // This builtin is equivalent to:
    // for i in 0..<count {
    //   (self + i).initialize(to: source[i])
    // }
  }
}


----- Swift.(file).UnsafeMutablePointer.moveAssign(from:UnsafeMutablePointer<Pointee>,count:Int)
extension UnsafeMutablePointer {
  public func moveAssign(from source: UnsafeMutablePointer, count: Int) {
    _debugPrecondition(
      count >= 0, "UnsafeMutablePointer.moveAssign(from:) with negative count")
    _debugPrecondition(
      self + count <= source || source + count <= self,
      "moveAssign overlapping range")
    Builtin.assignTakeArray(
      Pointee.self, self._rawValue, source._rawValue, count._builtinWordValue)
    // These builtins are equivalent to:
    // for i in 0..<count {
    //   self[i] = (source + i).move()
    // }
  }
}


----- Swift.(file).UnsafeMutablePointer.deinitialize(count:Int)
extension UnsafeMutablePointer {
  public func deinitialize(count: Int) -> UnsafeMutableRawPointer {
    _debugPrecondition(count >= 0, "UnsafeMutablePointer.deinitialize with negative count")
    // FIXME: optimization should be implemented, where if the `count` value
    // is 1, the `Builtin.destroy(Pointee.self, _rawValue)` gets called.
    Builtin.destroyArray(Pointee.self, _rawValue, count._builtinWordValue)
    return UnsafeMutableRawPointer(self)
  }
}


----- Swift.(file).UnsafeMutablePointer.withMemoryRebound(to:T.Type,capacity:Int,_:(UnsafeMutablePointer<T>) throws -> Result)
extension UnsafeMutablePointer {
  public func withMemoryRebound<T, Result>(to type: T.Type, capacity count: Int,
    _ body: (UnsafeMutablePointer<T>) throws -> Result
  ) rethrows -> Result {
    Builtin.bindMemory(_rawValue, count._builtinWordValue, T.self)
    defer {
      Builtin.bindMemory(_rawValue, count._builtinWordValue, Pointee.self)
    }
    return try body(UnsafeMutablePointer<T>(_rawValue))
  }
}


----- Swift.(file).UnsafeRawPointer.deallocate()
extension UnsafeRawPointer {
  public func deallocate() {
    Builtin.deallocRaw(_rawValue, (-1)._builtinWordValue, (-1)._builtinWordValue)
  }
}


----- Swift.(file).UnsafeRawPointer.bindMemory(to:T.Type,capacity:Int)
extension UnsafeRawPointer {
  public func bindMemory<T>(
    to type: T.Type, capacity count: Int
  ) -> UnsafePointer<T> {
    Builtin.bindMemory(_rawValue, count._builtinWordValue, type)
    return UnsafePointer<T>(_rawValue)
  }
}


----- Swift.(file).UnsafeRawPointer.load(fromByteOffset:Int,as:T.Type)
extension UnsafeRawPointer {
  public func load<T>(fromByteOffset offset: Int = 0, as type: T.Type) -> T {
    _debugPrecondition(0 == (UInt(bitPattern: self + offset)
        & (UInt(MemoryLayout<T>.alignment) - 1)),
      "load from misaligned raw pointer")

    return Builtin.loadRaw((self + offset)._rawValue)
  }
}


----- Swift.(file).UnsafeRawPointer.advanced(by:Int)
extension UnsafeRawPointer {
  public func advanced(by n: Int) -> UnsafeRawPointer {
    return UnsafeRawPointer(Builtin.gepRaw_Word(_rawValue, n._builtinWordValue))
  }
}


----- Swift.(file).UnsafeMutableRawPointer.allocate(byteCount:Int,alignment:Int)
extension UnsafeMutableRawPointer {
  public static func allocate(
    byteCount: Int, alignment: Int
  ) -> UnsafeMutableRawPointer {
    return UnsafeMutableRawPointer(Builtin.allocRaw(
        byteCount._builtinWordValue, alignment._builtinWordValue))
  }
}


----- Swift.(file).UnsafeMutableRawPointer.deallocate()
extension UnsafeMutableRawPointer {
  public func deallocate() {
    Builtin.deallocRaw(_rawValue, (-1)._builtinWordValue, (-1)._builtinWordValue)
  }
}


----- Swift.(file).UnsafeMutableRawPointer.bindMemory(to:T.Type,capacity:Int)
extension UnsafeMutableRawPointer {
  public func bindMemory<T>(
    to type: T.Type, capacity count: Int
  ) -> UnsafeMutablePointer<T> {
    Builtin.bindMemory(_rawValue, count._builtinWordValue, type)
    return UnsafeMutablePointer<T>(_rawValue)
  }
}


----- Swift.(file).UnsafeMutableRawPointer.initializeMemory(as:T.Type,repeating:T,count:Int)
extension UnsafeMutableRawPointer {
  public func initializeMemory<T>(
    as type: T.Type, repeating repeatedValue: T, count: Int
  ) -> UnsafeMutablePointer<T> {
    _debugPrecondition(count >= 0,
      "UnsafeMutableRawPointer.initializeMemory: negative count")

    Builtin.bindMemory(_rawValue, count._builtinWordValue, type)
    var nextPtr = self
    for _ in 0..<count {
      Builtin.initialize(repeatedValue, nextPtr._rawValue)
      nextPtr += MemoryLayout<T>.stride
    }
    return UnsafeMutablePointer(_rawValue)
  }
}


----- Swift.(file).UnsafeMutableRawPointer.initializeMemory(as:T.Type,from:UnsafePointer<T>,count:Int)
extension UnsafeMutableRawPointer {
  public func initializeMemory<T>(
    as type: T.Type, from source: UnsafePointer<T>, count: Int
  ) -> UnsafeMutablePointer<T> {
    _debugPrecondition(
      count >= 0,
      "UnsafeMutableRawPointer.initializeMemory with negative count")
    _debugPrecondition(
      (UnsafeRawPointer(self + count * MemoryLayout<T>.stride)
        <= UnsafeRawPointer(source))
      || UnsafeRawPointer(source + count) <= UnsafeRawPointer(self),
      "UnsafeMutableRawPointer.initializeMemory overlapping range")

    Builtin.bindMemory(_rawValue, count._builtinWordValue, type)
    Builtin.copyArray(
      T.self, self._rawValue, source._rawValue, count._builtinWordValue)
    // This builtin is equivalent to:
    // for i in 0..<count {
    //   (self.assumingMemoryBound(to: T.self) + i).initialize(to: source[i])
    // }
    return UnsafeMutablePointer(_rawValue)
  }
}


----- Swift.(file).UnsafeMutableRawPointer.moveInitializeMemory(as:T.Type,from:UnsafeMutablePointer<T>,count:Int)
extension UnsafeMutableRawPointer {
  public func moveInitializeMemory<T>(
    as type: T.Type, from source: UnsafeMutablePointer<T>, count: Int
  ) -> UnsafeMutablePointer<T> {
    _debugPrecondition(
      count >= 0,
      "UnsafeMutableRawPointer.moveInitializeMemory with negative count")

    Builtin.bindMemory(_rawValue, count._builtinWordValue, type)
    if self < UnsafeMutableRawPointer(source)
       || self >= UnsafeMutableRawPointer(source + count) {
      // initialize forward from a disjoint or following overlapping range.
      Builtin.takeArrayFrontToBack(
        T.self, self._rawValue, source._rawValue, count._builtinWordValue)
      // This builtin is equivalent to:
      // for i in 0..<count {
      //   (self.assumingMemoryBound(to: T.self) + i)
      //   .initialize(to: (source + i).move())
      // }
    }
    else {
      // initialize backward from a non-following overlapping range.
      Builtin.takeArrayBackToFront(
        T.self, self._rawValue, source._rawValue, count._builtinWordValue)
      // This builtin is equivalent to:
      // var src = source + count
      // var dst = self.assumingMemoryBound(to: T.self) + count
      // while dst != self {
      //   (--dst).initialize(to: (--src).move())
      // }
    }
    return UnsafeMutablePointer(_rawValue)
  }
}


----- Swift.(file).UnsafeMutableRawPointer.load(fromByteOffset:Int,as:T.Type)
extension UnsafeMutableRawPointer {
  public func load<T>(fromByteOffset offset: Int = 0, as type: T.Type) -> T {
    _debugPrecondition(0 == (UInt(bitPattern: self + offset)
        & (UInt(MemoryLayout<T>.alignment) - 1)),
      "load from misaligned raw pointer")

    return Builtin.loadRaw((self + offset)._rawValue)
  }
}


----- Swift.(file).UnsafeMutableRawPointer.storeBytes(of:T,toByteOffset:Int,as:T.Type)
extension UnsafeMutableRawPointer {
  public func storeBytes<T>(
    of value: T, toByteOffset offset: Int = 0, as type: T.Type
  ) {
    _debugPrecondition(0 == (UInt(bitPattern: self + offset)
        & (UInt(MemoryLayout<T>.alignment) - 1)),
      "storeBytes to misaligned raw pointer")

    var temp = value
    withUnsafeMutablePointer(to: &temp) { source in
      let rawSrc = UnsafeMutableRawPointer(source)._rawValue
      // FIXME: to be replaced by _memcpy when conversions are implemented.
      Builtin.int_memcpy_RawPointer_RawPointer_Int64(
        (self + offset)._rawValue, rawSrc, UInt64(MemoryLayout<T>.size)._value,
        /*volatile:*/ false._value)
    }
  }
}


----- Swift.(file).UnsafeMutableRawPointer.copyMemory(from:UnsafeRawPointer,byteCount:Int)
extension UnsafeMutableRawPointer {
  public func copyMemory(from source: UnsafeRawPointer, byteCount: Int) {
    _debugPrecondition(
      byteCount >= 0, "UnsafeMutableRawPointer.copyMemory with negative count")

    _memmove(dest: self, src: source, size: UInt(byteCount))
  }
}


----- Swift.(file).UnsafeMutableRawPointer.advanced(by:Int)
extension UnsafeMutableRawPointer {
  public func advanced(by n: Int) -> UnsafeMutableRawPointer {
    return UnsafeMutableRawPointer(Builtin.gepRaw_Word(_rawValue, n._builtinWordValue))
  }
}


----- Swift.(file)._ValidUTF8Buffer.Iterator
extension _ValidUTF8Buffer {
  public struct Iterator : IteratorProtocol, Sequence {
    @inlinable
    public init(_ x: _ValidUTF8Buffer) { _biasedBits = x._biasedBits }

    @inlinable
    public mutating func next() -> Element? {
      if _biasedBits == 0 { return nil }
      defer { _biasedBits >>= 8 }
      return Element(truncatingIfNeeded: _biasedBits) &- 1
    }
    @usableFromInline
    internal var _biasedBits: UInt32
  }
}


----- Swift.(file)._ValidUTF8Buffer.Index
extension _ValidUTF8Buffer {
  public struct Index : Comparable {
    @usableFromInline
    internal var _biasedBits: UInt32

    @inlinable
    internal init(_biasedBits: UInt32) { self._biasedBits = _biasedBits }

    @inlinable
    public static func == (lhs: Index, rhs: Index) -> Bool {
      return lhs._biasedBits == rhs._biasedBits
    }
    @inlinable
    public static func < (lhs: Index, rhs: Index) -> Bool {
      return lhs._biasedBits > rhs._biasedBits
    }
  }
}


----- Swift.(file)._ValidUTF8Buffer.index(after:_ValidUTF8Buffer.Index)
extension _ValidUTF8Buffer {
  public func index(after i: Index) -> Index {
    _debugPrecondition(i._biasedBits != 0)
    return Index(_biasedBits: i._biasedBits >> 8)
  }
}


----- Swift.(file)._ValidUTF8Buffer.index(before:_ValidUTF8Buffer.Index)
extension _ValidUTF8Buffer {
  public func index(before i: Index) -> Index {
    let offset = _ValidUTF8Buffer(_biasedBits: i._biasedBits).count
    _debugPrecondition(offset != 0)
    return Index(_biasedBits: _biasedBits &>> (offset &<< 3 - 8))
  }
}


----- Swift.(file)._ValidUTF8Buffer.distance(from:_ValidUTF8Buffer.Index,to:_ValidUTF8Buffer.Index)
extension _ValidUTF8Buffer {
  public func distance(from i: Index, to j: Index) -> Int {
    _debugPrecondition(_isValid(i))
    _debugPrecondition(_isValid(j))
    return (
      i._biasedBits.leadingZeroBitCount - j._biasedBits.leadingZeroBitCount
    ) &>> 3
  }
}


----- Swift.(file)._ValidUTF8Buffer.index(_:_ValidUTF8Buffer.Index,offsetBy:Int)
extension _ValidUTF8Buffer {
  public func index(_ i: Index, offsetBy n: Int) -> Index {
    let startOffset = distance(from: startIndex, to: i)
    let newOffset = startOffset + n
    _debugPrecondition(newOffset >= 0)
    _debugPrecondition(newOffset <= count)
    return Index(_biasedBits: _biasedBits._fullShiftRight(newOffset &<< 3))
  }
}


----- Swift.(file)._ValidUTF8Buffer.append(_:_ValidUTF8Buffer.Element)
extension _ValidUTF8Buffer {
  public mutating func append(_ e: Element) {
    _debugPrecondition(count + 1 <= capacity)
    _internalInvariant(
      e != 192 && e != 193 && !(245...255).contains(e), "invalid UTF8 byte")
    _biasedBits |= UInt32(e &+ 1) &<< (count &<< 3)
  }
}


----- Swift.(file)._ValidUTF8Buffer.removeFirst()
extension _ValidUTF8Buffer {
  public mutating func removeFirst() -> Element {
    _debugPrecondition(!isEmpty)
    let result = Element(truncatingIfNeeded: _biasedBits) &- 1
    _biasedBits = _biasedBits._fullShiftRight(8)
    return result
  }
}


----- Swift.(file)._ValidUTF8Buffer.replaceSubrange(_:Range<_ValidUTF8Buffer.Index>,with:C)
extension _ValidUTF8Buffer {
  public mutating func replaceSubrange<C: Collection>(
    _ target: Range<Index>, with replacement: C
  ) where C.Element == Element {
    _debugPrecondition(_isValid(target.lowerBound))
    _debugPrecondition(_isValid(target.upperBound))
    var r = _ValidUTF8Buffer()
    for x in self[..<target.lowerBound] { r.append(x) }
    for x in replacement                { r.append(x) }
    for x in self[target.upperBound...] { r.append(x) }
    self = r
  }
}


----- Swift.(file)._ValidUTF8Buffer.append(contentsOf:_ValidUTF8Buffer)
extension _ValidUTF8Buffer {
  public mutating func append(contentsOf other: _ValidUTF8Buffer) {
    _debugPrecondition(count + other.count <= capacity)
    _biasedBits |= UInt32(
      truncatingIfNeeded: other._biasedBits) &<< (count &<< 3)
  }
}: other._biasedBits) &<< (count &<< 3)
  }
}
